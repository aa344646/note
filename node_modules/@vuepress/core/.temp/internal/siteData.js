/**
 * Generated by "@vuepress/internal-site-data"
 */
export const siteData = {
  "title": "前端进阶宝典",
  "description": "前端系统进阶宝典 & 面试指南",
  "base": "/interview-docs/",
  "headTags": [
    [
      "link",
      {
        "rel": "icon",
        "href": "/interview-docs/img/hero-image.png"
      }
    ],
    [
      "meta",
      {
        "name": "keywords",
        "content": "前端,react,antd,vue,面试,js"
      }
    ],
    [
      "meta",
      {
        "name": "theme-color",
        "content": "#11a8cd"
      }
    ]
  ],
  "pages": [
    {
      "title": "JavaScript",
      "frontmatter": {
        "title": "JavaScript",
        "date": "2020-05-12T11:01:21.000Z",
        "permalink": "/pages/baseJavaScript",
        "article": false
      },
      "regularPath": "/10.%E5%9F%BA%E7%A1%80%E7%AF%87/10.%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/30.JavaScript.html",
      "relativePath": "10.基础篇/10.基础进阶/30.JavaScript.md",
      "key": "v-408ae7e2",
      "path": "/pages/baseJavaScript/",
      "headers": [
        {
          "level": 3,
          "title": "1 闭包",
          "slug": "_1-闭包",
          "normalizedTitle": "1 闭包",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2 说说你对作用域链的理解",
          "slug": "_2-说说你对作用域链的理解",
          "normalizedTitle": "2 说说你对作用域链的理解",
          "charIndex": 553
        },
        {
          "level": 3,
          "title": "JavaScript原型，原型链 ? 有什么特点？",
          "slug": "javascript原型-原型链-有什么特点",
          "normalizedTitle": "javascript原型，原型链 ? 有什么特点？",
          "charIndex": 702
        },
        {
          "level": 3,
          "title": "4 请解释什么是事件代理",
          "slug": "_4-请解释什么是事件代理",
          "normalizedTitle": "4 请解释什么是事件代理",
          "charIndex": 1680
        },
        {
          "level": 3,
          "title": "5 事件模型",
          "slug": "_5-事件模型",
          "normalizedTitle": "5 事件模型",
          "charIndex": 1913
        },
        {
          "level": 3,
          "title": "6 new操作符具体干了什么呢?",
          "slug": "_6-new操作符具体干了什么呢",
          "normalizedTitle": "6 new操作符具体干了什么呢?",
          "charIndex": 2263
        },
        {
          "level": 3,
          "title": "7 Ajax原理",
          "slug": "_7-ajax原理",
          "normalizedTitle": "7 ajax原理",
          "charIndex": 2387
        },
        {
          "level": 3,
          "title": "8 如何解决跨域问题?",
          "slug": "_8-如何解决跨域问题",
          "normalizedTitle": "8 如何解决跨域问题?",
          "charIndex": 3201
        },
        {
          "level": 3,
          "title": "9 那些操作会造成内存泄漏？",
          "slug": "_9-那些操作会造成内存泄漏",
          "normalizedTitle": "9 那些操作会造成内存泄漏？",
          "charIndex": 4133
        },
        {
          "level": 3,
          "title": "10 谈谈你对webpack的看法",
          "slug": "_10-谈谈你对webpack的看法",
          "normalizedTitle": "10 谈谈你对webpack的看法",
          "charIndex": 4438
        },
        {
          "level": 3,
          "title": "11 为什么要有同源限制？",
          "slug": "_11-为什么要有同源限制",
          "normalizedTitle": "11 为什么要有同源限制？",
          "charIndex": 4655
        },
        {
          "level": 3,
          "title": "12 JavaScript有几种类型的值",
          "slug": "_12-javascript有几种类型的值",
          "normalizedTitle": "12 javascript有几种类型的值",
          "charIndex": 4823
        },
        {
          "level": 3,
          "title": "13 说说严格模式的限制",
          "slug": "_13-说说严格模式的限制",
          "normalizedTitle": "13 说说严格模式的限制",
          "charIndex": 5130
        },
        {
          "level": 3,
          "title": "如何通过JS判断一个数组",
          "slug": "如何通过js判断一个数组",
          "normalizedTitle": "如何通过js判断一个数组",
          "charIndex": 5538
        },
        {
          "level": 3,
          "title": "14 Js动画与CSS动画区别及相应实现",
          "slug": "_14-js动画与css动画区别及相应实现",
          "normalizedTitle": "14 js动画与css动画区别及相应实现",
          "charIndex": 6139
        },
        {
          "level": 3,
          "title": "15 JS 数组和对象的遍历方式，以及几种方式的比较",
          "slug": "_15-js-数组和对象的遍历方式-以及几种方式的比较",
          "normalizedTitle": "15 js 数组和对象的遍历方式，以及几种方式的比较",
          "charIndex": 6400
        },
        {
          "level": 3,
          "title": "16 gulp是什么",
          "slug": "_16-gulp是什么",
          "normalizedTitle": "16 gulp是什么",
          "charIndex": 6946
        },
        {
          "level": 3,
          "title": "17 let var const",
          "slug": "_17-let-var-const",
          "normalizedTitle": "17 let var const",
          "charIndex": 7365
        },
        {
          "level": 3,
          "title": "18 怎样添加、移除、移动、复制、创建和查找节点",
          "slug": "_18-怎样添加、移除、移动、复制、创建和查找节点",
          "normalizedTitle": "18 怎样添加、移除、移动、复制、创建和查找节点",
          "charIndex": 7767
        },
        {
          "level": 3,
          "title": "19 window.onload和$(document).ready",
          "slug": "_19-window-onload和-document-ready",
          "normalizedTitle": "19 window.onload和$(document).ready",
          "charIndex": 8136
        },
        {
          "level": 3,
          "title": "20 addEventListener()和attachEvent()的区别",
          "slug": "_20-addeventlistener-和attachevent-的区别",
          "normalizedTitle": "20 addeventlistener()和attachevent()的区别",
          "charIndex": 9003
        },
        {
          "level": 3,
          "title": "21 数组去重方法总结",
          "slug": "_21-数组去重方法总结",
          "normalizedTitle": "21 数组去重方法总结",
          "charIndex": 9315
        },
        {
          "level": 3,
          "title": "22 Javascript全局函数和全局变量",
          "slug": "_22-javascript全局函数和全局变量",
          "normalizedTitle": "22 javascript全局函数和全局变量",
          "charIndex": 15409
        },
        {
          "level": 3,
          "title": "23 项目做过哪些性能优化？",
          "slug": "_23-项目做过哪些性能优化",
          "normalizedTitle": "23 项目做过哪些性能优化？",
          "charIndex": 15930
        },
        {
          "level": 3,
          "title": "24 WebSocket",
          "slug": "_24-websocket",
          "normalizedTitle": "24 websocket",
          "charIndex": 16233
        },
        {
          "level": 3,
          "title": "25 防抖/节流",
          "slug": "_25-防抖-节流",
          "normalizedTitle": "25 防抖/节流",
          "charIndex": 16706
        },
        {
          "level": 3,
          "title": "26 说说从输入URL到看到页面发生的全过程，越详细越好",
          "slug": "_26-说说从输入url到看到页面发生的全过程-越详细越好",
          "normalizedTitle": "26 说说从输入url到看到页面发生的全过程，越详细越好",
          "charIndex": 20251
        },
        {
          "level": 3,
          "title": "27 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？",
          "slug": "_27-现在要你完成一个dialog组件-说说你设计的思路-它应该有什么功能",
          "normalizedTitle": "27 现在要你完成一个dialog组件，说说你设计的思路？它应该有什么功能？",
          "charIndex": 20653
        },
        {
          "level": 3,
          "title": "28 ajax、axios、fetch区别",
          "slug": "_28-ajax、axios、fetch区别",
          "normalizedTitle": "28 ajax、axios、fetch区别",
          "charIndex": 21087
        },
        {
          "level": 3,
          "title": "Javascript如何实现继承",
          "slug": "javascript如何实现继承",
          "normalizedTitle": "javascript如何实现继承",
          "charIndex": 22152
        },
        {
          "level": 3,
          "title": "29 什么是函数节流？介绍一下应用场景和原理？",
          "slug": "_29-什么是函数节流-介绍一下应用场景和原理",
          "normalizedTitle": "29 什么是函数节流？介绍一下应用场景和原理？",
          "charIndex": 23147
        },
        {
          "level": 3,
          "title": "30 继承",
          "slug": "_30-继承",
          "normalizedTitle": "30 继承",
          "charIndex": 23707
        },
        {
          "level": 3,
          "title": "31 负载均衡",
          "slug": "_31-负载均衡",
          "normalizedTitle": "31 负载均衡",
          "charIndex": 24288
        },
        {
          "level": 3,
          "title": "32 CDN",
          "slug": "_32-cdn",
          "normalizedTitle": "32 cdn",
          "charIndex": 24499
        }
      ],
      "headersStr": "1 闭包 2 说说你对作用域链的理解 JavaScript原型，原型链 ? 有什么特点？ 4 请解释什么是事件代理 5 事件模型 6 new操作符具体干了什么呢? 7 Ajax原理 8 如何解决跨域问题? 9 那些操作会造成内存泄漏？ 10 谈谈你对webpack的看法 11 为什么要有同源限制？ 12 JavaScript有几种类型的值 13 说说严格模式的限制 如何通过JS判断一个数组 14 Js动画与CSS动画区别及相应实现 15 JS 数组和对象的遍历方式，以及几种方式的比较 16 gulp是什么 17 let var const 18 怎样添加、移除、移动、复制、创建和查找节点 19 window.onload和$(document).ready 20 addEventListener()和attachEvent()的区别 21 数组去重方法总结 22 Javascript全局函数和全局变量 23 项目做过哪些性能优化？ 24 WebSocket 25 防抖/节流 26 说说从输入URL到看到页面发生的全过程，越详细越好 27 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？ 28 ajax、axios、fetch区别 Javascript如何实现继承 29 什么是函数节流？介绍一下应用场景和原理？ 30 继承 31 负载均衡 32 CDN",
      "content": "# 1 闭包\n\n * 闭包就是能够读取其他函数内部变量的函数\n\n * 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域\n\n * 闭包的特性：\n   \n   * 函数内再嵌套函数\n   \n   * 内部函数可以引用外层的参数和变量\n   \n   * 参数和变量不会被垃圾回收机制回收\n\n说说你对闭包的理解\n\n * 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念\n\n * 闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中\n\n * 闭包的另一个用处，是封装对象的私有属性和私有方法\n\n * 好处：能够实现封装和缓存等；\n\n * 坏处：就是消耗内存、不正当使用会造成内存溢出的问题\n\n使用闭包的注意点\n\n * 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露\n\n * 解决方法是，在退出函数之前，将不使用的局部变量全部删除\n\n\n# 2 说说你对作用域链的理解\n\n * 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的\n\n * 简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期\n\n\n# JavaScript原型，原型链 ? 有什么特点？\n\n * 每个对象都会在其内部初始化一个属性，就是__proto__，当我们访问一个对象的属性时\n\n * 如果这个对象内部不存在这个属性，那么他就会去__proto__里找这个属性，这个__proto__又会有自己的__proto__，于是就这样一直找下去，也就是我们平时所说的原型链的概念。按照标准，__proto__ 是不对外公开的，也就是说是个私有属性\n\n * 关系：instance.constructor.prototype == instance.__proto__\n\n// eg.\nvar a = {}\n\na.constructor.prototype == a.__proto__\n\n\n * 特点：\n   \n   * JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变\n\n * 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的\n\n * 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象\n\n * 原型：\n   \n   * JavaScript的所有对象中都包含了一个 [__proto__] 内部属性，这个属性所对应的就是该对象的原型\n   \n   * JavaScript的函数对象，除了原型 [__proto__] 之外，还预置了 prototype 属性\n   \n   * 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [__proto__]。\n\n * 原型链：\n   \n   * 当一个对象调用的属性/方法自身不存在时，就会去自己 [__proto__] 关联的前辈 prototype 对象上去找\n   \n   * 如果没找到，就会去该 prototype 原型 [__proto__] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”\n\n * 原型特点：\n   \n   * JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变\n\n\n# 4 请解释什么是事件代理\n\n * 事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能\n\n * 可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒\n\n * 可以实现当新增子对象时无需再次对其绑定\n\n\n# 5 事件模型\n\n> W3C中定义事件的发生经历三个阶段：捕获阶段（capturing）、目标阶段（targetin）、冒泡阶段（bubbling）\n\n * 冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发\n\n * 捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发\n\n * DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件\n\n * 阻止冒泡：在W3c中，使用stopPropagation()方法；在IE下设置cancelBubble = true\n\n * 阻止捕获：阻止事件的默认行为，例如click - <a>后的跳转。在W3c中，使用preventDefault()方法，在IE下设置window.event.returnValue = false\n\n\n# 6 new操作符具体干了什么呢?\n\n * 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型\n\n * 属性和方法被加入到 this 引用的对象中\n\n * 新创建的对象由 this 所引用，并且最后隐式的返回 this\n\n\n# 7 Ajax原理\n\n * Ajax的原理简单来说是在用户和服务器之间加了—个中间层(AJAX引擎)，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据\n\n * Ajax的过程只涉及JavaScript、XMLHttpRequest和DOM。XMLHttpRequest是ajax的核心机制\n\n/** 1. 创建连接 **/\nvar xhr = null;\nxhr = new XMLHttpRequest()\n/** 2. 连接服务器 **/\nxhr.open('get', url, true)\n/** 3. 发送请求 **/\nxhr.send(null);\n/** 4. 接受请求 **/\nxhr.onreadystatechange = function(){\n\tif(xhr.readyState == 4){\n\t\tif(xhr.status == 200){\n\t\t\tsuccess(xhr.responseText);\n\t\t} else { \n\t\t\t/** false **/\n\t\t\tfail && fail(xhr.status);\n\t\t}\n\t}\n}\n\n\najax 有那些优缺点?\n\n * 优点：\n   \n   * 通过异步模式，提升了用户体验.\n   \n   * 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.\n   \n   * Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。\n   \n   * Ajax可以实现动态不刷新（局部刷新）\n\n * 缺点：\n   \n   * 安全问题 AJAX暴露了与服务器交互的细节。\n   \n   * 对搜索引擎的支持比较弱。\n   \n   * 不容易调试。\n\n\n# 8 如何解决跨域问题?\n\n> 首先了解下浏览器的同源策略 同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源\n\n那么怎样解决跨域问题的呢？\n\n * 通过jsonp跨域\n\nvar script = document.createElement('script');\nscript.type = 'text/javascript';\n\n// 传参并指定回调执行函数为onBack\nscript.src = 'http://www.....:8080/login?user=admin&callback=onBack';\ndocument.head.appendChild(script);\n\n// 回调执行函数\nfunction onBack(res) {\n    alert(JSON.stringify(res));\n}\n\n\n * document.domain + iframe跨域\n\n> 此方案仅限主域相同，子域不同的跨域应用场景\n\n1.）父窗口：(http://www.domain.com/a.html)\n\n<iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"></iframe>\n<script>\n    document.domain = 'domain.com';\n    var user = 'admin';\n</script>\n\n\n2.）子窗口：(http://child.domain.com/b.html)\n\ndocument.domain = 'domain.com';\n// 获取父窗口中变量\nalert('get js data from parent ---> ' + window.parent.user);\n\n\n * nginx代理跨域\n\n * nodejs中间件代理跨域\n\n * 后端在头部信息里面设置安全域名\n\n\n# 9 那些操作会造成内存泄漏？\n\n> JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收\n\n * 未使用 var 声明的全局变量\n\n * 闭包函数(Closures)\n\n * 循环引用(两个对象相互引用)\n\n * 控制台日志(console.log)\n\n * 移除存在绑定事件的DOM元素(IE)\n\n * setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏\n\n * 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收\n\n\n# 10 谈谈你对webpack的看法\n\n * WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源\n\n\n# 11 为什么要有同源限制？\n\n * 同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议\n\n * 举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。\n\n\n# 12 JavaScript有几种类型的值\n\n * 栈：原始数据类型（Undefined，Null，Boolean，Number、String）\n\n * 堆：引用数据类型（对象、数组和函数）\n\n * 两种类型的区别是：存储位置不同；\n\n * 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n\n * 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体\n\n\n# 13 说说严格模式的限制\n\n * 变量必须声明后再使用\n\n * 函数的参数不能有同名属性，否则报错\n\n * 不能使用with语句\n\n * 不能对只读属性赋值，否则报错\n\n * 不能使用前缀0表示八进制数，否则报错\n\n * 不能删除不可删除的属性，否则报错\n\n * 不能删除变量delete prop，会报错，只能删除属性delete global[prop]\n\n * eval不会在它的外层作用域引入变量\n\n * eval和arguments不能被重新赋值\n\n * arguments不会自动反映函数参数的变化\n\n * 不能使用arguments.callee\n\n * 不能使用arguments.caller\n\n * 禁止this指向全局对象\n\n * 不能使用fn.caller和fn.arguments获取函数调用的堆栈\n\n * 增加了保留字（比如protected、static和interface）\n\n\n# 如何通过JS判断一个数组\n\n * instanceof方法\n\n * instanceof 运算符是用来测试一个对象是否在其原型链原型构造函数的属性\n\nvar arr = [];\narr instanceof Array; // true\n\n\n * constructor方法\n\n * constructor属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数\n\nvar arr = [];\narr.constructor == Array; //true\n\n\n * 最简单的方法\n   * 这种写法，是 jQuery 正在使用的\n\nObject.prototype.toString.call(value) == '[object Array]'\n// 利用这个方法，可以写一个返回数据类型的方法\nvar isType = function (obj) {\n     return Object.prototype.toString.call(obj).slice(8,-1);\n}   \n\n\n * ES5新增方法isArray()\n\nvar a = new Array(123);\nvar b = new Date();\nconsole.log(Array.isArray(a)); //true\nconsole.log(Array.isArray(b)); //false\n\n\n\n# 14 Js动画与CSS动画区别及相应实现\n\n * CSS3的动画的优点\n   \n   * 在性能上会稍微好一些，浏览器会对CSS3的动画做一些优化\n   \n   * 代码相对简单\n\n * 缺点\n   \n   * 在动画控制上不够灵活\n   \n   * 兼容性不好\n\n * JavaScript的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容IE6，并且功能强大。对于一些复杂控制的动画，使用javascript会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑CSS吧\n\n\n# 15 JS 数组和对象的遍历方式，以及几种方式的比较\n\n> 通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。一般我们会采用下几种方式来进行数组的遍历\n\n * for in循环\n\n * for循环\n\n * forEach\n   \n   * 这里的 forEach回调中两个参数分别为 value，index\n   \n   * forEach 无法遍历对象\n   \n   * IE不支持该方法；Firefox 和 chrome 支持\n   \n   * forEach 无法使用 break，continue 跳出循环，且使用 return 是跳过本次循环\n\n * 这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题\n\n * 在方式一中，for-in需要分析出array的每个属性，这个操作性能开销很大。用在 key 已知的数组上是非常不划算的。所以尽量不要用for-in，除非你不清楚要处理哪些属性，例如 JSON对象这样的情况\n\n * 在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 array 里存放的都是 DOM 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低\n\n\n# 16 gulp是什么\n\n * gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成\n\n * Gulp的核心概念：流\n\n * 流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向\n\n * gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作\n\n * Gulp的特点：\n   \n   * 易于使用：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理\n   \n   * 构建快速 利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作\n   \n   * 易于学习 通过最少的 API，掌握 gulp 毫不费力，构建工作尽在掌握：如同一系列流管道\n\n\n# 17 let var const\n\nlet\n\n * 允许你声明一个作用域被限制在块级中的变量、语句或者表达式\n\n * let绑定不受变量提升的约束，这意味着let声明不会被提升到当前\n\n * 该变量处于从块开始到初始化处理的“暂存死区”\n\nvar\n\n * 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的\n\n * 由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明\n\nconst\n\n * 声明创建一个值的只读引用 (即指针)\n\n * 基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 const申明基本数据类型时\n\n * 再将其值改变时，将会造成报错， 例如 const a = 3 ; a = 5时 将会报错\n\n * 但是如果是复合类型时，如果只改变复合类型的其中某个Value项时， 将还是正常使用\n\n\n# 18 怎样添加、移除、移动、复制、创建和查找节点\n\n创建新节点\n\ncreateDocumentFragment()    //创建一个DOM片段\ncreateElement()   //创建一个具体的元素\ncreateTextNode()   //创建一个文本节点\n\n\n添加、移除、替换、插入\n\nappendChild()      //添加\nremoveChild()      //移除\nreplaceChild()      //替换\ninsertBefore()      //插入\n\n\n查找\n\ngetElementsByTagName()    //通过标签名称\ngetElementsByName()     //通过元素的Name属性的值\ngetElementById()        //通过元素Id，唯一性\n\n\n\n# 19 window.onload和$(document).ready\n\n> 原生JS的window.onload与Jquery的$(document).ready(function(){})有什么不同？如何用原生JS实现Jq的ready方法？\n\n * window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。\n\n * $(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕\n\nfunction ready(fn){\n      if(document.addEventListener) {        //标准浏览器\n          document.addEventListener('DOMContentLoaded', function() {\n              //注销事件, 避免反复触发\n              document.removeEventListener('DOMContentLoaded',arguments.callee, false);\n              fn();            //执行函数\n          }, false);\n      }else if(document.attachEvent) {        //IE\n          document.attachEvent('onreadystatechange', function() {\n             if(document.readyState == 'complete') {\n                 document.detachEvent('onreadystatechange', arguments.callee);\n                 fn();        //函数执行\n             }\n         });\n     }\n };\n\n\n\n# 20 addEventListener()和attachEvent()的区别\n\n * addEventListener()是符合W3C规范的标准方法; attachEvent()是IE低版本的非标准方法\n\n * addEventListener()支持事件冒泡和事件捕获; - 而attachEvent()只支持事件冒泡\n\n * addEventListener()的第一个参数中,事件类型不需要添加on; attachEvent()需要添加'on'\n\n * 如果为同一个元素绑定多个事件, addEventListener()会按照事件绑定的顺序依次执行, attachEvent()会按照事件绑定的顺序倒序执行\n\n\n# 21 数组去重方法总结\n\n方法一、利用ES6 Set去重（ES6中最常用）\n\nfunction unique (arr) {\n  return Array.from(new Set(arr))\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n //[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {}, {}]\n\n\n方法二、利用for嵌套for，然后splice去重（ES5中最常用）\n\nfunction unique(arr){            \n        for(var i=0; i<arr.length; i++){\n            for(var j=i+1; j<arr.length; j++){\n                if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个\n                    arr.splice(j,1);\n                    j--;\n                }\n            }\n        }\n\treturn arr;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n    //[1, \"true\", 15, false, undefined, NaN, NaN, \"NaN\", \"a\", {…}, {…}]     //NaN和{}没有去重，两个null直接消失了\n\n\n * 双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。\n\n * 想快速学习更多常用的ES6语法\n\n方法三、利用indexOf去重\n\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var array = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (array .indexOf(arr[i]) === -1) {\n            array .push(arr[i])\n        }\n    }\n    return array;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n   // [1, \"true\", true, 15, false, undefined, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, {…}]  //NaN、{}没有去重\n\n\n> 新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组\n\n方法四、利用sort()\n\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return;\n    }\n    arr = arr.sort()\n    var arrry= [arr[0]];\n    for (var i = 1; i < arr.length; i++) {\n        if (arr[i] !== arr[i-1]) {\n            arrry.push(arr[i]);\n        }\n    }\n    return arrry;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n// [0, 1, 15, \"NaN\", NaN, NaN, {…}, {…}, \"a\", false, null, true, \"true\", undefined]      //NaN、{}没有去重\n\n\n> 利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对\n\n方法五、利用对象的属性不能相同的特点进行去重\n\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var arrry= [];\n     var  obj = {};\n    for (var i = 0; i < arr.length; i++) {\n        if (!obj[arr[i]]) {\n            arrry.push(arr[i])\n            obj[arr[i]] = 1\n        } else {\n            obj[arr[i]]++\n        }\n    }\n    return arrry;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n//[1, \"true\", 15, false, undefined, null, NaN, 0, \"a\", {…}]    //两个true直接去掉了，NaN和{}去重\n\n\n方法六、利用includes\n\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var array =[];\n    for(var i = 0; i < arr.length; i++) {\n            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值\n                    array.push(arr[i]);\n              }\n    }\n    return array\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n    //[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}, {…}]     //{}没有去重\n\n\n方法七、利用hasOwnProperty\n\nfunction unique(arr) {\n    var obj = {};\n    return arr.filter(function(item, index, arr){\n        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)\n    })\n}\n    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n        console.log(unique(arr))\n//[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}]   //所有的都去重了\n\n\n> 利用hasOwnProperty 判断是否存在对象属性\n\n方法八、利用filter\n\nfunction unique(arr) {\n  return arr.filter(function(item, index, arr) {\n    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素\n    return arr.indexOf(item, 0) === index;\n  });\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n//[1, \"true\", true, 15, false, undefined, null, \"NaN\", 0, \"a\", {…}, {…}]\n\n\n方法九、利用递归去重\n\nfunction unique(arr) {\n    var array= arr;\n    var len = array.length;\n\n\tarray.sort(function(a,b){   //排序后更加方便去重\n\t\treturn a - b;\n\t})\n\n\tfunction loop(index){\n        if(index >= 1){\n            if(array[index] === array[index-1]){\n            array.splice(index,1);\n            }\n            loop(index - 1);    //递归loop，然后数组去重\n        }\n\t}\n\tloop(len-1);\n\treturn array;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n//[1, \"a\", \"true\", true, 15, false, 1, {…}, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, undefined]\n\n\n方法十、利用Map数据结构去重\n\nfunction arrayNonRepeatfy(arr) {\n\tlet map = new Map();\n\t\tlet array = new Array();  // 数组用于返回结果\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tif(map .has(arr[i])) {  // 如果有该key值\n\t\t\tmap .set(arr[i], true);\n\t\t} else {\n\t\t\tmap .set(arr[i], false);   // 如果没有该key值\n\t\t\tarray .push(arr[i]);\n\t\t}\n\t}\n\treturn array ;\n}\n var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n    console.log(unique(arr))\n//[1, \"a\", \"true\", true, 15, false, 1, {…}, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, undefined]\n\n\n> 创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果\n\n方法十一、利用reduce+includes\n\nfunction unique(arr){\n    return arr.reduce((prev,cur) => prev.includes(cur) ? prev : [...prev,cur],[]);\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr));\n// [1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}, {…}]\n\n\n\n方法十二、[...new Set(arr)]\n\n[...new Set(arr)]\n//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）\n\n\n\n# 22 Javascript全局函数和全局变量\n\n全局变量\n\n * Infinity 代表正的无穷大的数值。\n\n * NaN 指示某个值是不是数字值。\n\n * undefined 指示未定义的值。\n\n全局函数\n\n * decodeURI() 解码某个编码的 URI。\n\n * decodeURIComponent() 解码一个编码的 URI 组件。\n\n * encodeURI() 把字符串编码为 URI。\n\n * encodeURIComponent() 把字符串编码为 URI 组件。\n\n * escape() 对字符串进行编码。\n\n * eval() 计算 JavaScript 字符串，并把它作为脚本代码来执行。\n\n * isFinite() 检查某个值是否为有穷大的数。\n\n * isNaN() 检查某个值是否是数字。\n\n * Number() 把对象的值转换为数字。\n\n * parseFloat() 解析一个字符串并返回一个浮点数。\n\n * parseInt() 解析一个字符串并返回一个整数。\n\n * String() 把对象的值转换为字符串。\n\n * unescape() 对由escape() 编码的字符串进行解码\n\n\n# 23 项目做过哪些性能优化？\n\n * 减少 HTTP 请求数\n\n * 减少 DNS 查询\n\n * 使用 CDN\n\n * 避免重定向\n\n * 图片懒加载\n\n * 减少 DOM 元素数量\n\n * 减少DOM 操作\n\n * 使用外部 JavaScript 和 CSS\n\n * 压缩 JavaScript 、 CSS 、字体、图片等\n\n * 优化 CSS Sprite\n\n * 使用 iconfont\n\n * 字体裁剪\n\n * 多域名分发划分内容到不同域名\n\n * 尽量减少 iframe 使用\n\n * 避免图片 src 为空\n\n * 把样式表放在link 中\n\n * 把JavaScript放在页面底部\n\n\n# 24 WebSocket\n\n> 由于 http 存在一个明显的弊端（消息只能有客户端推送到服务器端，而服务器端不能主动推送到客户端），导致如果服务器如果有连续的变化，这时只能使用轮询，而轮询效率过低，并不适合。于是 WebSocket被发明出来\n\n> 相比与 http 具有以下有点\n\n * 支持双向通信，实时性更强；\n\n * 可以发送文本，也可以二进制文件；\n\n * 协议标识符是 ws，加密后是 wss ；\n\n * 较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部；\n\n * 支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）\n\n * 无跨域问题。\n\n> 实现比较简单，服务端库如 socket.io、ws，可以很好的帮助我们入门。而客户端也只需要参照 api 实现即可\n\n\n# 25 防抖/节流\n\n防抖\n\n> 在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。可以通过函数防抖动来实现\n\n// 使用 underscore 的源码来解释防抖动\n\n/**\n * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行\n *\n * @param  {function} func        回调函数\n * @param  {number}   wait        表示时间窗口的间隔\n * @param  {boolean}  immediate   设置为ture时，是否立即调用函数\n * @return {function}             返回客户调用函数\n */\n_.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      // 现在和上一次时间戳比较\n      var last = _.now() - timestamp;\n      // 如果当前间隔时间少于设定时间且大于0就重新设置定时器\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        // 否则的话就是时间到了执行回调函数\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      // 获得时间戳\n      timestamp = _.now();\n      // 如果定时器不存在且立即执行函数\n      var callNow = immediate && !timeout;\n      // 如果定时器不存在就创建一个\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        // 如果需要立即执行函数的话 通过 apply 执行\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n\n> 整体函数实现\n\n对于按钮防点击来说的实现\n\n * 开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了\n\n * 对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数\n\n节流\n\n> 防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行\n\n/**\n * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait\n *\n * @param  {function}   func      回调函数\n * @param  {number}     wait      表示时间窗口的间隔\n * @param  {object}     options   如果想忽略开始函数的的调用，传入{leading: false}。\n *                                如果想忽略结尾函数的调用，传入{trailing: false}\n *                                两者不能共存，否则函数不能执行\n * @return {function}             返回客户调用函数   \n */\n_.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    // 之前的时间戳\n    var previous = 0;\n    // 如果 options 没传则设为空对象\n    if (!options) options = {};\n    // 定时器回调函数\n    var later = function() {\n      // 如果设置了 leading，就将 previous 设为 0\n      // 用于下面函数的第一个 if 判断\n      previous = options.leading === false ? 0 : _.now();\n      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      // 获得当前时间戳\n      var now = _.now();\n      // 首次进入前者肯定为 true\n\t  // 如果需要第一次不执行函数\n\t  // 就将上次时间戳设为当前的\n      // 这样在接下来计算 remaining 的值时会大于0\n      if (!previous && options.leading === false) previous = now;\n      // 计算剩余时间\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      // 如果当前调用已经大于上次调用时间 + wait\n      // 或者用户手动调了时间\n \t  // 如果设置了 trailing，只会进入这个条件\n\t  // 如果没有设置 leading，那么第一次会进入这个条件\n\t  // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了\n\t  // 其实还是会进入的，因为定时器的延时\n\t  // 并不是准确的时间，很可能你设置了2秒\n\t  // 但是他需要2.2秒才触发，这时候就会进入这个条件\n      if (remaining <= 0 || remaining > wait) {\n        // 如果存在定时器就清理掉否则会调用二次回调\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        // 判断是否设置了定时器和 trailing\n\t    // 没有的话就开启一个定时器\n        // 并且不能不能同时设置 leading 和 trailing\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n\n\n# 26 说说从输入URL到看到页面发生的全过程，越详细越好\n\n * 首先浏览器主进程接管，开了一个下载线程。\n\n * 然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。\n\n * 将下载完的内容转交给Renderer进程管理。\n\n * Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。\n\n * 解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。\n\n * css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。\n\n * 绘制结束后，关闭TCP连接，过程有四次挥手\n\n\n# 27 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？\n\n * 该组件需要提供hook指定渲染位置，默认渲染在body下面。\n\n * 然后改组件可以指定外层样式，如宽度等\n\n * 组件外层还需要一层mask来遮住底层内容，点击mask可以执行传进来的onCancel函数关闭Dialog。\n\n * 另外组件是可控的，需要外层传入visible表示是否可见。\n\n * 然后Dialog可能需要自定义头head和底部footer，默认有头部和底部，底部有一个确认按钮和取消按钮，确认按钮会执行外部传进来的onOk事件，然后取消按钮会执行外部传进来的onCancel事件。\n\n * 当组件的visible为true时候，设置body的overflow为hidden，隐藏body的滚动条，反之显示滚动条。\n\n * 组件高度可能大于页面高度，组件内部需要滚动条。\n\n * 只有组件的visible有变化且为ture时候，才重渲染组件内的所有内容\n\n\n# 28 ajax、axios、fetch区别\n\njQuery ajax\n\n$.ajax({\n   type: 'POST',\n   url: url,\n   data: data,\n   dataType: dataType,\n   success: function () {},\n   error: function () {}\n});\n\n\n优缺点：\n\n * 本身是针对MVC的编程,不符合现在前端MVVM的浪潮\n\n * 基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案\n\n * JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）\n\naxios\n\naxios({\n    method: 'post',\n    url: '/user/12345',\n    data: {\n        firstName: 'Fred',\n        lastName: 'Flintstone'\n    }\n})\n.then(function (response) {\n    console.log(response);\n})\n.catch(function (error) {\n    console.log(error);\n});\n\n\n优缺点：\n\n * 从浏览器中创建 XMLHttpRequest\n\n * 从 node.js 发出 http 请求\n\n * 支持 Promise API\n\n * 拦截请求和响应\n\n * 转换请求和响应数据\n\n * 取消请求\n\n * 自动转换JSON数据\n\n * 客户端支持防止CSRF/XSRF\n\nfetch\n\ntry {\n  let response = await fetch(url);\n  let data = response.json();\n  console.log(data);\n} catch(e) {\n  console.log(\"Oops, error\", e);\n\n}\n\n\n优缺点：\n\n * fetcht只对网络请求报错，对400，500都当做成功的请求，需要封装去处理\n\n * fetch默认不会带cookie，需要添加配置项\n\n * fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费\n\n * fetch没有办法原生监测请求的进度，而XHR可以\n\n\n# Javascript如何实现继承\n\n> 构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上\n\nfunction Cat(name,color){\n 　Animal.apply(this, arguments);\n 　this.name = name;\n 　this.color = color;\n}\n\n\n * 实例继承：将子对象的 prototype 指向父对象的一个实例\n\nCat.prototype = new Animal();\nCat.prototype.constructor = Cat;\n\n\n> 拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象\n\nfunction extend(Child, Parent) {\n　　　var p = Parent.prototype;\n　　　var c = Child.prototype;\n　　　for (var i in p) {\n　　　   c[i] = p[i];\n　　　}\n　　　c.uber = p;\n　 }\n\n\n> 原型继承：将子对象的 prototype 指向父对象的 prototype\n\nfunction extend(Child, Parent) {\n    var F = function(){};\n  　F.prototype = Parent.prototype;\n  　Child.prototype = new F();\n  　Child.prototype.constructor = Child;\n  　Child.uber = Parent.prototype;\n}\n\n\n> ES6` 语法糖 `extends：class ColorPoint extends Point {}\n\nclass ColorPoint extends Point {\n    constructor(x, y, color) {\n      super(x, y); // 调用父类的constructor(x, y)\n      this.color = color;\n    }\n    toString() {\n      return this.color + ' ' + super.toString(); // 调用父类的toString()\n    }\n}\n\n\n\n# 29 什么是函数节流？介绍一下应用场景和原理？\n\n * 函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。 只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。 但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果）\n\n * 函数节流用于 onresize, onscroll 等短时间内会多次触发的事件\n\n * 函数节流的原理：使用定时器做时间节流。 当触发一个事件时，先用 setTimout 让这个事件延迟一小段时间再执行。 如果在这个时间间隔内又触发了事件，就 clearTimeout 原来的定时器， 再 setTimeout 一个新的定时器重复以上流程。\n\n函数节流简单实现：\n\nfunction throttle(method, context) {\n     clearTimeout(methor.tId);\n     method.tId = setTimeout(function(){\n         method.call(context);\n     }， 100); // 两次调用至少间隔 100ms\n}\n// 调用\nwindow.onresize = function(){\n  throttle(myFunc, window);\n}\n\n\n\n# 30 继承\n\n * 原型链继承，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构造函数传参。\n\n * 构造继承，使用父类的构造函数来增强子类实例，即复制父类的实例属性给子类，构造继承可以向父类传递参数，可以实现多继承，通过call多个父类对象。但是构造继承只能继承父类的实例属性和方法，不能继承原型属性和方法，无法实现函数服用，每个子类都有父类实例函数的副本，影响性能\n\n * 实例继承，为父类实例添加新特性，作为子类实例返回，实例继承的特点是不限制调用方法，不管是new 子类（）还是子类（）返回的对象具有相同的效果，缺点是实例是父类的实例，不是子类的实例，不支持多继承\n\n * 拷贝继承：特点：支持多继承，缺点：效率较低，内存占用高（因为要拷贝父类的属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用for in访问到）\n\n * 组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n * 寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点\n\n\n# 31 负载均衡\n\n> 多台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用\n\n * http重定向负载均衡：调度者根据策略选择服务器以302响应请求，缺点只有第一次有效果，后续操作维持在该服务器 dns负载均衡：解析域名时，访问多个ip服务器中的一个（可监控性较弱）\n * 反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大，性能受到 服务器群的数量\n\n\n# 32 CDN\n\n> 内容分发网络，基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。",
      "normalizedContent": "# 1 闭包\n\n * 闭包就是能够读取其他函数内部变量的函数\n\n * 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域\n\n * 闭包的特性：\n   \n   * 函数内再嵌套函数\n   \n   * 内部函数可以引用外层的参数和变量\n   \n   * 参数和变量不会被垃圾回收机制回收\n\n说说你对闭包的理解\n\n * 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念\n\n * 闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中\n\n * 闭包的另一个用处，是封装对象的私有属性和私有方法\n\n * 好处：能够实现封装和缓存等；\n\n * 坏处：就是消耗内存、不正当使用会造成内存溢出的问题\n\n使用闭包的注意点\n\n * 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在ie中可能导致内存泄露\n\n * 解决方法是，在退出函数之前，将不使用的局部变量全部删除\n\n\n# 2 说说你对作用域链的理解\n\n * 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的\n\n * 简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期\n\n\n# javascript原型，原型链 ? 有什么特点？\n\n * 每个对象都会在其内部初始化一个属性，就是__proto__，当我们访问一个对象的属性时\n\n * 如果这个对象内部不存在这个属性，那么他就会去__proto__里找这个属性，这个__proto__又会有自己的__proto__，于是就这样一直找下去，也就是我们平时所说的原型链的概念。按照标准，__proto__ 是不对外公开的，也就是说是个私有属性\n\n * 关系：instance.constructor.prototype == instance.__proto__\n\n// eg.\nvar a = {}\n\na.constructor.prototype == a.__proto__\n\n\n * 特点：\n   \n   * javascript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变\n\n * 当我们需要一个属性的时，javascript引擎会先看当前对象中是否有这个属性， 如果没有的\n\n * 就会查找他的prototype对象是否有这个属性，如此递推下去，一直检索到 object 内建对象\n\n * 原型：\n   \n   * javascript的所有对象中都包含了一个 [__proto__] 内部属性，这个属性所对应的就是该对象的原型\n   \n   * javascript的函数对象，除了原型 [__proto__] 之外，还预置了 prototype 属性\n   \n   * 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [__proto__]。\n\n * 原型链：\n   \n   * 当一个对象调用的属性/方法自身不存在时，就会去自己 [__proto__] 关联的前辈 prototype 对象上去找\n   \n   * 如果没找到，就会去该 prototype 原型 [__proto__] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”\n\n * 原型特点：\n   \n   * javascript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变\n\n\n# 4 请解释什么是事件代理\n\n * 事件代理（event delegation），又称之为事件委托。是 javascript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是dom元素的事件冒泡。使用事件代理的好处是可以提高性能\n\n * 可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒\n\n * 可以实现当新增子对象时无需再次对其绑定\n\n\n# 5 事件模型\n\n> w3c中定义事件的发生经历三个阶段：捕获阶段（capturing）、目标阶段（targetin）、冒泡阶段（bubbling）\n\n * 冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发\n\n * 捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发\n\n * dom事件流：同时支持两种事件模型：捕获型事件和冒泡型事件\n\n * 阻止冒泡：在w3c中，使用stoppropagation()方法；在ie下设置cancelbubble = true\n\n * 阻止捕获：阻止事件的默认行为，例如click - <a>后的跳转。在w3c中，使用preventdefault()方法，在ie下设置window.event.returnvalue = false\n\n\n# 6 new操作符具体干了什么呢?\n\n * 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型\n\n * 属性和方法被加入到 this 引用的对象中\n\n * 新创建的对象由 this 所引用，并且最后隐式的返回 this\n\n\n# 7 ajax原理\n\n * ajax的原理简单来说是在用户和服务器之间加了—个中间层(ajax引擎)，通过xmlhttprequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作dom而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据\n\n * ajax的过程只涉及javascript、xmlhttprequest和dom。xmlhttprequest是ajax的核心机制\n\n/** 1. 创建连接 **/\nvar xhr = null;\nxhr = new xmlhttprequest()\n/** 2. 连接服务器 **/\nxhr.open('get', url, true)\n/** 3. 发送请求 **/\nxhr.send(null);\n/** 4. 接受请求 **/\nxhr.onreadystatechange = function(){\n\tif(xhr.readystate == 4){\n\t\tif(xhr.status == 200){\n\t\t\tsuccess(xhr.responsetext);\n\t\t} else { \n\t\t\t/** false **/\n\t\t\tfail && fail(xhr.status);\n\t\t}\n\t}\n}\n\n\najax 有那些优缺点?\n\n * 优点：\n   \n   * 通过异步模式，提升了用户体验.\n   \n   * 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.\n   \n   * ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。\n   \n   * ajax可以实现动态不刷新（局部刷新）\n\n * 缺点：\n   \n   * 安全问题 ajax暴露了与服务器交互的细节。\n   \n   * 对搜索引擎的支持比较弱。\n   \n   * 不容易调试。\n\n\n# 8 如何解决跨域问题?\n\n> 首先了解下浏览器的同源策略 同源策略/sop（same origin policy）是一种约定，由netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到xss、csrf等攻击。所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源\n\n那么怎样解决跨域问题的呢？\n\n * 通过jsonp跨域\n\nvar script = document.createelement('script');\nscript.type = 'text/javascript';\n\n// 传参并指定回调执行函数为onback\nscript.src = 'http://www.....:8080/login?user=admin&callback=onback';\ndocument.head.appendchild(script);\n\n// 回调执行函数\nfunction onback(res) {\n    alert(json.stringify(res));\n}\n\n\n * document.domain + iframe跨域\n\n> 此方案仅限主域相同，子域不同的跨域应用场景\n\n1.）父窗口：(http://www.domain.com/a.html)\n\n<iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"></iframe>\n<script>\n    document.domain = 'domain.com';\n    var user = 'admin';\n</script>\n\n\n2.）子窗口：(http://child.domain.com/b.html)\n\ndocument.domain = 'domain.com';\n// 获取父窗口中变量\nalert('get js data from parent ---> ' + window.parent.user);\n\n\n * nginx代理跨域\n\n * nodejs中间件代理跨域\n\n * 后端在头部信息里面设置安全域名\n\n\n# 9 那些操作会造成内存泄漏？\n\n> javascript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收\n\n * 未使用 var 声明的全局变量\n\n * 闭包函数(closures)\n\n * 循环引用(两个对象相互引用)\n\n * 控制台日志(console.log)\n\n * 移除存在绑定事件的dom元素(ie)\n\n * settimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏\n\n * 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收\n\n\n# 10 谈谈你对webpack的看法\n\n * webpack 是一个模块打包工具，你可以使用webpack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包web开发中所用到的html、javascript、css以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源\n\n\n# 11 为什么要有同源限制？\n\n * 同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议\n\n * 举例说明：比如一个黑客程序，他利用iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。\n\n\n# 12 javascript有几种类型的值\n\n * 栈：原始数据类型（undefined，null，boolean，number、string）\n\n * 堆：引用数据类型（对象、数组和函数）\n\n * 两种类型的区别是：存储位置不同；\n\n * 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n\n * 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体\n\n\n# 13 说说严格模式的限制\n\n * 变量必须声明后再使用\n\n * 函数的参数不能有同名属性，否则报错\n\n * 不能使用with语句\n\n * 不能对只读属性赋值，否则报错\n\n * 不能使用前缀0表示八进制数，否则报错\n\n * 不能删除不可删除的属性，否则报错\n\n * 不能删除变量delete prop，会报错，只能删除属性delete global[prop]\n\n * eval不会在它的外层作用域引入变量\n\n * eval和arguments不能被重新赋值\n\n * arguments不会自动反映函数参数的变化\n\n * 不能使用arguments.callee\n\n * 不能使用arguments.caller\n\n * 禁止this指向全局对象\n\n * 不能使用fn.caller和fn.arguments获取函数调用的堆栈\n\n * 增加了保留字（比如protected、static和interface）\n\n\n# 如何通过js判断一个数组\n\n * instanceof方法\n\n * instanceof 运算符是用来测试一个对象是否在其原型链原型构造函数的属性\n\nvar arr = [];\narr instanceof array; // true\n\n\n * constructor方法\n\n * constructor属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数\n\nvar arr = [];\narr.constructor == array; //true\n\n\n * 最简单的方法\n   * 这种写法，是 jquery 正在使用的\n\nobject.prototype.tostring.call(value) == '[object array]'\n// 利用这个方法，可以写一个返回数据类型的方法\nvar istype = function (obj) {\n     return object.prototype.tostring.call(obj).slice(8,-1);\n}   \n\n\n * es5新增方法isarray()\n\nvar a = new array(123);\nvar b = new date();\nconsole.log(array.isarray(a)); //true\nconsole.log(array.isarray(b)); //false\n\n\n\n# 14 js动画与css动画区别及相应实现\n\n * css3的动画的优点\n   \n   * 在性能上会稍微好一些，浏览器会对css3的动画做一些优化\n   \n   * 代码相对简单\n\n * 缺点\n   \n   * 在动画控制上不够灵活\n   \n   * 兼容性不好\n\n * javascript的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容ie6，并且功能强大。对于一些复杂控制的动画，使用javascript会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑css吧\n\n\n# 15 js 数组和对象的遍历方式，以及几种方式的比较\n\n> 通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。一般我们会采用下几种方式来进行数组的遍历\n\n * for in循环\n\n * for循环\n\n * foreach\n   \n   * 这里的 foreach回调中两个参数分别为 value，index\n   \n   * foreach 无法遍历对象\n   \n   * ie不支持该方法；firefox 和 chrome 支持\n   \n   * foreach 无法使用 break，continue 跳出循环，且使用 return 是跳过本次循环\n\n * 这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题\n\n * 在方式一中，for-in需要分析出array的每个属性，这个操作性能开销很大。用在 key 已知的数组上是非常不划算的。所以尽量不要用for-in，除非你不清楚要处理哪些属性，例如 json对象这样的情况\n\n * 在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 array 里存放的都是 dom 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低\n\n\n# 16 gulp是什么\n\n * gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成\n\n * gulp的核心概念：流\n\n * 流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向\n\n * gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作\n\n * gulp的特点：\n   \n   * 易于使用：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理\n   \n   * 构建快速 利用 node.js 流的威力，你可以快速构建项目并减少频繁的 io 操作\n   \n   * 易于学习 通过最少的 api，掌握 gulp 毫不费力，构建工作尽在掌握：如同一系列流管道\n\n\n# 17 let var const\n\nlet\n\n * 允许你声明一个作用域被限制在块级中的变量、语句或者表达式\n\n * let绑定不受变量提升的约束，这意味着let声明不会被提升到当前\n\n * 该变量处于从块开始到初始化处理的“暂存死区”\n\nvar\n\n * 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的\n\n * 由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明\n\nconst\n\n * 声明创建一个值的只读引用 (即指针)\n\n * 基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 const申明基本数据类型时\n\n * 再将其值改变时，将会造成报错， 例如 const a = 3 ; a = 5时 将会报错\n\n * 但是如果是复合类型时，如果只改变复合类型的其中某个value项时， 将还是正常使用\n\n\n# 18 怎样添加、移除、移动、复制、创建和查找节点\n\n创建新节点\n\ncreatedocumentfragment()    //创建一个dom片段\ncreateelement()   //创建一个具体的元素\ncreatetextnode()   //创建一个文本节点\n\n\n添加、移除、替换、插入\n\nappendchild()      //添加\nremovechild()      //移除\nreplacechild()      //替换\ninsertbefore()      //插入\n\n\n查找\n\ngetelementsbytagname()    //通过标签名称\ngetelementsbyname()     //通过元素的name属性的值\ngetelementbyid()        //通过元素id，唯一性\n\n\n\n# 19 window.onload和$(document).ready\n\n> 原生js的window.onload与jquery的$(document).ready(function(){})有什么不同？如何用原生js实现jq的ready方法？\n\n * window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。\n\n * $(document).ready()是dom结构绘制完毕后就执行，不必等到加载完毕\n\nfunction ready(fn){\n      if(document.addeventlistener) {        //标准浏览器\n          document.addeventlistener('domcontentloaded', function() {\n              //注销事件, 避免反复触发\n              document.removeeventlistener('domcontentloaded',arguments.callee, false);\n              fn();            //执行函数\n          }, false);\n      }else if(document.attachevent) {        //ie\n          document.attachevent('onreadystatechange', function() {\n             if(document.readystate == 'complete') {\n                 document.detachevent('onreadystatechange', arguments.callee);\n                 fn();        //函数执行\n             }\n         });\n     }\n };\n\n\n\n# 20 addeventlistener()和attachevent()的区别\n\n * addeventlistener()是符合w3c规范的标准方法; attachevent()是ie低版本的非标准方法\n\n * addeventlistener()支持事件冒泡和事件捕获; - 而attachevent()只支持事件冒泡\n\n * addeventlistener()的第一个参数中,事件类型不需要添加on; attachevent()需要添加'on'\n\n * 如果为同一个元素绑定多个事件, addeventlistener()会按照事件绑定的顺序依次执行, attachevent()会按照事件绑定的顺序倒序执行\n\n\n# 21 数组去重方法总结\n\n方法一、利用es6 set去重（es6中最常用）\n\nfunction unique (arr) {\n  return array.from(new set(arr))\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, nan, nan,'nan', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n //[1, \"true\", true, 15, false, undefined, null, nan, \"nan\", 0, \"a\", {}, {}]\n\n\n方法二、利用for嵌套for，然后splice去重（es5中最常用）\n\nfunction unique(arr){            \n        for(var i=0; i<arr.length; i++){\n            for(var j=i+1; j<arr.length; j++){\n                if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个\n                    arr.splice(j,1);\n                    j--;\n                }\n            }\n        }\n\treturn arr;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, nan, nan,'nan', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n    //[1, \"true\", 15, false, undefined, nan, nan, \"nan\", \"a\", {…}, {…}]     //nan和{}没有去重，两个null直接消失了\n\n\n * 双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。\n\n * 想快速学习更多常用的es6语法\n\n方法三、利用indexof去重\n\nfunction unique(arr) {\n    if (!array.isarray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var array = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (array .indexof(arr[i]) === -1) {\n            array .push(arr[i])\n        }\n    }\n    return array;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, nan, nan,'nan', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n   // [1, \"true\", true, 15, false, undefined, null, nan, nan, \"nan\", 0, \"a\", {…}, {…}]  //nan、{}没有去重\n\n\n> 新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组\n\n方法四、利用sort()\n\nfunction unique(arr) {\n    if (!array.isarray(arr)) {\n        console.log('type error!')\n        return;\n    }\n    arr = arr.sort()\n    var arrry= [arr[0]];\n    for (var i = 1; i < arr.length; i++) {\n        if (arr[i] !== arr[i-1]) {\n            arrry.push(arr[i]);\n        }\n    }\n    return arrry;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, nan, nan,'nan', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n// [0, 1, 15, \"nan\", nan, nan, {…}, {…}, \"a\", false, null, true, \"true\", undefined]      //nan、{}没有去重\n\n\n> 利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对\n\n方法五、利用对象的属性不能相同的特点进行去重\n\nfunction unique(arr) {\n    if (!array.isarray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var arrry= [];\n     var  obj = {};\n    for (var i = 0; i < arr.length; i++) {\n        if (!obj[arr[i]]) {\n            arrry.push(arr[i])\n            obj[arr[i]] = 1\n        } else {\n            obj[arr[i]]++\n        }\n    }\n    return arrry;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, nan, nan,'nan', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n//[1, \"true\", 15, false, undefined, null, nan, 0, \"a\", {…}]    //两个true直接去掉了，nan和{}去重\n\n\n方法六、利用includes\n\nfunction unique(arr) {\n    if (!array.isarray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var array =[];\n    for(var i = 0; i < arr.length; i++) {\n            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值\n                    array.push(arr[i]);\n              }\n    }\n    return array\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, nan, nan,'nan', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n    //[1, \"true\", true, 15, false, undefined, null, nan, \"nan\", 0, \"a\", {…}, {…}]     //{}没有去重\n\n\n方法七、利用hasownproperty\n\nfunction unique(arr) {\n    var obj = {};\n    return arr.filter(function(item, index, arr){\n        return obj.hasownproperty(typeof item + item) ? false : (obj[typeof item + item] = true)\n    })\n}\n    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, nan, nan,'nan', 0, 0, 'a', 'a',{},{}];\n        console.log(unique(arr))\n//[1, \"true\", true, 15, false, undefined, null, nan, \"nan\", 0, \"a\", {…}]   //所有的都去重了\n\n\n> 利用hasownproperty 判断是否存在对象属性\n\n方法八、利用filter\n\nfunction unique(arr) {\n  return arr.filter(function(item, index, arr) {\n    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素\n    return arr.indexof(item, 0) === index;\n  });\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, nan, nan,'nan', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n//[1, \"true\", true, 15, false, undefined, null, \"nan\", 0, \"a\", {…}, {…}]\n\n\n方法九、利用递归去重\n\nfunction unique(arr) {\n    var array= arr;\n    var len = array.length;\n\n\tarray.sort(function(a,b){   //排序后更加方便去重\n\t\treturn a - b;\n\t})\n\n\tfunction loop(index){\n        if(index >= 1){\n            if(array[index] === array[index-1]){\n            array.splice(index,1);\n            }\n            loop(index - 1);    //递归loop，然后数组去重\n        }\n\t}\n\tloop(len-1);\n\treturn array;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, nan, nan,'nan', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n//[1, \"a\", \"true\", true, 15, false, 1, {…}, null, nan, nan, \"nan\", 0, \"a\", {…}, undefined]\n\n\n方法十、利用map数据结构去重\n\nfunction arraynonrepeatfy(arr) {\n\tlet map = new map();\n\t\tlet array = new array();  // 数组用于返回结果\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tif(map .has(arr[i])) {  // 如果有该key值\n\t\t\tmap .set(arr[i], true);\n\t\t} else {\n\t\t\tmap .set(arr[i], false);   // 如果没有该key值\n\t\t\tarray .push(arr[i]);\n\t\t}\n\t}\n\treturn array ;\n}\n var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, nan, nan,'nan', 0, 0, 'a', 'a',{},{}];\n    console.log(unique(arr))\n//[1, \"a\", \"true\", true, 15, false, 1, {…}, null, nan, nan, \"nan\", 0, \"a\", {…}, undefined]\n\n\n> 创建一个空map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到map中。由于map中不会出现相同的key值，所以最终得到的就是去重后的结果\n\n方法十一、利用reduce+includes\n\nfunction unique(arr){\n    return arr.reduce((prev,cur) => prev.includes(cur) ? prev : [...prev,cur],[]);\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, nan, nan,'nan', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr));\n// [1, \"true\", true, 15, false, undefined, null, nan, \"nan\", 0, \"a\", {…}, {…}]\n\n\n\n方法十二、[...new set(arr)]\n\n[...new set(arr)]\n//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）\n\n\n\n# 22 javascript全局函数和全局变量\n\n全局变量\n\n * infinity 代表正的无穷大的数值。\n\n * nan 指示某个值是不是数字值。\n\n * undefined 指示未定义的值。\n\n全局函数\n\n * decodeuri() 解码某个编码的 uri。\n\n * decodeuricomponent() 解码一个编码的 uri 组件。\n\n * encodeuri() 把字符串编码为 uri。\n\n * encodeuricomponent() 把字符串编码为 uri 组件。\n\n * escape() 对字符串进行编码。\n\n * eval() 计算 javascript 字符串，并把它作为脚本代码来执行。\n\n * isfinite() 检查某个值是否为有穷大的数。\n\n * isnan() 检查某个值是否是数字。\n\n * number() 把对象的值转换为数字。\n\n * parsefloat() 解析一个字符串并返回一个浮点数。\n\n * parseint() 解析一个字符串并返回一个整数。\n\n * string() 把对象的值转换为字符串。\n\n * unescape() 对由escape() 编码的字符串进行解码\n\n\n# 23 项目做过哪些性能优化？\n\n * 减少 http 请求数\n\n * 减少 dns 查询\n\n * 使用 cdn\n\n * 避免重定向\n\n * 图片懒加载\n\n * 减少 dom 元素数量\n\n * 减少dom 操作\n\n * 使用外部 javascript 和 css\n\n * 压缩 javascript 、 css 、字体、图片等\n\n * 优化 css sprite\n\n * 使用 iconfont\n\n * 字体裁剪\n\n * 多域名分发划分内容到不同域名\n\n * 尽量减少 iframe 使用\n\n * 避免图片 src 为空\n\n * 把样式表放在link 中\n\n * 把javascript放在页面底部\n\n\n# 24 websocket\n\n> 由于 http 存在一个明显的弊端（消息只能有客户端推送到服务器端，而服务器端不能主动推送到客户端），导致如果服务器如果有连续的变化，这时只能使用轮询，而轮询效率过低，并不适合。于是 websocket被发明出来\n\n> 相比与 http 具有以下有点\n\n * 支持双向通信，实时性更强；\n\n * 可以发送文本，也可以二进制文件；\n\n * 协议标识符是 ws，加密后是 wss ；\n\n * 较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而http协议每次通信都需要携带完整的头部；\n\n * 支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）\n\n * 无跨域问题。\n\n> 实现比较简单，服务端库如 socket.io、ws，可以很好的帮助我们入门。而客户端也只需要参照 api 实现即可\n\n\n# 25 防抖/节流\n\n防抖\n\n> 在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。可以通过函数防抖动来实现\n\n// 使用 underscore 的源码来解释防抖动\n\n/**\n * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行\n *\n * @param  {function} func        回调函数\n * @param  {number}   wait        表示时间窗口的间隔\n * @param  {boolean}  immediate   设置为ture时，是否立即调用函数\n * @return {function}             返回客户调用函数\n */\n_.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      // 现在和上一次时间戳比较\n      var last = _.now() - timestamp;\n      // 如果当前间隔时间少于设定时间且大于0就重新设置定时器\n      if (last < wait && last >= 0) {\n        timeout = settimeout(later, wait - last);\n      } else {\n        // 否则的话就是时间到了执行回调函数\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      // 获得时间戳\n      timestamp = _.now();\n      // 如果定时器不存在且立即执行函数\n      var callnow = immediate && !timeout;\n      // 如果定时器不存在就创建一个\n      if (!timeout) timeout = settimeout(later, wait);\n      if (callnow) {\n        // 如果需要立即执行函数的话 通过 apply 执行\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n\n> 整体函数实现\n\n对于按钮防点击来说的实现\n\n * 开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了\n\n * 对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数\n\n节流\n\n> 防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行\n\n/**\n * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait\n *\n * @param  {function}   func      回调函数\n * @param  {number}     wait      表示时间窗口的间隔\n * @param  {object}     options   如果想忽略开始函数的的调用，传入{leading: false}。\n *                                如果想忽略结尾函数的调用，传入{trailing: false}\n *                                两者不能共存，否则函数不能执行\n * @return {function}             返回客户调用函数   \n */\n_.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    // 之前的时间戳\n    var previous = 0;\n    // 如果 options 没传则设为空对象\n    if (!options) options = {};\n    // 定时器回调函数\n    var later = function() {\n      // 如果设置了 leading，就将 previous 设为 0\n      // 用于下面函数的第一个 if 判断\n      previous = options.leading === false ? 0 : _.now();\n      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      // 获得当前时间戳\n      var now = _.now();\n      // 首次进入前者肯定为 true\n\t  // 如果需要第一次不执行函数\n\t  // 就将上次时间戳设为当前的\n      // 这样在接下来计算 remaining 的值时会大于0\n      if (!previous && options.leading === false) previous = now;\n      // 计算剩余时间\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      // 如果当前调用已经大于上次调用时间 + wait\n      // 或者用户手动调了时间\n \t  // 如果设置了 trailing，只会进入这个条件\n\t  // 如果没有设置 leading，那么第一次会进入这个条件\n\t  // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了\n\t  // 其实还是会进入的，因为定时器的延时\n\t  // 并不是准确的时间，很可能你设置了2秒\n\t  // 但是他需要2.2秒才触发，这时候就会进入这个条件\n      if (remaining <= 0 || remaining > wait) {\n        // 如果存在定时器就清理掉否则会调用二次回调\n        if (timeout) {\n          cleartimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        // 判断是否设置了定时器和 trailing\n\t    // 没有的话就开启一个定时器\n        // 并且不能不能同时设置 leading 和 trailing\n        timeout = settimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n\n\n# 26 说说从输入url到看到页面发生的全过程，越详细越好\n\n * 首先浏览器主进程接管，开了一个下载线程。\n\n * 然后进行http请求（dns查询、ip寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。\n\n * 将下载完的内容转交给renderer进程管理。\n\n * renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。\n\n * 解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。\n\n * css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。\n\n * 绘制结束后，关闭tcp连接，过程有四次挥手\n\n\n# 27 现在要你完成一个dialog组件，说说你设计的思路？它应该有什么功能？\n\n * 该组件需要提供hook指定渲染位置，默认渲染在body下面。\n\n * 然后改组件可以指定外层样式，如宽度等\n\n * 组件外层还需要一层mask来遮住底层内容，点击mask可以执行传进来的oncancel函数关闭dialog。\n\n * 另外组件是可控的，需要外层传入visible表示是否可见。\n\n * 然后dialog可能需要自定义头head和底部footer，默认有头部和底部，底部有一个确认按钮和取消按钮，确认按钮会执行外部传进来的onok事件，然后取消按钮会执行外部传进来的oncancel事件。\n\n * 当组件的visible为true时候，设置body的overflow为hidden，隐藏body的滚动条，反之显示滚动条。\n\n * 组件高度可能大于页面高度，组件内部需要滚动条。\n\n * 只有组件的visible有变化且为ture时候，才重渲染组件内的所有内容\n\n\n# 28 ajax、axios、fetch区别\n\njquery ajax\n\n$.ajax({\n   type: 'post',\n   url: url,\n   data: data,\n   datatype: datatype,\n   success: function () {},\n   error: function () {}\n});\n\n\n优缺点：\n\n * 本身是针对mvc的编程,不符合现在前端mvvm的浪潮\n\n * 基于原生的xhr开发，xhr本身的架构不清晰，已经有了fetch的替代方案\n\n * jquery整个项目太大，单纯使用ajax却要引入整个jquery非常的不合理（采取个性化打包的方案又不能享受cdn服务）\n\naxios\n\naxios({\n    method: 'post',\n    url: '/user/12345',\n    data: {\n        firstname: 'fred',\n        lastname: 'flintstone'\n    }\n})\n.then(function (response) {\n    console.log(response);\n})\n.catch(function (error) {\n    console.log(error);\n});\n\n\n优缺点：\n\n * 从浏览器中创建 xmlhttprequest\n\n * 从 node.js 发出 http 请求\n\n * 支持 promise api\n\n * 拦截请求和响应\n\n * 转换请求和响应数据\n\n * 取消请求\n\n * 自动转换json数据\n\n * 客户端支持防止csrf/xsrf\n\nfetch\n\ntry {\n  let response = await fetch(url);\n  let data = response.json();\n  console.log(data);\n} catch(e) {\n  console.log(\"oops, error\", e);\n\n}\n\n\n优缺点：\n\n * fetcht只对网络请求报错，对400，500都当做成功的请求，需要封装去处理\n\n * fetch默认不会带cookie，需要添加配置项\n\n * fetch不支持abort，不支持超时控制，使用settimeout及promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费\n\n * fetch没有办法原生监测请求的进度，而xhr可以\n\n\n# javascript如何实现继承\n\n> 构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上\n\nfunction cat(name,color){\n 　animal.apply(this, arguments);\n 　this.name = name;\n 　this.color = color;\n}\n\n\n * 实例继承：将子对象的 prototype 指向父对象的一个实例\n\ncat.prototype = new animal();\ncat.prototype.constructor = cat;\n\n\n> 拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象\n\nfunction extend(child, parent) {\n　　　var p = parent.prototype;\n　　　var c = child.prototype;\n　　　for (var i in p) {\n　　　   c[i] = p[i];\n　　　}\n　　　c.uber = p;\n　 }\n\n\n> 原型继承：将子对象的 prototype 指向父对象的 prototype\n\nfunction extend(child, parent) {\n    var f = function(){};\n  　f.prototype = parent.prototype;\n  　child.prototype = new f();\n  　child.prototype.constructor = child;\n  　child.uber = parent.prototype;\n}\n\n\n> es6` 语法糖 `extends：class colorpoint extends point {}\n\nclass colorpoint extends point {\n    constructor(x, y, color) {\n      super(x, y); // 调用父类的constructor(x, y)\n      this.color = color;\n    }\n    tostring() {\n      return this.color + ' ' + super.tostring(); // 调用父类的tostring()\n    }\n}\n\n\n\n# 29 什么是函数节流？介绍一下应用场景和原理？\n\n * 函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。 只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。 但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果）\n\n * 函数节流用于 onresize, onscroll 等短时间内会多次触发的事件\n\n * 函数节流的原理：使用定时器做时间节流。 当触发一个事件时，先用 settimout 让这个事件延迟一小段时间再执行。 如果在这个时间间隔内又触发了事件，就 cleartimeout 原来的定时器， 再 settimeout 一个新的定时器重复以上流程。\n\n函数节流简单实现：\n\nfunction throttle(method, context) {\n     cleartimeout(methor.tid);\n     method.tid = settimeout(function(){\n         method.call(context);\n     }， 100); // 两次调用至少间隔 100ms\n}\n// 调用\nwindow.onresize = function(){\n  throttle(myfunc, window);\n}\n\n\n\n# 30 继承\n\n * 原型链继承，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构造函数传参。\n\n * 构造继承，使用父类的构造函数来增强子类实例，即复制父类的实例属性给子类，构造继承可以向父类传递参数，可以实现多继承，通过call多个父类对象。但是构造继承只能继承父类的实例属性和方法，不能继承原型属性和方法，无法实现函数服用，每个子类都有父类实例函数的副本，影响性能\n\n * 实例继承，为父类实例添加新特性，作为子类实例返回，实例继承的特点是不限制调用方法，不管是new 子类（）还是子类（）返回的对象具有相同的效果，缺点是实例是父类的实例，不是子类的实例，不支持多继承\n\n * 拷贝继承：特点：支持多继承，缺点：效率较低，内存占用高（因为要拷贝父类的属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用for in访问到）\n\n * 组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n * 寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点\n\n\n# 31 负载均衡\n\n> 多台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用\n\n * http重定向负载均衡：调度者根据策略选择服务器以302响应请求，缺点只有第一次有效果，后续操作维持在该服务器 dns负载均衡：解析域名时，访问多个ip服务器中的一个（可监控性较弱）\n * 反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大，性能受到 服务器群的数量\n\n\n# 32 cdn\n\n> 内容分发网络，基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "webpack相关",
      "frontmatter": {
        "title": "webpack相关",
        "date": "2022-08-26T15:11:32.000Z",
        "permalink": "/pages/baseWebpack/"
      },
      "regularPath": "/10.%E5%9F%BA%E7%A1%80%E7%AF%87/10.%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/40.webpack%E7%9B%B8%E5%85%B3.html",
      "relativePath": "10.基础篇/10.基础进阶/40.webpack相关.md",
      "key": "v-37775b06",
      "path": "/pages/baseWebpack/",
      "headers": [
        {
          "level": 3,
          "title": "1 打包体积 优化思路",
          "slug": "_1-打包体积-优化思路",
          "normalizedTitle": "1 打包体积 优化思路",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2 打包效率",
          "slug": "_2-打包效率",
          "normalizedTitle": "2 打包效率",
          "charIndex": 195
        },
        {
          "level": 3,
          "title": "3 Loader",
          "slug": "_3-loader",
          "normalizedTitle": "3 loader",
          "charIndex": 396
        },
        {
          "level": 3,
          "title": "4 说一下webpack的一些plugin，怎么使用webpack对项目进行优化",
          "slug": "_4-说一下webpack的一些plugin-怎么使用webpack对项目进行优化",
          "normalizedTitle": "4 说一下webpack的一些plugin，怎么使用webpack对项目进行优化",
          "charIndex": 828
        },
        {
          "level": 3,
          "title": "5 webpack Plugin 和 Loader 的区别",
          "slug": "_5-webpack-plugin-和-loader-的区别",
          "normalizedTitle": "5 webpack plugin 和 loader 的区别",
          "charIndex": 1322
        },
        {
          "level": 3,
          "title": "6 tree shaking 的原理是什么",
          "slug": "_6-tree-shaking-的原理是什么",
          "normalizedTitle": "6 tree shaking 的原理是什么",
          "charIndex": 1739
        },
        {
          "level": 3,
          "title": "7 common.js 和 es6 中模块引入的区别",
          "slug": "_7-common-js-和-es6-中模块引入的区别",
          "normalizedTitle": "7 common.js 和 es6 中模块引入的区别",
          "charIndex": 1848
        },
        {
          "level": 3,
          "title": "8 babel原理",
          "slug": "_8-babel原理",
          "normalizedTitle": "8 babel原理",
          "charIndex": 2413
        }
      ],
      "headersStr": "1 打包体积 优化思路 2 打包效率 3 Loader 4 说一下webpack的一些plugin，怎么使用webpack对项目进行优化 5 webpack Plugin 和 Loader 的区别 6 tree shaking 的原理是什么 7 common.js 和 es6 中模块引入的区别 8 babel原理",
      "content": "# 1 打包体积 优化思路\n\n * 提取第三方库或通过引用外部文件的方式引入第三方库\n\n * 代码压缩插件UglifyJsPlugin\n\n * 服务器启用gzip压缩\n\n * 按需加载资源文件 require.ensure\n\n * 优化devtool中的source-map\n\n * 剥离css文件，单独打包\n\n * 去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致\n\n\n# 2 打包效率\n\n * 开发环境采用增量构建，启用热更新\n\n * 开发环境不做无意义的工作如提取css计算文件hash等\n\n * 配置devtool\n\n * 选择合适的loader\n\n * 个别loader开启cache 如babel-loader\n\n * 第三方库采用引入方式\n\n * 提取公共代码\n\n * 优化构建时的搜索路径 指明需要构建目录及不需要构建目录\n\n * 模块化引入需要的部分\n\n\n# 3 Loader\n\n编写一个loader\n\nloader`就是一个`node`模块，它输出了一个函数。当某种资源需要用这个`loader`转换时，这个函数会被调用。并且，这个函数可以通过提供给它的`this`上下文访问`Loader API`。 `reverse-txt-loader\n\n\n// 定义\nmodule.exports = function(src) {\n  //src是原文件内容（abcde），下面对内容进行处理，这里是反转\n  var result = src.split('').reverse().join('');\n  //返回JavaScript源码，必须是String或者Buffer\n  return `module.exports = '${result}'`;\n}\n//使用\n{\n\ttest: /\\.txt$/,\n\tuse: [\n\t\t{\n\t\t\t'./path/reverse-txt-loader'\n\t\t}\n\t]\n},\n\n\n\n# 4 说一下webpack的一些plugin，怎么使用webpack对项目进行优化\n\n构建优化\n\n * 减少编译体积 ContextReplacementPugin、IgnorePlugin、babel-plugin-import、babel-plugin-transform-runtime\n\n * 并行编译 happypack、thread-loader、uglifyjsWebpackPlugin开启并行\n\n * 缓存 cache-loader、hard-source-webpack-plugin、uglifyjsWebpackPlugin开启缓存、babel-loader开启缓存\n\n * 预编译 dllWebpackPlugin && DllReferencePlugin、auto-dll-webapck-plugin\n\n性能优化\n\n * 减少编译体积 Tree-shaking、Scope Hositing\n\n * hash缓存 webpack-md5-plugin\n\n * 拆包 splitChunksPlugin、import()、require.ensure\n\n\n# 5 webpack Plugin 和 Loader 的区别\n\n * Loader\n   \n   * 用于对模块源码的转换，loader 描述了 webpack 如何处理非 javascript 模块，并且在 build 中引入这些依赖。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或者将内联图像转换为 data URL。比如说：CSS-Loader，Style-Loader 等\n\n * Plugin:\n   \n   * 目的在于解决 loader 无法实现的其他事,它直接作用于 webpack，扩展了它的功能。在 webpack 运行的生命周期中会广播出许多事件，plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务\n\n\n# 6 tree shaking 的原理是什么\n\n * ES6 Module引入进行静态分析，故而编译的时候正确判断到底加载了那些模块\n\n * 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码\n\n\n# 7 common.js 和 es6 中模块引入的区别\n\n> CommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。运行在浏览器端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: AMD)，用来对前端模块进行管理。自 ES6 起，引入了一套新的 ES6 Module规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 ES6 Module 兼容还不太好，我们平时在 Webpack 中使用的 export和 import，会经过 Babel 转换为 CommonJS 规范\n\n在使用上的差别主要有：\n\n * CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n\n * CommonJS 模块是运行时加载，ES6 模块是编译时输出接口（静态编译）。\n\n * CommonJs 是单个值导出，ES6 Module 可以导出多个\n\n * CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层\n\n * CommonJs 的 this 是当前模块，ES6 Module 的 this 是 undefined\n\n\n# 8 babel原理\n\nBabel 是一个 JavaScript 编译器。他把最新版的 javascript 编译成当下可以执行的版本，简言之，利用 babel 就可以让我们在当前的项目中随意的使用这些新最新的 es6，甚至 es7 的语法\n\n> ES6、7代码输入 -> babylon进行解析 -> 得到AST（抽象语法树）-> plugin用babel-traverse对AST树进行遍历转译 ->得到新的AST树->用babel-generator通过AST树生成ES5代码\n\nBabel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）\n\n * 解析 将代码解析成抽象语法树（AST），每个 js 引擎（比如 Chrome 浏览器中的 V8 引擎）都有自己的 AST 解析器，而 Babel 是通过 Babylon 实现的。在解析过程中有两个阶段：词法分析和语法分析，词法分析阶段把字符串形式的代码转换为令牌（tokens）流，令牌类似于 AST 中节点；而语法分析阶段则会把一个令牌流转换成 AST 的形式，同时这个阶段会把令牌中的信息转换成 AST 的表述结构\n\n * 转换 在这个阶段，Babel 接受得到 AST 并通过 babel-traverse 对其进行深度优先遍历，在此过程中对节点进行添加、更新及移除操作。这部分也是 Babel 插件介入工作的部分\n\n * 生成 将经过转换的 AST 通过 babel-generator再转换成 js 代码，过程就是深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。",
      "normalizedContent": "# 1 打包体积 优化思路\n\n * 提取第三方库或通过引用外部文件的方式引入第三方库\n\n * 代码压缩插件uglifyjsplugin\n\n * 服务器启用gzip压缩\n\n * 按需加载资源文件 require.ensure\n\n * 优化devtool中的source-map\n\n * 剥离css文件，单独打包\n\n * 去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致\n\n\n# 2 打包效率\n\n * 开发环境采用增量构建，启用热更新\n\n * 开发环境不做无意义的工作如提取css计算文件hash等\n\n * 配置devtool\n\n * 选择合适的loader\n\n * 个别loader开启cache 如babel-loader\n\n * 第三方库采用引入方式\n\n * 提取公共代码\n\n * 优化构建时的搜索路径 指明需要构建目录及不需要构建目录\n\n * 模块化引入需要的部分\n\n\n# 3 loader\n\n编写一个loader\n\nloader`就是一个`node`模块，它输出了一个函数。当某种资源需要用这个`loader`转换时，这个函数会被调用。并且，这个函数可以通过提供给它的`this`上下文访问`loader api`。 `reverse-txt-loader\n\n\n// 定义\nmodule.exports = function(src) {\n  //src是原文件内容（abcde），下面对内容进行处理，这里是反转\n  var result = src.split('').reverse().join('');\n  //返回javascript源码，必须是string或者buffer\n  return `module.exports = '${result}'`;\n}\n//使用\n{\n\ttest: /\\.txt$/,\n\tuse: [\n\t\t{\n\t\t\t'./path/reverse-txt-loader'\n\t\t}\n\t]\n},\n\n\n\n# 4 说一下webpack的一些plugin，怎么使用webpack对项目进行优化\n\n构建优化\n\n * 减少编译体积 contextreplacementpugin、ignoreplugin、babel-plugin-import、babel-plugin-transform-runtime\n\n * 并行编译 happypack、thread-loader、uglifyjswebpackplugin开启并行\n\n * 缓存 cache-loader、hard-source-webpack-plugin、uglifyjswebpackplugin开启缓存、babel-loader开启缓存\n\n * 预编译 dllwebpackplugin && dllreferenceplugin、auto-dll-webapck-plugin\n\n性能优化\n\n * 减少编译体积 tree-shaking、scope hositing\n\n * hash缓存 webpack-md5-plugin\n\n * 拆包 splitchunksplugin、import()、require.ensure\n\n\n# 5 webpack plugin 和 loader 的区别\n\n * loader\n   \n   * 用于对模块源码的转换，loader 描述了 webpack 如何处理非 javascript 模块，并且在 build 中引入这些依赖。loader 可以将文件从不同的语言（如 typescript）转换为 javascript，或者将内联图像转换为 data url。比如说：css-loader，style-loader 等\n\n * plugin:\n   \n   * 目的在于解决 loader 无法实现的其他事,它直接作用于 webpack，扩展了它的功能。在 webpack 运行的生命周期中会广播出许多事件，plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 api 改变输出结果。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务\n\n\n# 6 tree shaking 的原理是什么\n\n * es6 module引入进行静态分析，故而编译的时候正确判断到底加载了那些模块\n\n * 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码\n\n\n# 7 common.js 和 es6 中模块引入的区别\n\n> commonjs 是一种模块规范，最初被应用于 nodejs，成为 nodejs 的模块规范。运行在浏览器端的 javascript 由于也缺少类似的规范，在 es6 出来之前，前端也实现了一套相同的模块规范 (例如: amd)，用来对前端模块进行管理。自 es6 起，引入了一套新的 es6 module规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 es6 module 兼容还不太好，我们平时在 webpack 中使用的 export和 import，会经过 babel 转换为 commonjs 规范\n\n在使用上的差别主要有：\n\n * commonjs 模块输出的是一个值的拷贝，es6 模块输出的是值的引用。\n\n * commonjs 模块是运行时加载，es6 模块是编译时输出接口（静态编译）。\n\n * commonjs 是单个值导出，es6 module 可以导出多个\n\n * commonjs 是动态语法可以写在判断里，es6 module 静态语法只能写在顶层\n\n * commonjs 的 this 是当前模块，es6 module 的 this 是 undefined\n\n\n# 8 babel原理\n\nbabel 是一个 javascript 编译器。他把最新版的 javascript 编译成当下可以执行的版本，简言之，利用 babel 就可以让我们在当前的项目中随意的使用这些新最新的 es6，甚至 es7 的语法\n\n> es6、7代码输入 -> babylon进行解析 -> 得到ast（抽象语法树）-> plugin用babel-traverse对ast树进行遍历转译 ->得到新的ast树->用babel-generator通过ast树生成es5代码\n\nbabel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）\n\n * 解析 将代码解析成抽象语法树（ast），每个 js 引擎（比如 chrome 浏览器中的 v8 引擎）都有自己的 ast 解析器，而 babel 是通过 babylon 实现的。在解析过程中有两个阶段：词法分析和语法分析，词法分析阶段把字符串形式的代码转换为令牌（tokens）流，令牌类似于 ast 中节点；而语法分析阶段则会把一个令牌流转换成 ast 的形式，同时这个阶段会把令牌中的信息转换成 ast 的表述结构\n\n * 转换 在这个阶段，babel 接受得到 ast 并通过 babel-traverse 对其进行深度优先遍历，在此过程中对节点进行添加、更新及移除操作。这部分也是 babel 插件介入工作的部分\n\n * 生成 将经过转换的 ast 通过 babel-generator再转换成 js 代码，过程就是深度优先遍历整个 ast，然后构建可以表示转换后代码的字符串。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "综合",
      "frontmatter": {
        "title": "综合",
        "date": "2022-08-26T15:21:11.000Z",
        "permalink": "/pages/baseUs/"
      },
      "regularPath": "/10.%E5%9F%BA%E7%A1%80%E7%AF%87/10.%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/50.%E7%BB%BC%E5%90%88.html",
      "relativePath": "10.基础篇/10.基础进阶/50.综合.md",
      "key": "v-4c18c55a",
      "path": "/pages/baseUs/",
      "headers": [
        {
          "level": 3,
          "title": "1 谈谈你对重构的理解",
          "slug": "_1-谈谈你对重构的理解",
          "normalizedTitle": "1 谈谈你对重构的理解",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2 什么样的前端代码是好的",
          "slug": "_2-什么样的前端代码是好的",
          "normalizedTitle": "2 什么样的前端代码是好的",
          "charIndex": 238
        },
        {
          "level": 3,
          "title": "3 对前端工程师这个职位是怎么样理解的？它的前景会怎么样",
          "slug": "_3-对前端工程师这个职位是怎么样理解的-它的前景会怎么样",
          "normalizedTitle": "3 对前端工程师这个职位是怎么样理解的？它的前景会怎么样",
          "charIndex": 323
        },
        {
          "level": 3,
          "title": "4 你觉得前端工程的价值体现在哪",
          "slug": "_4-你觉得前端工程的价值体现在哪",
          "normalizedTitle": "4 你觉得前端工程的价值体现在哪",
          "charIndex": 547
        },
        {
          "level": 3,
          "title": "5 平时如何管理你的项目",
          "slug": "_5-平时如何管理你的项目",
          "normalizedTitle": "5 平时如何管理你的项目",
          "charIndex": 690
        },
        {
          "level": 3,
          "title": "6 组件封装",
          "slug": "_6-组件封装",
          "normalizedTitle": "6 组件封装",
          "charIndex": 1055
        },
        {
          "level": 3,
          "title": "7 Web 前端开发的注意事项",
          "slug": "_7-web-前端开发的注意事项",
          "normalizedTitle": "7 web 前端开发的注意事项",
          "charIndex": 1149
        },
        {
          "level": 3,
          "title": "8 在设计 Web APP 时，应当遵循以下几点",
          "slug": "_8-在设计-web-app-时-应当遵循以下几点",
          "normalizedTitle": "8 在设计 web app 时，应当遵循以下几点",
          "charIndex": 1325
        },
        {
          "level": 3,
          "title": "9 你怎么看待 Web App/hybrid App/Native App？（移动端前端 和 Web 前端区别？）",
          "slug": "_9-你怎么看待-web-app-hybrid-app-native-app-移动端前端-和-web-前端区别",
          "normalizedTitle": "9 你怎么看待 web app/hybrid app/native app？（移动端前端 和 web 前端区别？）",
          "charIndex": 1450
        },
        {
          "level": 3,
          "title": "10 页面重构怎么操作",
          "slug": "_10-页面重构怎么操作",
          "normalizedTitle": "10 页面重构怎么操作",
          "charIndex": 1870
        }
      ],
      "headersStr": "1 谈谈你对重构的理解 2 什么样的前端代码是好的 3 对前端工程师这个职位是怎么样理解的？它的前景会怎么样 4 你觉得前端工程的价值体现在哪 5 平时如何管理你的项目 6 组件封装 7 Web 前端开发的注意事项 8 在设计 Web APP 时，应当遵循以下几点 9 你怎么看待 Web App/hybrid App/Native App？（移动端前端 和 Web 前端区别？） 10 页面重构怎么操作",
      "content": "# 1 谈谈你对重构的理解\n\n * 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI\n\n * 对于传统的网站来说重构通常是：\n   \n   * 表格(table)布局改为DIV+CSS\n   \n   * 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)\n   \n   * 对于移动平台的优化\n   \n   * 针对于SEO进行优化\n\n\n# 2 什么样的前端代码是好的\n\n * 高复用低耦合，这样文件小，好维护，而且好扩展。\n * 具有可用性、健壮性、可靠性、宽容性等特点\n * 遵循设计模式的六大原则\n\n\n# 3 对前端工程师这个职位是怎么样理解的？它的前景会怎么样\n\n * 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近\n   \n   * 实现界面交互\n   \n   * 提升用户体验\n   \n   * 基于NodeJS，可跨平台开发\n\n * 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，\n\n * 与团队成员，UI设计，产品经理的沟通；\n\n * 做好的页面结构，页面重构和用户体验；\n\n\n# 4 你觉得前端工程的价值体现在哪\n\n * 为简化用户使用提供技术支持（交互部分）\n\n * 为多个浏览器兼容性提供支持\n\n * 为提高用户浏览速度（浏览器性能）提供支持\n\n * 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持\n\n * 为展示数据提供支持（数据接口）\n\n\n# 5 平时如何管理你的项目\n\n * 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；\n\n * 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；\n\n * 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；\n\n * 页面进行标注（例如 页面 模块 开始和结束）；\n\n * CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；\n\n * JS 分文件夹存放 命名以该JS功能为准的英文翻译。\n\n * 图片采用整合的 images.png png8 格式文件使用 - 尽量整合在一起使用方便将来的管理\n\n * 规定全局样式、公共脚本\n\n * 严格要求代码注释(html/js/css)\n\n * 严格要求静态资源存放路径\n\n * Git 提交必须填写说明\n\n\n# 6 组件封装\n\n> 目的：为了重用，提高开发效率和代码质量 注意：低耦合，单一职责，可复用性，可维护性 常用操作\n\n * 分析布局\n * 初步开发\n * 化繁为简\n * 组件抽象\n\n\n# 7 Web 前端开发的注意事项\n\n * 特别设置 meta 标签 viewport\n * 百分比布局宽度，结合 box-sizing: border-box;\n * 使用 rem 作为计算单位。rem 只参照跟节点 html 的字体大小计算\n * 使用 css3 新特性。弹性盒模型、多列布局、媒体查询等\n * 多机型、多尺寸、多系统覆盖测试\n\n\n# 8 在设计 Web APP 时，应当遵循以下几点\n\n * 简化不重要的动画/动效/图形文字样式\n * 少用手势，避免与浏览器手势冲突\n * 减少页面内容，页面跳转次数，尽量在当前页面显示\n * 增强 Loading 趣味性，增强页面主次关系\n\n\n# 9 你怎么看待 Web App/hybrid App/Native App？（移动端前端 和 Web 前端区别？）\n\n * Web App(HTML5)：采用HTML5生存在浏览器中的应用，不需要下载安装\n   * 优点：开发成本低，迭代更新容易，不需用户升级，跨多个平台和终端\n   * 缺点：消息推送不够及时，支持图形和动画效果较差，功能使用限制（相机、GPS等）\n * Hybrid App(混合开发)：UI WebView，需要下载安装\n   * 优点：接近 Native App 的体验，部分支持离线功能\n   * 缺点：性能速度较慢，未知的部署时间，受限于技术尚不成熟\n * Native App(原生开发)：依托于操作系统，有很强的交互，需要用户下载安装使用\n   * 优点：用户体验完美，支持离线工作，可访问本地资源（通讯录，相册）\n   * 缺点：开发成本高（多系统），开发成本高（版本更新），需要应用商店的审核\n\n\n# 10 页面重构怎么操作\n\n> 网站重构：不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。\n\n * 页面重构可以考虑的方面：\n   * 升级第三方依赖\n   * 使用HTML5、CSS3、ES6 新特性\n   * 加入响应式布局\n   * 统一代码风格规范\n   * 减少代码间的耦合\n   * 压缩/合并静态资源\n   * 程序的性能优化\n   * 采用CDN来加速资源加载\n   * 对于JS DOM的优化\n   * HTTP服务器的文件缓存",
      "normalizedContent": "# 1 谈谈你对重构的理解\n\n * 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变ui的情况下，对网站进行优化， 在扩展的同时保持一致的ui\n\n * 对于传统的网站来说重构通常是：\n   \n   * 表格(table)布局改为div+css\n   \n   * 使网站前端兼容于现代浏览器(针对于不合规范的css、如对ie6有效的)\n   \n   * 对于移动平台的优化\n   \n   * 针对于seo进行优化\n\n\n# 2 什么样的前端代码是好的\n\n * 高复用低耦合，这样文件小，好维护，而且好扩展。\n * 具有可用性、健壮性、可靠性、宽容性等特点\n * 遵循设计模式的六大原则\n\n\n# 3 对前端工程师这个职位是怎么样理解的？它的前景会怎么样\n\n * 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近\n   \n   * 实现界面交互\n   \n   * 提升用户体验\n   \n   * 基于nodejs，可跨平台开发\n\n * 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，\n\n * 与团队成员，ui设计，产品经理的沟通；\n\n * 做好的页面结构，页面重构和用户体验；\n\n\n# 4 你觉得前端工程的价值体现在哪\n\n * 为简化用户使用提供技术支持（交互部分）\n\n * 为多个浏览器兼容性提供支持\n\n * 为提高用户浏览速度（浏览器性能）提供支持\n\n * 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持\n\n * 为展示数据提供支持（数据接口）\n\n\n# 5 平时如何管理你的项目\n\n * 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；\n\n * 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；\n\n * 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；\n\n * 页面进行标注（例如 页面 模块 开始和结束）；\n\n * css跟html 分文件夹并行存放，命名都得统一（例如style.css）；\n\n * js 分文件夹存放 命名以该js功能为准的英文翻译。\n\n * 图片采用整合的 images.png png8 格式文件使用 - 尽量整合在一起使用方便将来的管理\n\n * 规定全局样式、公共脚本\n\n * 严格要求代码注释(html/js/css)\n\n * 严格要求静态资源存放路径\n\n * git 提交必须填写说明\n\n\n# 6 组件封装\n\n> 目的：为了重用，提高开发效率和代码质量 注意：低耦合，单一职责，可复用性，可维护性 常用操作\n\n * 分析布局\n * 初步开发\n * 化繁为简\n * 组件抽象\n\n\n# 7 web 前端开发的注意事项\n\n * 特别设置 meta 标签 viewport\n * 百分比布局宽度，结合 box-sizing: border-box;\n * 使用 rem 作为计算单位。rem 只参照跟节点 html 的字体大小计算\n * 使用 css3 新特性。弹性盒模型、多列布局、媒体查询等\n * 多机型、多尺寸、多系统覆盖测试\n\n\n# 8 在设计 web app 时，应当遵循以下几点\n\n * 简化不重要的动画/动效/图形文字样式\n * 少用手势，避免与浏览器手势冲突\n * 减少页面内容，页面跳转次数，尽量在当前页面显示\n * 增强 loading 趣味性，增强页面主次关系\n\n\n# 9 你怎么看待 web app/hybrid app/native app？（移动端前端 和 web 前端区别？）\n\n * web app(html5)：采用html5生存在浏览器中的应用，不需要下载安装\n   * 优点：开发成本低，迭代更新容易，不需用户升级，跨多个平台和终端\n   * 缺点：消息推送不够及时，支持图形和动画效果较差，功能使用限制（相机、gps等）\n * hybrid app(混合开发)：ui webview，需要下载安装\n   * 优点：接近 native app 的体验，部分支持离线功能\n   * 缺点：性能速度较慢，未知的部署时间，受限于技术尚不成熟\n * native app(原生开发)：依托于操作系统，有很强的交互，需要用户下载安装使用\n   * 优点：用户体验完美，支持离线工作，可访问本地资源（通讯录，相册）\n   * 缺点：开发成本高（多系统），开发成本高（版本更新），需要应用商店的审核\n\n\n# 10 页面重构怎么操作\n\n> 网站重构：不改变ui的情况下，对网站进行优化，在扩展的同时保持一致的ui。\n\n * 页面重构可以考虑的方面：\n   * 升级第三方依赖\n   * 使用html5、css3、es6 新特性\n   * 加入响应式布局\n   * 统一代码风格规范\n   * 减少代码间的耦合\n   * 压缩/合并静态资源\n   * 程序的性能优化\n   * 采用cdn来加速资源加载\n   * 对于js dom的优化\n   * http服务器的文件缓存",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "HTML、HTTP、web综合问题",
      "frontmatter": {
        "title": "HTML、HTTP、web综合问题",
        "date": "2022-05-31T17:19:38.000Z",
        "permalink": "/pages/base",
        "article": false
      },
      "regularPath": "/10.%E5%9F%BA%E7%A1%80%E7%AF%87/10.%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/10.HTML%E3%80%81HTTP%E3%80%81web%E7%BB%BC%E5%90%88%E9%97%AE%E9%A2%98.html",
      "relativePath": "10.基础篇/10.基础进阶/10.HTML、HTTP、web综合问题.md",
      "key": "v-21015bef",
      "path": "/pages/base/",
      "headers": [
        {
          "level": 3,
          "title": "1 前端需要注意哪些SEO",
          "slug": "_1-前端需要注意哪些seo",
          "normalizedTitle": "1 前端需要注意哪些seo",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2 <img>的title和alt有什么区别",
          "slug": "_2-img-的title和alt有什么区别",
          "normalizedTitle": "2 <img>的title和alt有什么区别",
          "charIndex": 404
        },
        {
          "level": 3,
          "title": "3 HTTP的几种请求方法用途",
          "slug": "_3-http的几种请求方法用途",
          "normalizedTitle": "3 http的几种请求方法用途",
          "charIndex": 548
        },
        {
          "level": 3,
          "title": "4 从浏览器地址栏输入url到显示页面的步骤",
          "slug": "_4-从浏览器地址栏输入url到显示页面的步骤",
          "normalizedTitle": "4 从浏览器地址栏输入url到显示页面的步骤",
          "charIndex": 956
        },
        {
          "level": 3,
          "title": "5 如何进行网站性能优化",
          "slug": "_5-如何进行网站性能优化",
          "normalizedTitle": "5 如何进行网站性能优化",
          "charIndex": 1765
        },
        {
          "level": 3,
          "title": "6 HTTP状态码及其含义",
          "slug": "_6-http状态码及其含义",
          "normalizedTitle": "6 http状态码及其含义",
          "charIndex": 2899
        },
        {
          "level": 3,
          "title": "7 语义化的理解",
          "slug": "_7-语义化的理解",
          "normalizedTitle": "7 语义化的理解",
          "charIndex": 3603
        },
        {
          "level": 3,
          "title": "8 介绍一下你对浏览器内核的理解？",
          "slug": "_8-介绍一下你对浏览器内核的理解",
          "normalizedTitle": "8 介绍一下你对浏览器内核的理解？",
          "charIndex": 3782
        },
        {
          "level": 3,
          "title": "9 html5有哪些新特性、移除了那些元素？",
          "slug": "_9-html5有哪些新特性、移除了那些元素",
          "normalizedTitle": "9 html5有哪些新特性、移除了那些元素？",
          "charIndex": 4333
        },
        {
          "level": 3,
          "title": "10 HTML5的离线储存怎么使用，工作原理能不能解释一下？",
          "slug": "_10-html5的离线储存怎么使用-工作原理能不能解释一下",
          "normalizedTitle": "10 html5的离线储存怎么使用，工作原理能不能解释一下？",
          "charIndex": 5311
        },
        {
          "level": 3,
          "title": "11 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢",
          "slug": "_11-浏览器是怎么对html5的离线储存资源进行管理和加载的呢",
          "normalizedTitle": "11 浏览器是怎么对html5的离线储存资源进行管理和加载的呢",
          "charIndex": 5762
        },
        {
          "level": 3,
          "title": "12 请描述一下 cookies，sessionStorage 和 localStorage 的区别？",
          "slug": "_12-请描述一下-cookies-sessionstorage-和-localstorage-的区别",
          "normalizedTitle": "12 请描述一下 cookies，sessionstorage 和 localstorage 的区别？",
          "charIndex": 6050
        },
        {
          "level": 3,
          "title": "13 iframe有那些缺点？",
          "slug": "_13-iframe有那些缺点",
          "normalizedTitle": "13 iframe有那些缺点？",
          "charIndex": 6519
        },
        {
          "level": 3,
          "title": "14 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?",
          "slug": "_14-doctype作用-严格模式与混杂模式如何区分-它们有何意义",
          "normalizedTitle": "14 doctype作用? 严格模式与混杂模式如何区分？它们有何意义?",
          "charIndex": 6725
        },
        {
          "level": 3,
          "title": "15 Canvas和SVG有什么区别？",
          "slug": "_15-canvas和svg有什么区别",
          "normalizedTitle": "15 canvas和svg有什么区别？",
          "charIndex": 7090
        },
        {
          "level": 3,
          "title": "16 viewport",
          "slug": "_16-viewport",
          "normalizedTitle": "16 viewport",
          "charIndex": 7251
        },
        {
          "level": 3,
          "title": "17 渲染优化",
          "slug": "_17-渲染优化",
          "normalizedTitle": "17 渲染优化",
          "charIndex": 7918
        },
        {
          "level": 3,
          "title": "18 meta viewport相关",
          "slug": "_18-meta-viewport相关",
          "normalizedTitle": "18 meta viewport相关",
          "charIndex": 8801
        },
        {
          "level": 3,
          "title": "19 你能描述一下渐进增强和优雅降级之间的不同吗",
          "slug": "_19-你能描述一下渐进增强和优雅降级之间的不同吗",
          "normalizedTitle": "19 你能描述一下渐进增强和优雅降级之间的不同吗",
          "charIndex": 10937
        },
        {
          "level": 3,
          "title": "20 知道的网页制作会用到的图片格式有哪些？",
          "slug": "_20-知道的网页制作会用到的图片格式有哪些",
          "normalizedTitle": "20 知道的网页制作会用到的图片格式有哪些？",
          "charIndex": 11192
        },
        {
          "level": 3,
          "title": "21 优化大量图片的加载",
          "slug": "_21-优化大量图片的加载",
          "normalizedTitle": "21 优化大量图片的加载",
          "charIndex": 11612
        },
        {
          "level": 3,
          "title": "22 谈谈Cookie的弊端",
          "slug": "_22-谈谈cookie的弊端",
          "normalizedTitle": "22 谈谈cookie的弊端",
          "charIndex": 11915
        }
      ],
      "headersStr": "1 前端需要注意哪些SEO 2 <img>的title和alt有什么区别 3 HTTP的几种请求方法用途 4 从浏览器地址栏输入url到显示页面的步骤 5 如何进行网站性能优化 6 HTTP状态码及其含义 7 语义化的理解 8 介绍一下你对浏览器内核的理解？ 9 html5有哪些新特性、移除了那些元素？ 10 HTML5的离线储存怎么使用，工作原理能不能解释一下？ 11 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢 12 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ 13 iframe有那些缺点？ 14 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义? 15 Canvas和SVG有什么区别？ 16 viewport 17 渲染优化 18 meta viewport相关 19 你能描述一下渐进增强和优雅降级之间的不同吗 20 知道的网页制作会用到的图片格式有哪些？ 21 优化大量图片的加载 22 谈谈Cookie的弊端",
      "content": "# 1 前端需要注意哪些SEO\n\n * 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可\n\n * 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页\n\n * 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取\n\n * 重要内容不要用js输出：爬虫不会执行js获取内容\n\n * 少用iframe：搜索引擎不会抓取iframe中的内容\n\n * 非装饰性图片必须加alt\n\n * 提高网站速度：网站速度是搜索引擎排序的一个重要指标\n\n\n# 2 <img>的title和alt有什么区别\n\n * title 通常当鼠标滑动到元素上的时候显示\n\n * alt是<img>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。\n\n\n# 3 HTTP的几种请求方法用途\n\n * GET方法\n   \n   * 发送一个请求来取得服务器上的某一资源\n\n * POST方法\n   \n   * 向URL指定的资源提交数据或附加新的数据\n\n * PUT方法\n   \n   * 跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST没有\n\n * HEAD方法\n   \n   * 只请求页面的首部\n\n * DELETE方法\n   \n   * 删除服务器上的某资源\n\n * OPTIONS方法\n   \n   * 它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息\n\n * TRACE方法\n   \n   * TRACE方法被用于激发一个远程的，应用层的请求消息回路\n\n * CONNECT方法\n   \n   * 把请求连接转换到透明的TCP/IP通道\n\n\n# 4 从浏览器地址栏输入url到显示页面的步骤\n\n基础版本\n\n * 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；\n\n * 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；\n\n * 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；\n\n * 载入解析到的资源文件，渲染页面，完成。\n\n详细简版\n\n 1. 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）\n\n 2. 开启网络线程到发出一个完整的HTTP请求（这一部分涉及到dns查询，TCP/IP请求，五层因特网协议栈等知识）\n\n 3. 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）\n\n 4. 后台和前台的HTTP交互（这一部分包括HTTP头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）\n\n 5. 单独拎出来的缓存问题，HTTP的缓存（这部分包括http缓存头部，ETag，catch-control等）\n\n 6. 浏览器接收到HTTP数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和DOMContentLoaded等）\n\n 7. CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）\n\n 8. JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）\n\n 9. 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）\n\n\n# 5 如何进行网站性能优化\n\n * content方面\n   \n   * 减少HTTP请求：合并文件、CSS精灵、inline Image\n   \n   * 减少DNS查询：DNS缓存、将资源分布到恰当数量的主机名\n   \n   * 减少DOM元素数量\n\n * Server方面\n   \n   * 使用CDN\n   \n   * 配置ETag\n   \n   * 对组件使用Gzip压缩\n\n * Cookie方面\n   \n   * 减小cookie大小\n\n * css方面\n   \n   * 将样式表放到页面顶部\n   \n   * 不使用CSS表达式\n   \n   * 使用<link>不使用@import\n\n * Javascript方面\n   \n   * 将脚本放到页面底部\n   \n   * 将javascript和css从外部引入\n   \n   * 压缩javascript和css\n   \n   * 删除不需要的脚本\n   \n   * 减少DOM访问\n\n * 图片方面\n   \n   * 优化图片：根据实际颜色需要选择色深、压缩\n   \n   * 优化css精灵\n   \n   * 不要在HTML中拉伸图片\n\n你有用过哪些前端性能优化的方法？\n\n * 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。\n\n * 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数\n\n * 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。\n\n * 当需要设置的样式很多时设置className而不是直接操作style\n\n * 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作\n\n * 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)\n\n * 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳\n\n * 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢\n\n谈谈性能优化问题\n\n * 代码层面：避免使用css表达式，避免使用高级选择器，通配选择器\n\n * 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等\n\n * 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载\n\n * 请求带宽：压缩文件，开启GZIP\n\n\n# 6 HTTP状态码及其含义\n\n * 1XX：信息状态码\n   \n   * 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n\n * 2XX：成功状态码\n   \n   * 200 OK 正常返回信息\n   \n   * 201 Created 请求成功并且服务器创建了新的资源\n   \n   * 202 Accepted 服务器已接受请求，但尚未处理\n\n * 3XX：重定向\n   \n   * 301 Moved Permanently 请求的网页已永久移动到新位置。\n   \n   * 302 Found 临时性重定向。\n   \n   * 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。\n   \n   * 304 Not Modified 自从上次请求后，请求的网页未修改过。\n\n * 4XX：客户端错误\n   \n   * 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\n   \n   * 401 Unauthorized 请求未授权。\n   \n   * 403 Forbidden 禁止访问。\n   \n   * 404 Not Found 找不到如何与 URI 相匹配的资源。\n\n * 5XX: 服务器错误\n   \n   * 500 Internal Server Error 最常见的服务器端错误。\n   \n   * 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。\n\n\n# 7 语义化的理解\n\n * 用正确的标签做正确的事情！\n\n * HTML语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。\n\n * 在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。\n\n * 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。\n\n * 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n\n\n# 8 介绍一下你对浏览器内核的理解？\n\n * 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎\n\n * 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核\n\n * JS引擎则：解析和执行javascript来实现网页的动态效果\n\n * 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎\n\n常见的浏览器内核有哪些\n\n * Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]\n\n * Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等\n\n * Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink]\n\n * Webkit内核：Safari,Chrome等。 [ Chrome的Blink（WebKit的分支）]\n\n\n# 9 html5有哪些新特性、移除了那些元素？\n\n * HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加\n   \n   * 新增选择器 document.querySelector、document.querySelectorAll\n   \n   * 拖拽释放(Drag and drop) API\n   \n   * 媒体播放的 video 和 audio\n   \n   * 本地存储 localStorage 和 sessionStorage\n   \n   * 离线应用 manifest\n   \n   * 桌面通知 Notifications\n   \n   * 语意化标签 article、footer、header、nav、section\n   \n   * 增强表单控件 calendar、date、time、email、url、search\n   \n   * 地理位置 Geolocation\n   \n   * 多任务 webworker\n   \n   * 全双工通信协议 websocket\n   \n   * 历史管理 history\n   \n   * 跨域资源共享(CORS) Access-Control-Allow-Origin\n   \n   * 页面可见性改变事件 visibilitychange\n   \n   * 跨窗口通信 PostMessage\n   \n   * Form Data 对象\n   \n   * 绘画 canvas\n\n * 移除的元素：\n   \n   * 纯表现的元素：basefont、big、center、font、 s、strike、tt、u\n   \n   * 对可用性产生负面影响的元素：frame、frameset、noframes\n\n * 支持HTML5新标签：\n   \n   * IE8/IE7/IE6支持通过document.createElement方法产生的标签\n   \n   * 可以利用这一特性让这些浏览器支持HTML5新标签\n   \n   * 浏览器支持新标签后，还需要添加标签默认的样式\n\n * 当然也可以直接使用成熟的框架、比如html5shim\n\n如何区分 HTML 和 HTML5\n\n * DOCTYPE声明、新增的结构元素、功能元素\n\n\n# 10 HTML5的离线储存怎么使用，工作原理能不能解释一下？\n\n * 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件\n\n * 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示\n\n * 如何使用：\n   \n   * 页面头部像下面一样加入一个manifest的属性；\n   \n   * 在cache.manifest文件的编写离线存储的资源\n   \n   * 在离线状态时，操作window.applicationCache进行需求实现\n\nCACHE MANIFEST\n#v0.11\nCACHE:\njs/app.js\ncss/style.css\nNETWORK:\nresourse/logo.png\nFALLBACK:\n/offline.html\n\n\n\n# 11 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢\n\n * 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。\n\n * 离线的情况下，浏览器就直接使用离线存储的资源。\n\n\n# 12 请描述一下 cookies，sessionStorage 和 localStorage 的区别？\n\n * cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）\n\n * cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递\n\n * sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存\n\n * 存储大小：\n   \n   * cookie数据大小不能超过4k\n   \n   * sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大\n\n * 有期时间：\n   \n   * localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据\n   \n   * sessionStorage 数据在当前浏览器窗口关闭后自动删除\n   \n   * cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n\n\n# 13 iframe有那些缺点？\n\n * iframe会阻塞主页面的Onload事件\n\n * 搜索引擎的检索程序无法解读这种页面，不利于SEO\n\n * iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载\n\n * 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题\n\n\n# 14 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?\n\n * 页面被加载的时，link会同时被加载，而@imort页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载 import只在IE5以上才能识别，而link是XHTML标签，无兼容问题 link方式的样式的权重 高于@import的权重\n\n * <!DOCTYPE> 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档\n\n * 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行\n\n * 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现\n\n\n# 15 Canvas和SVG有什么区别？\n\n * svg绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。canvas输出的是一整幅画布\n\n * svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿\n\n\n# 16 viewport\n\n <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n    // width    设置viewport宽度，为一个正整数，或字符串‘device-width’\n    // device-width  设备宽度\n    // height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置\n    // initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数\n    // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数\n    // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数\n    // user-scalable    是否允许手动缩放\n\n\n * 延伸提问\n   * 怎样处理 移动端 1px 被 渲染成 2px问题\n\n局部处理\n\n * meta标签中的 viewport属性 ，initial-scale 设置为 1\n * rem按照设计稿标准走，外加利用transfrome 的scale(0.5) 缩小一倍即可；\n\n全局处理\n\n * mate标签中的 viewport属性 ，initial-scale 设置为 0.5\n * rem 按照设计稿标准走即可\n\n\n# 17 渲染优化\n\n * 禁止使用iframe（阻塞父文档onload事件）\n   \n   * iframe会阻塞主页面的Onload事件\n   \n   * 搜索引擎的检索程序无法解读这种页面，不利于SEO\n   \n   * iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载\n   \n   * 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript\n   \n   * 动态给iframe添加src属性值，这样可以绕开以上两个问题\n\n * 禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）\n\n * 使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流）\n\n * 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU\n   \n   * 小图标优势在于\n     \n     * 减少HTTP请求\n     \n     * 避免文件跨域\n     \n     * 修改及时生效\n\n * 页面头部的<style></style> <script></script> 会阻塞页面；（因为 Renderer进程中 JS线程和渲染线程是互斥的）\n\n * 页面中空的 href 和 src 会阻塞页面其他资源的加载 (阻塞下载进程)\n\n * 网页gzip，CDN托管，data缓存 ，图片服务器\n\n * 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数\n\n * 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能\n\n * 当需要设置的样式很多时设置className而不是直接操作style\n\n * 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作\n\n * 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳\n\n * 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO\n\n\n# 18 meta viewport相关\n\n<!DOCTYPE html>  <!--H5标准声明，使用 HTML5 doctype，不区分大小写-->\n<head lang=”en”> <!--标准的 lang 属性写法-->\n<meta charset=’utf-8′>    <!--声明文档使用的字符编码-->\n<meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/>   <!--优先使用 IE 最新版本和 Chrome-->\n<meta name=”description” content=”不超过150个字符”/>       <!--页面描述-->\n<meta name=”keywords” content=””/>     <!-- 页面关键词-->\n<meta name=”author” content=”name, email@gmail.com”/>    <!--网页作者-->\n<meta name=”robots” content=”index,follow”/>      <!--搜索引擎抓取-->\n<meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”> <!--为移动设备添加 viewport-->\n<meta name=”apple-mobile-web-app-title” content=”标题”> <!--iOS 设备 begin-->\n<meta name=”apple-mobile-web-app-capable” content=”yes”/>  <!--添加到主屏后的标题（iOS 6 新增）\n是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏-->\n<meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”>\n<!--添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）-->\n<meta name=”apple-mobile-web-app-status-bar-style” content=”black”/>\n<meta name=”format-detection” content=”telphone=no, email=no”/>  <!--设置苹果工具栏颜色-->\n<meta name=”renderer” content=”webkit”> <!-- 启用360浏览器的极速模式(webkit)-->\n<meta http-equiv=”X-UA-Compatible” content=”IE=edge”>     <!--避免IE使用兼容模式-->\n<meta http-equiv=”Cache-Control” content=”no-siteapp” />    <!--不让百度转码-->\n<meta name=”HandheldFriendly” content=”true”>     <!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓-->\n<meta name=”MobileOptimized” content=”320″>   <!--微软的老式浏览器-->\n<meta name=”screen-orientation” content=”portrait”>   <!--uc强制竖屏-->\n<meta name=”x5-orientation” content=”portrait”>    <!--QQ强制竖屏-->\n<meta name=”full-screen” content=”yes”>              <!--UC强制全屏-->\n<meta name=”x5-fullscreen” content=”true”>       <!--QQ强制全屏-->\n<meta name=”browsermode” content=”application”>   <!--UC应用模式-->\n<meta name=”x5-page-mode” content=”app”>   <!-- QQ应用模式-->\n<meta name=”msapplication-tap-highlight” content=”no”>    <!--windows phone 点击无高亮\n设置页面不缓存-->\n<meta http-equiv=”pragma” content=”no-cache”>\n<meta http-equiv=”cache-control” content=”no-cache”>\n<meta http-equiv=”expires” content=”0″>\n\n\n\n# 19 你能描述一下渐进增强和优雅降级之间的不同吗\n\n * 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n\n * 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n\n> 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带\n\n\n# 20 知道的网页制作会用到的图片格式有哪些？\n\n * png-8、png-24、jpeg、gif、svg\n\n> 但是上面的那些都不是面试官想要的最后答案。面试官希望听到是Webp,Apng。（是否有关注新技术，新鲜事物）\n\n * Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。\n\n * 在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%。\n\n * Apng：全称是“Animated Portable Network Graphics”, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 iOS safari 8的支持，有望代替GIF成为下一代动态图标准\n\n\n# 21 优化大量图片的加载\n\n * 图片懒加载，在页面上的未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。\n\n * 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。\n\n * 如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。\n\n * 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。\n\n * 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。\n\n\n# 22 谈谈Cookie的弊端\n\n> cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的\n\n * 每个特定的域名下最多生成20个cookie\n\n * IE6或更低版本最多20个cookie\n\n * IE7和之后的版本最后可以有50个cookie\n\n * Firefox最多50个cookie\n\n * chrome和Safari没有做硬性限制\n\n * IE 和 Opera 会清理近期最少使用的 cookie，Firefox 会随机清理 cookie\n\n * cookie 的最大大约为 4096 字节，为了兼容性，一般设置不超过 4095 字节\n\n * 如果 cookie 被人拦截了，就可以取得所有的 session 信息",
      "normalizedContent": "# 1 前端需要注意哪些seo\n\n * 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可\n\n * 语义化的html代码，符合w3c规范：语义化代码让搜索引擎容易理解网页\n\n * 重要内容html代码放在最前：搜索引擎抓取html顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取\n\n * 重要内容不要用js输出：爬虫不会执行js获取内容\n\n * 少用iframe：搜索引擎不会抓取iframe中的内容\n\n * 非装饰性图片必须加alt\n\n * 提高网站速度：网站速度是搜索引擎排序的一个重要指标\n\n\n# 2 <img>的title和alt有什么区别\n\n * title 通常当鼠标滑动到元素上的时候显示\n\n * alt是<img>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。\n\n\n# 3 http的几种请求方法用途\n\n * get方法\n   \n   * 发送一个请求来取得服务器上的某一资源\n\n * post方法\n   \n   * 向url指定的资源提交数据或附加新的数据\n\n * put方法\n   \n   * 跟post方法很像，也是想服务器提交数据。但是，它们之间有不同。put指定了资源在服务器上的位置，而post没有\n\n * head方法\n   \n   * 只请求页面的首部\n\n * delete方法\n   \n   * 删除服务器上的某资源\n\n * options方法\n   \n   * 它用于获取当前url所支持的方法。如果请求成功，会有一个allow的头包含类似“get,post”这样的信息\n\n * trace方法\n   \n   * trace方法被用于激发一个远程的，应用层的请求消息回路\n\n * connect方法\n   \n   * 把请求连接转换到透明的tcp/ip通道\n\n\n# 4 从浏览器地址栏输入url到显示页面的步骤\n\n基础版本\n\n * 浏览器根据请求的url交给dns域名解析，找到真实ip，向服务器发起请求；\n\n * 服务器交给后台处理完成后返回数据，浏览器接收文件（html、js、css、图象等）；\n\n * 浏览器对加载到的资源（html、js、css等）进行语法解析，建立相应的内部数据结构（如html的dom）；\n\n * 载入解析到的资源文件，渲染页面，完成。\n\n详细简版\n\n 1. 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）\n\n 2. 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）\n\n 3. 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）\n\n 4. 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）\n\n 5. 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）\n\n 6. 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、gpu绘制、外链资源的处理、loaded和domcontentloaded等）\n\n 7. css的可视化格式模型（元素的渲染规则，如包含块，控制框，bfc，ifc等概念）\n\n 8. js引擎解析过程（js的解释阶段，预处理阶段，执行阶段生成执行上下文，vo，作用域链、回收机制等等）\n\n 9. 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）\n\n\n# 5 如何进行网站性能优化\n\n * content方面\n   \n   * 减少http请求：合并文件、css精灵、inline image\n   \n   * 减少dns查询：dns缓存、将资源分布到恰当数量的主机名\n   \n   * 减少dom元素数量\n\n * server方面\n   \n   * 使用cdn\n   \n   * 配置etag\n   \n   * 对组件使用gzip压缩\n\n * cookie方面\n   \n   * 减小cookie大小\n\n * css方面\n   \n   * 将样式表放到页面顶部\n   \n   * 不使用css表达式\n   \n   * 使用<link>不使用@import\n\n * javascript方面\n   \n   * 将脚本放到页面底部\n   \n   * 将javascript和css从外部引入\n   \n   * 压缩javascript和css\n   \n   * 删除不需要的脚本\n   \n   * 减少dom访问\n\n * 图片方面\n   \n   * 优化图片：根据实际颜色需要选择色深、压缩\n   \n   * 优化css精灵\n   \n   * 不要在html中拉伸图片\n\n你有用过哪些前端性能优化的方法？\n\n * 减少http请求次数：css sprites, js、css源码压缩、图片大小控制合适；网页gzip，cdn托管，data缓存 ，图片服务器。\n\n * 前端模板 js+数据，减少由于html标签导致的带宽浪费，前端用变量保存ajax请求结果，每次操作本地变量，不用请求，减少请求次数\n\n * 用innerhtml代替dom操作，减少dom操作次数，优化javascript性能。\n\n * 当需要设置的样式很多时设置classname而不是直接操作style\n\n * 少用全局变量、缓存dom节点查找的结果。减少io读取操作\n\n * 避免使用css expression（css表达式)又称dynamic properties(动态属性)\n\n * 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳\n\n * 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢\n\n谈谈性能优化问题\n\n * 代码层面：避免使用css表达式，避免使用高级选择器，通配选择器\n\n * 缓存利用：缓存ajax，使用cdn，使用外部js和css文件以便缓存，添加expires头，服务端配置etag，减少dns查找等\n\n * 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载\n\n * 请求带宽：压缩文件，开启gzip\n\n\n# 6 http状态码及其含义\n\n * 1xx：信息状态码\n   \n   * 100 continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n\n * 2xx：成功状态码\n   \n   * 200 ok 正常返回信息\n   \n   * 201 created 请求成功并且服务器创建了新的资源\n   \n   * 202 accepted 服务器已接受请求，但尚未处理\n\n * 3xx：重定向\n   \n   * 301 moved permanently 请求的网页已永久移动到新位置。\n   \n   * 302 found 临时性重定向。\n   \n   * 303 see other 临时性重定向，且总是使用 get 请求新的 uri。\n   \n   * 304 not modified 自从上次请求后，请求的网页未修改过。\n\n * 4xx：客户端错误\n   \n   * 400 bad request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\n   \n   * 401 unauthorized 请求未授权。\n   \n   * 403 forbidden 禁止访问。\n   \n   * 404 not found 找不到如何与 uri 相匹配的资源。\n\n * 5xx: 服务器错误\n   \n   * 500 internal server error 最常见的服务器端错误。\n   \n   * 503 service unavailable 服务器端暂时无法处理请求（可能是过载或维护）。\n\n\n# 7 语义化的理解\n\n * 用正确的标签做正确的事情！\n\n * html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析。\n\n * 在没有样式css情况下也以一种文档格式显示，并且是容易阅读的。\n\n * 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 seo。\n\n * 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n\n\n# 8 介绍一下你对浏览器内核的理解？\n\n * 主要分成两部分：渲染引擎(layout engineer或rendering engine)和js引擎\n\n * 渲染引擎：负责取得网页的内容（html、xml、图像等等）、整理讯息（例如加入css等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核\n\n * js引擎则：解析和执行javascript来实现网页的动态效果\n\n * 最开始渲染引擎和js引擎并没有区分的很明确，后来js引擎越来越独立，内核就倾向于只指渲染引擎\n\n常见的浏览器内核有哪些\n\n * trident内核：ie,maxthon,tt,the world,360,搜狗浏览器等。[又称mshtml]\n\n * gecko内核：netscape6及以上版本，ff,mozillasuite/seamonkey等\n\n * presto内核：opera7及以上。 [opera内核原为：presto，现为：blink]\n\n * webkit内核：safari,chrome等。 [ chrome的blink（webkit的分支）]\n\n\n# 9 html5有哪些新特性、移除了那些元素？\n\n * html5 现在已经不是 sgml 的子集，主要是关于图像，位置，存储，多任务等功能的增加\n   \n   * 新增选择器 document.queryselector、document.queryselectorall\n   \n   * 拖拽释放(drag and drop) api\n   \n   * 媒体播放的 video 和 audio\n   \n   * 本地存储 localstorage 和 sessionstorage\n   \n   * 离线应用 manifest\n   \n   * 桌面通知 notifications\n   \n   * 语意化标签 article、footer、header、nav、section\n   \n   * 增强表单控件 calendar、date、time、email、url、search\n   \n   * 地理位置 geolocation\n   \n   * 多任务 webworker\n   \n   * 全双工通信协议 websocket\n   \n   * 历史管理 history\n   \n   * 跨域资源共享(cors) access-control-allow-origin\n   \n   * 页面可见性改变事件 visibilitychange\n   \n   * 跨窗口通信 postmessage\n   \n   * form data 对象\n   \n   * 绘画 canvas\n\n * 移除的元素：\n   \n   * 纯表现的元素：basefont、big、center、font、 s、strike、tt、u\n   \n   * 对可用性产生负面影响的元素：frame、frameset、noframes\n\n * 支持html5新标签：\n   \n   * ie8/ie7/ie6支持通过document.createelement方法产生的标签\n   \n   * 可以利用这一特性让这些浏览器支持html5新标签\n   \n   * 浏览器支持新标签后，还需要添加标签默认的样式\n\n * 当然也可以直接使用成熟的框架、比如html5shim\n\n如何区分 html 和 html5\n\n * doctype声明、新增的结构元素、功能元素\n\n\n# 10 html5的离线储存怎么使用，工作原理能不能解释一下？\n\n * 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件\n\n * 原理：html5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示\n\n * 如何使用：\n   \n   * 页面头部像下面一样加入一个manifest的属性；\n   \n   * 在cache.manifest文件的编写离线存储的资源\n   \n   * 在离线状态时，操作window.applicationcache进行需求实现\n\ncache manifest\n#v0.11\ncache:\njs/app.js\ncss/style.css\nnetwork:\nresourse/logo.png\nfallback:\n/offline.html\n\n\n\n# 11 浏览器是怎么对html5的离线储存资源进行管理和加载的呢\n\n * 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。\n\n * 离线的情况下，浏览器就直接使用离线存储的资源。\n\n\n# 12 请描述一下 cookies，sessionstorage 和 localstorage 的区别？\n\n * cookie是网站为了标示用户身份而储存在用户本地终端（client side）上的数据（通常经过加密）\n\n * cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递\n\n * sessionstorage和localstorage不会自动把数据发给服务器，仅在本地保存\n\n * 存储大小：\n   \n   * cookie数据大小不能超过4k\n   \n   * sessionstorage和localstorage虽然也有存储大小的限制，但比cookie大得多，可以达到5m或更大\n\n * 有期时间：\n   \n   * localstorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据\n   \n   * sessionstorage 数据在当前浏览器窗口关闭后自动删除\n   \n   * cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n\n\n# 13 iframe有那些缺点？\n\n * iframe会阻塞主页面的onload事件\n\n * 搜索引擎的检索程序无法解读这种页面，不利于seo\n\n * iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载\n\n * 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题\n\n\n# 14 doctype作用? 严格模式与混杂模式如何区分？它们有何意义?\n\n * 页面被加载的时，link会同时被加载，而@imort页面被加载的时，link会同时被加载，而@import引用的css会等到页面被加载完再加载 import只在ie5以上才能识别，而link是xhtml标签，无兼容问题 link方式的样式的权重 高于@import的权重\n\n * <!doctype> 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档\n\n * 严格模式的排版和 js 运作模式是 以该浏览器支持的最高标准运行\n\n * 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 doctype不存在或格式不正确会导致文档以混杂模式呈现\n\n\n# 15 canvas和svg有什么区别？\n\n * svg绘制出来的每一个图形的元素都是独立的dom节点，能够方便的绑定事件或用来修改。canvas输出的是一整幅画布\n\n * svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿\n\n\n# 16 viewport\n\n <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n    // width    设置viewport宽度，为一个正整数，或字符串‘device-width’\n    // device-width  设备宽度\n    // height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置\n    // initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数\n    // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数\n    // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数\n    // user-scalable    是否允许手动缩放\n\n\n * 延伸提问\n   * 怎样处理 移动端 1px 被 渲染成 2px问题\n\n局部处理\n\n * meta标签中的 viewport属性 ，initial-scale 设置为 1\n * rem按照设计稿标准走，外加利用transfrome 的scale(0.5) 缩小一倍即可；\n\n全局处理\n\n * mate标签中的 viewport属性 ，initial-scale 设置为 0.5\n * rem 按照设计稿标准走即可\n\n\n# 17 渲染优化\n\n * 禁止使用iframe（阻塞父文档onload事件）\n   \n   * iframe会阻塞主页面的onload事件\n   \n   * 搜索引擎的检索程序无法解读这种页面，不利于seo\n   \n   * iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载\n   \n   * 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript\n   \n   * 动态给iframe添加src属性值，这样可以绕开以上两个问题\n\n * 禁止使用gif图片实现loading效果（降低cpu消耗，提升渲染性能）\n\n * 使用css3代码代替js动画（尽可能避免重绘重排以及回流）\n\n * 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费cpu\n   \n   * 小图标优势在于\n     \n     * 减少http请求\n     \n     * 避免文件跨域\n     \n     * 修改及时生效\n\n * 页面头部的<style></style> <script></script> 会阻塞页面；（因为 renderer进程中 js线程和渲染线程是互斥的）\n\n * 页面中空的 href 和 src 会阻塞页面其他资源的加载 (阻塞下载进程)\n\n * 网页gzip，cdn托管，data缓存 ，图片服务器\n\n * 前端模板 js+数据，减少由于html标签导致的带宽浪费，前端用变量保存ajax请求结果，每次操作本地变量，不用请求，减少请求次数\n\n * 用innerhtml代替dom操作，减少dom操作次数，优化javascript性能\n\n * 当需要设置的样式很多时设置classname而不是直接操作style\n\n * 少用全局变量、缓存dom节点查找的结果。减少io读取操作\n\n * 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳\n\n * 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘io\n\n\n# 18 meta viewport相关\n\n<!doctype html>  <!--h5标准声明，使用 html5 doctype，不区分大小写-->\n<head lang=”en”> <!--标准的 lang 属性写法-->\n<meta charset=’utf-8′>    <!--声明文档使用的字符编码-->\n<meta http-equiv=”x-ua-compatible” content=”ie=edge,chrome=1″/>   <!--优先使用 ie 最新版本和 chrome-->\n<meta name=”description” content=”不超过150个字符”/>       <!--页面描述-->\n<meta name=”keywords” content=””/>     <!-- 页面关键词-->\n<meta name=”author” content=”name, email@gmail.com”/>    <!--网页作者-->\n<meta name=”robots” content=”index,follow”/>      <!--搜索引擎抓取-->\n<meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”> <!--为移动设备添加 viewport-->\n<meta name=”apple-mobile-web-app-title” content=”标题”> <!--ios 设备 begin-->\n<meta name=”apple-mobile-web-app-capable” content=”yes”/>  <!--添加到主屏后的标题（ios 6 新增）\n是否启用 webapp 全屏模式，删除苹果默认的工具栏和菜单栏-->\n<meta name=”apple-itunes-app” content=”app-id=myappstoreid, affiliate-data=myaffiliatedata, app-argument=myurl”>\n<!--添加智能 app 广告条 smart app banner（ios 6+ safari）-->\n<meta name=”apple-mobile-web-app-status-bar-style” content=”black”/>\n<meta name=”format-detection” content=”telphone=no, email=no”/>  <!--设置苹果工具栏颜色-->\n<meta name=”renderer” content=”webkit”> <!-- 启用360浏览器的极速模式(webkit)-->\n<meta http-equiv=”x-ua-compatible” content=”ie=edge”>     <!--避免ie使用兼容模式-->\n<meta http-equiv=”cache-control” content=”no-siteapp” />    <!--不让百度转码-->\n<meta name=”handheldfriendly” content=”true”>     <!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓-->\n<meta name=”mobileoptimized” content=”320″>   <!--微软的老式浏览器-->\n<meta name=”screen-orientation” content=”portrait”>   <!--uc强制竖屏-->\n<meta name=”x5-orientation” content=”portrait”>    <!--qq强制竖屏-->\n<meta name=”full-screen” content=”yes”>              <!--uc强制全屏-->\n<meta name=”x5-fullscreen” content=”true”>       <!--qq强制全屏-->\n<meta name=”browsermode” content=”application”>   <!--uc应用模式-->\n<meta name=”x5-page-mode” content=”app”>   <!-- qq应用模式-->\n<meta name=”msapplication-tap-highlight” content=”no”>    <!--windows phone 点击无高亮\n设置页面不缓存-->\n<meta http-equiv=”pragma” content=”no-cache”>\n<meta http-equiv=”cache-control” content=”no-cache”>\n<meta http-equiv=”expires” content=”0″>\n\n\n\n# 19 你能描述一下渐进增强和优雅降级之间的不同吗\n\n * 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n\n * 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n\n> 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带\n\n\n# 20 知道的网页制作会用到的图片格式有哪些？\n\n * png-8、png-24、jpeg、gif、svg\n\n> 但是上面的那些都不是面试官想要的最后答案。面试官希望听到是webp,apng。（是否有关注新技术，新鲜事物）\n\n * webp：webp格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有jpeg的2/3，并能节省大量的服务器带宽资源和数据空间。facebook ebay等知名网站已经开始测试并使用webp格式。\n\n * 在质量相同的情况下，webp格式图像的体积要比jpeg格式图像小40%。\n\n * apng：全称是“animated portable network graphics”, 是png的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 ios safari 8的支持，有望代替gif成为下一代动态图标准\n\n\n# 21 优化大量图片的加载\n\n * 图片懒加载，在页面上的未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。\n\n * 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。\n\n * 如果图片为css图片，可以使用csssprite，svgsprite，iconfont、base64等技术。\n\n * 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。\n\n * 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。\n\n\n# 22 谈谈cookie的弊端\n\n> cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的\n\n * 每个特定的域名下最多生成20个cookie\n\n * ie6或更低版本最多20个cookie\n\n * ie7和之后的版本最后可以有50个cookie\n\n * firefox最多50个cookie\n\n * chrome和safari没有做硬性限制\n\n * ie 和 opera 会清理近期最少使用的 cookie，firefox 会随机清理 cookie\n\n * cookie 的最大大约为 4096 字节，为了兼容性，一般设置不超过 4095 字节\n\n * 如果 cookie 被人拦截了，就可以取得所有的 session 信息",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "数据类型",
      "frontmatter": {
        "title": "数据类型",
        "date": "2022-08-03T21:31:15.000Z",
        "permalink": "/pages/dataType/",
        "article": false
      },
      "regularPath": "/20.%E9%AB%98%E9%A2%91%E7%AF%87/10.JavaScript%E7%AF%87/10.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",
      "relativePath": "20.高频篇/10.JavaScript篇/10.数据类型.md",
      "key": "v-111c1b58",
      "path": "/pages/dataType/",
      "headers": [
        {
          "level": 3,
          "title": "1. JavaScript有哪些数据类型，它们的区别？",
          "slug": "_1-javascript有哪些数据类型-它们的区别",
          "normalizedTitle": "1. javascript有哪些数据类型，它们的区别？",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 数据类型检测的方式有哪些",
          "slug": "_2-数据类型检测的方式有哪些",
          "normalizedTitle": "2. 数据类型检测的方式有哪些",
          "charIndex": 813
        },
        {
          "level": 3,
          "title": "3. 判断数组的方式有哪些",
          "slug": "_3-判断数组的方式有哪些",
          "normalizedTitle": "3. 判断数组的方式有哪些",
          "charIndex": 3157
        },
        {
          "level": 3,
          "title": "4. null和undefined区别",
          "slug": "_4-null和undefined区别",
          "normalizedTitle": "4. null和undefined区别",
          "charIndex": 3498
        },
        {
          "level": 3,
          "title": "5. typeof null 的结果是什么，为什么？",
          "slug": "_5-typeof-null-的结果是什么-为什么",
          "normalizedTitle": "5. typeof null 的结果是什么，为什么？",
          "charIndex": 3926
        },
        {
          "level": 3,
          "title": "6. intanceof 操作符的实现原理及实现",
          "slug": "_6-intanceof-操作符的实现原理及实现",
          "normalizedTitle": "6. intanceof 操作符的实现原理及实现",
          "charIndex": 4472
        },
        {
          "level": 3,
          "title": "7. 为什么0.1+0.2 ! == 0.3，如何让其相等",
          "slug": "_7-为什么0-1-0-2-0-3-如何让其相等",
          "normalizedTitle": "7. 为什么0.1+0.2 ! == 0.3，如何让其相等",
          "charIndex": 4947
        },
        {
          "level": 3,
          "title": "8. 如何获取安全的 undefined 值？",
          "slug": "_8-如何获取安全的-undefined-值",
          "normalizedTitle": "8. 如何获取安全的 undefined 值？",
          "charIndex": 6966
        },
        {
          "level": 3,
          "title": "9. typeof NaN 的结果是什么？",
          "slug": "_9-typeof-nan-的结果是什么",
          "normalizedTitle": "9. typeof nan 的结果是什么？",
          "charIndex": 7147
        },
        {
          "level": 3,
          "title": "10. isNaN 和 Number.isNaN 函数的区别？",
          "slug": "_10-isnan-和-number-isnan-函数的区别",
          "normalizedTitle": "10. isnan 和 number.isnan 函数的区别？",
          "charIndex": 7389
        },
        {
          "level": 3,
          "title": "12. 其他值到字符串的转换规则？",
          "slug": "_12-其他值到字符串的转换规则",
          "normalizedTitle": "12. 其他值到字符串的转换规则？",
          "charIndex": 7598
        },
        {
          "level": 3,
          "title": "13. 其他值到数字值的转换规则？",
          "slug": "_13-其他值到数字值的转换规则",
          "normalizedTitle": "13. 其他值到数字值的转换规则？",
          "charIndex": 7988
        },
        {
          "level": 3,
          "title": "14. 其他值到布尔类型的值的转换规则？",
          "slug": "_14-其他值到布尔类型的值的转换规则",
          "normalizedTitle": "14. 其他值到布尔类型的值的转换规则？",
          "charIndex": 8447
        },
        {
          "level": 3,
          "title": "15. || 和 && 操作符的返回值？",
          "slug": "_15-和-操作符的返回值",
          "normalizedTitle": "15. || 和 &amp;&amp; 操作符的返回值？",
          "charIndex": null
        },
        {
          "level": 3,
          "title": "16. Object.is() 与比较操作符 “===”、“==” 的区别？",
          "slug": "_16-object-is-与比较操作符-、-的区别",
          "normalizedTitle": "16. object.is() 与比较操作符 “===”、“==” 的区别？",
          "charIndex": 8809
        },
        {
          "level": 3,
          "title": "17. 什么是 JavaScript 中的包装类型？",
          "slug": "_17-什么是-javascript-中的包装类型",
          "normalizedTitle": "17. 什么是 javascript 中的包装类型？",
          "charIndex": 9038
        },
        {
          "level": 3,
          "title": "18. JavaScript 中如何进行隐式类型转换？",
          "slug": "_18-javascript-中如何进行隐式类型转换",
          "normalizedTitle": "18. javascript 中如何进行隐式类型转换？",
          "charIndex": 9647
        },
        {
          "level": 3,
          "title": "19. + 操作符什么时候用于字符串的拼接？",
          "slug": "_19-操作符什么时候用于字符串的拼接",
          "normalizedTitle": "19. + 操作符什么时候用于字符串的拼接？",
          "charIndex": 11716
        },
        {
          "level": 3,
          "title": "20. 为什么会有BigInt的提案？",
          "slug": "_20-为什么会有bigint的提案",
          "normalizedTitle": "20. 为什么会有bigint的提案？",
          "charIndex": 12004
        },
        {
          "level": 3,
          "title": "21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别",
          "slug": "_21-object-assign和扩展运算法是深拷贝还是浅拷贝-两者区别",
          "normalizedTitle": "21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别",
          "charIndex": 12189
        }
      ],
      "headersStr": "1. JavaScript有哪些数据类型，它们的区别？ 2. 数据类型检测的方式有哪些 3. 判断数组的方式有哪些 4. null和undefined区别 5. typeof null 的结果是什么，为什么？ 6. intanceof 操作符的实现原理及实现 7. 为什么0.1+0.2 ! == 0.3，如何让其相等 8. 如何获取安全的 undefined 值？ 9. typeof NaN 的结果是什么？ 10. isNaN 和 Number.isNaN 函数的区别？ 12. 其他值到字符串的转换规则？ 13. 其他值到数字值的转换规则？ 14. 其他值到布尔类型的值的转换规则？ 15. || 和 && 操作符的返回值？ 16. Object.is() 与比较操作符 “===”、“==” 的区别？ 17. 什么是 JavaScript 中的包装类型？ 18. JavaScript 中如何进行隐式类型转换？ 19. + 操作符什么时候用于字符串的拼接？ 20. 为什么会有BigInt的提案？ 21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别",
      "content": "# 1. JavaScript有哪些数据类型，它们的区别？\n\nJavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。\n\n其中 Symbol 和 BigInt 是ES6 中新增的数据类型：\n\n * Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。\n * BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。\n\n这些数据可以分为原始数据类型和引用数据类型：\n\n * 栈：原始数据类型（Undefined、Null、Boolean、Number、String）\n * 堆：引用数据类型（对象、数组和函数）\n\n两种类型的区别在于存储位置的不同：\n\n * 原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n * 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n\n堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：\n\n * 在数据结构中，栈中数据的存取方式为先进后出。\n * 堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。\n\n在操作系统中，内存被分为栈区和堆区：\n\n * 栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。\n * 堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。\n\n\n# 2. 数据类型检测的方式有哪些\n\n（1）typeof\n\nconsole.log(typeof 2);               // number\nconsole.log(typeof true);            // boolean\nconsole.log(typeof 'str');           // string\nconsole.log(typeof []);              // object    \nconsole.log(typeof function(){});    // function\nconsole.log(typeof {});              // object\nconsole.log(typeof undefined);       // undefined\nconsole.log(typeof null);            // object\n\n\n其中数组、对象、null都会被判断为object，其他判断都正确。\n\n（2）instanceof\n\ninstanceof可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。\n\nconsole.log(2 instanceof Number);                    // false\nconsole.log(true instanceof Boolean);                // false \nconsole.log('str' instanceof String);                // false \n \nconsole.log([] instanceof Array);                    // true\nconsole.log(function(){} instanceof Function);       // true\nconsole.log({} instanceof Object);                   // true\n\n\n可以看到，instanceof只能正确判断引用数据类型，而不能判断基本数据类型。instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。\n\n（3） constructor\n\nconsole.log((2).constructor === Number); // true\nconsole.log((true).constructor === Boolean); // true\nconsole.log(('str').constructor === String); // true\nconsole.log(([]).constructor === Array); // true\nconsole.log((function() {}).constructor === Function); // true\nconsole.log(({}).constructor === Object); // true\n\n\nconstructor有两个作用，一是判断数据的类型，二是对象实例通过 constrcutor 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了：\n\nfunction Fn(){};\n \nFn.prototype = new Array();\n \nvar f = new Fn();\n \nconsole.log(f.constructor===Fn);    // false\nconsole.log(f.constructor===Array); // true\n\n\n（4）Object.prototype.toString.call()\n\nObject.prototype.toString.call() 使用 Object 对象的原型方法 toString 来判断数据类型：\n\nvar a = Object.prototype.toString;\n \nconsole.log(a.call(2));\nconsole.log(a.call(true));\nconsole.log(a.call('str'));\nconsole.log(a.call([]));\nconsole.log(a.call(function(){}));\nconsole.log(a.call({}));\nconsole.log(a.call(undefined));\nconsole.log(a.call(null));\n\n\n同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？\n\n这是因为toString是Object的原型方法，而Array、function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。\n\n\n# 3. 判断数组的方式有哪些\n\n * 通过Object.prototype.toString.call()做判断\n\nObject.prototype.toString.call(obj).slice(8,-1) === 'Array';\n\n\n * 通过原型链做判断\n\nobj.__proto__ === Array.prototype;\n\n\n * 通过ES6的Array.isArray()做判断\n\nArray.isArrray(obj);\n\n\n * 通过instanceof做判断\n\nobj instanceof Array\n\n\n * 通过Array.prototype.isPrototypeOf\n\nArray.prototype.isPrototypeOf(obj)\n\n\n\n# 4. null和undefined区别\n\n首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。\n\nundefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。\n\nundefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。\n\n当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。\n\n\n# 5. typeof null 的结果是什么，为什么？\n\ntypeof null 的结果是Object。\n\n在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits) 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：\n\n000: object   - 当前存储的数据指向一个对象。\n  1: int      - 当前存储的数据是一个 31 位的有符号整数。\n010: double   - 当前存储的数据指向一个双精度的浮点数。\n100: string   - 当前存储的数据指向一个字符串。\n110: boolean  - 当前存储的数据是布尔值。\n\n\n如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。\n\n有两种特殊数据类型：\n\n * undefined的值是 (-2)30(一个超出整数范围的数字)；\n * null 的值是机器码 NULL 指针(null 指针的值全是 0)\n\n那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。\n\n\n# 6. intanceof 操作符的实现原理及实现\n\ninstanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\n\nfunction myInstanceof(left, right) {\n  // 获取对象的原型\n  let proto = Object.getPrototypeOf(left)\n  // 获取构造函数的 prototype 对象\n  let prototype = right.prototype; \n \n  // 判断构造函数的 prototype 对象是否在对象的原型链上\n  while (true) {\n    if (!proto) return false;\n    if (proto === prototype) return true;\n    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型\n    proto = Object.getPrototypeOf(proto);\n  }\n}\n\n\n\n# 7. 为什么0.1+0.2 ! == 0.3，如何让其相等\n\n在开发过程中遇到类似这样的问题：\n\nlet n1 = 0.1, n2 = 0.2\nconsole.log(n1 + n2)  // 0.30000000000000004\n\n\n这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：\n\n(n1 + n2).toFixed(2) // 注意，toFixed为四舍五入\n\n\ntoFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？\n\n计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？\n\n一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。\n\n根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：0.30000000000000004。\n\n下面看一下双精度数是如何保存的：\n\n * 第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位\n * 第二部分（绿色）：用来存储指数（exponent），占用11位\n * 第三部分（红色）：用来存储小数（fraction），占用52位\n\n对于0.1，它的二进制为：\n\n0.00011001100110011001100110011001100110011001100110011001 10011...\n\n\n转为科学计数法（科学计数法的结果就是浮点数）：\n\n1.1001100110011001100110011001100110011001100110011001*2^-4\n\n\n可以看出0.1的符号位为0，指数位为-4，小数位为：\n\n1001100110011001100110011001100110011001100110011001\n\n\n那么问题又来了，指数位是负数，该如何保存呢？\n\nIEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定双精度数的偏移量为1023。\n\n * 当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是-1022~1013。\n * 当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。\n * 当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。\n\n对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：1111111011.\n\n所以，0.1表示为：\n\n0 1111111011 1001100110011001100110011001100110011001100110011001\n\n\n说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？\n\n对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了Number.EPSILON属性，而它的值就是2-52，只要判断0.1+0.2-0.3是否小于Number.EPSILON，如果小于，就可以判断为0.1+0.2 ===0.3\n\nfunction numberepsilon(arg1,arg2){                   \n  return Math.abs(arg1 - arg2) < Number.EPSILON;        \n}        \n\nconsole.log(numberepsilon(0.1 + 0.2, 0.3)); // true\n\n\n\n# 8. 如何获取安全的 undefined 值？\n\n因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。\n\n\n# 9. typeof NaN 的结果是什么？\n\nNaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。\n\ntypeof NaN; // \"number\"\n\n\nNaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。\n\n\n# 10. isNaN 和 Number.isNaN 函数的区别？\n\n * 函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。\n * 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。\n\n\n# 12. 其他值到字符串的转换规则？\n\n * Null 和 Undefined 类型 ，null 转换为 \"null\"，undefined 转换为 \"undefined\"，\n * Boolean 类型，true 转换为 \"true\"，false 转换为 \"false\"。\n * Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。\n * Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。\n * 对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如\"[object Object]\"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。\n\n\n# 13. 其他值到数字值的转换规则？\n\n * Undefined 类型的值转换为 NaN。\n * Null 类型的值转换为 0。\n * Boolean 类型的值，true 转换为 1，false 转换为 0。\n * String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。\n * Symbol 类型的值不能转换为数字，会报错。\n * 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。\n\n为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。\n\n如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。\n\n\n# 14. 其他值到布尔类型的值的转换规则？\n\n以下这些是假值： • undefined • null • false • +0、-0 和 NaN • \"\"\n\n假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。\n\n\n# 15. || 和 && 操作符的返回值？\n\n|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。\n\n * 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。\n * && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。\n\n|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果\n\n\n# 16. Object.is() 与比较操作符 “===”、“==” 的区别？\n\n * 使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。\n * 使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。\n * 使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。\n\n\n# 17. 什么是 JavaScript 中的包装类型？\n\n在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：\n\nconst a = \"abc\";\na.length; // 3\na.toUpperCase(); // \"ABC\"\n\n\n在访问'abc'.length时，JavaScript 将'abc'在后台转换成String('abc')，然后再访问其length属性。\n\nJavaScript也可以使用Object函数显式地将基本类型转换为包装类型：\n\nvar a = 'abc'\nObject(a) // String {\"abc\"}\n\n\n也可以使用valueOf方法将包装类型倒转成基本类型：\n\nvar a = 'abc'\nvar b = Object(a)\nvar c = b.valueOf() // 'abc'\n\n\n看看如下代码会打印出什么：\n\nvar a = new Boolean( false );\nif (!a) {\n\tconsole.log( \"Oops\" ); // never runs\n}\n\n\n答案是什么都不会打印，因为虽然包裹的基本类型是false，但是false被包裹成包装类型后就成了对象，所以其非值为false，所以循环体中的内容不会运行。\n\n\n# 18. JavaScript 中如何进行隐式类型转换？\n\n首先要介绍ToPrimitive方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：\n\n/**\n* @obj 需要转换的对象\n* @type 期望的结果类型\n*/\nToPrimitive(obj,type)\n\n\ntype的值为number或者string。\n\n（1）当type为number时规则如下：\n\n * 调用obj的valueOf方法，如果为原始值，则返回，否则下一步；\n * 调用obj的toString方法，后续同上；\n * 抛出TypeError 异常。\n\n（2）当type为string时规则如下：\n\n * 调用obj的toString方法，如果为原始值，则返回，否则下一步；\n * 调用obj的valueOf方法，后续同上；\n * 抛出TypeError 异常。\n\n可以看出两者的主要区别在于调用toString和valueOf的先后顺序。默认情况下：\n\n * 如果对象为 Date 对象，则type默认为string；\n * 其他情况下，type默认为number。\n\n总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：\n\nvar objToNumber = value => Number(value.valueOf().toString())\nobjToNumber([]) === 0\nobjToNumber({}) === NaN\n\n\n而 JavaScript 中的隐式类型转换主要发生在+、-、*、/以及==、>、<这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用ToPrimitive转换成基本类型，再进行操作。\n\n以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被ToPrimitive转换成基本类型，所以最终还是要应用基本类型转换规则）：\n\n 1. +操作符 +操作符的两边有至少一个string类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。\n\n1 + '23' // '123'\n 1 + false // 1 \n 1 + Symbol() // Uncaught TypeError: Cannot convert a Symbol value to a number\n '1' + false // '1false'\n false + true // 1\n\n\n 1. -、*、\\操作符\n\nNaN也是一个数字\n\n1 * '23' // 23\n 1 * false // 0\n 1 / 'aa' // NaN\n\n\n 1. 对于==操作符\n\n操作符两边的值都尽量转成number：\n\n3 == true // false, 3 转为number为3，true转为number为1\n'0' == false //true, '0'转为number为0，false转为number为0\n'0' == 0 // '0'转为number为0\n\n\n 1. 对于<和>比较符\n\n如果两边都是字符串，则比较字母表顺序：\n\n'ca' < 'bd' // false\n'a' < 'b' // true\n\n\n其他情况下，转换为数字再比较：\n\n'12' < 13 // true\nfalse > -1 // true\n\n\n以上说的是基本类型的隐式转换，而对象会被ToPrimitive转换为基本类型再进行转换：\n\nvar a = {}\na > 2 // false\n\n\n其对比过程如下：\n\na.valueOf() // {}, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步\na.toString() // \"[object Object]\"，现在是一个字符串了\nNumber(a.toString()) // NaN，根据上面 < 和 > 操作符的规则，要转换成数字\nNaN > 2 //false，得出比较结果\n\n\n又比如：\n\nvar a = {name:'Jack'}\nvar b = {age: 18}\na + b // \"[object Object][object Object]\"\n\n\n运算过程如下：\n\na.valueOf() // {}，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步\na.toString() // \"[object Object]\"\nb.valueOf() // 同理\nb.toString() // \"[object Object]\"\na + b // \"[object Object][object Object]\"\n\n\n\n# 19. + 操作符什么时候用于字符串的拼接？\n\n根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。\n\n简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。\n\n那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。\n\n\n# 20. 为什么会有BigInt的提案？\n\nJavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。\n\n\n# 21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别\n\n扩展运算符：\n\nlet outObj = {\n  inObj: {a: 1, b: 2}\n}\nlet newObj = {...outObj}\nnewObj.inObj.a = 2\nconsole.log(outObj) // {inObj: {a: 2, b: 2}}\n\n\nObject.assign():\n\nlet outObj = {\n  inObj: {a: 1, b: 2}\n}\nlet newObj = Object.assign({}, outObj)\nnewObj.inObj.a = 2\nconsole.log(outObj) // {inObj: {a: 2, b: 2}}\n\n\n可以看到，两者都是浅拷贝。\n\n * Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。\n * 扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。",
      "normalizedContent": "# 1. javascript有哪些数据类型，它们的区别？\n\njavascript共有八种数据类型，分别是 undefined、null、boolean、number、string、object、symbol、bigint。\n\n其中 symbol 和 bigint 是es6 中新增的数据类型：\n\n * symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。\n * bigint 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 bigint 可以安全地存储和操作大整数，即使这个数已经超出了 number 能够表示的安全整数范围。\n\n这些数据可以分为原始数据类型和引用数据类型：\n\n * 栈：原始数据类型（undefined、null、boolean、number、string）\n * 堆：引用数据类型（对象、数组和函数）\n\n两种类型的区别在于存储位置的不同：\n\n * 原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n * 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n\n堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：\n\n * 在数据结构中，栈中数据的存取方式为先进后出。\n * 堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。\n\n在操作系统中，内存被分为栈区和堆区：\n\n * 栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。\n * 堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。\n\n\n# 2. 数据类型检测的方式有哪些\n\n（1）typeof\n\nconsole.log(typeof 2);               // number\nconsole.log(typeof true);            // boolean\nconsole.log(typeof 'str');           // string\nconsole.log(typeof []);              // object    \nconsole.log(typeof function(){});    // function\nconsole.log(typeof {});              // object\nconsole.log(typeof undefined);       // undefined\nconsole.log(typeof null);            // object\n\n\n其中数组、对象、null都会被判断为object，其他判断都正确。\n\n（2）instanceof\n\ninstanceof可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。\n\nconsole.log(2 instanceof number);                    // false\nconsole.log(true instanceof boolean);                // false \nconsole.log('str' instanceof string);                // false \n \nconsole.log([] instanceof array);                    // true\nconsole.log(function(){} instanceof function);       // true\nconsole.log({} instanceof object);                   // true\n\n\n可以看到，instanceof只能正确判断引用数据类型，而不能判断基本数据类型。instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。\n\n（3） constructor\n\nconsole.log((2).constructor === number); // true\nconsole.log((true).constructor === boolean); // true\nconsole.log(('str').constructor === string); // true\nconsole.log(([]).constructor === array); // true\nconsole.log((function() {}).constructor === function); // true\nconsole.log(({}).constructor === object); // true\n\n\nconstructor有两个作用，一是判断数据的类型，二是对象实例通过 constrcutor 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了：\n\nfunction fn(){};\n \nfn.prototype = new array();\n \nvar f = new fn();\n \nconsole.log(f.constructor===fn);    // false\nconsole.log(f.constructor===array); // true\n\n\n（4）object.prototype.tostring.call()\n\nobject.prototype.tostring.call() 使用 object 对象的原型方法 tostring 来判断数据类型：\n\nvar a = object.prototype.tostring;\n \nconsole.log(a.call(2));\nconsole.log(a.call(true));\nconsole.log(a.call('str'));\nconsole.log(a.call([]));\nconsole.log(a.call(function(){}));\nconsole.log(a.call({}));\nconsole.log(a.call(undefined));\nconsole.log(a.call(null));\n\n\n同样是检测对象obj调用tostring方法，obj.tostring()的结果和object.prototype.tostring.call(obj)的结果不一样，这是为什么？\n\n这是因为tostring是object的原型方法，而array、function等类型作为object的实例，都重写了tostring方法。不同的对象类型调用tostring方法时，根据原型链的知识，调用的是对应的重写之后的tostring方法（function类型返回内容为函数体的字符串，array类型返回元素组成的字符串…），而不会去调用object上原型tostring方法（返回对象的具体类型），所以采用obj.tostring()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用object原型上的tostring方法。\n\n\n# 3. 判断数组的方式有哪些\n\n * 通过object.prototype.tostring.call()做判断\n\nobject.prototype.tostring.call(obj).slice(8,-1) === 'array';\n\n\n * 通过原型链做判断\n\nobj.__proto__ === array.prototype;\n\n\n * 通过es6的array.isarray()做判断\n\narray.isarrray(obj);\n\n\n * 通过instanceof做判断\n\nobj instanceof array\n\n\n * 通过array.prototype.isprototypeof\n\narray.prototype.isprototypeof(obj)\n\n\n\n# 4. null和undefined区别\n\n首先 undefined 和 null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。\n\nundefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。\n\nundefined 在 javascript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。\n\n当对这两种类型使用 typeof 进行判断时，null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。\n\n\n# 5. typeof null 的结果是什么，为什么？\n\ntypeof null 的结果是object。\n\n在 javascript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits) 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：\n\n000: object   - 当前存储的数据指向一个对象。\n  1: int      - 当前存储的数据是一个 31 位的有符号整数。\n010: double   - 当前存储的数据指向一个双精度的浮点数。\n100: string   - 当前存储的数据指向一个字符串。\n110: boolean  - 当前存储的数据是布尔值。\n\n\n如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。\n\n有两种特殊数据类型：\n\n * undefined的值是 (-2)30(一个超出整数范围的数字)；\n * null 的值是机器码 null 指针(null 指针的值全是 0)\n\n那也就是说null的类型标签也是000，和object的类型标签一样，所以会被判定为object。\n\n\n# 6. intanceof 操作符的实现原理及实现\n\ninstanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\n\nfunction myinstanceof(left, right) {\n  // 获取对象的原型\n  let proto = object.getprototypeof(left)\n  // 获取构造函数的 prototype 对象\n  let prototype = right.prototype; \n \n  // 判断构造函数的 prototype 对象是否在对象的原型链上\n  while (true) {\n    if (!proto) return false;\n    if (proto === prototype) return true;\n    // 如果没有找到，就继续从其原型上找，object.getprototypeof方法用来获取指定对象的原型\n    proto = object.getprototypeof(proto);\n  }\n}\n\n\n\n# 7. 为什么0.1+0.2 ! == 0.3，如何让其相等\n\n在开发过程中遇到类似这样的问题：\n\nlet n1 = 0.1, n2 = 0.2\nconsole.log(n1 + n2)  // 0.30000000000000004\n\n\n这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：\n\n(n1 + n2).tofixed(2) // 注意，tofixed为四舍五入\n\n\ntofixed(num) 方法可把 number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？\n\n计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那javascript是如何处理无限循环的二进制小数呢？\n\n一般我们认为数字包括整数和小数，但是在 javascript 中只有一种数字类型：number，它的实现遵循ieee 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。\n\n根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：0.30000000000000004。\n\n下面看一下双精度数是如何保存的：\n\n * 第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位\n * 第二部分（绿色）：用来存储指数（exponent），占用11位\n * 第三部分（红色）：用来存储小数（fraction），占用52位\n\n对于0.1，它的二进制为：\n\n0.00011001100110011001100110011001100110011001100110011001 10011...\n\n\n转为科学计数法（科学计数法的结果就是浮点数）：\n\n1.1001100110011001100110011001100110011001100110011001*2^-4\n\n\n可以看出0.1的符号位为0，指数位为-4，小数位为：\n\n1001100110011001100110011001100110011001100110011001\n\n\n那么问题又来了，指数位是负数，该如何保存呢？\n\nieee标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于javascript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，ieee固定双精度数的偏移量为1023。\n\n * 当指数位不全是0也不全是1时(规格化的数值)，ieee规定，阶码计算公式为 e-bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是-1022~1013。\n * 当指数位全部是0的时候(非规格化的数值)，ieee规定，阶码的计算公式为1-bias，即1-1023= -1022。\n * 当指数位全部是1的时候(特殊值)，ieee规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，nan。 具体的，小数位不为0的时候表示nan；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。\n\n对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：1111111011.\n\n所以，0.1表示为：\n\n0 1111111011 1001100110011001100110011001100110011001100110011001\n\n\n说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？\n\n对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对javascript来说，这个值通常为2-52，在es6中，提供了number.epsilon属性，而它的值就是2-52，只要判断0.1+0.2-0.3是否小于number.epsilon，如果小于，就可以判断为0.1+0.2 ===0.3\n\nfunction numberepsilon(arg1,arg2){                   \n  return math.abs(arg1 - arg2) < number.epsilon;        \n}        \n\nconsole.log(numberepsilon(0.1 + 0.2, 0.3)); // true\n\n\n\n# 8. 如何获取安全的 undefined 值？\n\n因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。\n\n\n# 9. typeof nan 的结果是什么？\n\nnan 指“不是一个数字”（not a number），nan 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。\n\ntypeof nan; // \"number\"\n\n\nnan 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 nan !== nan 为 true。\n\n\n# 10. isnan 和 number.isnan 函数的区别？\n\n * 函数 isnan 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 nan 的判断。\n * 函数 number.isnan 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 nan ，不会进行数据类型的转换，这种方法对于 nan 的判断更为准确。\n\n\n# 12. 其他值到字符串的转换规则？\n\n * null 和 undefined 类型 ，null 转换为 \"null\"，undefined 转换为 \"undefined\"，\n * boolean 类型，true 转换为 \"true\"，false 转换为 \"false\"。\n * number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。\n * symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。\n * 对普通对象来说，除非自行定义 tostring() 方法，否则会调用 tostring()（object.prototype.tostring()）来返回内部属性 [[class]] 的值，如\"[object object]\"。如果对象有自己的 tostring() 方法，字符串化时就会调用该方法并使用其返回值。\n\n\n# 13. 其他值到数字值的转换规则？\n\n * undefined 类型的值转换为 nan。\n * null 类型的值转换为 0。\n * boolean 类型的值，true 转换为 1，false 转换为 0。\n * string 类型的值转换如同使用 number() 函数进行转换，如果包含非数字值则转换为 nan，空字符串为 0。\n * symbol 类型的值不能转换为数字，会报错。\n * 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。\n\n为了将值转换为相应的基本类型值，抽象操作 toprimitive 会首先（通过内部操作 defaultvalue）检查该值是否有valueof()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 tostring() 的返回值（如果存在）来进行强制类型转换。\n\n如果 valueof() 和 tostring() 均不返回基本类型值，会产生 typeerror 错误。\n\n\n# 14. 其他值到布尔类型的值的转换规则？\n\n以下这些是假值： • undefined • null • false • +0、-0 和 nan • \"\"\n\n假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。\n\n\n# 15. || 和 && 操作符的返回值？\n\n|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。\n\n * 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。\n * && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。\n\n|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果\n\n\n# 16. object.is() 与比较操作符 “===”、“==” 的区别？\n\n * 使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。\n * 使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。\n * 使用 object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 nan 是相等的。\n\n\n# 17. 什么是 javascript 中的包装类型？\n\n在 javascript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 javascript 会在后台隐式地将基本类型的值转换为对象，如：\n\nconst a = \"abc\";\na.length; // 3\na.touppercase(); // \"abc\"\n\n\n在访问'abc'.length时，javascript 将'abc'在后台转换成string('abc')，然后再访问其length属性。\n\njavascript也可以使用object函数显式地将基本类型转换为包装类型：\n\nvar a = 'abc'\nobject(a) // string {\"abc\"}\n\n\n也可以使用valueof方法将包装类型倒转成基本类型：\n\nvar a = 'abc'\nvar b = object(a)\nvar c = b.valueof() // 'abc'\n\n\n看看如下代码会打印出什么：\n\nvar a = new boolean( false );\nif (!a) {\n\tconsole.log( \"oops\" ); // never runs\n}\n\n\n答案是什么都不会打印，因为虽然包裹的基本类型是false，但是false被包裹成包装类型后就成了对象，所以其非值为false，所以循环体中的内容不会运行。\n\n\n# 18. javascript 中如何进行隐式类型转换？\n\n首先要介绍toprimitive方法，这是 javascript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：\n\n/**\n* @obj 需要转换的对象\n* @type 期望的结果类型\n*/\ntoprimitive(obj,type)\n\n\ntype的值为number或者string。\n\n（1）当type为number时规则如下：\n\n * 调用obj的valueof方法，如果为原始值，则返回，否则下一步；\n * 调用obj的tostring方法，后续同上；\n * 抛出typeerror 异常。\n\n（2）当type为string时规则如下：\n\n * 调用obj的tostring方法，如果为原始值，则返回，否则下一步；\n * 调用obj的valueof方法，后续同上；\n * 抛出typeerror 异常。\n\n可以看出两者的主要区别在于调用tostring和valueof的先后顺序。默认情况下：\n\n * 如果对象为 date 对象，则type默认为string；\n * 其他情况下，type默认为number。\n\n总结上面的规则，对于 date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：\n\nvar objtonumber = value => number(value.valueof().tostring())\nobjtonumber([]) === 0\nobjtonumber({}) === nan\n\n\n而 javascript 中的隐式类型转换主要发生在+、-、*、/以及==、>、<这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用toprimitive转换成基本类型，再进行操作。\n\n以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被toprimitive转换成基本类型，所以最终还是要应用基本类型转换规则）：\n\n 1. +操作符 +操作符的两边有至少一个string类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。\n\n1 + '23' // '123'\n 1 + false // 1 \n 1 + symbol() // uncaught typeerror: cannot convert a symbol value to a number\n '1' + false // '1false'\n false + true // 1\n\n\n 1. -、*、\\操作符\n\nnan也是一个数字\n\n1 * '23' // 23\n 1 * false // 0\n 1 / 'aa' // nan\n\n\n 1. 对于==操作符\n\n操作符两边的值都尽量转成number：\n\n3 == true // false, 3 转为number为3，true转为number为1\n'0' == false //true, '0'转为number为0，false转为number为0\n'0' == 0 // '0'转为number为0\n\n\n 1. 对于<和>比较符\n\n如果两边都是字符串，则比较字母表顺序：\n\n'ca' < 'bd' // false\n'a' < 'b' // true\n\n\n其他情况下，转换为数字再比较：\n\n'12' < 13 // true\nfalse > -1 // true\n\n\n以上说的是基本类型的隐式转换，而对象会被toprimitive转换为基本类型再进行转换：\n\nvar a = {}\na > 2 // false\n\n\n其对比过程如下：\n\na.valueof() // {}, 上面提到过，toprimitive默认type为number，所以先valueof，结果还是个对象，下一步\na.tostring() // \"[object object]\"，现在是一个字符串了\nnumber(a.tostring()) // nan，根据上面 < 和 > 操作符的规则，要转换成数字\nnan > 2 //false，得出比较结果\n\n\n又比如：\n\nvar a = {name:'jack'}\nvar b = {age: 18}\na + b // \"[object object][object object]\"\n\n\n运算过程如下：\n\na.valueof() // {}，上面提到过，toprimitive默认type为number，所以先valueof，结果还是个对象，下一步\na.tostring() // \"[object object]\"\nb.valueof() // 同理\nb.tostring() // \"[object object]\"\na + b // \"[object object][object object]\"\n\n\n\n# 19. + 操作符什么时候用于字符串的拼接？\n\n根据 es5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 toprimitive 抽象操作，该抽象操作再调用 [[defaultvalue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。\n\n简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。\n\n那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。\n\n\n# 20. 为什么会有bigint的提案？\n\njavascript中number.max_safe_integer表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了bigint来解决此问题。\n\n\n# 21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别\n\n扩展运算符：\n\nlet outobj = {\n  inobj: {a: 1, b: 2}\n}\nlet newobj = {...outobj}\nnewobj.inobj.a = 2\nconsole.log(outobj) // {inobj: {a: 2, b: 2}}\n\n\nobject.assign():\n\nlet outobj = {\n  inobj: {a: 1, b: 2}\n}\nlet newobj = object.assign({}, outobj)\nnewobj.inobj.a = 2\nconsole.log(outobj) // {inobj: {a: 2, b: 2}}\n\n\n可以看到，两者都是浅拷贝。\n\n * object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 es6 setter。\n * 扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制es6的 symbols 属性。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "css 部分",
      "frontmatter": {
        "title": "css 部分",
        "date": "2022-05-31T17:45:40.000Z",
        "permalink": "/pages/baseCss",
        "article": false
      },
      "regularPath": "/10.%E5%9F%BA%E7%A1%80%E7%AF%87/10.%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/20.css%E9%83%A8%E5%88%86.html",
      "relativePath": "10.基础篇/10.基础进阶/20.css部分.md",
      "key": "v-311ca307",
      "path": "/pages/baseCss/",
      "headers": [
        {
          "level": 3,
          "title": "1 css sprite是什么，有什么优缺点",
          "slug": "_1-css-sprite是什么-有什么优缺点",
          "normalizedTitle": "1 css sprite是什么，有什么优缺点",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2 display: none;与visibility: hidden;的区别",
          "slug": "_2-display-none-与visibility-hidden-的区别",
          "normalizedTitle": "2 display: none;与visibility: hidden;的区别",
          "charIndex": 290
        },
        {
          "level": 3,
          "title": "3 清除浮动的几种方式，各自的优缺点",
          "slug": "_3-清除浮动的几种方式-各自的优缺点",
          "normalizedTitle": "3 清除浮动的几种方式，各自的优缺点",
          "charIndex": 724
        },
        {
          "level": 3,
          "title": "4 css3有哪些新特性",
          "slug": "_4-css3有哪些新特性",
          "normalizedTitle": "4 css3有哪些新特性",
          "charIndex": 909
        },
        {
          "level": 3,
          "title": "5 display有哪些值？说明他们的作用",
          "slug": "_5-display有哪些值-说明他们的作用",
          "normalizedTitle": "5 display有哪些值？说明他们的作用",
          "charIndex": 2178
        },
        {
          "level": 3,
          "title": "6 CSS不同选择器的权重(CSS层叠的规则)",
          "slug": "_6-css不同选择器的权重-css层叠的规则",
          "normalizedTitle": "6 css不同选择器的权重(css层叠的规则)",
          "charIndex": 2400
        },
        {
          "level": 3,
          "title": "7 px和em的区别",
          "slug": "_7-px和em的区别",
          "normalizedTitle": "7 px和em的区别",
          "charIndex": 2821
        },
        {
          "level": 3,
          "title": "8 Sass、LESS是什么？大家为什么要使用他们？",
          "slug": "_8-sass、less是什么-大家为什么要使用他们",
          "normalizedTitle": "8 sass、less是什么？大家为什么要使用他们？",
          "charIndex": 3069
        },
        {
          "level": 3,
          "title": "9 水平居中的方法",
          "slug": "_9-水平居中的方法",
          "normalizedTitle": "9 水平居中的方法",
          "charIndex": 3446
        },
        {
          "level": 3,
          "title": "10 重绘和回流（重排）是什么，如何避免？",
          "slug": "_10-重绘和回流-重排-是什么-如何避免",
          "normalizedTitle": "10 重绘和回流（重排）是什么，如何避免？",
          "charIndex": 3630
        },
        {
          "level": 3,
          "title": "11 如何实现小于12px的字体效果",
          "slug": "_11-如何实现小于12px的字体效果",
          "normalizedTitle": "11 如何实现小于12px的字体效果",
          "charIndex": 4296
        },
        {
          "level": 3,
          "title": "12 请列举几种隐藏元素的方法",
          "slug": "_12-请列举几种隐藏元素的方法",
          "normalizedTitle": "12 请列举几种隐藏元素的方法",
          "charIndex": 4441
        },
        {
          "level": 3,
          "title": "13 CSS优化、提高性能的方法有哪些",
          "slug": "_13-css优化、提高性能的方法有哪些",
          "normalizedTitle": "13 css优化、提高性能的方法有哪些",
          "charIndex": 4870
        },
        {
          "level": 3,
          "title": "14 在网页中的应该使用奇数还是偶数的字体",
          "slug": "_14-在网页中的应该使用奇数还是偶数的字体",
          "normalizedTitle": "14 在网页中的应该使用奇数还是偶数的字体",
          "charIndex": 5079
        },
        {
          "level": 3,
          "title": "15 什么是视差滚动效果，如何给每页做不同的动画",
          "slug": "_15-什么是视差滚动效果-如何给每页做不同的动画",
          "normalizedTitle": "15 什么是视差滚动效果，如何给每页做不同的动画",
          "charIndex": 5225
        },
        {
          "level": 3,
          "title": "16 ::before 和 :after 中双冒号和单冒号有什么区别",
          "slug": "_16-before-和-after-中双冒号和单冒号有什么区别",
          "normalizedTitle": "16 ::before 和 :after 中双冒号和单冒号有什么区别",
          "charIndex": 5472
        },
        {
          "level": 3,
          "title": "17 如何修改Chrome记住密码后自动填充表单的黄色背景",
          "slug": "_17-如何修改chrome记住密码后自动填充表单的黄色背景",
          "normalizedTitle": "17 如何修改chrome记住密码后自动填充表单的黄色背景",
          "charIndex": 5779
        }
      ],
      "headersStr": "1 css sprite是什么，有什么优缺点 2 display: none;与visibility: hidden;的区别 3 清除浮动的几种方式，各自的优缺点 4 css3有哪些新特性 5 display有哪些值？说明他们的作用 6 CSS不同选择器的权重(CSS层叠的规则) 7 px和em的区别 8 Sass、LESS是什么？大家为什么要使用他们？ 9 水平居中的方法 10 重绘和回流（重排）是什么，如何避免？ 11 如何实现小于12px的字体效果 12 请列举几种隐藏元素的方法 13 CSS优化、提高性能的方法有哪些 14 在网页中的应该使用奇数还是偶数的字体 15 什么是视差滚动效果，如何给每页做不同的动画 16 ::before 和 :after 中双冒号和单冒号有什么区别 17 如何修改Chrome记住密码后自动填充表单的黄色背景",
      "content": "# 1 css sprite是什么，有什么优缺点\n\n * css sprite中文名为 雪碧图，也叫精灵图，\n\n * 概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。\n\n * 优点：\n   \n   * 减少HTTP请求数，极大地提高页面加载速度\n   \n   * 增加图片信息重复度，提高压缩比，减少图片大小\n   \n   * 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现\n\n * 缺点：\n   \n   * 图片合并麻烦\n   \n   * 维护麻烦，修改一个图片可能需要从新布局整个图片，样式\n\n\n# 2 display: none;与visibility: hidden;的区别\n\n * 联系：它们都能让元素不可见\n\n * 区别：\n   \n   * display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见\n   \n   * display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式\n   \n   * 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。\n   \n   * 读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容\n\n\n# 3 清除浮动的几种方式，各自的优缺点\n\n * 父级div定义height\n\n * 结尾处加空div标签clear:both\n\n * 父级div定义伪类:after和zoom\n\n * 父级div定义overflow:hidden\n\n * 父级div也浮动，需要定义宽度\n\n * 结尾处加br标签clear:both\n\n * 比较好的是第3种方式，好多网站都这么用\n\n\n# 4 css3有哪些新特性\n\n * 新增选择器 p:nth-child(n){color: rgba(255, 0, 0, 0.75)}\n\n * 弹性盒模型 display: flex;\n\n * 多列布局 column-count: 5;\n\n * 媒体查询 @media (max-width: 480px) {.box: {column-count: 1;}}\n\n * 个性化字体 @font-face{font-family: BorderWeb; src:url(BORDERW0.eot);}\n\n * 颜色透明度 color: rgba(255, 0, 0, 0.75);\n\n * 圆角 border-radius: 5px;\n\n * 渐变 background:linear-gradient(red, green, blue);\n\n * 阴影 box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);\n\n * 倒影 box-reflect: below 2px;\n\n * 文字装饰 text-stroke-color: red;\n\n * 文字溢出 text-overflow:ellipsis;\n\n * 背景效果 background-size: 100px 100px;\n\n * 边框效果 border-image:url(bt_blue.png) 0 10;\n\n * 转换\n   \n   * 旋转 transform: rotate(20deg);\n   \n   * 倾斜 transform: skew(150deg, -10deg);\n   \n   * 位移 transform: translate(20px, 20px);\n   \n   * 缩放 transform: scale(.5);\n\n * 平滑过渡 transition: all .3s ease-in .1s;\n\n * 动画 @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;\n\nCSS3新增伪类有那些？\n\n * p:first-of-type 选择属于其父元素的首个<p>元素的每个<p> 元素。\n\n * p:last-of-type 选择属于其父元素的最后 <p> 元素的每个<p> 元素。\n\n * p:only-of-type 选择属于其父元素唯一的 <p>元素的每个 <p> 元素。\n\n * p:only-child 选择属于其父元素的唯一子元素的每个 <p> 元素。\n\n * p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n * :after 在元素之前添加内容,也可以用来做清除浮动。\n\n * :before 在元素之后添加内容。\n\n * :enabled 已启用的表单元素。\n\n * :disabled 已禁用的表单元素。\n\n * :checked 单选框或复选框被选中。\n\n\n# 5 display有哪些值？说明他们的作用\n\n * block 转换成块状元素。\n\n * inline 转换成行内元素。\n\n * none 设置元素不可见。\n\n * inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。\n\n * list-item 象块类型元素一样显示，并添加样式列表标记。\n\n * table 此元素会作为块级表格来显示\n\n * inherit 规定应该从父元素继承 display 属性的值\n\n\n# 6 CSS不同选择器的权重(CSS层叠的规则)\n\n * ！important规则最重要，大于其它规则\n\n * 行内样式规则，加1000\n\n * 对于选择器中给定的各个ID属性值，加100\n\n * 对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加10\n\n * 对于选择其中给定的各个元素标签选择器，加1\n\n * 如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则\n\n> 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下/// 例子是演示各种定义的权重值：\n\n/*权重为1*/\ndiv{\n}\n/*权重为10*/\n.class1{\n}\n/*权重为100*/\n#id1{\n}\n/*权重为100+1=101*/\n#id1 div{\n}\n/*权重为10+1=11*/\n.class1 div{\n}\n/*权重为10+10+1=21*/\n.class1 .class2 div{\n}\n\n\n\n# 7 px和em的区别\n\n * px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。\n\n * 浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。\n\n>  * px 相对于显示器屏幕分辨率，无法用浏览器字体放大功能\n\n>  * em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size\n\n\n# 8 Sass、LESS是什么？大家为什么要使用他们？\n\n * 他们是CSS预处理器。他是CSS上的一种抽象层。他们是一种特殊的语法/语言编译成CSS。\n\n * 例如Less是一种动态样式语言. 将CSS赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js)\n\n为什么要使用它们？\n\n * 结构清晰，便于扩展。\n\n * 可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对- 浏览器语法差异的重复处理，减少无意义的机械劳动。\n\n * 可以轻松实现多重继承。\n\n * 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只- 是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译\n\n\n# 9 水平居中的方法\n\n * 元素为行内元素，设置父元素text-align:center\n\n * 如果元素宽度固定，可以设置左右margin为auto;\n\n * 绝对定位和移动: absolute + transform\n\n * 使用flex-box布局，指定justify-content属性为center\n\n * display设置为tabel-ceil\n\n\n# 10 重绘和回流（重排）是什么，如何避免？\n\n * 重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘\n\n * 回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流\n\n * 注意：JS获取Layout属性值（如：offsetLeft、scrollTop、getComputedStyle等）也会引起回流。因为浏览器需要通过回流计算最新值\n\n * 回流必将引起重绘，而重绘不一定会引起回流\n\n如何最小化重绘(repaint)和回流(reflow)：\n\n * 需要要对元素进行复杂的操作时，可以先隐藏(display:\"none\")，操作完成后再显示\n\n * 需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document\n\n * 缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流\n\n * 尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流）\n\n * 避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面）\n\n * 尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color\n\n * 批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx\n\n\n# 11 如何实现小于12px的字体效果\n\n * transform:scale()这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个display:inline-block;\n\ntransform: scale(0.7);\n\n\ncss的属性，可以缩放大小\n\n\n# 12 请列举几种隐藏元素的方法\n\n * visibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在\n\n * opacity: 0; CSS3属性，设置0可以使一个元素完全透明\n\n * position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外\n\n * display: none; 元素会变得不可见，并且不会再占用文档的空间。\n\n * transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留\n\n * <div hidden=\"hidden\"> HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态\n\n * height: 0; 将元素高度设为 0 ，并消除边框\n\n * filter: blur(0); CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中\n\n\n# 13 CSS优化、提高性能的方法有哪些\n\n * 多个css合并，尽量减少HTTP请求\n\n * 将css文件放在页面最上面\n\n * 移除空的css规则\n\n * 避免使用CSS表达式\n\n * 选择器优化嵌套，尽量避免层级过深\n\n * 充分利用css继承属性，减少代码量\n\n * 抽象提取公共样式，减少代码量\n\n * 属性值为0时，不加单位\n\n * 属性值为小于1的小数时，省略小数点前面的0\n\n * css雪碧图\n\n\n# 14 在网页中的应该使用奇数还是偶数的字体\n\n * 在网页中的应该使用“偶数”字体：\n   \n   * 偶数字号相对更容易和 web 设计的其他部分构成比例关系\n   \n   * 使用奇数号字体时文本段落无法对齐\n   \n   * 宋体的中文网页排布中使用最多的就是 12 和 14\n\n\n# 15 什么是视差滚动效果，如何给每页做不同的动画\n\n * 视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验\n\n * 一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的\n\n * 实现原理\n   \n   * 以 “页面滚动条” 作为 “视差动画进度条”\n   \n   * 以 “滚轮刻度” 当作 “动画帧度” 去播放动画的\n   \n   * 监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果\n\n\n# 16 ::before 和 :after 中双冒号和单冒号有什么区别\n\n * 在 CSS 中伪类一直用 : 表示，如 :hover, :active 等\n\n * 伪元素在CSS1中已存在，当时语法是用 : 表示，如 :before 和 :after\n\n * 后来在CSS3中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类\n\n * 由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素\n\n * 综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容IE的老语法\n\n\n# 17 如何修改Chrome记住密码后自动填充表单的黄色背景\n\n * 产生原因：由于Chrome默认会给自动填充的input表单加上 input:-webkit-autofill 私有属性造成的\n\n * 解决方案1：在form标签上直接关闭了表单的自动填充：autocomplete=\"off\"\n\n * 解决方案2：input:-webkit-autofill { background-color: transparent; }\n\ninput [type=search] 搜索框右侧小图标如何美化？\n\ninput[type=\"search\"]::-webkit-search-cancel-button{\n  -webkit-appearance: none;\n  height: 15px;\n  width: 15px;\n  border-radius: 8px;\n  background:url(\"images/searchicon.png\") no-repeat 0 0;\n  background-size: 15px 15px;\n}\n",
      "normalizedContent": "# 1 css sprite是什么，有什么优缺点\n\n * css sprite中文名为 雪碧图，也叫精灵图，\n\n * 概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。\n\n * 优点：\n   \n   * 减少http请求数，极大地提高页面加载速度\n   \n   * 增加图片信息重复度，提高压缩比，减少图片大小\n   \n   * 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现\n\n * 缺点：\n   \n   * 图片合并麻烦\n   \n   * 维护麻烦，修改一个图片可能需要从新布局整个图片，样式\n\n\n# 2 display: none;与visibility: hidden;的区别\n\n * 联系：它们都能让元素不可见\n\n * 区别：\n   \n   * display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见\n   \n   * display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式\n   \n   * 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。\n   \n   * 读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容\n\n\n# 3 清除浮动的几种方式，各自的优缺点\n\n * 父级div定义height\n\n * 结尾处加空div标签clear:both\n\n * 父级div定义伪类:after和zoom\n\n * 父级div定义overflow:hidden\n\n * 父级div也浮动，需要定义宽度\n\n * 结尾处加br标签clear:both\n\n * 比较好的是第3种方式，好多网站都这么用\n\n\n# 4 css3有哪些新特性\n\n * 新增选择器 p:nth-child(n){color: rgba(255, 0, 0, 0.75)}\n\n * 弹性盒模型 display: flex;\n\n * 多列布局 column-count: 5;\n\n * 媒体查询 @media (max-width: 480px) {.box: {column-count: 1;}}\n\n * 个性化字体 @font-face{font-family: borderweb; src:url(borderw0.eot);}\n\n * 颜色透明度 color: rgba(255, 0, 0, 0.75);\n\n * 圆角 border-radius: 5px;\n\n * 渐变 background:linear-gradient(red, green, blue);\n\n * 阴影 box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);\n\n * 倒影 box-reflect: below 2px;\n\n * 文字装饰 text-stroke-color: red;\n\n * 文字溢出 text-overflow:ellipsis;\n\n * 背景效果 background-size: 100px 100px;\n\n * 边框效果 border-image:url(bt_blue.png) 0 10;\n\n * 转换\n   \n   * 旋转 transform: rotate(20deg);\n   \n   * 倾斜 transform: skew(150deg, -10deg);\n   \n   * 位移 transform: translate(20px, 20px);\n   \n   * 缩放 transform: scale(.5);\n\n * 平滑过渡 transition: all .3s ease-in .1s;\n\n * 动画 @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;\n\ncss3新增伪类有那些？\n\n * p:first-of-type 选择属于其父元素的首个<p>元素的每个<p> 元素。\n\n * p:last-of-type 选择属于其父元素的最后 <p> 元素的每个<p> 元素。\n\n * p:only-of-type 选择属于其父元素唯一的 <p>元素的每个 <p> 元素。\n\n * p:only-child 选择属于其父元素的唯一子元素的每个 <p> 元素。\n\n * p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n * :after 在元素之前添加内容,也可以用来做清除浮动。\n\n * :before 在元素之后添加内容。\n\n * :enabled 已启用的表单元素。\n\n * :disabled 已禁用的表单元素。\n\n * :checked 单选框或复选框被选中。\n\n\n# 5 display有哪些值？说明他们的作用\n\n * block 转换成块状元素。\n\n * inline 转换成行内元素。\n\n * none 设置元素不可见。\n\n * inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。\n\n * list-item 象块类型元素一样显示，并添加样式列表标记。\n\n * table 此元素会作为块级表格来显示\n\n * inherit 规定应该从父元素继承 display 属性的值\n\n\n# 6 css不同选择器的权重(css层叠的规则)\n\n * ！important规则最重要，大于其它规则\n\n * 行内样式规则，加1000\n\n * 对于选择器中给定的各个id属性值，加100\n\n * 对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加10\n\n * 对于选择其中给定的各个元素标签选择器，加1\n\n * 如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则\n\n> 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下/// 例子是演示各种定义的权重值：\n\n/*权重为1*/\ndiv{\n}\n/*权重为10*/\n.class1{\n}\n/*权重为100*/\n#id1{\n}\n/*权重为100+1=101*/\n#id1 div{\n}\n/*权重为10+1=11*/\n.class1 div{\n}\n/*权重为10+10+1=21*/\n.class1 .class2 div{\n}\n\n\n\n# 7 px和em的区别\n\n * px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。\n\n * 浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。\n\n>  * px 相对于显示器屏幕分辨率，无法用浏览器字体放大功能\n\n>  * em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size\n\n\n# 8 sass、less是什么？大家为什么要使用他们？\n\n * 他们是css预处理器。他是css上的一种抽象层。他们是一种特殊的语法/语言编译成css。\n\n * 例如less是一种动态样式语言. 将css赋予了动态语言的特性，如变量，继承，运算， 函数. less 既可以在客户端上运行 (支持ie 6+, webkit, firefox)，也可一在服务端运行 (借助 node.js)\n\n为什么要使用它们？\n\n * 结构清晰，便于扩展。\n\n * 可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对- 浏览器语法差异的重复处理，减少无意义的机械劳动。\n\n * 可以轻松实现多重继承。\n\n * 完全兼容 css 代码，可以方便地应用到老项目中。less 只- 是在 css 语法上做了扩展，所以老的 css 代码也可以与 less 代码一同编译\n\n\n# 9 水平居中的方法\n\n * 元素为行内元素，设置父元素text-align:center\n\n * 如果元素宽度固定，可以设置左右margin为auto;\n\n * 绝对定位和移动: absolute + transform\n\n * 使用flex-box布局，指定justify-content属性为center\n\n * display设置为tabel-ceil\n\n\n# 10 重绘和回流（重排）是什么，如何避免？\n\n * 重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘\n\n * 回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流\n\n * 注意：js获取layout属性值（如：offsetleft、scrolltop、getcomputedstyle等）也会引起回流。因为浏览器需要通过回流计算最新值\n\n * 回流必将引起重绘，而重绘不一定会引起回流\n\n如何最小化重绘(repaint)和回流(reflow)：\n\n * 需要要对元素进行复杂的操作时，可以先隐藏(display:\"none\")，操作完成后再显示\n\n * 需要创建多个dom节点时，使用documentfragment创建完后一次性的加入document\n\n * 缓存layout属性值，如：var left = elem.offsetleft; 这样，多次使用 left 只产生一次回流\n\n * 尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流）\n\n * 避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面）\n\n * 尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color\n\n * 批量修改元素样式：elem.classname 和 elem.style.csstext 代替 elem.style.xxx\n\n\n# 11 如何实现小于12px的字体效果\n\n * transform:scale()这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个display:inline-block;\n\ntransform: scale(0.7);\n\n\ncss的属性，可以缩放大小\n\n\n# 12 请列举几种隐藏元素的方法\n\n * visibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在\n\n * opacity: 0; css3属性，设置0可以使一个元素完全透明\n\n * position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外\n\n * display: none; 元素会变得不可见，并且不会再占用文档的空间。\n\n * transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留\n\n * <div hidden=\"hidden\"> html5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态\n\n * height: 0; 将元素高度设为 0 ，并消除边框\n\n * filter: blur(0); css3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中\n\n\n# 13 css优化、提高性能的方法有哪些\n\n * 多个css合并，尽量减少http请求\n\n * 将css文件放在页面最上面\n\n * 移除空的css规则\n\n * 避免使用css表达式\n\n * 选择器优化嵌套，尽量避免层级过深\n\n * 充分利用css继承属性，减少代码量\n\n * 抽象提取公共样式，减少代码量\n\n * 属性值为0时，不加单位\n\n * 属性值为小于1的小数时，省略小数点前面的0\n\n * css雪碧图\n\n\n# 14 在网页中的应该使用奇数还是偶数的字体\n\n * 在网页中的应该使用“偶数”字体：\n   \n   * 偶数字号相对更容易和 web 设计的其他部分构成比例关系\n   \n   * 使用奇数号字体时文本段落无法对齐\n   \n   * 宋体的中文网页排布中使用最多的就是 12 和 14\n\n\n# 15 什么是视差滚动效果，如何给每页做不同的动画\n\n * 视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验\n\n * 一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的\n\n * 实现原理\n   \n   * 以 “页面滚动条” 作为 “视差动画进度条”\n   \n   * 以 “滚轮刻度” 当作 “动画帧度” 去播放动画的\n   \n   * 监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果\n\n\n# 16 ::before 和 :after 中双冒号和单冒号有什么区别\n\n * 在 css 中伪类一直用 : 表示，如 :hover, :active 等\n\n * 伪元素在css1中已存在，当时语法是用 : 表示，如 :before 和 :after\n\n * 后来在css3中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类\n\n * 由于低版本ie对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素\n\n * 综上所述：::before 是 css3 中写伪元素的新语法； :after 是 css1 中存在的、兼容ie的老语法\n\n\n# 17 如何修改chrome记住密码后自动填充表单的黄色背景\n\n * 产生原因：由于chrome默认会给自动填充的input表单加上 input:-webkit-autofill 私有属性造成的\n\n * 解决方案1：在form标签上直接关闭了表单的自动填充：autocomplete=\"off\"\n\n * 解决方案2：input:-webkit-autofill { background-color: transparent; }\n\ninput [type=search] 搜索框右侧小图标如何美化？\n\ninput[type=\"search\"]::-webkit-search-cancel-button{\n  -webkit-appearance: none;\n  height: 15px;\n  width: 15px;\n  border-radius: 8px;\n  background:url(\"images/searchicon.png\") no-repeat 0 0;\n  background-size: 15px 15px;\n}\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "ES6",
      "frontmatter": {
        "title": "ES6",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/es6/",
        "article": false
      },
      "regularPath": "/20.%E9%AB%98%E9%A2%91%E7%AF%87/10.JavaScript%E7%AF%87/20.ES6.html",
      "relativePath": "20.高频篇/10.JavaScript篇/20.ES6.md",
      "key": "v-10ecc226",
      "path": "/pages/es6/",
      "headers": [
        {
          "level": 3,
          "title": "1. let、const、var的区别",
          "slug": "_1-let、const、var的区别",
          "normalizedTitle": "1. let、const、var的区别",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. const对象的属性可以修改吗",
          "slug": "_2-const对象的属性可以修改吗",
          "normalizedTitle": "2. const对象的属性可以修改吗",
          "charIndex": 789
        },
        {
          "level": 3,
          "title": "3. 如果new一个箭头函数的会怎么样",
          "slug": "_3-如果new一个箭头函数的会怎么样",
          "normalizedTitle": "3. 如果new一个箭头函数的会怎么样",
          "charIndex": 993
        },
        {
          "level": 3,
          "title": "4. 箭头函数与普通函数的区别",
          "slug": "_4-箭头函数与普通函数的区别",
          "normalizedTitle": "4. 箭头函数与普通函数的区别",
          "charIndex": 1264
        },
        {
          "level": 3,
          "title": "5. 箭头函数的this指向哪⾥？",
          "slug": "_5-箭头函数的this指向哪里",
          "normalizedTitle": "5. 箭头函数的this指向哪⾥？",
          "charIndex": 2563
        },
        {
          "level": 3,
          "title": "6. 扩展运算符的作用及使用场景",
          "slug": "_6-扩展运算符的作用及使用场景",
          "normalizedTitle": "6. 扩展运算符的作用及使用场景",
          "charIndex": 3022
        },
        {
          "level": 3,
          "title": "7. ES6中模板语法与字符串处理",
          "slug": "_7-es6中模板语法与字符串处理",
          "normalizedTitle": "7. es6中模板语法与字符串处理",
          "charIndex": 4830
        },
        {
          "level": 3,
          "title": "8. 对对象与数组的解构的理解",
          "slug": "_8-对对象与数组的解构的理解",
          "normalizedTitle": "8. 对对象与数组的解构的理解",
          "charIndex": 6471
        },
        {
          "level": 3,
          "title": "9. 如何提取高度嵌套的对象里的指定属性？",
          "slug": "_9-如何提取高度嵌套的对象里的指定属性",
          "normalizedTitle": "9. 如何提取高度嵌套的对象里的指定属性？",
          "charIndex": 6773
        },
        {
          "level": 3,
          "title": "10. 对 rest 参数的理解",
          "slug": "_10-对-rest-参数的理解",
          "normalizedTitle": "10. 对 rest 参数的理解",
          "charIndex": 7339
        },
        {
          "level": 3,
          "title": "11. 说一下es6的导入导出模块",
          "slug": "_11-说一下es6的导入导出模块",
          "normalizedTitle": "11. 说一下es6的导入导出模块",
          "charIndex": 7777
        }
      ],
      "headersStr": "1. let、const、var的区别 2. const对象的属性可以修改吗 3. 如果new一个箭头函数的会怎么样 4. 箭头函数与普通函数的区别 5. 箭头函数的this指向哪⾥？ 6. 扩展运算符的作用及使用场景 7. ES6中模板语法与字符串处理 8. 对对象与数组的解构的理解 9. 如何提取高度嵌套的对象里的指定属性？ 10. 对 rest 参数的理解 11. 说一下es6的导入导出模块",
      "content": "# 1. let、const、var的区别\n\n（1）块级作用域： 块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：\n\n * 内层变量可能覆盖外层变量\n * 用来计数的循环变量泄露为全局变量\n\n（2）变量提升： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。\n\n（3）给全局添加属性： 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。\n\n（4）重复声明： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。\n\n（5）暂时性死区： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。\n\n（6）初始值设置： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。\n\n（7）指针指向： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。\n\n区别          VAR   LET   CONST\n是否有块级作用域    ×     ✔️    ✔️\n是否存在变量提升    ✔️    ×     ×\n是否添加全局属性    ✔️    ×     ×\n能否重复声明变量    ✔️    ×     ×\n是否存在暂时性死区   ×     ✔️    ✔️\n是否必须设置初始值   ×     ×     ✔️\n能否改变指针指向    ✔️    ✔️    ×\n\n\n# 2. const对象的属性可以修改吗\n\nconst保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。\n\n但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。\n\n\n# 3. 如果new一个箭头函数的会怎么样\n\n箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。\n\nnew操作符的实现步骤如下：\n\n 1. 创建一个对象\n 2. 将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）\n 3. 指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）\n 4. 返回新的对象\n\n所以，上面的第二、三步，箭头函数都是没有办法执行的。\n\n\n# 4. 箭头函数与普通函数的区别\n\n（1）箭头函数比普通函数更加简洁\n\n * 如果没有参数，就直接写一个空括号即可\n * 如果只有一个参数，可以省去参数的括号\n * 如果有多个参数，用逗号分割\n * 如果函数体的返回值只有一句，可以省略大括号\n * 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：\n\nlet fn = () => void doesNotReturn();\n\n\n（2）箭头函数没有自己的this\n\n箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。\n\n（3）箭头函数继承来的this指向永远不会改变\n\nvar id = 'GLOBAL';\nvar obj = {\n  id: 'OBJ',\n  a: function(){\n    console.log(this.id);\n  },\n  b: () => {\n    console.log(this.id);\n  }\n};\nobj.a();    // 'OBJ'\nobj.b();    // 'GLOBAL'\nnew obj.a()  // undefined\nnew obj.b()  // Uncaught TypeError: obj.b is not a constructor\n\n\n对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。\n\n（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向\n\nvar id = 'Global';\nlet fun1 = () => {\n    console.log(this.id)\n};\nfun1();                     // 'Global'\nfun1.call({id: 'Obj'});     // 'Global'\nfun1.apply({id: 'Obj'});    // 'Global'\nfun1.bind({id: 'Obj'})();   // 'Global'\n\n\n（5）箭头函数不能作为构造函数使用\n\n构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。\n\n（6）箭头函数没有自己的arguments\n\n箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。\n\n（7）箭头函数没有prototype\n\n（8）箭头函数不能用作Generator函数，不能使用yeild关键字\n\n\n# 5. 箭头函数的this指向哪⾥？\n\n箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。\n\n可以⽤Babel理解⼀下箭头函数:\n\n// ES6 \nconst obj = { \n  getArrow() { \n    return () => { \n      console.log(this === obj); \n    }; \n  } \n}\n\n\n转化后：\n\n// ES5，由 Babel 转译\nvar obj = { \n   getArrow: function getArrow() { \n     var _this = this; \n     return function () { \n        console.log(_this === obj); \n     }; \n   } \n};\n\n\n\n# 6. 扩展运算符的作用及使用场景\n\n（1）对象扩展运算符\n\n对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。\n\nlet bar = { a: 1, b: 2 };\nlet baz = { ...bar }; // { a: 1, b: 2 }\n\n\n上述方法实际上等价于:\n\nlet bar = { a: 1, b: 2 };\nlet baz = Object.assign({}, bar); // { a: 1, b: 2 }\n\n\nObject.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。\n\n同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。\n\nlet bar = {a: 1, b: 2};\nlet baz = {...bar, ...{a:2, b: 4}};  // {a: 2, b: 4}\n\n\n利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数，reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。\n\n需要注意：扩展运算符对对象实例的拷贝属于浅拷贝。\n\n（2）数组扩展运算符\n\n数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。\n\nconsole.log(...[1, 2, 3])\n// 1 2 3\nconsole.log(...[1, [2, 3, 4], 5])\n// 1 [2, 3, 4] 5\n\n\n下面是数组的扩展运算符的应用：\n\n * 将数组转换为参数序列\n\nfunction add(x, y) {\n  return x + y;\n}\nconst numbers = [1, 2];\nadd(...numbers) // 3\n\n\n * 复制数组\n\nconst arr1 = [1, 2];\nconst arr2 = [...arr1];\n\n\n要记住：扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。\n\n * 合并数组\n\n如果想在数组内合并数组，可以这样：\n\nconst arr1 = ['two', 'three'];const arr2 = ['one', ...arr1, 'four', 'five'];// [\"one\", \"two\", \"three\", \"four\", \"five\"]\n\n\n * 扩展运算符与解构赋值结合起来，用于生成数组\n\nconst [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest  // [2, 3, 4, 5]\n\n\n需要注意：如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。\n\nconst [...rest, last] = [1, 2, 3, 4, 5];         // 报错const [first, ...rest, last] = [1, 2, 3, 4, 5];  // 报错\n\n\n * 将字符串转为真正的数组\n\n[...'hello']    // [ \"h\", \"e\", \"l\", \"l\", \"o\" ]\n\n\n * 任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组\n\n比较常见的应用是可以将某些数据结构转为数组：\n\n// arguments对象\nfunction foo() {\n  const args = [...arguments];\n}\n\n\n用于替换es5中的Array.prototype.slice.call(arguments)写法。\n\n * 使用Math函数获取数组中特定的值\n\nconst numbers = [9, 4, 7, 1];\nMath.min(...numbers); // 1\nMath.max(...numbers); // 9\n\n\n\n# 7. ES6中模板语法与字符串处理\n\nES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：\n\nvar name = 'css'   \nvar career = 'coder' \nvar hobby = ['coding', 'writing']\nvar finalString = 'my name is ' + name + ', I work as a ' + career + ', I love ' + hobby[0] + ' and ' + hobby[1]\n\n\n仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：\n\nvar name = 'css'   \nvar career = 'coder' \nvar hobby = ['coding', 'writing']\nvar finalString = `my name is ${name}, I work as a ${career} I love ${hobby[0]} and ${hobby[1]}`\n\n\n字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：\n\n * 在模板字符串中，空格、缩进、换行都会被保留\n * 模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算\n\n基于第一点，可以在模板字符串里无障碍地直接写 html 代码：\n\nlet list = `\n\t<ul>\n\t\t<li>列表项1</li>\n\t\t<li>列表项2</li>\n\t</ul>\n`;\nconsole.log(message); // 正确输出，不存在报错\n\n\n基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：\n\nfunction add(a, b) {\n  const finalString = `${a} + ${b} = ${a+b}`\n  console.log(finalString)\n}\nadd(1, 2) // 输出 '1 + 2 = 3'\n\n\n除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：\n\n（1）存在性判定：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf > -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。\n\n * includes：判断字符串与子串的包含关系：\n\nconst son = 'haha' \nconst father = 'xixi haha hehe'\nfather.includes(son) // true\n\n\n * startsWith：判断字符串是否以某个/某串字符开头：\n\nconst father = 'xixi haha hehe'\nfather.startsWith('haha') // false\nfather.startsWith('xixi') // true\n\n\n * endsWith：判断字符串是否以某个/某串字符结尾：\n\nconst father = 'xixi haha hehe'\n  father.endsWith('hehe') // true\n\n\n（2）自动重复：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：\n\nconst sourceCode = 'repeat for 3 times;'\nconst repeated = sourceCode.repeat(3) \nconsole.log(repeated) // repeat for 3 times;repeat for 3 times;repeat for 3 times;\n\n\n\n# 8. 对对象与数组的解构的理解\n\n解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。 1）数组的解构 在解构数组时，以元素的位置为匹配条件来提取想要的数据的：\n\nconst [a, b, c] = [1, 2, 3]\n\n\n2）对象的解构 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：\n\nconst stu = {\n  name: 'Bob',\n  age: 24\n}\n\n\n假如想要解构它的两个自有属性，可以这样：\n\nconst { name, age } = stu\n\n\n\n# 9. 如何提取高度嵌套的对象里的指定属性？\n\n有时会遇到一些嵌套程度非常深的对象：\n\nconst school = {\n   classes: {\n      stu: {\n         name: 'Bob',\n         age: 24,\n      }\n   }\n}\n\n\n像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：\n\nconst { name } = school\n\n\n显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：\n\nconst { classes } = school\nconst { stu } = classes\nconst { name } = stu\nname // 'Bob'\n\n\n但是还有一种更标准的做法，可以用一行代码来解决这个问题：\n\nconst { classes: { stu: { name } }} = school\n       \nconsole.log(name)  // 'Bob'\n\n\n可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。\n\n\n# 10. 对 rest 参数的理解\n\n扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：\n\nfunction mutiple(...args) {\n  let result = 1;\n  for (var val of args) {\n    result *= val;\n  }\n  return result;\n}\nmutiple(1, 2, 3, 4) // 24\n\n\n这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：\n\nfunction mutiple(...args) {\n  console.log(args)\n}\nmutiple(1, 2, 3, 4) // [1, 2, 3, 4]\n\n\n这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。\n\n\n# 11. 说一下es6的导入导出模块\n\n> 导入通过import关键字\n\n// 只导入一个\nimport {sum} from \"./example.js\"\n// 导入多个\nimport {sum,multiply,time} from \"./exportExample.js\"\n// 导入一整个模块\nimport * as example from \"./exportExample.js\"\n复制代码\n\n\n> 导出通过export关键字\n\n//可以将export放在任何变量,函数或类声明的前面\nexport var firstName = 'Michael';\nexport var lastName = 'Jackson';\nexport var year = 1958;\n//也可以使用大括号指定所要输出的一组变量\nvar firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\nexport {firstName, lastName, year};\n//使用export default时，对应的import语句不需要使用大括号\nlet bosh = function crs(){}\nexport default bosh;\nimport crc from 'crc';\n//不使用export default时，对应的import语句需要使用大括号\nlet bosh = function crs(){}\nexport bosh;\nimport {crc} from 'crc';\n",
      "normalizedContent": "# 1. let、const、var的区别\n\n（1）块级作用域： 块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了es5中的两个问题：\n\n * 内层变量可能覆盖外层变量\n * 用来计数的循环变量泄露为全局变量\n\n（2）变量提升： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。\n\n（3）给全局添加属性： 浏览器的全局对象是window，node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。\n\n（4）重复声明： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。\n\n（5）暂时性死区： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。\n\n（6）初始值设置： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。\n\n（7）指针指向： let和const都是es6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。\n\n区别          var   let   const\n是否有块级作用域    ×     ✔️    ✔️\n是否存在变量提升    ✔️    ×     ×\n是否添加全局属性    ✔️    ×     ×\n能否重复声明变量    ✔️    ×     ×\n是否存在暂时性死区   ×     ✔️    ✔️\n是否必须设置初始值   ×     ×     ✔️\n能否改变指针指向    ✔️    ✔️    ×\n\n\n# 2. const对象的属性可以修改吗\n\nconst保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。\n\n但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。\n\n\n# 3. 如果new一个箭头函数的会怎么样\n\n箭头函数是es6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能new一个箭头函数。\n\nnew操作符的实现步骤如下：\n\n 1. 创建一个对象\n 2. 将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）\n 3. 指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）\n 4. 返回新的对象\n\n所以，上面的第二、三步，箭头函数都是没有办法执行的。\n\n\n# 4. 箭头函数与普通函数的区别\n\n（1）箭头函数比普通函数更加简洁\n\n * 如果没有参数，就直接写一个空括号即可\n * 如果只有一个参数，可以省去参数的括号\n * 如果有多个参数，用逗号分割\n * 如果函数体的返回值只有一句，可以省略大括号\n * 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：\n\nlet fn = () => void doesnotreturn();\n\n\n（2）箭头函数没有自己的this\n\n箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。\n\n（3）箭头函数继承来的this指向永远不会改变\n\nvar id = 'global';\nvar obj = {\n  id: 'obj',\n  a: function(){\n    console.log(this.id);\n  },\n  b: () => {\n    console.log(this.id);\n  }\n};\nobj.a();    // 'obj'\nobj.b();    // 'global'\nnew obj.a()  // undefined\nnew obj.b()  // uncaught typeerror: obj.b is not a constructor\n\n\n对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向window对象。需要注意，定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。\n\n（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向\n\nvar id = 'global';\nlet fun1 = () => {\n    console.log(this.id)\n};\nfun1();                     // 'global'\nfun1.call({id: 'obj'});     // 'global'\nfun1.apply({id: 'obj'});    // 'global'\nfun1.bind({id: 'obj'})();   // 'global'\n\n\n（5）箭头函数不能作为构造函数使用\n\n构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。\n\n（6）箭头函数没有自己的arguments\n\n箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。\n\n（7）箭头函数没有prototype\n\n（8）箭头函数不能用作generator函数，不能使用yeild关键字\n\n\n# 5. 箭头函数的this指向哪⾥？\n\n箭头函数不同于传统javascript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。\n\n可以⽤babel理解⼀下箭头函数:\n\n// es6 \nconst obj = { \n  getarrow() { \n    return () => { \n      console.log(this === obj); \n    }; \n  } \n}\n\n\n转化后：\n\n// es5，由 babel 转译\nvar obj = { \n   getarrow: function getarrow() { \n     var _this = this; \n     return function () { \n        console.log(_this === obj); \n     }; \n   } \n};\n\n\n\n# 6. 扩展运算符的作用及使用场景\n\n（1）对象扩展运算符\n\n对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。\n\nlet bar = { a: 1, b: 2 };\nlet baz = { ...bar }; // { a: 1, b: 2 }\n\n\n上述方法实际上等价于:\n\nlet bar = { a: 1, b: 2 };\nlet baz = object.assign({}, bar); // { a: 1, b: 2 }\n\n\nobject.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。object.assign方法的第一个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。\n\n同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。\n\nlet bar = {a: 1, b: 2};\nlet baz = {...bar, ...{a:2, b: 4}};  // {a: 2, b: 4}\n\n\n利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数，reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。\n\n需要注意：扩展运算符对对象实例的拷贝属于浅拷贝。\n\n（2）数组扩展运算符\n\n数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。\n\nconsole.log(...[1, 2, 3])\n// 1 2 3\nconsole.log(...[1, [2, 3, 4], 5])\n// 1 [2, 3, 4] 5\n\n\n下面是数组的扩展运算符的应用：\n\n * 将数组转换为参数序列\n\nfunction add(x, y) {\n  return x + y;\n}\nconst numbers = [1, 2];\nadd(...numbers) // 3\n\n\n * 复制数组\n\nconst arr1 = [1, 2];\nconst arr2 = [...arr1];\n\n\n要记住：扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。\n\n * 合并数组\n\n如果想在数组内合并数组，可以这样：\n\nconst arr1 = ['two', 'three'];const arr2 = ['one', ...arr1, 'four', 'five'];// [\"one\", \"two\", \"three\", \"four\", \"five\"]\n\n\n * 扩展运算符与解构赋值结合起来，用于生成数组\n\nconst [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest  // [2, 3, 4, 5]\n\n\n需要注意：如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。\n\nconst [...rest, last] = [1, 2, 3, 4, 5];         // 报错const [first, ...rest, last] = [1, 2, 3, 4, 5];  // 报错\n\n\n * 将字符串转为真正的数组\n\n[...'hello']    // [ \"h\", \"e\", \"l\", \"l\", \"o\" ]\n\n\n * 任何 iterator 接口的对象，都可以用扩展运算符转为真正的数组\n\n比较常见的应用是可以将某些数据结构转为数组：\n\n// arguments对象\nfunction foo() {\n  const args = [...arguments];\n}\n\n\n用于替换es5中的array.prototype.slice.call(arguments)写法。\n\n * 使用math函数获取数组中特定的值\n\nconst numbers = [9, 4, 7, 1];\nmath.min(...numbers); // 1\nmath.max(...numbers); // 9\n\n\n\n# 7. es6中模板语法与字符串处理\n\nes6 提出了“模板语法”的概念。在 es6 以前，拼接字符串是很麻烦的事情：\n\nvar name = 'css'   \nvar career = 'coder' \nvar hobby = ['coding', 'writing']\nvar finalstring = 'my name is ' + name + ', i work as a ' + career + ', i love ' + hobby[0] + ' and ' + hobby[1]\n\n\n仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：\n\nvar name = 'css'   \nvar career = 'coder' \nvar hobby = ['coding', 'writing']\nvar finalstring = `my name is ${name}, i work as a ${career} i love ${hobby[0]} and ${hobby[1]}`\n\n\n字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：\n\n * 在模板字符串中，空格、缩进、换行都会被保留\n * 模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算\n\n基于第一点，可以在模板字符串里无障碍地直接写 html 代码：\n\nlet list = `\n\t<ul>\n\t\t<li>列表项1</li>\n\t\t<li>列表项2</li>\n\t</ul>\n`;\nconsole.log(message); // 正确输出，不存在报错\n\n\n基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：\n\nfunction add(a, b) {\n  const finalstring = `${a} + ${b} = ${a+b}`\n  console.log(finalstring)\n}\nadd(1, 2) // 输出 '1 + 2 = 3'\n\n\n除了模板语法外， es6中还新增了一系列的字符串方法用于提升开发效率：\n\n（1）存在性判定：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexof > -1 来做。现在 es6 提供了三个方法：includes、startswith、endswith，它们都会返回一个布尔值来告诉你是否存在。\n\n * includes：判断字符串与子串的包含关系：\n\nconst son = 'haha' \nconst father = 'xixi haha hehe'\nfather.includes(son) // true\n\n\n * startswith：判断字符串是否以某个/某串字符开头：\n\nconst father = 'xixi haha hehe'\nfather.startswith('haha') // false\nfather.startswith('xixi') // true\n\n\n * endswith：判断字符串是否以某个/某串字符结尾：\n\nconst father = 'xixi haha hehe'\n  father.endswith('hehe') // true\n\n\n（2）自动重复：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：\n\nconst sourcecode = 'repeat for 3 times;'\nconst repeated = sourcecode.repeat(3) \nconsole.log(repeated) // repeat for 3 times;repeat for 3 times;repeat for 3 times;\n\n\n\n# 8. 对对象与数组的解构的理解\n\n解构是 es6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。 1）数组的解构 在解构数组时，以元素的位置为匹配条件来提取想要的数据的：\n\nconst [a, b, c] = [1, 2, 3]\n\n\n2）对象的解构 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：\n\nconst stu = {\n  name: 'bob',\n  age: 24\n}\n\n\n假如想要解构它的两个自有属性，可以这样：\n\nconst { name, age } = stu\n\n\n\n# 9. 如何提取高度嵌套的对象里的指定属性？\n\n有时会遇到一些嵌套程度非常深的对象：\n\nconst school = {\n   classes: {\n      stu: {\n         name: 'bob',\n         age: 24,\n      }\n   }\n}\n\n\n像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：\n\nconst { name } = school\n\n\n显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：\n\nconst { classes } = school\nconst { stu } = classes\nconst { name } = stu\nname // 'bob'\n\n\n但是还有一种更标准的做法，可以用一行代码来解决这个问题：\n\nconst { classes: { stu: { name } }} = school\n       \nconsole.log(name)  // 'bob'\n\n\n可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。\n\n\n# 10. 对 rest 参数的理解\n\n扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：\n\nfunction mutiple(...args) {\n  let result = 1;\n  for (var val of args) {\n    result *= val;\n  }\n  return result;\n}\nmutiple(1, 2, 3, 4) // 24\n\n\n这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：\n\nfunction mutiple(...args) {\n  console.log(args)\n}\nmutiple(1, 2, 3, 4) // [1, 2, 3, 4]\n\n\n这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。\n\n\n# 11. 说一下es6的导入导出模块\n\n> 导入通过import关键字\n\n// 只导入一个\nimport {sum} from \"./example.js\"\n// 导入多个\nimport {sum,multiply,time} from \"./exportexample.js\"\n// 导入一整个模块\nimport * as example from \"./exportexample.js\"\n复制代码\n\n\n> 导出通过export关键字\n\n//可以将export放在任何变量,函数或类声明的前面\nexport var firstname = 'michael';\nexport var lastname = 'jackson';\nexport var year = 1958;\n//也可以使用大括号指定所要输出的一组变量\nvar firstname = 'michael';\nvar lastname = 'jackson';\nvar year = 1958;\nexport {firstname, lastname, year};\n//使用export default时，对应的import语句不需要使用大括号\nlet bosh = function crs(){}\nexport default bosh;\nimport crc from 'crc';\n//不使用export default时，对应的import语句需要使用大括号\nlet bosh = function crs(){}\nexport bosh;\nimport {crc} from 'crc';\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "JavaScript基础",
      "frontmatter": {
        "title": "JavaScript基础",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/JavaScript/",
        "article": false
      },
      "regularPath": "/20.%E9%AB%98%E9%A2%91%E7%AF%87/10.JavaScript%E7%AF%87/30.JavaScript%E5%9F%BA%E7%A1%80.html",
      "relativePath": "20.高频篇/10.JavaScript篇/30.JavaScript基础.md",
      "key": "v-ab685476",
      "path": "/pages/JavaScript/",
      "headers": [
        {
          "level": 3,
          "title": "1. new操作符的实现原理",
          "slug": "_1-new操作符的实现原理",
          "normalizedTitle": "1. new操作符的实现原理",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. map和Object的区别",
          "slug": "_2-map和object的区别",
          "normalizedTitle": "2. map和object的区别",
          "charIndex": 782
        },
        {
          "level": 3,
          "title": "3. map和weakMap的区别",
          "slug": "_3-map和weakmap的区别",
          "normalizedTitle": "3. map和weakmap的区别",
          "charIndex": 1346
        },
        {
          "level": 3,
          "title": "4. JavaScript有哪些内置对象",
          "slug": "_4-javascript有哪些内置对象",
          "normalizedTitle": "4. javascript有哪些内置对象",
          "charIndex": 3185
        },
        {
          "level": 3,
          "title": "5. 常用的正则表达式有哪些？",
          "slug": "_5-常用的正则表达式有哪些",
          "normalizedTitle": "5. 常用的正则表达式有哪些？",
          "charIndex": 4256
        },
        {
          "level": 3,
          "title": "6. 对JSON的理解",
          "slug": "_6-对json的理解",
          "normalizedTitle": "6. 对json的理解",
          "charIndex": 4597
        },
        {
          "level": 3,
          "title": "7. JavaScript脚本延迟加载的方式有哪些？",
          "slug": "_7-javascript脚本延迟加载的方式有哪些",
          "normalizedTitle": "7. javascript脚本延迟加载的方式有哪些？",
          "charIndex": 5282
        },
        {
          "level": 3,
          "title": "8. JavaScript 类数组对象的定义？",
          "slug": "_8-javascript-类数组对象的定义",
          "normalizedTitle": "8. javascript 类数组对象的定义？",
          "charIndex": 5837
        },
        {
          "level": 3,
          "title": "9. 数组有哪些原生方法？",
          "slug": "_9-数组有哪些原生方法",
          "normalizedTitle": "9. 数组有哪些原生方法？",
          "charIndex": 6312
        },
        {
          "level": 3,
          "title": "10. Unicode、UTF-8、UTF-16、UTF-32的区别？",
          "slug": "_10-unicode、utf-8、utf-16、utf-32的区别",
          "normalizedTitle": "10. unicode、utf-8、utf-16、utf-32的区别？",
          "charIndex": 6795
        },
        {
          "level": 3,
          "title": "11. 常见的位运算符有哪些？其计算规则是什么？",
          "slug": "_11-常见的位运算符有哪些-其计算规则是什么",
          "normalizedTitle": "11. 常见的位运算符有哪些？其计算规则是什么？",
          "charIndex": 10005
        },
        {
          "level": 3,
          "title": "12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?",
          "slug": "_12-为什么函数的-arguments-参数是类数组而不是数组-如何遍历类数组",
          "normalizedTitle": "12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?",
          "charIndex": 12240
        },
        {
          "level": 3,
          "title": "13. 什么是 DOM 和 BOM？",
          "slug": "_13-什么是-dom-和-bom",
          "normalizedTitle": "13. 什么是 dom 和 bom？",
          "charIndex": 12782
        },
        {
          "level": 3,
          "title": "14. 对类数组对象的理解，如何转化为数组",
          "slug": "_14-对类数组对象的理解-如何转化为数组",
          "normalizedTitle": "14. 对类数组对象的理解，如何转化为数组",
          "charIndex": 13134
        },
        {
          "level": 3,
          "title": "15. escape、encodeURI、encodeURIComponent 的区别",
          "slug": "_15-escape、encodeuri、encodeuricomponent-的区别",
          "normalizedTitle": "15. escape、encodeuri、encodeuricomponent 的区别",
          "charIndex": 13604
        },
        {
          "level": 3,
          "title": "16. 对AJAX的理解，实现一个AJAX请求",
          "slug": "_16-对ajax的理解-实现一个ajax请求",
          "normalizedTitle": "16. 对ajax的理解，实现一个ajax请求",
          "charIndex": 13925
        },
        {
          "level": 3,
          "title": "17. JavaScript为什么要进行变量提升，它导致了什么问题？",
          "slug": "_17-javascript为什么要进行变量提升-它导致了什么问题",
          "normalizedTitle": "17. javascript为什么要进行变量提升，它导致了什么问题？",
          "charIndex": 15817
        },
        {
          "level": 3,
          "title": "18. 什么是尾调用，使用尾调用有什么好处？",
          "slug": "_18-什么是尾调用-使用尾调用有什么好处",
          "normalizedTitle": "18. 什么是尾调用，使用尾调用有什么好处？",
          "charIndex": 17451
        },
        {
          "level": 3,
          "title": "19.  ES6模块与CommonJS模块有什么异同？",
          "slug": "_19-es6模块与commonjs模块有什么异同",
          "normalizedTitle": "19.  es6模块与commonjs模块有什么异同？",
          "charIndex": null
        },
        {
          "level": 3,
          "title": "20. 常见的DOM操作有哪些",
          "slug": "_20-常见的dom操作有哪些",
          "normalizedTitle": "20. 常见的dom操作有哪些",
          "charIndex": 17987
        },
        {
          "level": 3,
          "title": "21. use strict是什么意思 ? 使用它区别是什么？",
          "slug": "_21-use-strict是什么意思-使用它区别是什么",
          "normalizedTitle": "21. use strict是什么意思 ? 使用它区别是什么？",
          "charIndex": 20184
        },
        {
          "level": 3,
          "title": "22. 如何判断一个对象是否属于某个类？",
          "slug": "_22-如何判断一个对象是否属于某个类",
          "normalizedTitle": "22. 如何判断一个对象是否属于某个类？",
          "charIndex": 20477
        },
        {
          "level": 3,
          "title": "23. 强类型语言和弱类型语言的区别",
          "slug": "_23-强类型语言和弱类型语言的区别",
          "normalizedTitle": "23. 强类型语言和弱类型语言的区别",
          "charIndex": 20756
        },
        {
          "level": 3,
          "title": "24. 解释性语言和编译型语言的区别",
          "slug": "_24-解释性语言和编译型语言的区别",
          "normalizedTitle": "24. 解释性语言和编译型语言的区别",
          "charIndex": 21161
        },
        {
          "level": 3,
          "title": "25. for...in和for...of的区别",
          "slug": "_25-for-in和for-of的区别",
          "normalizedTitle": "25. for...in和for...of的区别",
          "charIndex": 21774
        },
        {
          "level": 3,
          "title": "26. 如何使用for...of遍历对象",
          "slug": "_26-如何使用for-of遍历对象",
          "normalizedTitle": "26. 如何使用for...of遍历对象",
          "charIndex": 22145
        },
        {
          "level": 3,
          "title": "27. ajax、axios、fetch的区别",
          "slug": "_27-ajax、axios、fetch的区别",
          "normalizedTitle": "27. ajax、axios、fetch的区别",
          "charIndex": 23018
        },
        {
          "level": 3,
          "title": "28. 数组的遍历方法有哪些",
          "slug": "_28-数组的遍历方法有哪些",
          "normalizedTitle": "28. 数组的遍历方法有哪些",
          "charIndex": 24121
        },
        {
          "level": 3,
          "title": "29. forEach和map方法有什么区别",
          "slug": "_29-foreach和map方法有什么区别",
          "normalizedTitle": "29. foreach和map方法有什么区别",
          "charIndex": 24740
        }
      ],
      "headersStr": "1. new操作符的实现原理 2. map和Object的区别 3. map和weakMap的区别 4. JavaScript有哪些内置对象 5. 常用的正则表达式有哪些？ 6. 对JSON的理解 7. JavaScript脚本延迟加载的方式有哪些？ 8. JavaScript 类数组对象的定义？ 9. 数组有哪些原生方法？ 10. Unicode、UTF-8、UTF-16、UTF-32的区别？ 11. 常见的位运算符有哪些？其计算规则是什么？ 12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组? 13. 什么是 DOM 和 BOM？ 14. 对类数组对象的理解，如何转化为数组 15. escape、encodeURI、encodeURIComponent 的区别 16. 对AJAX的理解，实现一个AJAX请求 17. JavaScript为什么要进行变量提升，它导致了什么问题？ 18. 什么是尾调用，使用尾调用有什么好处？ 19.  ES6模块与CommonJS模块有什么异同？ 20. 常见的DOM操作有哪些 21. use strict是什么意思 ? 使用它区别是什么？ 22. 如何判断一个对象是否属于某个类？ 23. 强类型语言和弱类型语言的区别 24. 解释性语言和编译型语言的区别 25. for...in和for...of的区别 26. 如何使用for...of遍历对象 27. ajax、axios、fetch的区别 28. 数组的遍历方法有哪些 29. forEach和map方法有什么区别",
      "content": "# 1. new操作符的实现原理\n\nnew操作符的执行过程：\n\n（1）首先创建了一个新的空对象\n\n（2）设置原型，将对象的原型设置为函数的 prototype 对象。\n\n（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\n\n（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。\n\n具体实现：\n\nfunction objectFactory() {\n  let newObject = null;\n  let constructor = Array.prototype.shift.call(arguments);\n  let result = null;\n  // 判断参数是否是一个函数\n  if (typeof constructor !== \"function\") {\n    console.error(\"type error\");\n    return;\n  }\n  // 新建一个空对象，对象的原型为构造函数的 prototype 对象\n  newObject = Object.create(constructor.prototype);\n  // 将 this 指向新建对象，并执行函数\n  result = constructor.apply(newObject, arguments);\n  // 判断返回对象\n  let flag = result && (typeof result === \"object\" || typeof result === \"function\");\n  // 判断返回结果\n  return flag ? result : newObject;\n}\n// 使用方法\nobjectFactory(构造函数, 初始化参数);\n\n\n\n# 2. map和Object的区别\n\n       MAP                                            OBJECT\n意外的键   Map默认情况不包含任何键，只包含显式插入的键。                       Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。\n键的类型   Map的键可以是任意值，包括函数、对象或任意基本类型。                    Object 的键必须是 String 或是Symbol。\n键的顺序   Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。   Object 的键是无序的\nSize   Map 的键值对个数可以轻易地通过size 属性获取                     Object 的键值对个数只能手动计算\n迭代     Map 是 iterable 的，所以可以直接被迭代。                    迭代Object需要以某种方式获取它的键然后才能迭代。\n性能     在频繁增删键值对的场景下表现更好。                              在频繁添加和删除键值对的场景下未作出优化。\n\n\n# 3. map和weakMap的区别\n\n（1）Map map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。\n\n实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：\n\nconst map = [\n     [\"name\",\"张三\"],\n     [\"age\",18],\n]\n\n\nMap数据结构有以下操作方法：\n\n * size： map.size 返回Map结构的成员总数。\n * set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）\n * get(key)：该方法读取key对应的键值，如果找不到key，返回undefined。\n * has(key)：该方法返回一个布尔值，表示某个键是否在当前Map对象中。\n * delete(key)：该方法删除某个键，返回true，如果删除失败，返回false。\n * clear()：map.clear()清除所有成员，没有返回值。\n\nMap结构原生提供是三个遍历器生成函数和一个遍历方法\n\n * keys()：返回键名的遍历器。\n * values()：返回键值的遍历器。\n * entries()：返回所有成员的遍历器。\n * forEach()：遍历Map的所有成员。\n\nconst map = new Map([\n     [\"foo\",1],\n     [\"bar\",2],\n])\nfor(let key of map.keys()){\n    console.log(key);  // foo bar\n}\nfor(let value of map.values()){\n     console.log(value); // 1 2\n}\nfor(let items of map.entries()){\n    console.log(items);  // [\"foo\",1]  [\"bar\",2]\n}\nmap.forEach( (value,key,map) => {\n     console.log(key,value); // foo 1    bar 2\n})\n\n\n（2）WeakMap WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。其键必须是对象，原始数据类型不能作为key值，而值可以是任意的。\n\n该对象也有以下几种方法：\n\n * set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）\n * get(key)：该方法读取key对应的键值，如果找不到key，返回undefined。\n * has(key)：该方法返回一个布尔值，表示某个键是否在当前Map对象中。\n * delete(key)：该方法删除某个键，返回true，如果删除失败，返回false。\n\n其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。\n\nWeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。\n\n而WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。\n\n总结：\n\n * Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。\n * WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。\n\n\n# 4. JavaScript有哪些内置对象\n\n全局的对象（ global objects ）或称标准内置对象，不要和 \"全局对象（global object）\" 混淆。这里说的全局的对象是说在 全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。\n\n标准内置对象的分类：\n\n（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量\n\n（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等\n\n（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等\n\n（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date\n\n（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp\n\n（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array\n\n（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。 例如 Map、Set、WeakMap、WeakSet\n\n（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。 例如 SIMD 等\n\n（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等\n\n（10）控制抽象对象 例如 Promise、Generator 等\n\n（11）反射。例如 Reflect、Proxy\n\n（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等\n\n（13）WebAssembly\n\n（14）其他。例如 arguments\n\n总结： js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。\n\n\n# 5. 常用的正则表达式有哪些？\n\n// （1）匹配 16 进制颜色值\nvar regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;\n\n// （2）匹配日期，如 yyyy-mm-dd 格式\nvar regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;\n\n// （3）匹配 qq 号\nvar regex = /^[1-9][0-9]{4,10}$/g;\n\n// （4）手机号码正则\nvar regex = /^1[34578]\\d{9}$/g;\n\n// （5）用户名正则\nvar regex = /^[a-zA-Z\\$][a-zA-Z0-9_\\$]{4,16}$/;\n\n\n\n# 6. 对JSON的理解\n\nJSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。\n\n在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。\n\n因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。\n\n在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，\n\n * JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。\n * JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。\n\n\n# 7. JavaScript脚本延迟加载的方式有哪些？\n\n延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。\n\n一般有以下几种方式：\n\n * defer 属性： 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。\n * async 属性： 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。\n * 动态创建 DOM 方式： 动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。\n * 使用 setTimeout 延迟方法： 设置一个定时器来延迟加载js脚本文件\n * 让 JS 最后加载： 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。\n\n\n# 8. JavaScript 类数组对象的定义？\n\n一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。\n\n常见的类数组转换为数组的方法有这样几种：\n\n（1）通过 call 调用数组的 slice 方法来实现转换\n\nArray.prototype.slice.call(arrayLike);\n\n\n（2）通过 call 调用数组的 splice 方法来实现转换\n\nArray.prototype.splice.call(arrayLike, 0);\n\n\n（3）通过 apply 调用数组的 concat 方法来实现转换\n\nArray.prototype.concat.apply([], arrayLike);\n\n\n（4）通过 Array.from 方法来实现转换\n\nArray.from(arrayLike);\n\n\n\n# 9. 数组有哪些原生方法？\n\n * 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。\n * 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。\n * 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。\n * 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。\n * 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。\n * 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法\n * 数组归并方法 reduce() 和 reduceRight() 方法\n\n\n# 10. Unicode、UTF-8、UTF-16、UTF-32的区别？\n\n# （1）Unicode\n\n在说Unicode之前需要先了解一下ASCII码：ASCII 码（American Standard Code for Information Interchange）称为美国标准信息交换码。\n\n * 它是基于拉丁字母的一套电脑编码系统。\n * 它定义了一个用于代表常见字符的字典。\n * 它包含了\"A-Z\"(包含大小写)，数据\"0-9\" 以及一些常见的符号。\n * 它是专门为英语而设计的，有128个编码，对其他语言无能为力\n\nASCII码可以表示的编码有限，要想表示其他语言的编码，还是要使用Unicode来表示，可以说Unicode是ASCII 的超集。\n\nUnicode全称 Unicode Translation Format，又叫做统一码、万国码、单一码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。\n\nUnicode的实现方式（也就是编码方式）有很多种，常见的是UTF-8、UTF-16、UTF-32和USC-2。\n\n# （2）UTF-8\n\nUTF-8是使用最广泛的Unicode编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容ASCII码的128个字符。\n\n注意： UTF-8 是一种编码方式，Unicode是一个字符集合。\n\nUTF-8的编码规则：\n\n * 对于单字节的符号，字节的第一位为0，后面的7位为这个字符的Unicode编码，因此对于英文字母，它的Unicode编码和ACSII编码一样。\n * 对于n字节的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的Unicode码 。\n\n来看一下具体的Unicode编号范围与对应的UTF-8二进制格式 ：\n\n编码范围（编号对应的十进制数）              二进制格式\n0x00—0x7F （0-127）            0xxxxxxx\n0x80—0x7FF （128-2047）        110xxxxx 10xxxxxx\n0x800—0xFFFF （2048-65535）    1110xxxx 10xxxxxx 10xxxxxx\n0x10000—0x10FFFF （65536以上）   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n那该如何通过具体的Unicode编码，进行具体的UTF-8编码呢？步骤如下：\n\n * 找到该Unicode编码的所在的编号范围，进而找到与之对应的二进制格式\n * 将Unicode编码转换为二进制数（去掉最高位的0）\n * 将二进制数从右往左一次填入二进制格式的X中，如果有X未填，就设为0\n\n来看一个实际的例子： “马” 字的Unicode编码是：0x9A6C，整数编号是39532 （1）首选确定了该字符在第三个范围内，它的格式是 1110xxxx 10xxxxxx 10xxxxxx （2）39532对应的二进制数为1001 1010 0110 1100 （3）将二进制数填入X中，结果是：11101001 10101001 10101100\n\n# （3）UTF-16\n\n1. 平面的概念\n\n在了解UTF-16之前，先看一下平面的概念： Unicode编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放65536（216）个字符，这称为一个平面，目前总共有17 个平面。\n\n最前面的一个平面称为基本平面，它的码点从0 — 216-1，写成16进制就是U+0000 — U+FFFF，那剩下的16个平面就是辅助平面，码点范围是 U+10000—U+10FFFF。\n\n2. UTF-16 概念：\n\nUTF-16也是Unicode编码集的一种编码形式，把Unicode字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。Unicode字符的码位需要1个或者2个16位长的码元来表示，因此UTF-16也是用变长字节表示的。\n\n3. UTF-16 编码规则：\n\n * 编号在 U+0000—U+FFFF 的字符（常用字符集），直接用两个字节表示。\n * 编号在 U+10000—U+10FFFF 之间的字符，需要用四个字节表示。\n\n4. 编码识别\n\n那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？\n\nUTF-16 编码肯定也考虑到了这个问题，在基本平面内，从 U+D800 — U+DFFF 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。\n\n辅助平面共有 220 个字符位，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 — U+DBFF，称为高位（H），后 10 位映射在 U+DC00 — U+DFFF，称为低位（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。\n\n因此，当遇到两个字节时，发现它的码点在 U+D800 —U+DBFF之间，就可以知道，它后面的两个字节的码点应该在 U+DC00 — U+DFFF 之间，这四个字节必须放在一起进行解读。\n\n5. 举例说明\n\n以 \"𡠀\" 字为例，它的 Unicode 码点为 0x21800，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：\n\n * 首先计算超出部分的结果：0x21800 - 0x10000\n * 将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：0001000110 0000000000\n * 将得到的两个10位二进制数分别对应到两个区间中\n * U+D800 对应的二进制数为 1101100000000000， 将0001000110填充在它的后10 个二进制位，得到 1101100001000110，转成 16 进制数为 0xD846。同理，低位为 0xDC00，所以这个字的UTF-16 编码为 0xD846 0xDC00\n\n# （4） UTF-32\n\nUTF-32 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。\n\n比如“马” 字的Unicode编号是：U+9A6C，整数编号是39532，直接转化为二进制：1001 1010 0110 1100，这就是它的UTF-32编码。\n\n# （5）总结\n\nUnicode、UTF-8、UTF-16、UTF-32有什么区别？\n\n * Unicode 是编码字符集（字符集），而UTF-8、UTF-16、UTF-32是字符集编码（编码规则）；\n * UTF-16 使用变长码元序列的编码方式，相较于定长码元序列的UTF-32算法更复杂，甚至比同样是变长码元序列的UTF-8也更为复杂，因为其引入了独特的代理对这样的代理机制；\n * UTF-8需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而UTF-16不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；\n * 如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用UTF-8就比UTF-16节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么UTF-16就占优势了，可以节省很多空间\n\n\n# 11. 常见的位运算符有哪些？其计算规则是什么？\n\n现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。\n\n常见的位运算有以下几种：\n\n运算符   描述   运算规则                            \n&     与    两个位都为1时，结果才为1                   \n|     或    两个位都为0时，结果才为0                   \n^     异或   两个位相同为0，相异为1                    \n~     取反   0变1，1变0                         \n<<    左移   各二进制位全部左移若干位，高位丢弃，低位补0          \n>>    右移   各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃   \n\n# 1. 按位与运算符（&）\n\n定义： 参加运算的两个数据按二进制位进行“与”运算。 运算规则：\n\n0 & 0 = 0  \n0 & 1 = 0  \n1 & 0 = 0  \n1 & 1 = 1\n\n\n总结：两位同时为1，结果才为1，否则结果为0。 例如：3&5 即：\n\n0000 0011 \n   0000 0101 \n = 0000 0001\n\n\n因此 3&5 的值为1。 注意：负数按补码形式参加按位与运算。\n\n用途：\n\n（1）判断奇偶\n\n只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((i & 1) == 0)代替if (i % 2 == 0)来判断a是不是偶数。\n\n（2）清零\n\n如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。\n\n# 2. 按位或运算符（|）\n\n定义： 参加运算的两个对象按二进制位进行“或”运算。\n\n运算规则：\n\n0 | 0 = 0\n0 | 1 = 1  \n1 | 0 = 1  \n1 | 1 = 1\n\n\n总结：参加运算的两个对象只要有一个为1，其值为1。 例如：3|5即：\n\n0000 0011\n  0000 0101 \n= 0000 0111\n\n\n因此，3|5的值为7。 注意：负数按补码形式参加按位或运算。\n\n# 3. 异或运算符（^）\n\n定义： 参加运算的两个数据按二进制位进行“异或”运算。\n\n运算规则：\n\n0 ^ 0 = 0  \n0 ^ 1 = 1  \n1 ^ 0 = 1  \n1 ^ 1 = 0\n\n\n总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。 例如：3|5即：\n\n0000 0011\n  0000 0101 \n= 0000 0110\n\n\n因此，3^5的值为6。 异或运算的性质:\n\n * 交换律：(a^b)^c == a^(b^c)\n * 结合律：(a + b)^c == a^b + b^c\n * 对于任何数x，都有 x^x=0，x^0=x\n * 自反性: a^b^b=a^0=a;\n\n# 4. 取反运算符 (~)\n\n定义： 参加运算的一个数据按二进制进行“取反”运算。\n\n运算规则：\n\n~ 1 = 0~ 0 = 1\n\n\n总结：对一个二进制数按位取反，即将0变1，1变0。 例如：~6 即：\n\n0000 0110= 1111 1001\n\n\n在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。 当发现按位取反为负数时，就直接取其补码，变为十进制：\n\n0000 0110   = 1111 1001反码：1000 0110补码：1000 0111\n\n\n因此，~6的值为-7。\n\n# 5. 左移运算符（<<）\n\n定义： 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。 设 a=1010 1110，a = a<< 2 将a的二进制位左移2位、右补0，即得a=1011 1000。 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。\n\n# 6. 右移运算符（>>）\n\n定义： 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 例如：a=a>>2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。 操作数每右移一位，相当于该数除以2。\n\n# 7. 原码、补码、反码\n\n上面提到了补码、反码等知识，这里就补充一下。 计算机中的有符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。\n\n（1）原码\n\n原码就是一个数的二进制数。例如：10的原码为0000 1010\n\n（2）反码\n\n * 正数的反码与原码相同，如：10 反码为 0000 1010\n * 负数的反码为除符号位，按位取反，即0变1，1变0。\n\n例如：-10\n\n原码：1000 1010\n反码：1111 0101\n\n\n（3）补码\n\n * 正数的补码与原码相同，如：10 补码为 0000 1010\n * 负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。\n\n例如：-10\n\n原码：1000 1010\n反码：1111 0101\n补码：1111 0110\n\n\n\n# 12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?\n\narguments是一个对象，它的属性是从 0 开始依次递增的数字，还有callee和length等属性，与数组相似；但是它却没有数组常见的方法属性，如forEach, reduce等，所以叫它们类数组。\n\n要遍历类数组，有三个方法：\n\n（1）将数组的方法应用到类数组上，这时候就可以使用call和apply方法，如：\n\nfunction foo(){ \n  Array.prototype.forEach.call(arguments, a => console.log(a))\n}\n\n\n（2）使用Array.from方法将类数组转化成数组：‌\n\nfunction foo(){ \n  const arrArgs = Array.from(arguments) \n  arrArgs.forEach(a => console.log(a))\n}\n\n\n（3）使用展开运算符将类数组转化成数组\n\nfunction foo(){ \n    const arrArgs = [...arguments] \n    arrArgs.forEach(a => console.log(a)) \n}\n\n\n\n# 13. 什么是 DOM 和 BOM？\n\n * DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。\n * BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。\n\n\n# 14. 对类数组对象的理解，如何转化为数组\n\n一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。\n\n常见的类数组转换为数组的方法有这样几种：\n\n * 通过 call 调用数组的 slice 方法来实现转换\n\nArray.prototype.slice.call(arrayLike);\n\n\n * 通过 call 调用数组的 splice 方法来实现转换\n\nArray.prototype.splice.call(arrayLike, 0);\n\n\n * 通过 apply 调用数组的 concat 方法来实现转换\n\nArray.prototype.concat.apply([], arrayLike);\n\n\n * 通过 Array.from 方法来实现转换\n\nArray.from(arrayLike);\n\n\n\n# 15. escape、encodeURI、encodeURIComponent 的区别\n\n * encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。\n * encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。\n * escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。\n\n\n# 16. 对AJAX的理解，实现一个AJAX请求\n\nAJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。\n\n创建AJAX请求的步骤：\n\n * 创建一个 XMLHttpRequest 对象。\n * 在这个对象上使用 open 方法创建一个 HTTP 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。\n * 在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。\n * 当对象的属性和监听函数设置完成后，最后调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。\n\nconst SERVER_URL = \"/server\";\nlet xhr = new XMLHttpRequest();\n// 创建 Http 请求\nxhr.open(\"GET\", url, true);\n// 设置状态监听函数\nxhr.onreadystatechange = function() {\n  if (this.readyState !== 4) return;\n  // 当请求成功时\n  if (this.status === 200) {\n    handle(this.response);\n  } else {\n    console.error(this.statusText);\n  }\n};\n// 设置请求失败时的监听函数\nxhr.onerror = function() {\n  console.error(this.statusText);\n};\n// 设置请求头信息\nxhr.responseType = \"json\";\nxhr.setRequestHeader(\"Accept\", \"application/json\");\n// 发送 Http 请求\nxhr.send(null);\n\n\n使用Promise封装AJAX：\n\n// promise 封装实现：\nfunction getJSON(url) {\n  // 创建一个 promise 对象\n  let promise = new Promise(function(resolve, reject) {\n    let xhr = new XMLHttpRequest();\n    // 新建一个 http 请求\n    xhr.open(\"GET\", url, true);\n    // 设置状态的监听函数\n    xhr.onreadystatechange = function() {\n      if (this.readyState !== 4) return;\n      // 当请求成功或失败时，改变 promise 的状态\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    // 设置错误监听函数\n    xhr.onerror = function() {\n      reject(new Error(this.statusText));\n    };\n    // 设置响应的数据类型\n    xhr.responseType = \"json\";\n    // 设置请求头信息\n    xhr.setRequestHeader(\"Accept\", \"application/json\");\n    // 发送 http 请求\n    xhr.send(null);\n  });\n  return promise;\n}\n\n\n\n# 17. JavaScript为什么要进行变量提升，它导致了什么问题？\n\n变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。\n\n造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。\n\n首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。\n\n * 在解析阶段\n   \n   ，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。\n   \n   * 全局上下文：变量定义，函数声明\n   * 函数上下文：变量定义，函数声明，this，arguments\n\n * 在执行阶段，就是按照代码的顺序依次执行。\n\n那为什么会进行变量提升呢？主要有以下两个原因：\n\n * 提高性能\n * 容错性更好\n\n（1）提高性能 在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。\n\n在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。\n\n（2）容错性更好\n\n变量提升可以在一定程度上提高JS的容错性，看下面的代码：\n\na = 1;var a;console.log(a);\n\n\n如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。\n\n虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。\n\n总结：\n\n * 解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间\n * 声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行\n\n变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：\n\nvar tmp = new Date();\n\nfunction fn(){\n\tconsole.log(tmp);\n\tif(false){\n\t\tvar tmp = 'hello world';\n\t}\n}\n\nfn();  // undefined\n\n\n在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。\n\nvar tmp = 'hello world';\n\nfor (var i = 0; i < tmp.length; i++) {\n\tconsole.log(tmp[i]);\n}\n\nconsole.log(i); // 11\n\n\n由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。\n\n\n# 18. 什么是尾调用，使用尾调用有什么好处？\n\n尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。\n\n\n# 19. ES6模块与CommonJS模块有什么异同？\n\nES6 Module和CommonJS模块的区别：\n\n * CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；\n * import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。\n\nES6 Module和CommonJS模块的共同点：\n\n * CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。\n\n\n# 20. 常见的DOM操作有哪些\n\n# 1）DOM 节点的获取\n\nDOM 节点的获取的API及使用：\n\ngetElementById // 按照 id 查询\ngetElementsByTagName // 按照标签名查询\ngetElementsByClassName // 按照类名查询\nquerySelectorAll // 按照 css 选择器查询\n\n// 按照 id 查询\nvar imooc = document.getElementById('imooc') // 查询到 id 为 imooc 的元素\n// 按照标签名查询\nvar pList = document.getElementsByTagName('p')  // 查询到标签为 p 的集合\nconsole.log(divList.length)\nconsole.log(divList[0])\n// 按照类名查询\nvar moocList = document.getElementsByClassName('mooc') // 查询到类名为 mooc 的集合\n// 按照 css 选择器查询\nvar pList = document.querySelectorAll('.mooc') // 查询到类名为 mooc 的集合\n\n\n# 2）DOM 节点的创建\n\n创建一个新节点，并把它添加到指定节点的后面。 已知的 HTML 结构如下：\n\n<html>\n  <head>\n    <title>DEMO</title>\n  </head>\n  <body>\n    <div id=\"container\"> \n      <h1 id=\"title\">我是标题</h1>\n    </div>   \n  </body>\n</html>\n\n\n要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：\n\n// 首先获取父节点\nvar container = document.getElementById('container')\n// 创建新节点\nvar targetSpan = document.createElement('span')\n// 设置 span 节点的内容\ntargetSpan.innerHTML = 'hello world'\n// 把新创建的元素塞进父节点里去\ncontainer.appendChild(targetSpan)\n\n\n# 3）DOM 节点的删除\n\n删除指定的 DOM 节点， 已知的 HTML 结构如下：\n\n<html>\n  <head>\n    <title>DEMO</title>\n  </head>\n  <body>\n    <div id=\"container\"> \n      <h1 id=\"title\">我是标题</h1>\n    </div>   \n  </body>\n</html>\n\n\n需要删除 id 为 title 的元素，做法是：\n\n// 获取目标元素的父元素\nvar container = document.getElementById('container')\n// 获取目标元素\nvar targetNode = document.getElementById('title')\n// 删除目标元素\ncontainer.removeChild(targetNode)\n\n\n或者通过子节点数组来完成删除：\n\n// 获取目标元素的父元素var container = document.getElementById('container')// 获取目标元素var targetNode = container.childNodes[1]// 删除目标元素container.removeChild(targetNode)\n\n\n# 4）修改 DOM 元素\n\n修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。\n\n将指定的两个 DOM 元素交换位置， 已知的 HTML 结构如下：\n\n<html>\n  <head>\n    <title>DEMO</title>\n  </head>\n  <body>\n    <div id=\"container\"> \n      <h1 id=\"title\">我是标题</h1>\n      <p id=\"content\">我是内容</p>\n    </div>   \n  </body>\n</html>\n\n\n现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：\n\n// 获取父元素\nvar container = document.getElementById('container')   \n \n// 获取两个需要被交换的元素\nvar title = document.getElementById('title')\nvar content = document.getElementById('content')\n// 交换两个元素，把 content 置于 title 前面\ncontainer.insertBefore(content, title)\n\n\n\n# 21. use strict是什么意思 ? 使用它区别是什么？\n\nuse strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：\n\n * 消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;\n * 消除代码运行的不安全之处，保证代码运行的安全；\n * 提高编译器效率，增加运行速度；\n * 为未来新版本的 Javascript 做好铺垫。\n\n区别：\n\n * 禁止使用 with 语句。\n * 禁止 this 关键字指向全局对象。\n * 对象不能有重名的属性。\n\n\n# 22. 如何判断一个对象是否属于某个类？\n\n * 第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\n * 第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。\n * 第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。\n\n\n# 23. 强类型语言和弱类型语言的区别\n\n * 强类型语言：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。\n * 弱类型语言：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串'12'和整数3进行连接得到字符串'123'，在相加的时候会进行强制类型转换。\n\n两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。\n\n\n# 24. 解释性语言和编译型语言的区别\n\n（1）解释型语言 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下\n\n * 解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；\n * 只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；\n * JavaScript、Python等属于解释型语言。\n\n（2）编译型语言 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：\n\n * 一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；\n * 与特定平台相关，一般无法移植到其他平台；\n * C、C++等属于编译型语言。\n\n两者主要区别在于： 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。\n\n\n# 25. for...in和for...of的区别\n\nfor…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下\n\n * for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；\n * for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；\n * 对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；\n\n总结： for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。\n\n\n# 26. 如何使用for...of遍历对象\n\nfor…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。\n\n如果需要遍历的对象是类数组对象，用Array.from转成数组即可。\n\nvar obj = {\n    0:'one',\n    1:'two',\n    length: 2\n};\nobj = Array.from(obj);\nfor(var k of obj){\n    console.log(k)\n}\n\n\n如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。\n\n//方法一：\nvar obj = {\n    a:1,\n    b:2,\n    c:3\n};\n\nobj[Symbol.iterator] = function(){\n\tvar keys = Object.keys(this);\n\tvar count = 0;\n\treturn {\n\t\tnext(){\n\t\t\tif(count<keys.length){\n\t\t\t\treturn {value: obj[keys[count++]],done:false};\n\t\t\t}else{\n\t\t\t\treturn {value:undefined,done:true};\n\t\t\t}\n\t\t}\n\t}\n};\n\nfor(var k of obj){\n\tconsole.log(k);\n}\n\n// 方法二\nvar obj = {\n    a:1,\n    b:2,\n    c:3\n};\nobj[Symbol.iterator] = function*(){\n    var keys = Object.keys(obj);\n    for(var k of keys){\n        yield [k,obj[k]]\n    }\n};\n\nfor(var [k,v] of obj){\n    console.log(k,v);\n}\n\n\n\n# 27. ajax、axios、fetch的区别\n\n（1）AJAX Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：\n\n * 本身是针对MVC编程，不符合前端MVVM的浪潮\n * 基于原生XHR开发，XHR本身的架构不清晰\n * 不符合关注分离（Separation of Concerns）的原则\n * 配置和调用方式非常混乱，而且基于事件的异步模型不友好。\n\n（2）Fetch fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。\n\nfetch的优点：\n\n * 语法简洁，更加语义化\n * 基于标准 Promise 实现，支持 async/await\n * 更加底层，提供的API丰富（request, response）\n * 脱离了XHR，是ES规范里新的实现方式\n\nfetch的缺点：\n\n * fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。\n * fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})\n * fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费\n * fetch没有办法原生监测请求的进度，而XHR可以\n\n（3）Axios Axios 是一种基于Promise封装的HTTP客户端，其特点如下：\n\n * 浏览器端发起XMLHttpRequests请求\n * node端发起http请求\n * 支持Promise API\n * 监听请求和返回\n * 对请求和返回进行转化\n * 取消请求\n * 自动转换json数据\n * 客户端支持抵御XSRF攻击\n\n\n# 28. 数组的遍历方法有哪些\n\n方法                         是否改变原数组   特点\nforEach()                  否         数组方法，不改变原数组，没有返回值\nmap()                      否         数组方法，不改变原数组，有返回值，可链式调用\nfilter()                   否         数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用\nfor...of                   否         for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环\nevery() 和 some()           否         数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.\nfind() 和 findIndex()       否         数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值\nreduce() 和 reduceRight()   否         数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作\n\n\n# 29. forEach和map方法有什么区别\n\n这方法都是用来遍历数组的，两者区别如下：\n\n * forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；\n * map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；",
      "normalizedContent": "# 1. new操作符的实现原理\n\nnew操作符的执行过程：\n\n（1）首先创建了一个新的空对象\n\n（2）设置原型，将对象的原型设置为函数的 prototype 对象。\n\n（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\n\n（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。\n\n具体实现：\n\nfunction objectfactory() {\n  let newobject = null;\n  let constructor = array.prototype.shift.call(arguments);\n  let result = null;\n  // 判断参数是否是一个函数\n  if (typeof constructor !== \"function\") {\n    console.error(\"type error\");\n    return;\n  }\n  // 新建一个空对象，对象的原型为构造函数的 prototype 对象\n  newobject = object.create(constructor.prototype);\n  // 将 this 指向新建对象，并执行函数\n  result = constructor.apply(newobject, arguments);\n  // 判断返回对象\n  let flag = result && (typeof result === \"object\" || typeof result === \"function\");\n  // 判断返回结果\n  return flag ? result : newobject;\n}\n// 使用方法\nobjectfactory(构造函数, 初始化参数);\n\n\n\n# 2. map和object的区别\n\n       map                                            object\n意外的键   map默认情况不包含任何键，只包含显式插入的键。                       object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。\n键的类型   map的键可以是任意值，包括函数、对象或任意基本类型。                    object 的键必须是 string 或是symbol。\n键的顺序   map 中的 key 是有序的。因此，当迭代的时候， map 对象以插入的顺序返回键值。   object 的键是无序的\nsize   map 的键值对个数可以轻易地通过size 属性获取                     object 的键值对个数只能手动计算\n迭代     map 是 iterable 的，所以可以直接被迭代。                    迭代object需要以某种方式获取它的键然后才能迭代。\n性能     在频繁增删键值对的场景下表现更好。                              在频繁添加和删除键值对的场景下未作出优化。\n\n\n# 3. map和weakmap的区别\n\n（1）map map本质上就是键值对的集合，但是普通的object中的键值对中的键只能是字符串。而es6提供的map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的hash结构。如果map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。\n\n实际上map是一个数组，它的每一个数据也都是一个数组，其形式如下：\n\nconst map = [\n     [\"name\",\"张三\"],\n     [\"age\",18],\n]\n\n\nmap数据结构有以下操作方法：\n\n * size： map.size 返回map结构的成员总数。\n * set(key,value)：设置键名key对应的键值value，然后返回整个map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前map对象，所以可以链式调用）\n * get(key)：该方法读取key对应的键值，如果找不到key，返回undefined。\n * has(key)：该方法返回一个布尔值，表示某个键是否在当前map对象中。\n * delete(key)：该方法删除某个键，返回true，如果删除失败，返回false。\n * clear()：map.clear()清除所有成员，没有返回值。\n\nmap结构原生提供是三个遍历器生成函数和一个遍历方法\n\n * keys()：返回键名的遍历器。\n * values()：返回键值的遍历器。\n * entries()：返回所有成员的遍历器。\n * foreach()：遍历map的所有成员。\n\nconst map = new map([\n     [\"foo\",1],\n     [\"bar\",2],\n])\nfor(let key of map.keys()){\n    console.log(key);  // foo bar\n}\nfor(let value of map.values()){\n     console.log(value); // 1 2\n}\nfor(let items of map.entries()){\n    console.log(items);  // [\"foo\",1]  [\"bar\",2]\n}\nmap.foreach( (value,key,map) => {\n     console.log(key,value); // foo 1    bar 2\n})\n\n\n（2）weakmap weakmap 对象也是一组键值对的集合，其中的键是弱引用的。其键必须是对象，原始数据类型不能作为key值，而值可以是任意的。\n\n该对象也有以下几种方法：\n\n * set(key,value)：设置键名key对应的键值value，然后返回整个map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前map对象，所以可以链式调用）\n * get(key)：该方法读取key对应的键值，如果找不到key，返回undefined。\n * has(key)：该方法返回一个布尔值，表示某个键是否在当前map对象中。\n * delete(key)：该方法删除某个键，返回true，如果删除失败，返回false。\n\n其clear()方法已经被弃用，所以可以通过创建一个空的weakmap并替换原对象来实现清除。\n\nweakmap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。\n\n而weakmap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，weakmap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。\n\n总结：\n\n * map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。\n * weakmap 结构与 map 结构类似，也是用于生成键值对的集合。但是 weakmap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 weakmap 的键名所指向的对象，不计入垃圾回收机制。\n\n\n# 4. javascript有哪些内置对象\n\n全局的对象（ global objects ）或称标准内置对象，不要和 \"全局对象（global object）\" 混淆。这里说的全局的对象是说在 全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。\n\n标准内置对象的分类：\n\n（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 infinity、nan、undefined、null 字面量\n\n（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parsefloat()、parseint() 等\n\n（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 object、function、boolean、symbol、error 等\n\n（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 number、math、date\n\n（5）字符串，用来表示和操作字符串的对象。例如 string、regexp\n\n（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 array\n\n（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。 例如 map、set、weakmap、weakset\n\n（8）矢量集合，simd 矢量集合中的数据会被组织为一个数据序列。 例如 simd 等\n\n（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 json 编码的数据。例如 json 等\n\n（10）控制抽象对象 例如 promise、generator 等\n\n（11）反射。例如 reflect、proxy\n\n（12）国际化，为了支持多语言处理而加入 ecmascript 的对象。例如 intl、intl.collator 等\n\n（13）webassembly\n\n（14）其他。例如 arguments\n\n总结： js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 nan、undefined，全局函数如 parseint()、parsefloat() 用来实例化对象的构造函数如 date、object 等，还有提供数学计算的单体内置对象如 math 对象。\n\n\n# 5. 常用的正则表达式有哪些？\n\n// （1）匹配 16 进制颜色值\nvar regex = /#([0-9a-fa-f]{6}|[0-9a-fa-f]{3})/g;\n\n// （2）匹配日期，如 yyyy-mm-dd 格式\nvar regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;\n\n// （3）匹配 qq 号\nvar regex = /^[1-9][0-9]{4,10}$/g;\n\n// （4）手机号码正则\nvar regex = /^1[34578]\\d{9}$/g;\n\n// （5）用户名正则\nvar regex = /^[a-za-z\\$][a-za-z0-9_\\$]{4,16}$/;\n\n\n\n# 6. 对json的理解\n\njson 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。\n\n在项目开发中，使用 json 作为前后端数据交换的方式。在前端通过将一个符合 json 格式的数据结构序列化为 json 字符串，然后将它传递到后端，后端通过 json 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。\n\n因为 json 的语法是基于 js 的，因此很容易将 json 和 js 中的对象弄混，但是应该注意的是 json 和 js 中的对象不是一回事，json 中对象格式更加严格，比如说在 json 中属性值不能为函数，不能出现 nan 这样的属性值等，因此大多数的 js 对象是不符合 json 对象的格式的。\n\n在 js 中提供了两个函数来实现 js 数据结构和 json 格式的转换处理，\n\n * json.stringify 函数，通过传入一个符合 json 格式的数据结构，将其转换为一个 json 字符串。如果传入的数据结构不符合 json 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 json 格式的字符串。\n * json.parse() 函数，这个函数用来将 json 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 json 格式的字符串的话，将会抛出错误。当从后端接收到 json 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。\n\n\n# 7. javascript脚本延迟加载的方式有哪些？\n\n延迟加载就是等页面加载完成之后再加载 javascript 文件。 js 延迟加载有助于提高页面加载速度。\n\n一般有以下几种方式：\n\n * defer 属性： 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。\n * async 属性： 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。\n * 动态创建 dom 方式： 动态创建 dom 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。\n * 使用 settimeout 延迟方法： 设置一个定时器来延迟加载js脚本文件\n * 让 js 最后加载： 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。\n\n\n# 8. javascript 类数组对象的定义？\n\n一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 dom 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。\n\n常见的类数组转换为数组的方法有这样几种：\n\n（1）通过 call 调用数组的 slice 方法来实现转换\n\narray.prototype.slice.call(arraylike);\n\n\n（2）通过 call 调用数组的 splice 方法来实现转换\n\narray.prototype.splice.call(arraylike, 0);\n\n\n（3）通过 apply 调用数组的 concat 方法来实现转换\n\narray.prototype.concat.apply([], arraylike);\n\n\n（4）通过 array.from 方法来实现转换\n\narray.from(arraylike);\n\n\n\n# 9. 数组有哪些原生方法？\n\n * 数组和字符串的转换方法：tostring()、tolocalstring()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。\n * 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。\n * 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。\n * 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。\n * 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。\n * 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexof() 和 lastindexof() 迭代方法 every()、some()、filter()、map() 和 foreach() 方法\n * 数组归并方法 reduce() 和 reduceright() 方法\n\n\n# 10. unicode、utf-8、utf-16、utf-32的区别？\n\n# （1）unicode\n\n在说unicode之前需要先了解一下ascii码：ascii 码（american standard code for information interchange）称为美国标准信息交换码。\n\n * 它是基于拉丁字母的一套电脑编码系统。\n * 它定义了一个用于代表常见字符的字典。\n * 它包含了\"a-z\"(包含大小写)，数据\"0-9\" 以及一些常见的符号。\n * 它是专门为英语而设计的，有128个编码，对其他语言无能为力\n\nascii码可以表示的编码有限，要想表示其他语言的编码，还是要使用unicode来表示，可以说unicode是ascii 的超集。\n\nunicode全称 unicode translation format，又叫做统一码、万国码、单一码。unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。\n\nunicode的实现方式（也就是编码方式）有很多种，常见的是utf-8、utf-16、utf-32和usc-2。\n\n# （2）utf-8\n\nutf-8是使用最广泛的unicode编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容ascii码的128个字符。\n\n注意： utf-8 是一种编码方式，unicode是一个字符集合。\n\nutf-8的编码规则：\n\n * 对于单字节的符号，字节的第一位为0，后面的7位为这个字符的unicode编码，因此对于英文字母，它的unicode编码和acsii编码一样。\n * 对于n字节的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的unicode码 。\n\n来看一下具体的unicode编号范围与对应的utf-8二进制格式 ：\n\n编码范围（编号对应的十进制数）              二进制格式\n0x00—0x7f （0-127）            0xxxxxxx\n0x80—0x7ff （128-2047）        110xxxxx 10xxxxxx\n0x800—0xffff （2048-65535）    1110xxxx 10xxxxxx 10xxxxxx\n0x10000—0x10ffff （65536以上）   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n那该如何通过具体的unicode编码，进行具体的utf-8编码呢？步骤如下：\n\n * 找到该unicode编码的所在的编号范围，进而找到与之对应的二进制格式\n * 将unicode编码转换为二进制数（去掉最高位的0）\n * 将二进制数从右往左一次填入二进制格式的x中，如果有x未填，就设为0\n\n来看一个实际的例子： “马” 字的unicode编码是：0x9a6c，整数编号是39532 （1）首选确定了该字符在第三个范围内，它的格式是 1110xxxx 10xxxxxx 10xxxxxx （2）39532对应的二进制数为1001 1010 0110 1100 （3）将二进制数填入x中，结果是：11101001 10101001 10101100\n\n# （3）utf-16\n\n1. 平面的概念\n\n在了解utf-16之前，先看一下平面的概念： unicode编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放65536（216）个字符，这称为一个平面，目前总共有17 个平面。\n\n最前面的一个平面称为基本平面，它的码点从0 — 216-1，写成16进制就是u+0000 — u+ffff，那剩下的16个平面就是辅助平面，码点范围是 u+10000—u+10ffff。\n\n2. utf-16 概念：\n\nutf-16也是unicode编码集的一种编码形式，把unicode字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。unicode字符的码位需要1个或者2个16位长的码元来表示，因此utf-16也是用变长字节表示的。\n\n3. utf-16 编码规则：\n\n * 编号在 u+0000—u+ffff 的字符（常用字符集），直接用两个字节表示。\n * 编号在 u+10000—u+10ffff 之间的字符，需要用四个字节表示。\n\n4. 编码识别\n\n那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？\n\nutf-16 编码肯定也考虑到了这个问题，在基本平面内，从 u+d800 — u+dfff 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。\n\n辅助平面共有 220 个字符位，因此表示这些字符至少需要 20 个二进制位。utf-16 将这 20 个二进制位分成两半，前 10 位映射在 u+d800 — u+dbff，称为高位（h），后 10 位映射在 u+dc00 — u+dfff，称为低位（l）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。\n\n因此，当遇到两个字节时，发现它的码点在 u+d800 —u+dbff之间，就可以知道，它后面的两个字节的码点应该在 u+dc00 — u+dfff 之间，这四个字节必须放在一起进行解读。\n\n5. 举例说明\n\n以 \"𡠀\" 字为例，它的 unicode 码点为 0x21800，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：\n\n * 首先计算超出部分的结果：0x21800 - 0x10000\n * 将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：0001000110 0000000000\n * 将得到的两个10位二进制数分别对应到两个区间中\n * u+d800 对应的二进制数为 1101100000000000， 将0001000110填充在它的后10 个二进制位，得到 1101100001000110，转成 16 进制数为 0xd846。同理，低位为 0xdc00，所以这个字的utf-16 编码为 0xd846 0xdc00\n\n# （4） utf-32\n\nutf-32 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。\n\n比如“马” 字的unicode编号是：u+9a6c，整数编号是39532，直接转化为二进制：1001 1010 0110 1100，这就是它的utf-32编码。\n\n# （5）总结\n\nunicode、utf-8、utf-16、utf-32有什么区别？\n\n * unicode 是编码字符集（字符集），而utf-8、utf-16、utf-32是字符集编码（编码规则）；\n * utf-16 使用变长码元序列的编码方式，相较于定长码元序列的utf-32算法更复杂，甚至比同样是变长码元序列的utf-8也更为复杂，因为其引入了独特的代理对这样的代理机制；\n * utf-8需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而utf-16不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；\n * 如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用utf-8就比utf-16节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么utf-16就占优势了，可以节省很多空间\n\n\n# 11. 常见的位运算符有哪些？其计算规则是什么？\n\n现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。\n\n常见的位运算有以下几种：\n\n运算符   描述   运算规则                            \n&     与    两个位都为1时，结果才为1                   \n|     或    两个位都为0时，结果才为0                   \n^     异或   两个位相同为0，相异为1                    \n~     取反   0变1，1变0                         \n<<    左移   各二进制位全部左移若干位，高位丢弃，低位补0          \n>>    右移   各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃   \n\n# 1. 按位与运算符（&）\n\n定义： 参加运算的两个数据按二进制位进行“与”运算。 运算规则：\n\n0 & 0 = 0  \n0 & 1 = 0  \n1 & 0 = 0  \n1 & 1 = 1\n\n\n总结：两位同时为1，结果才为1，否则结果为0。 例如：3&5 即：\n\n0000 0011 \n   0000 0101 \n = 0000 0001\n\n\n因此 3&5 的值为1。 注意：负数按补码形式参加按位与运算。\n\n用途：\n\n（1）判断奇偶\n\n只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((i & 1) == 0)代替if (i % 2 == 0)来判断a是不是偶数。\n\n（2）清零\n\n如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。\n\n# 2. 按位或运算符（|）\n\n定义： 参加运算的两个对象按二进制位进行“或”运算。\n\n运算规则：\n\n0 | 0 = 0\n0 | 1 = 1  \n1 | 0 = 1  \n1 | 1 = 1\n\n\n总结：参加运算的两个对象只要有一个为1，其值为1。 例如：3|5即：\n\n0000 0011\n  0000 0101 \n= 0000 0111\n\n\n因此，3|5的值为7。 注意：负数按补码形式参加按位或运算。\n\n# 3. 异或运算符（^）\n\n定义： 参加运算的两个数据按二进制位进行“异或”运算。\n\n运算规则：\n\n0 ^ 0 = 0  \n0 ^ 1 = 1  \n1 ^ 0 = 1  \n1 ^ 1 = 0\n\n\n总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。 例如：3|5即：\n\n0000 0011\n  0000 0101 \n= 0000 0110\n\n\n因此，3^5的值为6。 异或运算的性质:\n\n * 交换律：(a^b)^c == a^(b^c)\n * 结合律：(a + b)^c == a^b + b^c\n * 对于任何数x，都有 x^x=0，x^0=x\n * 自反性: a^b^b=a^0=a;\n\n# 4. 取反运算符 (~)\n\n定义： 参加运算的一个数据按二进制进行“取反”运算。\n\n运算规则：\n\n~ 1 = 0~ 0 = 1\n\n\n总结：对一个二进制数按位取反，即将0变1，1变0。 例如：~6 即：\n\n0000 0110= 1111 1001\n\n\n在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。 当发现按位取反为负数时，就直接取其补码，变为十进制：\n\n0000 0110   = 1111 1001反码：1000 0110补码：1000 0111\n\n\n因此，~6的值为-7。\n\n# 5. 左移运算符（<<）\n\n定义： 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。 设 a=1010 1110，a = a<< 2 将a的二进制位左移2位、右补0，即得a=1011 1000。 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。\n\n# 6. 右移运算符（>>）\n\n定义： 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 例如：a=a>>2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。 操作数每右移一位，相当于该数除以2。\n\n# 7. 原码、补码、反码\n\n上面提到了补码、反码等知识，这里就补充一下。 计算机中的有符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。\n\n（1）原码\n\n原码就是一个数的二进制数。例如：10的原码为0000 1010\n\n（2）反码\n\n * 正数的反码与原码相同，如：10 反码为 0000 1010\n * 负数的反码为除符号位，按位取反，即0变1，1变0。\n\n例如：-10\n\n原码：1000 1010\n反码：1111 0101\n\n\n（3）补码\n\n * 正数的补码与原码相同，如：10 补码为 0000 1010\n * 负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。\n\n例如：-10\n\n原码：1000 1010\n反码：1111 0101\n补码：1111 0110\n\n\n\n# 12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?\n\narguments是一个对象，它的属性是从 0 开始依次递增的数字，还有callee和length等属性，与数组相似；但是它却没有数组常见的方法属性，如foreach, reduce等，所以叫它们类数组。\n\n要遍历类数组，有三个方法：\n\n（1）将数组的方法应用到类数组上，这时候就可以使用call和apply方法，如：\n\nfunction foo(){ \n  array.prototype.foreach.call(arguments, a => console.log(a))\n}\n\n\n（2）使用array.from方法将类数组转化成数组：‌\n\nfunction foo(){ \n  const arrargs = array.from(arguments) \n  arrargs.foreach(a => console.log(a))\n}\n\n\n（3）使用展开运算符将类数组转化成数组\n\nfunction foo(){ \n    const arrargs = [...arguments] \n    arrargs.foreach(a => console.log(a)) \n}\n\n\n\n# 13. 什么是 dom 和 bom？\n\n * dom 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。\n * bom 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。bom的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 dom 的最根本的对象 document 对象也是 bom 的 window 对象的子对象。\n\n\n# 14. 对类数组对象的理解，如何转化为数组\n\n一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 dom 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。\n\n常见的类数组转换为数组的方法有这样几种：\n\n * 通过 call 调用数组的 slice 方法来实现转换\n\narray.prototype.slice.call(arraylike);\n\n\n * 通过 call 调用数组的 splice 方法来实现转换\n\narray.prototype.splice.call(arraylike, 0);\n\n\n * 通过 apply 调用数组的 concat 方法来实现转换\n\narray.prototype.concat.apply([], arraylike);\n\n\n * 通过 array.from 方法来实现转换\n\narray.from(arraylike);\n\n\n\n# 15. escape、encodeuri、encodeuricomponent 的区别\n\n * encodeuri 是对整个 uri 进行转义，将 uri 中的非法字符转换为合法字符，所以对于一些在 uri 中有特殊意义的字符不会进行转义。\n * encodeuricomponent 是对 uri 的组成部分进行转义，所以一些特殊字符也会得到转义。\n * escape 和 encodeuri 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeuri 首先会将字符转换为 utf-8 的格式，再在每个字节前加上 %。\n\n\n# 16. 对ajax的理解，实现一个ajax请求\n\najax是 asynchronous javascript and xml 的缩写，指的是通过 javascript 的 异步通信，从服务器获取 xml 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。\n\n创建ajax请求的步骤：\n\n * 创建一个 xmlhttprequest 对象。\n * 在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。\n * 在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 setrequestheader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 xmlhttprequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readystate 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。\n * 当对象的属性和监听函数设置完成后，最后调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。\n\nconst server_url = \"/server\";\nlet xhr = new xmlhttprequest();\n// 创建 http 请求\nxhr.open(\"get\", url, true);\n// 设置状态监听函数\nxhr.onreadystatechange = function() {\n  if (this.readystate !== 4) return;\n  // 当请求成功时\n  if (this.status === 200) {\n    handle(this.response);\n  } else {\n    console.error(this.statustext);\n  }\n};\n// 设置请求失败时的监听函数\nxhr.onerror = function() {\n  console.error(this.statustext);\n};\n// 设置请求头信息\nxhr.responsetype = \"json\";\nxhr.setrequestheader(\"accept\", \"application/json\");\n// 发送 http 请求\nxhr.send(null);\n\n\n使用promise封装ajax：\n\n// promise 封装实现：\nfunction getjson(url) {\n  // 创建一个 promise 对象\n  let promise = new promise(function(resolve, reject) {\n    let xhr = new xmlhttprequest();\n    // 新建一个 http 请求\n    xhr.open(\"get\", url, true);\n    // 设置状态的监听函数\n    xhr.onreadystatechange = function() {\n      if (this.readystate !== 4) return;\n      // 当请求成功或失败时，改变 promise 的状态\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new error(this.statustext));\n      }\n    };\n    // 设置错误监听函数\n    xhr.onerror = function() {\n      reject(new error(this.statustext));\n    };\n    // 设置响应的数据类型\n    xhr.responsetype = \"json\";\n    // 设置请求头信息\n    xhr.setrequestheader(\"accept\", \"application/json\");\n    // 发送 http 请求\n    xhr.send(null);\n  });\n  return promise;\n}\n\n\n\n# 17. javascript为什么要进行变量提升，它导致了什么问题？\n\n变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。\n\n造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。\n\n首先要知道，js在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。\n\n * 在解析阶段\n   \n   ，js会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。\n   \n   * 全局上下文：变量定义，函数声明\n   * 函数上下文：变量定义，函数声明，this，arguments\n\n * 在执行阶段，就是按照代码的顺序依次执行。\n\n那为什么会进行变量提升呢？主要有以下两个原因：\n\n * 提高性能\n * 容错性更好\n\n（1）提高性能 在js代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。\n\n在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。\n\n（2）容错性更好\n\n变量提升可以在一定程度上提高js的容错性，看下面的代码：\n\na = 1;var a;console.log(a);\n\n\n如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。\n\n虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。\n\n总结：\n\n * 解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间\n * 声明提升还可以提高js代码的容错性，使一些不规范的代码也可以正常执行\n\n变量提升虽然有一些优点，但是他也会造成一定的问题，在es6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：\n\nvar tmp = new date();\n\nfunction fn(){\n\tconsole.log(tmp);\n\tif(false){\n\t\tvar tmp = 'hello world';\n\t}\n}\n\nfn();  // undefined\n\n\n在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。\n\nvar tmp = 'hello world';\n\nfor (var i = 0; i < tmp.length; i++) {\n\tconsole.log(tmp[i]);\n}\n\nconsole.log(i); // 11\n\n\n由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。\n\n\n# 18. 什么是尾调用，使用尾调用有什么好处？\n\n尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 es6 的尾调用优化只在严格模式下开启，正常模式是无效的。\n\n\n# 19. es6模块与commonjs模块有什么异同？\n\nes6 module和commonjs模块的区别：\n\n * commonjs是对模块的浅拷⻉，es6 module是对模块的引⽤，即es6 module只存只读，不能改变其值，也就是指针指向不能变，类似const；\n * import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonjs对重新赋值（改变指针指向），但是对es6 module赋值会编译报错。\n\nes6 module和commonjs模块的共同点：\n\n * commonjs和es6 module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。\n\n\n# 20. 常见的dom操作有哪些\n\n# 1）dom 节点的获取\n\ndom 节点的获取的api及使用：\n\ngetelementbyid // 按照 id 查询\ngetelementsbytagname // 按照标签名查询\ngetelementsbyclassname // 按照类名查询\nqueryselectorall // 按照 css 选择器查询\n\n// 按照 id 查询\nvar imooc = document.getelementbyid('imooc') // 查询到 id 为 imooc 的元素\n// 按照标签名查询\nvar plist = document.getelementsbytagname('p')  // 查询到标签为 p 的集合\nconsole.log(divlist.length)\nconsole.log(divlist[0])\n// 按照类名查询\nvar mooclist = document.getelementsbyclassname('mooc') // 查询到类名为 mooc 的集合\n// 按照 css 选择器查询\nvar plist = document.queryselectorall('.mooc') // 查询到类名为 mooc 的集合\n\n\n# 2）dom 节点的创建\n\n创建一个新节点，并把它添加到指定节点的后面。 已知的 html 结构如下：\n\n<html>\n  <head>\n    <title>demo</title>\n  </head>\n  <body>\n    <div id=\"container\"> \n      <h1 id=\"title\">我是标题</h1>\n    </div>   \n  </body>\n</html>\n\n\n要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：\n\n// 首先获取父节点\nvar container = document.getelementbyid('container')\n// 创建新节点\nvar targetspan = document.createelement('span')\n// 设置 span 节点的内容\ntargetspan.innerhtml = 'hello world'\n// 把新创建的元素塞进父节点里去\ncontainer.appendchild(targetspan)\n\n\n# 3）dom 节点的删除\n\n删除指定的 dom 节点， 已知的 html 结构如下：\n\n<html>\n  <head>\n    <title>demo</title>\n  </head>\n  <body>\n    <div id=\"container\"> \n      <h1 id=\"title\">我是标题</h1>\n    </div>   \n  </body>\n</html>\n\n\n需要删除 id 为 title 的元素，做法是：\n\n// 获取目标元素的父元素\nvar container = document.getelementbyid('container')\n// 获取目标元素\nvar targetnode = document.getelementbyid('title')\n// 删除目标元素\ncontainer.removechild(targetnode)\n\n\n或者通过子节点数组来完成删除：\n\n// 获取目标元素的父元素var container = document.getelementbyid('container')// 获取目标元素var targetnode = container.childnodes[1]// 删除目标元素container.removechild(targetnode)\n\n\n# 4）修改 dom 元素\n\n修改 dom 元素这个动作可以分很多维度，比如说移动 dom 元素的位置，修改 dom 元素的属性等。\n\n将指定的两个 dom 元素交换位置， 已知的 html 结构如下：\n\n<html>\n  <head>\n    <title>demo</title>\n  </head>\n  <body>\n    <div id=\"container\"> \n      <h1 id=\"title\">我是标题</h1>\n      <p id=\"content\">我是内容</p>\n    </div>   \n  </body>\n</html>\n\n\n现在需要调换 title 和 content 的位置，可以考虑 insertbefore 或者 appendchild：\n\n// 获取父元素\nvar container = document.getelementbyid('container')   \n \n// 获取两个需要被交换的元素\nvar title = document.getelementbyid('title')\nvar content = document.getelementbyid('content')\n// 交换两个元素，把 content 置于 title 前面\ncontainer.insertbefore(content, title)\n\n\n\n# 21. use strict是什么意思 ? 使用它区别是什么？\n\nuse strict 是一种 ecmascript5 添加的（严格模式）运行模式，这种模式使得 javascript 在更严格的条件下运行。设立严格模式的目的如下：\n\n * 消除 javascript 语法的不合理、不严谨之处，减少怪异行为;\n * 消除代码运行的不安全之处，保证代码运行的安全；\n * 提高编译器效率，增加运行速度；\n * 为未来新版本的 javascript 做好铺垫。\n\n区别：\n\n * 禁止使用 with 语句。\n * 禁止 this 关键字指向全局对象。\n * 对象不能有重名的属性。\n\n\n# 22. 如何判断一个对象是否属于某个类？\n\n * 第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\n * 第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。\n * 第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 object.prototype.tostring() 方法来打印对象的[[class]] 属性来进行判断。\n\n\n# 23. 强类型语言和弱类型语言的区别\n\n * 强类型语言：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。java和c++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。\n * 弱类型语言：弱类型语言也称为弱类型定义语言，与强类型定义相反。javascript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如javascript是弱类型定义的，在javascript中就可以将字符串'12'和整数3进行连接得到字符串'123'，在相加的时候会进行强制类型转换。\n\n两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。\n\n\n# 24. 解释性语言和编译型语言的区别\n\n（1）解释型语言 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下\n\n * 解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；\n * 只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；\n * javascript、python等属于解释型语言。\n\n（2）编译型语言 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：\n\n * 一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；\n * 与特定平台相关，一般无法移植到其他平台；\n * c、c++等属于编译型语言。\n\n两者主要区别在于： 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。\n\n\n# 25. for...in和for...of的区别\n\nfor…of 是es6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和es3中的for…in的区别如下\n\n * for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；\n * for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；\n * 对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；\n\n总结： for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、set、map 以及 generator 对象。\n\n\n# 26. 如何使用for...of遍历对象\n\nfor…of是作为es6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。\n\n如果需要遍历的对象是类数组对象，用array.from转成数组即可。\n\nvar obj = {\n    0:'one',\n    1:'two',\n    length: 2\n};\nobj = array.from(obj);\nfor(var k of obj){\n    console.log(k)\n}\n\n\n如果不是类数组对象，就给对象添加一个[symbol.iterator]属性，并指向一个迭代器即可。\n\n//方法一：\nvar obj = {\n    a:1,\n    b:2,\n    c:3\n};\n\nobj[symbol.iterator] = function(){\n\tvar keys = object.keys(this);\n\tvar count = 0;\n\treturn {\n\t\tnext(){\n\t\t\tif(count<keys.length){\n\t\t\t\treturn {value: obj[keys[count++]],done:false};\n\t\t\t}else{\n\t\t\t\treturn {value:undefined,done:true};\n\t\t\t}\n\t\t}\n\t}\n};\n\nfor(var k of obj){\n\tconsole.log(k);\n}\n\n// 方法二\nvar obj = {\n    a:1,\n    b:2,\n    c:3\n};\nobj[symbol.iterator] = function*(){\n    var keys = object.keys(obj);\n    for(var k of keys){\n        yield [k,obj[k]]\n    }\n};\n\nfor(var [k,v] of obj){\n    console.log(k,v);\n}\n\n\n\n# 27. ajax、axios、fetch的区别\n\n（1）ajax ajax 即“asynchronousjavascriptandxml”（异步 javascript 和 xml），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：\n\n * 本身是针对mvc编程，不符合前端mvvm的浪潮\n * 基于原生xhr开发，xhr本身的架构不清晰\n * 不符合关注分离（separation of concerns）的原则\n * 配置和调用方式非常混乱，而且基于事件的异步模型不友好。\n\n（2）fetch fetch号称是ajax的替代品，是在es6出现的，使用了es6中的promise对象。fetch是基于promise设计的。fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用xmlhttprequest对象。\n\nfetch的优点：\n\n * 语法简洁，更加语义化\n * 基于标准 promise 实现，支持 async/await\n * 更加底层，提供的api丰富（request, response）\n * 脱离了xhr，是es规范里新的实现方式\n\nfetch的缺点：\n\n * fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。\n * fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})\n * fetch不支持abort，不支持超时控制，使用settimeout及promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费\n * fetch没有办法原生监测请求的进度，而xhr可以\n\n（3）axios axios 是一种基于promise封装的http客户端，其特点如下：\n\n * 浏览器端发起xmlhttprequests请求\n * node端发起http请求\n * 支持promise api\n * 监听请求和返回\n * 对请求和返回进行转化\n * 取消请求\n * 自动转换json数据\n * 客户端支持抵御xsrf攻击\n\n\n# 28. 数组的遍历方法有哪些\n\n方法                         是否改变原数组   特点\nforeach()                  否         数组方法，不改变原数组，没有返回值\nmap()                      否         数组方法，不改变原数组，有返回值，可链式调用\nfilter()                   否         数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用\nfor...of                   否         for...of遍历具有iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环\nevery() 和 some()           否         数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.\nfind() 和 findindex()       否         数组方法，find()返回的是第一个符合条件的值；findindex()返回的是第一个返回条件的值的索引值\nreduce() 和 reduceright()   否         数组方法，reduce()对数组正序操作；reduceright()对数组逆序操作\n\n\n# 29. foreach和map方法有什么区别\n\n这方法都是用来遍历数组的，两者区别如下：\n\n * foreach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；\n * map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "JavaScript进阶",
      "frontmatter": {
        "title": "JavaScript进阶",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/effect/",
        "article": false
      },
      "regularPath": "/20.%E9%AB%98%E9%A2%91%E7%AF%87/10.JavaScript%E7%AF%87/40.%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html",
      "relativePath": "20.高频篇/10.JavaScript篇/40.原型与原型链.md",
      "key": "v-2a365120",
      "path": "/pages/effect/",
      "headers": [
        {
          "level": 3,
          "title": "1. 对原型、原型链的理解",
          "slug": "_1-对原型、原型链的理解",
          "normalizedTitle": "1. 对原型、原型链的理解",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 原型修改、重写",
          "slug": "_2-原型修改、重写",
          "normalizedTitle": "2. 原型修改、重写",
          "charIndex": 553
        },
        {
          "level": 3,
          "title": "3. 原型链指向",
          "slug": "_3-原型链指向",
          "normalizedTitle": "3. 原型链指向",
          "charIndex": 1403
        },
        {
          "level": 3,
          "title": "4. 原型链的终点是什么？如何打印出原型链的终点？",
          "slug": "_4-原型链的终点是什么-如何打印出原型链的终点",
          "normalizedTitle": "4. 原型链的终点是什么？如何打印出原型链的终点？",
          "charIndex": 1748
        },
        {
          "level": 3,
          "title": "5. 如何获得对象非原型链上的属性？",
          "slug": "_5-如何获得对象非原型链上的属性",
          "normalizedTitle": "5. 如何获得对象非原型链上的属性？",
          "charIndex": 1969
        }
      ],
      "headersStr": "1. 对原型、原型链的理解 2. 原型修改、重写 3. 原型链指向 4. 原型链的终点是什么？如何打印出原型链的终点？ 5. 如何获得对象非原型链上的属性？",
      "content": "# 1. 对原型、原型链的理解\n\n在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。\n\n当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。\n\n特点： JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。\n\n\n# 2. 原型修改、重写\n\nfunction Person(name) {\n    this.name = name\n}\n// 修改原型\nPerson.prototype.getName = function() {}\nvar p = new Person('hello')\nconsole.log(p.__proto__ === Person.prototype) // true\nconsole.log(p.__proto__ === p.constructor.prototype) // true\n// 重写原型\nPerson.prototype = {\n    getName: function() {}\n}\nvar p = new Person('hello')\nconsole.log(p.__proto__ === Person.prototype)        // true\nconsole.log(p.__proto__ === p.constructor.prototype) // false\n\n\n可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候p.constructor === Object ，而不是p.constructor === Person。要想成立，就要用constructor指回来：\n\nPerson.prototype = {\n    getName: function() {}\n}\nvar p = new Person('hello')\np.constructor = Person\nconsole.log(p.__proto__ === Person.prototype)        // true\nconsole.log(p.__proto__ === p.constructor.prototype) // true\n\n\n\n# 3. 原型链指向\n\np.__proto__  // Person.prototype\nPerson.prototype.__proto__  // Object.prototype\np.__proto__.__proto__ //Object.prototype\np.__proto__.constructor.prototype.__proto__ // Object.prototype\nPerson.prototype.constructor.prototype.__proto__ // Object.prototype\np1.__proto__.constructor // Person\nPerson.prototype.constructor  // Person\n\n\n\n# 4. 原型链的终点是什么？如何打印出原型链的终点？\n\n由于Object是构造函数，原型链终点是Object.prototype.__proto__，而Object.prototype.__proto__=== null // true，所以，原型链的终点是null。原型链上的所有原型都是对象，所有的对象最终都是由Object构造的，而Object.prototype的下一级是Object.prototype.__proto__。\n\n\n# 5. 如何获得对象非原型链上的属性？\n\n使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：\n\nfunction iterate(obj){\n   var res=[];\n   for(var key in obj){\n        if(obj.hasOwnProperty(key))\n           res.push(key+': '+obj[key]);\n   }\n   return res;\n} \n",
      "normalizedContent": "# 1. 对原型、原型链的理解\n\n在javascript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 es5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。es5 中新增了一个 object.getprototypeof() 方法，可以通过这个方法来获取对象的原型。\n\n当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 object.prototype 所以这就是新建的对象为什么能够使用 tostring() 等方法的原因。\n\n特点： javascript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。\n\n\n# 2. 原型修改、重写\n\nfunction person(name) {\n    this.name = name\n}\n// 修改原型\nperson.prototype.getname = function() {}\nvar p = new person('hello')\nconsole.log(p.__proto__ === person.prototype) // true\nconsole.log(p.__proto__ === p.constructor.prototype) // true\n// 重写原型\nperson.prototype = {\n    getname: function() {}\n}\nvar p = new person('hello')\nconsole.log(p.__proto__ === person.prototype)        // true\nconsole.log(p.__proto__ === p.constructor.prototype) // false\n\n\n可以看到修改原型的时候p的构造函数不是指向person了，因为直接给person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数object，所以这时候p.constructor === object ，而不是p.constructor === person。要想成立，就要用constructor指回来：\n\nperson.prototype = {\n    getname: function() {}\n}\nvar p = new person('hello')\np.constructor = person\nconsole.log(p.__proto__ === person.prototype)        // true\nconsole.log(p.__proto__ === p.constructor.prototype) // true\n\n\n\n# 3. 原型链指向\n\np.__proto__  // person.prototype\nperson.prototype.__proto__  // object.prototype\np.__proto__.__proto__ //object.prototype\np.__proto__.constructor.prototype.__proto__ // object.prototype\nperson.prototype.constructor.prototype.__proto__ // object.prototype\np1.__proto__.constructor // person\nperson.prototype.constructor  // person\n\n\n\n# 4. 原型链的终点是什么？如何打印出原型链的终点？\n\n由于object是构造函数，原型链终点是object.prototype.__proto__，而object.prototype.__proto__=== null // true，所以，原型链的终点是null。原型链上的所有原型都是对象，所有的对象最终都是由object构造的，而object.prototype的下一级是object.prototype.__proto__。\n\n\n# 5. 如何获得对象非原型链上的属性？\n\n使用后hasownproperty()方法来判断属性是否属于原型链的属性：\n\nfunction iterate(obj){\n   var res=[];\n   for(var key in obj){\n        if(obj.hasownproperty(key))\n           res.push(key+': '+obj[key]);\n   }\n   return res;\n} \n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "this&call&apply&bind",
      "frontmatter": {
        "title": "this&call&apply&bind",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/thisCall/",
        "article": false
      },
      "regularPath": "/20.%E9%AB%98%E9%A2%91%E7%AF%87/10.JavaScript%E7%AF%87/60.this&call&apply&bind.html",
      "relativePath": "20.高频篇/10.JavaScript篇/60.this&call&apply&bind.md",
      "key": "v-67f3a292",
      "path": "/pages/thisCall/",
      "headers": [
        {
          "level": 3,
          "title": "1. 对this对象的理解",
          "slug": "_1-对this对象的理解",
          "normalizedTitle": "1. 对this对象的理解",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. call() 和 apply() 的区别？",
          "slug": "_2-call-和-apply-的区别",
          "normalizedTitle": "2. call() 和 apply() 的区别？",
          "charIndex": 584
        },
        {
          "level": 3,
          "title": "3. 实现call、apply 及 bind 函数",
          "slug": "_3-实现call、apply-及-bind-函数",
          "normalizedTitle": "3. 实现call、apply 及 bind 函数",
          "charIndex": 826
        }
      ],
      "headersStr": "1. 对this对象的理解 2. call() 和 apply() 的区别？ 3. 实现call、apply 及 bind 函数",
      "content": "# 1. 对this对象的理解\n\nthis 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。\n\n * 第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。\n * 第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。\n * 第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。\n * 第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。\n\n这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。\n\n\n# 2. call() 和 apply() 的区别？\n\n它们的作用一模一样，区别仅在于传入参数的形式的不同。\n\n * apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。\n * call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。\n\n\n# 3. 实现call、apply 及 bind 函数\n\n（1）call 函数的实现步骤：\n\n * 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n * 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n * 处理传入的参数，截取第一个参数后的所有参数。\n * 将函数作为上下文对象的一个属性。\n * 使用上下文对象来调用这个方法，并保存返回结果。\n * 删除刚才新增的属性。\n * 返回结果。\n\nFunction.prototype.myCall = function(context) {\n  // 判断调用对象\n  if (typeof this !== \"function\") {\n    console.error(\"type error\");\n  }\n  // 获取参数\n  let args = [...arguments].slice(1),\n    result = null;\n  // 判断 context 是否传入，如果未传入则设置为 window\n  context = context || window;\n  // 将调用函数设为对象的方法\n  context.fn = this;\n  // 调用函数\n  result = context.fn(...args);\n  // 将属性删除\n  delete context.fn;\n  return result;\n};\n\n\n（2）apply 函数的实现步骤：\n\n * 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n * 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n * 将函数作为上下文对象的一个属性。\n * 判断参数值是否传入\n * 使用上下文对象来调用这个方法，并保存返回结果。\n * 删除刚才新增的属性\n * 返回结果\n\nFunction.prototype.myApply = function(context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== \"function\") {\n    throw new TypeError(\"Error\");\n  }\n  let result = null;\n  // 判断 context 是否存在，如果未传入则为 window\n  context = context || window;\n  // 将函数设为对象的方法\n  context.fn = this;\n  // 调用方法\n  if (arguments[1]) {\n    result = context.fn(...arguments[1]);\n  } else {\n    result = context.fn();\n  }\n  // 将属性删除\n  delete context.fn;\n  return result;\n};\n\n\n（3）bind 函数的实现步骤：\n\n * 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n * 保存当前函数的引用，获取其余传入参数值。\n * 创建一个函数返回\n * 函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。\n\nFunction.prototype.myBind = function(context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== \"function\") {\n    throw new TypeError(\"Error\");\n  }\n  // 获取参数\n  var args = [...arguments].slice(1),\n    fn = this;\n  return function Fn() {\n    // 根据调用方式，传入不同绑定值\n    return fn.apply(\n      this instanceof Fn ? this : context,\n      args.concat(...arguments)\n    );\n  };\n};\n",
      "normalizedContent": "# 1. 对this对象的理解\n\nthis 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。\n\n * 第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。\n * 第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。\n * 第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。\n * 第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。\n\n这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。\n\n\n# 2. call() 和 apply() 的区别？\n\n它们的作用一模一样，区别仅在于传入参数的形式的不同。\n\n * apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。\n * call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。\n\n\n# 3. 实现call、apply 及 bind 函数\n\n（1）call 函数的实现步骤：\n\n * 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n * 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n * 处理传入的参数，截取第一个参数后的所有参数。\n * 将函数作为上下文对象的一个属性。\n * 使用上下文对象来调用这个方法，并保存返回结果。\n * 删除刚才新增的属性。\n * 返回结果。\n\nfunction.prototype.mycall = function(context) {\n  // 判断调用对象\n  if (typeof this !== \"function\") {\n    console.error(\"type error\");\n  }\n  // 获取参数\n  let args = [...arguments].slice(1),\n    result = null;\n  // 判断 context 是否传入，如果未传入则设置为 window\n  context = context || window;\n  // 将调用函数设为对象的方法\n  context.fn = this;\n  // 调用函数\n  result = context.fn(...args);\n  // 将属性删除\n  delete context.fn;\n  return result;\n};\n\n\n（2）apply 函数的实现步骤：\n\n * 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n * 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n * 将函数作为上下文对象的一个属性。\n * 判断参数值是否传入\n * 使用上下文对象来调用这个方法，并保存返回结果。\n * 删除刚才新增的属性\n * 返回结果\n\nfunction.prototype.myapply = function(context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== \"function\") {\n    throw new typeerror(\"error\");\n  }\n  let result = null;\n  // 判断 context 是否存在，如果未传入则为 window\n  context = context || window;\n  // 将函数设为对象的方法\n  context.fn = this;\n  // 调用方法\n  if (arguments[1]) {\n    result = context.fn(...arguments[1]);\n  } else {\n    result = context.fn();\n  }\n  // 将属性删除\n  delete context.fn;\n  return result;\n};\n\n\n（3）bind 函数的实现步骤：\n\n * 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n * 保存当前函数的引用，获取其余传入参数值。\n * 创建一个函数返回\n * 函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。\n\nfunction.prototype.mybind = function(context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== \"function\") {\n    throw new typeerror(\"error\");\n  }\n  // 获取参数\n  var args = [...arguments].slice(1),\n    fn = this;\n  return function fn() {\n    // 根据调用方式，传入不同绑定值\n    return fn.apply(\n      this instanceof fn ? this : context,\n      args.concat(...arguments)\n    );\n  };\n};\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "执行上下文&作用域链&闭包",
      "frontmatter": {
        "title": "执行上下文&作用域链&闭包",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/context/",
        "article": false
      },
      "regularPath": "/20.%E9%AB%98%E9%A2%91%E7%AF%87/10.JavaScript%E7%AF%87/50.%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87&%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE&%E9%97%AD%E5%8C%85.html",
      "relativePath": "20.高频篇/10.JavaScript篇/50.执行上下文&作用域链&闭包.md",
      "key": "v-66ce963e",
      "path": "/pages/context/",
      "headers": [
        {
          "level": 3,
          "title": "1. 对闭包的理解",
          "slug": "_1-对闭包的理解",
          "normalizedTitle": "1. 对闭包的理解",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 对作用域、作用域链的理解",
          "slug": "_2-对作用域、作用域链的理解",
          "normalizedTitle": "2. 对作用域、作用域链的理解",
          "charIndex": 1203
        },
        {
          "level": 3,
          "title": "3. 对执行上下文的理解",
          "slug": "_3-对执行上下文的理解",
          "normalizedTitle": "3. 对执行上下文的理解",
          "charIndex": 1935
        }
      ],
      "headersStr": "1. 对闭包的理解 2. 对作用域、作用域链的理解 3. 对执行上下文的理解",
      "content": "# 1. 对闭包的理解\n\n闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。\n\n闭包有两个常用的用途；\n\n * 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。\n * 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\n\n比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。\n\nfunction A() {\n  let a = 1\n  window.B = function () {\n      console.log(a)\n  }\n}\nA()\nB() // 1\n\n\n在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题\n\nfor (var i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n\n\n首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。解决办法有三种：\n\n * 第一种是使用闭包的方式\n\nfor (var i = 1; i <= 5; i++) {  ;(function(j) {    setTimeout(function timer() {      console.log(j)    }, j * 1000)  })(i)}\n\n\n在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。\n\n * 第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。\n\nfor (var i = 1; i <= 5; i++) {\n  setTimeout(\n    function timer(j) {\n      console.log(j)\n    },\n    i * 1000,\n    i\n  )\n}\n\n\n * 第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式\n\nfor (let i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n\n\n\n# 2. 对作用域、作用域链的理解\n\n# 1）全局作用域和函数作用域\n\n（1）全局作用域\n\n * 最外层函数和最外层函数外面定义的变量拥有全局作用域\n * 所有未定义直接赋值的变量自动声明为全局作用域\n * 所有window对象的属性拥有全局作用域\n * 全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。\n\n（2）函数作用域\n\n * 函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到\n * 作用域是分层的，内层作用域可以访问外层作用域，反之不行\n\n# 2）块级作用域\n\n * 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由{ }包裹的代码片段）\n * let和const声明的变量不会有变量提升，也不可以重复声明\n * 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。\n\n作用域链： 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。\n\n作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。\n\n作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。\n\n当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。\n\n\n# 3. 对执行上下文的理解\n\n# 1. 执行上下文类型\n\n（1）全局执行上下文\n\n任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。\n\n（2）函数执行上下文\n\n当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。\n\n（3）eval函数执行上下文\n\n执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。\n\n# 2. 执行上下文栈\n\n * JavaScript引擎使用执行上下文栈来管理执行上下文\n * 当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。\n\nlet a = 'Hello World!';\nfunction first() {\n  console.log('Inside first function');\n  second();\n  console.log('Again inside first function');\n}\nfunction second() {\n  console.log('Inside second function');\n}\nfirst();\n//执行顺序\n//先执行second(),在执行first()\n\n\n# 3. 创建执行上下文\n\n创建执行上下文有两个阶段：创建阶段和执行阶段\n\n1）创建阶段\n\n（1）this绑定\n\n * 在全局执行上下文中，this指向全局对象（window对象）\n * 在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined\n\n（2）创建词法环境组件\n\n * 词法环境是一种有标识符——变量映射的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。\n * 词法环境的内部有两个组件：加粗样式：环境记录器:用来储存变量个函数声明的实际位置外部环境的引用：可以访问父级作用域\n\n（3）创建变量环境组件\n\n * 变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。\n\n2）执行阶段 此阶段会完成对变量的分配，最后执行完代码。\n\n简单来说执行上下文就是指：\n\n在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。\n\n在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。\n\n * 全局上下文：变量定义，函数声明\n * 函数上下文：变量定义，函数声明，this，arguments",
      "normalizedContent": "# 1. 对闭包的理解\n\n闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。\n\n闭包有两个常用的用途；\n\n * 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。\n * 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\n\n比如，函数 a 内部有一个函数 b，函数 b 可以访问到函数 a 中的变量，那么函数 b 就是闭包。\n\nfunction a() {\n  let a = 1\n  window.b = function () {\n      console.log(a)\n  }\n}\na()\nb() // 1\n\n\n在 js 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题\n\nfor (var i = 1; i <= 5; i++) {\n  settimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n\n\n首先因为 settimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。解决办法有三种：\n\n * 第一种是使用闭包的方式\n\nfor (var i = 1; i <= 5; i++) {  ;(function(j) {    settimeout(function timer() {      console.log(j)    }, j * 1000)  })(i)}\n\n\n在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。\n\n * 第二种就是使用 settimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。\n\nfor (var i = 1; i <= 5; i++) {\n  settimeout(\n    function timer(j) {\n      console.log(j)\n    },\n    i * 1000,\n    i\n  )\n}\n\n\n * 第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式\n\nfor (let i = 1; i <= 5; i++) {\n  settimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n\n\n\n# 2. 对作用域、作用域链的理解\n\n# 1）全局作用域和函数作用域\n\n（1）全局作用域\n\n * 最外层函数和最外层函数外面定义的变量拥有全局作用域\n * 所有未定义直接赋值的变量自动声明为全局作用域\n * 所有window对象的属性拥有全局作用域\n * 全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。\n\n（2）函数作用域\n\n * 函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到\n * 作用域是分层的，内层作用域可以访问外层作用域，反之不行\n\n# 2）块级作用域\n\n * 使用es6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由{ }包裹的代码片段）\n * let和const声明的变量不会有变量提升，也不可以重复声明\n * 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。\n\n作用域链： 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。\n\n作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。\n\n作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。\n\n当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。\n\n\n# 3. 对执行上下文的理解\n\n# 1. 执行上下文类型\n\n（1）全局执行上下文\n\n任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。\n\n（2）函数执行上下文\n\n当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。\n\n（3）eval函数执行上下文\n\n执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。\n\n# 2. 执行上下文栈\n\n * javascript引擎使用执行上下文栈来管理执行上下文\n * 当javascript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。\n\nlet a = 'hello world!';\nfunction first() {\n  console.log('inside first function');\n  second();\n  console.log('again inside first function');\n}\nfunction second() {\n  console.log('inside second function');\n}\nfirst();\n//执行顺序\n//先执行second(),在执行first()\n\n\n# 3. 创建执行上下文\n\n创建执行上下文有两个阶段：创建阶段和执行阶段\n\n1）创建阶段\n\n（1）this绑定\n\n * 在全局执行上下文中，this指向全局对象（window对象）\n * 在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined\n\n（2）创建词法环境组件\n\n * 词法环境是一种有标识符——变量映射的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。\n * 词法环境的内部有两个组件：加粗样式：环境记录器:用来储存变量个函数声明的实际位置外部环境的引用：可以访问父级作用域\n\n（3）创建变量环境组件\n\n * 变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。\n\n2）执行阶段 此阶段会完成对变量的分配，最后执行完代码。\n\n简单来说执行上下文就是指：\n\n在执行一点js代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。\n\n在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。\n\n * 全局上下文：变量定义，函数声明\n * 函数上下文：变量定义，函数声明，this，arguments",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "面向对象",
      "frontmatter": {
        "title": "面向对象",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/objectOriented/",
        "article": false
      },
      "regularPath": "/20.%E9%AB%98%E9%A2%91%E7%AF%87/10.JavaScript%E7%AF%87/80.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",
      "relativePath": "20.高频篇/10.JavaScript篇/80.面向对象.md",
      "key": "v-1f3ba745",
      "path": "/pages/objectOriented/",
      "headers": [
        {
          "level": 3,
          "title": "1. 对象创建的方式有哪些？",
          "slug": "_1-对象创建的方式有哪些",
          "normalizedTitle": "1. 对象创建的方式有哪些？",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 对象继承的方式有哪些？",
          "slug": "_2-对象继承的方式有哪些",
          "normalizedTitle": "2. 对象继承的方式有哪些？",
          "charIndex": 1281
        }
      ],
      "headersStr": "1. 对象创建的方式有哪些？ 2. 对象继承的方式有哪些？",
      "content": "# 1. 对象创建的方式有哪些？\n\n一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：\n\n（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。\n\n（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。\n\n（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。\n\n（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。\n\n（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。\n\n（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。\n\n\n# 2. 对象继承的方式有哪些？\n\n（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。\n\n（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。\n\n（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。\n\n（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。\n\n（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。\n\n（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。",
      "normalizedContent": "# 1. 对象创建的方式有哪些？\n\n一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 es6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：\n\n（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。\n\n（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。\n\n（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。\n\n（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。\n\n（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。\n\n（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。\n\n\n# 2. 对象继承的方式有哪些？\n\n（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。\n\n（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。\n\n（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。\n\n（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，es5 中定义的 object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。\n\n（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。\n\n（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "垃圾回收与内存泄漏",
      "frontmatter": {
        "title": "垃圾回收与内存泄漏",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/garbageCollection/",
        "article": false
      },
      "regularPath": "/20.%E9%AB%98%E9%A2%91%E7%AF%87/10.JavaScript%E7%AF%87/90.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.html",
      "relativePath": "20.高频篇/10.JavaScript篇/90.垃圾回收与内存泄漏.md",
      "key": "v-d591212e",
      "path": "/pages/garbageCollection/",
      "headers": [
        {
          "level": 3,
          "title": "1. 浏览器的垃圾回收机制",
          "slug": "_1-浏览器的垃圾回收机制",
          "normalizedTitle": "1. 浏览器的垃圾回收机制",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 哪些情况会导致内存泄漏",
          "slug": "_2-哪些情况会导致内存泄漏",
          "normalizedTitle": "2. 哪些情况会导致内存泄漏",
          "charIndex": 1501
        }
      ],
      "headersStr": "1. 浏览器的垃圾回收机制 2. 哪些情况会导致内存泄漏",
      "content": "# 1. 浏览器的垃圾回收机制\n\n# （1）垃圾回收的概念\n\n垃圾回收：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。\n\n回收机制：\n\n * Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。\n * JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。\n * 不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。\n\n# （2）垃圾回收的方式\n\n浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。\n\n1）标记清除\n\n * 标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。\n * 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。\n\n2）引用计数\n\n * 另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。\n * 这种方法会引起循环引用的问题：例如：obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。\n\nfunction fun() {\n    let obj1 = {};\n    let obj2 = {};\n    obj1.a = obj2; // obj1 引用 obj2\n    obj2.a = obj1; // obj2 引用 obj1\n}\n\n\n这种情况下，就要手动释放变量占用的内存：\n\nobj1.a =  null\nobj2.a =  null\n\n\n# （3）减少垃圾回收\n\n虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。\n\n * 对数组进行优化： 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。\n * 对object进行优化： 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。\n * 对函数进行优化： 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。\n\n\n# 2. 哪些情况会导致内存泄漏\n\n以下四种情况会造成内存的泄漏：\n\n * 意外的全局变量： 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\n * 被遗忘的计时器或回调函数： 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。\n * 脱离 DOM 的引用： 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。\n * 闭包： 不合理的使用闭包，从而导致某些变量一直被留在内存当中。",
      "normalizedContent": "# 1. 浏览器的垃圾回收机制\n\n# （1）垃圾回收的概念\n\n垃圾回收：javascript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。\n\n回收机制：\n\n * javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。\n * javascript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。\n * 不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。\n\n# （2）垃圾回收的方式\n\n浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。\n\n1）标记清除\n\n * 标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。\n * 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。\n\n2）引用计数\n\n * 另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。\n * 这种方法会引起循环引用的问题：例如：obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。\n\nfunction fun() {\n    let obj1 = {};\n    let obj2 = {};\n    obj1.a = obj2; // obj1 引用 obj2\n    obj2.a = obj1; // obj2 引用 obj1\n}\n\n\n这种情况下，就要手动释放变量占用的内存：\n\nobj1.a =  null\nobj2.a =  null\n\n\n# （3）减少垃圾回收\n\n虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。\n\n * 对数组进行优化： 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。\n * 对object进行优化： 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。\n * 对函数进行优化： 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。\n\n\n# 2. 哪些情况会导致内存泄漏\n\n以下四种情况会造成内存的泄漏：\n\n * 意外的全局变量： 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\n * 被遗忘的计时器或回调函数： 设置了 setinterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。\n * 脱离 dom 的引用： 获取一个 dom 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。\n * 闭包： 不合理的使用闭包，从而导致某些变量一直被留在内存当中。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "异步编程",
      "frontmatter": {
        "title": "异步编程",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/asynchronous/",
        "article": false
      },
      "regularPath": "/20.%E9%AB%98%E9%A2%91%E7%AF%87/10.JavaScript%E7%AF%87/70.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B.html",
      "relativePath": "20.高频篇/10.JavaScript篇/70.异步编程.md",
      "key": "v-15bd6f42",
      "path": "/pages/asynchronous/",
      "headers": [
        {
          "level": 3,
          "title": "1. 异步编程的实现方式？",
          "slug": "_1-异步编程的实现方式",
          "normalizedTitle": "1. 异步编程的实现方式？",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. setTimeout、Promise、Async/Await 的区别",
          "slug": "_2-settimeout、promise、async-await-的区别",
          "normalizedTitle": "2. settimeout、promise、async/await 的区别",
          "charIndex": 636
        },
        {
          "level": 3,
          "title": "3. 对Promise的理解",
          "slug": "_3-对promise的理解",
          "normalizedTitle": "3. 对promise的理解",
          "charIndex": 2388
        },
        {
          "level": 3,
          "title": "4. Promise的基本用法",
          "slug": "_4-promise的基本用法",
          "normalizedTitle": "4. promise的基本用法",
          "charIndex": 3775
        },
        {
          "level": 3,
          "title": "5. Promise解决了什么问题",
          "slug": "_5-promise解决了什么问题",
          "normalizedTitle": "5. promise解决了什么问题",
          "charIndex": 8550
        },
        {
          "level": 3,
          "title": "6. Promise.all和Promise.race的区别的使用场景",
          "slug": "_6-promise-all和promise-race的区别的使用场景",
          "normalizedTitle": "6. promise.all和promise.race的区别的使用场景",
          "charIndex": 9364
        },
        {
          "level": 3,
          "title": "7.  对async/await 的理解",
          "slug": "_7-对async-await-的理解",
          "normalizedTitle": "7.  对async/await 的理解",
          "charIndex": null
        },
        {
          "level": 3,
          "title": "8. await 到底在等啥？",
          "slug": "_8-await-到底在等啥",
          "normalizedTitle": "8. await 到底在等啥？",
          "charIndex": 10937
        },
        {
          "level": 3,
          "title": "9.  async/await的优势",
          "slug": "_9-async-await的优势",
          "normalizedTitle": "9.  async/await的优势",
          "charIndex": null
        },
        {
          "level": 3,
          "title": "10. async/await对比Promise的优势",
          "slug": "_10-async-await对比promise的优势",
          "normalizedTitle": "10. async/await对比promise的优势",
          "charIndex": 13787
        },
        {
          "level": 3,
          "title": "11. async/await 如何捕获异常",
          "slug": "_11-async-await-如何捕获异常",
          "normalizedTitle": "11. async/await 如何捕获异常",
          "charIndex": 14100
        }
      ],
      "headersStr": "1. 异步编程的实现方式？ 2. setTimeout、Promise、Async/Await 的区别 3. 对Promise的理解 4. Promise的基本用法 5. Promise解决了什么问题 6. Promise.all和Promise.race的区别的使用场景 7.  对async/await 的理解 8. await 到底在等啥？ 9.  async/await的优势 10. async/await对比Promise的优势 11. async/await 如何捕获异常",
      "content": "# 1. 异步编程的实现方式？\n\nJavaScript中的异步机制可以分为以下几种：\n\n * 回调函数 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。\n * Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。\n * generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。\n * async 函数 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。\n\n\n# 2. setTimeout、Promise、Async/Await 的区别\n\n# （1）setTimeout\n\nconsole.log('script start')\t//1. 打印 script start\nsetTimeout(function(){\n    console.log('settimeout')\t// 4. 打印 settimeout\n})\t// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数\nconsole.log('script end')\t//3. 打印 script start\n// 输出顺序：script start->script end->settimeout\n\n\n# （2）Promise\n\nPromise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。\n\nconsole.log('script start')\nlet promise1 = new Promise(function (resolve) {\n    console.log('promise1')\n    resolve()\n    console.log('promise1 end')\n}).then(function () {\n    console.log('promise2')\n})\nsetTimeout(function(){\n    console.log('settimeout')\n})\nconsole.log('script end')\n// 输出顺序: script start->promise1->promise1 end->script end->promise2->settimeout\n\n\n当JS主线程执行到Promise对象时：\n\n * promise1.then() 的回调就是一个 task\n * promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue\n * promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中\n * setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况\n\n# （3）async/await\n\nasync function async1(){\n   console.log('async1 start');\n    await async2();\n    console.log('async1 end')\n}\nasync function async2(){\n    console.log('async2')\n}\nconsole.log('script start');\nasync1();\nconsole.log('script end')\n// 输出顺序：script start->async1 start->async2->script end->async1 end\n\n\nasync 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。\n\n例如：\n\nasync function func1() {\n    return 1\n}\nconsole.log(func1())\n\n\nfunc1().then(res => {\n    console.log(res);  // 30\n})\n\n\nawait的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。\n\n\n# 3. 对Promise的理解\n\nPromise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。\n\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\n（1）Promise的实例有三个状态:\n\n * Pending（进行中）\n * Resolved（已完成）\n * Rejected（已拒绝）\n\n当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。\n\n（2）Promise的实例有两个过程：\n\n * pending -> fulfilled : Resolved（已完成）\n * pending -> rejected：Rejected（已拒绝）\n\n注意：一旦从进行状态变成为其他状态就永远不能更改状态了。\n\nPromise的特点：\n\n * 对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“承诺”；\n * 一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。\n\nPromise的缺点：\n\n * 无法取消Promise，一旦新建它就会立即执行，无法中途取消。\n * 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。\n * 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n\n总结： Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。\n\n状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。\n\n注意： 在构造 Promise 的时候，构造函数内部的代码是立即执行的\n\n\n# 4. Promise的基本用法\n\n# （1）创建Promise对象\n\nPromise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。\n\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。\n\nconst promise = new Promise(function(resolve, reject) {\n  // ... some code\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\n\n一般情况下都会使用new Promise()来创建promise对象，但是也可以使用promise.resolve和promise.reject这两个方法：\n\n * Promise.resolve\n\nPromise.resolve(value)的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：\n\nPromise.resolve(11).then(function(value){\n  console.log(value); // 打印出11\n});\n\n\nresolve(11)代码中，会让promise对象进入确定(resolve状态)，并将参数11传递给后面的then所指定的onFulfilled 函数；\n\n创建promise对象可以使用new Promise的形式创建对象，也可以使用Promise.resolve(value)的形式创建promise对象；\n\n * Promise.reject\n\nPromise.reject 也是new Promise的快捷形式，也创建一个promise对象。代码如下：\n\nPromise.reject(new Error(“我错了，请原谅俺！！”));\n\n\n就是下面的代码new Promise的简单形式：\n\nnew Promise(function(resolve,reject){\n   reject(new Error(\"我错了！\"));\n});\n\n\n下面是使用resolve方法和reject方法：\n\nfunction testPromise(ready) {\n  return new Promise(function(resolve,reject){\n    if(ready) {\n      resolve(\"hello world\");\n    }else {\n      reject(\"No thanks\");\n    }\n  });\n};\n// 方法调用\ntestPromise(true).then(function(msg){\n  console.log(msg);\n},function(error){\n  console.log(error);\n});\n\n\n上面的代码的含义是给testPromise方法传递一个参数，返回一个promise对象，如果为true的话，那么调用promise对象中的resolve()方法，并且把其中的参数传递给后面的then第一个函数内，因此打印出 “hello world”, 如果为false的话，会调用promise对象中的reject()方法，则会进入then的第二个函数内，会打印No thanks；\n\n# （2）Promise方法\n\nPromise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。\n\n 1. then()\n\n当Promise执行的内容符合成功条件时，调用resolve函数，失败就调用reject函数。Promise创建完了，那该如何调用呢？\n\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n\n\nthen方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中第二个参数可以省略。 then方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n\n当要写有顺序的异步事件时，需要串行时，可以这样写：\n\nlet promise = new Promise((resolve,reject)=>{\n    ajax('first').success(function(res){\n        resolve(res);\n    })\n})\npromise.then(res=>{\n    return new Promise((resovle,reject)=>{\n        ajax('second').success(function(res){\n            resolve(res)\n        })\n    })\n}).then(res=>{\n    return new Promise((resovle,reject)=>{\n        ajax('second').success(function(res){\n            resolve(res)\n        })\n    })\n}).then(res=>{\n    \n})\n\n\n那当要写的事件没有顺序或者关系时，还如何写呢？可以使用all 方法来解决。\n\n2. catch()\n\nPromise对象除了有then方法，还有一个catch方法，该方法相当于then方法的第二个参数，指向reject的回调函数。不过catch方法还有一个作用，就是在执行resolve回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入catch方法中。\n\np.then((data) => {\n     console.log('resolved',data);\n},(err) => {\n     console.log('rejected',err);\n     }\n); \np.then((data) => {\n    console.log('resolved',data);\n}).catch((err) => {\n    console.log('rejected',err);\n});\n\n\n3. all()\n\nall方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个promise对象。当数组中所有的promise的状态都达到resolved的时候，all方法的状态就会变成resolved，如果有一个状态变成了rejected，那么all方法的状态就会变成rejected。\n\njavascript\nlet promise1 = new Promise((resolve,reject)=>{\n\tsetTimeout(()=>{\n       resolve(1);\n\t},2000)\n});\nlet promise2 = new Promise((resolve,reject)=>{\n\tsetTimeout(()=>{\n       resolve(2);\n\t},1000)\n});\nlet promise3 = new Promise((resolve,reject)=>{\n\tsetTimeout(()=>{\n       resolve(3);\n\t},3000)\n});\nPromise.all([promise1,promise2,promise3]).then(res=>{\n    console.log(res);\n    //结果为：[1,2,3] \n})\n\n\n调用all方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象resolve执行时的值。\n\n（4）race()\n\nrace方法和all一样，接受的参数是一个每项都是promise的数组，但是与all不同的是，当最先执行完的事件执行完之后，就直接返回该promise对象的值。如果第一个promise对象状态变成resolved，那自身的状态变成了resolved；反之第一个promise变成rejected，那自身状态就会变成rejected。\n\nlet promise1 = new Promise((resolve,reject)=>{\n\tsetTimeout(()=>{\n       reject(1);\n\t},2000)\n});\nlet promise2 = new Promise((resolve,reject)=>{\n\tsetTimeout(()=>{\n       resolve(2);\n\t},1000)\n});\nlet promise3 = new Promise((resolve,reject)=>{\n\tsetTimeout(()=>{\n       resolve(3);\n\t},3000)\n});\nPromise.race([promise1,promise2,promise3]).then(res=>{\n\tconsole.log(res);\n\t//结果：2\n},rej=>{\n    console.log(rej)};\n)\n\n\n那么race方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：\n\nPromise.race([promise1,timeOutPromise(5000)]).then(res=>{})\n\n\n5. finally()\n\nfinally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\n\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n\n\n上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。\n\n下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。\n\nserver.listen(port)\n  .then(function () {\n    // ...\n  })\n  .finally(server.stop);\n\n\nfinally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。finally本质上是then方法的特例：\n\npromise\n.finally(() => {\n  // 语句\n});\n// 等同于\npromise\n.then(\n  result => {\n    // 语句\n    return result;\n  },\n  error => {\n    // 语句\n    throw error;\n  }\n);\n\n\n上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。\n\n\n# 5. Promise解决了什么问题\n\n在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：\n\nlet fs = require('fs')\nfs.readFile('./a.txt','utf8',function(err,data){\n  fs.readFile(data,'utf8',function(err,data){\n    fs.readFile(data,'utf8',function(err,data){\n      console.log(data)\n    })\n  })\n})\n\n\n上面的代码有如下缺点：\n\n * 后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。\n * 如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。\n\nPromise出现之后，代码变成这样：\n\nlet fs = require('fs')\nfunction read(url){\n  return new Promise((resolve,reject)=>{\n    fs.readFile(url,'utf8',function(error,data){\n      error && reject(error)\n      resolve(data)\n    })\n  })\n}\nread('./a.txt').then(data=>{\n  return read(data) \n}).then(data=>{\n  return read(data)  \n}).then(data=>{\n  console.log(data)\n})\n\n\n这样代码看起了就简洁了很多，解决了地狱回调的问题。\n\n\n# 6. Promise.all和Promise.race的区别的使用场景\n\n（1）Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。\n\nPromise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。\n\n需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。\n\n（2）Promise.race\n\n顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：\n\nPromise.race([promise1,timeOutPromise(5000)]).then(res=>{})\n\n\n\n# 7. 对async/await 的理解\n\nasync/await其实是Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么：\n\nasync function testAsy(){\n   return 'hello world';\n}\nlet result = testAsy(); \nconsole.log(result)\n\n\n所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。\n\nasync 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：then() 链来处理这个 Promise 对象，就像这样：\n\nasync function testAsy(){\n   return 'hello world'\n}\nlet result = testAsy() \nconsole.log(result)\nresult.then(v=>{\n    console.log(v)   // hello world\n})\n\n\n那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 Promise.resolve(undefined)。\n\n联想一下 Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。\n\n注意：Promise.resolve(x) 可以看作是 new Promise(resolve => resolve(x)) 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。\n\n\n# 8. await 到底在等啥？\n\nawait 在等待什么呢？ 一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。\n\n因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：\n\nfunction getSomething() {\n    return \"something\";\n}\nasync function testAsync() {\n    return Promise.resolve(\"hello async\");\n}\nasync function test() {\n    const v1 = await getSomething();\n    const v2 = await testAsync();\n    console.log(v1, v2);\n}\ntest();\n\n\nawait 表达式的运算结果取决于它等的是什么。\n\n * 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。\n * 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。\n\n来看一个例子：\n\nfunction testAsy(x){\n   return new Promise(resolve=>{setTimeout(() => {\n       resolve(x);\n     }, 3000)\n    }\n   )\n}\nasync function testAwt(){    \n  let result =  await testAsy('hello world');\n  console.log(result);    // 3秒钟之后出现hello world\n  console.log('cuger')   // 3秒钟之后出现cug\n}\ntestAwt();\nconsole.log('cug')  //立即输出cug\n\n\n这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以'cug''最先输出，hello world'和‘cuger’是3秒钟后同时出现的。\n\n\n# 9. async/await的优势\n\n单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。\n\n假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 setTimeout 来模拟异步操作：\n\n/**\n * 传入参数 n，表示这个函数执行的时间（毫秒）\n * 执行的结果是 n + 200，这个值将用于下一步骤\n */\nfunction takeLongTime(n) {\n    return new Promise(resolve => {\n        setTimeout(() => resolve(n + 200), n);\n    });\n}\nfunction step1(n) {\n    console.log(`step1 with ${n}`);\n    return takeLongTime(n);\n}\nfunction step2(n) {\n    console.log(`step2 with ${n}`);\n    return takeLongTime(n);\n}\nfunction step3(n) {\n    console.log(`step3 with ${n}`);\n    return takeLongTime(n);\n}\n\n\n现在用 Promise 方式来实现这三个步骤的处理：\n\nfunction doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    step1(time1)\n        .then(time2 => step2(time2))\n        .then(time3 => step3(time3))\n        .then(result => {\n            console.log(`result is ${result}`);\n            console.timeEnd(\"doIt\");\n        });\n}\ndoIt();\n// c:\\var\\test>node --harmony_async_await .\n// step1 with 300\n// step2 with 500\n// step3 with 700\n// result is 900\n// doIt: 1507.251ms\n\n\n输出结果 result 是 step3() 的参数 700 + 200 = 900。doIt() 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time()/console.timeEnd() 计算的结果一致。\n\n如果用 async/await 来实现呢，会是这样：\n\nasync function doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time2);\n    const result = await step3(time3);\n    console.log(`result is ${result}`);\n    console.timeEnd(\"doIt\");\n}\ndoIt();\n\n\n结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样\n\n\n# 10. async/await对比Promise的优势\n\n * 代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担\n * Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅\n * 错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余\n * 调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。\n\n\n# 11. async/await 如何捕获异常\n\nasync function fn(){\n    try{\n        let a = await Promise.reject('error')\n    }catch(error){\n        console.log(error)\n    }\n}\n",
      "normalizedContent": "# 1. 异步编程的实现方式？\n\njavascript中的异步机制可以分为以下几种：\n\n * 回调函数 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。\n * promise 的方式，使用 promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。\n * generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。\n * async 函数 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。\n\n\n# 2. settimeout、promise、async/await 的区别\n\n# （1）settimeout\n\nconsole.log('script start')\t//1. 打印 script start\nsettimeout(function(){\n    console.log('settimeout')\t// 4. 打印 settimeout\n})\t// 2. 调用 settimeout 函数，并定义其完成后执行的回调函数\nconsole.log('script end')\t//3. 打印 script start\n// 输出顺序：script start->script end->settimeout\n\n\n# （2）promise\n\npromise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个promise实例。\n\nconsole.log('script start')\nlet promise1 = new promise(function (resolve) {\n    console.log('promise1')\n    resolve()\n    console.log('promise1 end')\n}).then(function () {\n    console.log('promise2')\n})\nsettimeout(function(){\n    console.log('settimeout')\n})\nconsole.log('script end')\n// 输出顺序: script start->promise1->promise1 end->script end->promise2->settimeout\n\n\n当js主线程执行到promise对象时：\n\n * promise1.then() 的回调就是一个 task\n * promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue\n * promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中\n * settimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况\n\n# （3）async/await\n\nasync function async1(){\n   console.log('async1 start');\n    await async2();\n    console.log('async1 end')\n}\nasync function async2(){\n    console.log('async2')\n}\nconsole.log('script start');\nasync1();\nconsole.log('script end')\n// 输出顺序：script start->async1 start->async2->script end->async1 end\n\n\nasync 函数返回一个 promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。\n\n例如：\n\nasync function func1() {\n    return 1\n}\nconsole.log(func1())\n\n\nfunc1().then(res => {\n    console.log(res);  // 30\n})\n\n\nawait的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（promise对象）之后，才能继续执行下面的代码。await通过返回一个promise对象来实现同步的效果。\n\n\n# 3. 对promise的理解\n\npromise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。\n\n所谓promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，promise 是一个对象，从它可以获取异步操作的消息。promise 提供统一的 api，各种异步操作都可以用同样的方法进行处理。\n\n（1）promise的实例有三个状态:\n\n * pending（进行中）\n * resolved（已完成）\n * rejected（已拒绝）\n\n当把一件事情交给promise时，它的状态就是pending，任务完成了状态就变成了resolved、没有完成失败了就变成了rejected。\n\n（2）promise的实例有两个过程：\n\n * pending -> fulfilled : resolved（已完成）\n * pending -> rejected：rejected（已拒绝）\n\n注意：一旦从进行状态变成为其他状态就永远不能更改状态了。\n\npromise的特点：\n\n * 对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“承诺”；\n * 一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。\n\npromise的缺点：\n\n * 无法取消promise，一旦新建它就会立即执行，无法中途取消。\n * 如果不设置回调函数，promise内部抛出的错误，不会反应到外部。\n * 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n\n总结： promise 对象是异步编程的一种解决方案，最早由社区提出。promise 是一个构造函数，接收一个函数作为参数，返回一个 promise 实例。一个 promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。\n\n状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。\n\n注意： 在构造 promise 的时候，构造函数内部的代码是立即执行的\n\n\n# 4. promise的基本用法\n\n# （1）创建promise对象\n\npromise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。\n\npromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。\n\nconst promise = new promise(function(resolve, reject) {\n  // ... some code\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\n\n一般情况下都会使用new promise()来创建promise对象，但是也可以使用promise.resolve和promise.reject这两个方法：\n\n * promise.resolve\n\npromise.resolve(value)的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：\n\npromise.resolve(11).then(function(value){\n  console.log(value); // 打印出11\n});\n\n\nresolve(11)代码中，会让promise对象进入确定(resolve状态)，并将参数11传递给后面的then所指定的onfulfilled 函数；\n\n创建promise对象可以使用new promise的形式创建对象，也可以使用promise.resolve(value)的形式创建promise对象；\n\n * promise.reject\n\npromise.reject 也是new promise的快捷形式，也创建一个promise对象。代码如下：\n\npromise.reject(new error(“我错了，请原谅俺！！”));\n\n\n就是下面的代码new promise的简单形式：\n\nnew promise(function(resolve,reject){\n   reject(new error(\"我错了！\"));\n});\n\n\n下面是使用resolve方法和reject方法：\n\nfunction testpromise(ready) {\n  return new promise(function(resolve,reject){\n    if(ready) {\n      resolve(\"hello world\");\n    }else {\n      reject(\"no thanks\");\n    }\n  });\n};\n// 方法调用\ntestpromise(true).then(function(msg){\n  console.log(msg);\n},function(error){\n  console.log(error);\n});\n\n\n上面的代码的含义是给testpromise方法传递一个参数，返回一个promise对象，如果为true的话，那么调用promise对象中的resolve()方法，并且把其中的参数传递给后面的then第一个函数内，因此打印出 “hello world”, 如果为false的话，会调用promise对象中的reject()方法，则会进入then的第二个函数内，会打印no thanks；\n\n# （2）promise方法\n\npromise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。\n\n 1. then()\n\n当promise执行的内容符合成功条件时，调用resolve函数，失败就调用reject函数。promise创建完了，那该如何调用呢？\n\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n\n\nthen方法可以接受两个回调函数作为参数。第一个回调函数是promise对象的状态变为resolved时调用，第二个回调函数是promise对象的状态变为rejected时调用。其中第二个参数可以省略。 then方法返回的是一个新的promise实例（不是原来那个promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n\n当要写有顺序的异步事件时，需要串行时，可以这样写：\n\nlet promise = new promise((resolve,reject)=>{\n    ajax('first').success(function(res){\n        resolve(res);\n    })\n})\npromise.then(res=>{\n    return new promise((resovle,reject)=>{\n        ajax('second').success(function(res){\n            resolve(res)\n        })\n    })\n}).then(res=>{\n    return new promise((resovle,reject)=>{\n        ajax('second').success(function(res){\n            resolve(res)\n        })\n    })\n}).then(res=>{\n    \n})\n\n\n那当要写的事件没有顺序或者关系时，还如何写呢？可以使用all 方法来解决。\n\n2. catch()\n\npromise对象除了有then方法，还有一个catch方法，该方法相当于then方法的第二个参数，指向reject的回调函数。不过catch方法还有一个作用，就是在执行resolve回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入catch方法中。\n\np.then((data) => {\n     console.log('resolved',data);\n},(err) => {\n     console.log('rejected',err);\n     }\n); \np.then((data) => {\n    console.log('resolved',data);\n}).catch((err) => {\n    console.log('rejected',err);\n});\n\n\n3. all()\n\nall方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个promise对象。当数组中所有的promise的状态都达到resolved的时候，all方法的状态就会变成resolved，如果有一个状态变成了rejected，那么all方法的状态就会变成rejected。\n\njavascript\nlet promise1 = new promise((resolve,reject)=>{\n\tsettimeout(()=>{\n       resolve(1);\n\t},2000)\n});\nlet promise2 = new promise((resolve,reject)=>{\n\tsettimeout(()=>{\n       resolve(2);\n\t},1000)\n});\nlet promise3 = new promise((resolve,reject)=>{\n\tsettimeout(()=>{\n       resolve(3);\n\t},3000)\n});\npromise.all([promise1,promise2,promise3]).then(res=>{\n    console.log(res);\n    //结果为：[1,2,3] \n})\n\n\n调用all方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象resolve执行时的值。\n\n（4）race()\n\nrace方法和all一样，接受的参数是一个每项都是promise的数组，但是与all不同的是，当最先执行完的事件执行完之后，就直接返回该promise对象的值。如果第一个promise对象状态变成resolved，那自身的状态变成了resolved；反之第一个promise变成rejected，那自身状态就会变成rejected。\n\nlet promise1 = new promise((resolve,reject)=>{\n\tsettimeout(()=>{\n       reject(1);\n\t},2000)\n});\nlet promise2 = new promise((resolve,reject)=>{\n\tsettimeout(()=>{\n       resolve(2);\n\t},1000)\n});\nlet promise3 = new promise((resolve,reject)=>{\n\tsettimeout(()=>{\n       resolve(3);\n\t},3000)\n});\npromise.race([promise1,promise2,promise3]).then(res=>{\n\tconsole.log(res);\n\t//结果：2\n},rej=>{\n    console.log(rej)};\n)\n\n\n那么race方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：\n\npromise.race([promise1,timeoutpromise(5000)]).then(res=>{})\n\n\n5. finally()\n\nfinally方法用于指定不管 promise 对象最后状态如何，都会执行的操作。该方法是 es2018 引入标准的。\n\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n\n\n上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。\n\n下面是一个例子，服务器使用 promise 处理请求，然后使用finally方法关掉服务器。\n\nserver.listen(port)\n  .then(function () {\n    // ...\n  })\n  .finally(server.stop);\n\n\nfinally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 promise 的执行结果。finally本质上是then方法的特例：\n\npromise\n.finally(() => {\n  // 语句\n});\n// 等同于\npromise\n.then(\n  result => {\n    // 语句\n    return result;\n  },\n  error => {\n    // 语句\n    throw error;\n  }\n);\n\n\n上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。\n\n\n# 5. promise解决了什么问题\n\n在工作中经常会碰到这样一个需求，比如我使用ajax发一个a请求后，成功后拿到数据，需要把数据传给b请求；那么需要如下编写代码：\n\nlet fs = require('fs')\nfs.readfile('./a.txt','utf8',function(err,data){\n  fs.readfile(data,'utf8',function(err,data){\n    fs.readfile(data,'utf8',function(err,data){\n      console.log(data)\n    })\n  })\n})\n\n\n上面的代码有如下缺点：\n\n * 后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。\n * 如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。\n\npromise出现之后，代码变成这样：\n\nlet fs = require('fs')\nfunction read(url){\n  return new promise((resolve,reject)=>{\n    fs.readfile(url,'utf8',function(error,data){\n      error && reject(error)\n      resolve(data)\n    })\n  })\n}\nread('./a.txt').then(data=>{\n  return read(data) \n}).then(data=>{\n  return read(data)  \n}).then(data=>{\n  console.log(data)\n})\n\n\n这样代码看起了就简洁了很多，解决了地狱回调的问题。\n\n\n# 6. promise.all和promise.race的区别的使用场景\n\n（1）promise.all promise.all可以将多个promise实例包装成一个新的promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。\n\npromise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。\n\n需要注意，promise.all获得的成功结果的数组里面的数据顺序和promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用promise.all来解决。\n\n（2）promise.race\n\n顾名思义，promse.race就是赛跑的意思，意思就是说，promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：\n\npromise.race([promise1,timeoutpromise(5000)]).then(res=>{})\n\n\n\n# 7. 对async/await 的理解\n\nasync/await其实是generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么：\n\nasync function testasy(){\n   return 'hello world';\n}\nlet result = testasy(); \nconsole.log(result)\n\n\n所以，async 函数返回的是一个 promise 对象。async 函数（包含函数语句、函数表达式、lambda表达式）会返回一个 promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 promise.resolve() 封装成 promise 对象。\n\nasync 函数返回的是一个 promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：then() 链来处理这个 promise 对象，就像这样：\n\nasync function testasy(){\n   return 'hello world'\n}\nlet result = testasy() \nconsole.log(result)\nresult.then(v=>{\n    console.log(v)   // hello world\n})\n\n\n那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 promise.resolve(undefined)。\n\n联想一下 promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 promise 对象的函数并无二致。\n\n注意：promise.resolve(x) 可以看作是 new promise(resolve => resolve(x)) 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 promise 实例。\n\n\n# 8. await 到底在等啥？\n\nawait 在等待什么呢？ 一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 promise 对象或者其它值（换句话说，就是没有特殊限定）。\n\n因为 async 函数返回一个 promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：\n\nfunction getsomething() {\n    return \"something\";\n}\nasync function testasync() {\n    return promise.resolve(\"hello async\");\n}\nasync function test() {\n    const v1 = await getsomething();\n    const v2 = await testasync();\n    console.log(v1, v2);\n}\ntest();\n\n\nawait 表达式的运算结果取决于它等的是什么。\n\n * 如果它等到的不是一个 promise 对象，那 await 表达式的运算结果就是它等到的东西。\n * 如果它等到的是一个 promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。\n\n来看一个例子：\n\nfunction testasy(x){\n   return new promise(resolve=>{settimeout(() => {\n       resolve(x);\n     }, 3000)\n    }\n   )\n}\nasync function testawt(){    \n  let result =  await testasy('hello world');\n  console.log(result);    // 3秒钟之后出现hello world\n  console.log('cuger')   // 3秒钟之后出现cug\n}\ntestawt();\nconsole.log('cug')  //立即输出cug\n\n\n这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 promise 对象中异步执行。await暂停当前async的执行，所以'cug''最先输出，hello world'和‘cuger’是3秒钟后同时出现的。\n\n\n# 9. async/await的优势\n\n单一的 promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 promise 组成的 then 链的时候，优势就能体现出来了（很有意思，promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。\n\n假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 settimeout 来模拟异步操作：\n\n/**\n * 传入参数 n，表示这个函数执行的时间（毫秒）\n * 执行的结果是 n + 200，这个值将用于下一步骤\n */\nfunction takelongtime(n) {\n    return new promise(resolve => {\n        settimeout(() => resolve(n + 200), n);\n    });\n}\nfunction step1(n) {\n    console.log(`step1 with ${n}`);\n    return takelongtime(n);\n}\nfunction step2(n) {\n    console.log(`step2 with ${n}`);\n    return takelongtime(n);\n}\nfunction step3(n) {\n    console.log(`step3 with ${n}`);\n    return takelongtime(n);\n}\n\n\n现在用 promise 方式来实现这三个步骤的处理：\n\nfunction doit() {\n    console.time(\"doit\");\n    const time1 = 300;\n    step1(time1)\n        .then(time2 => step2(time2))\n        .then(time3 => step3(time3))\n        .then(result => {\n            console.log(`result is ${result}`);\n            console.timeend(\"doit\");\n        });\n}\ndoit();\n// c:\\var\\test>node --harmony_async_await .\n// step1 with 300\n// step2 with 500\n// step3 with 700\n// result is 900\n// doit: 1507.251ms\n\n\n输出结果 result 是 step3() 的参数 700 + 200 = 900。doit() 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time()/console.timeend() 计算的结果一致。\n\n如果用 async/await 来实现呢，会是这样：\n\nasync function doit() {\n    console.time(\"doit\");\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time2);\n    const result = await step3(time3);\n    console.log(`result is ${result}`);\n    console.timeend(\"doit\");\n}\ndoit();\n\n\n结果和之前的 promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样\n\n\n# 10. async/await对比promise的优势\n\n * 代码读起来更加同步，promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担\n * promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅\n * 错误处理友好，async/await可以⽤成熟的try/catch，promise的错误捕获⾮常冗余\n * 调试友好，promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。\n\n\n# 11. async/await 如何捕获异常\n\nasync function fn(){\n    try{\n        let a = await promise.reject('error')\n    }catch(error){\n        console.log(error)\n    }\n}\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "高频HTML",
      "frontmatter": {
        "title": "高频HTML",
        "date": "2022-10-18T21:31:15.000Z",
        "permalink": "/pages/highHtml/",
        "article": false
      },
      "regularPath": "/20.%E9%AB%98%E9%A2%91%E7%AF%87/20.HTML%E7%AF%87/10.%E9%AB%98%E9%A2%91HTML.html",
      "relativePath": "20.高频篇/20.HTML篇/10.高频HTML.md",
      "key": "v-5c7313b2",
      "path": "/pages/highHtml/",
      "headers": [
        {
          "level": 3,
          "title": "1. src和href的区别",
          "slug": "_1-src和href的区别",
          "normalizedTitle": "1. src和href的区别",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 对HTML语义化的理解",
          "slug": "_2-对html语义化的理解",
          "normalizedTitle": "2. 对html语义化的理解",
          "charIndex": 276
        },
        {
          "level": 3,
          "title": "3. DOCTYPE(⽂档类型) 的作⽤",
          "slug": "_3-doctype-文档类型-的作用",
          "normalizedTitle": "3. doctype(⽂档类型) 的作⽤",
          "charIndex": 679
        },
        {
          "level": 3,
          "title": "4. script标签中defer和async的区别",
          "slug": "_4-script标签中defer和async的区别",
          "normalizedTitle": "4. script标签中defer和async的区别",
          "charIndex": 1072
        },
        {
          "level": 3,
          "title": "5. 常⽤的meta标签有哪些",
          "slug": "_5-常用的meta标签有哪些",
          "normalizedTitle": "5. 常⽤的meta标签有哪些",
          "charIndex": 1449
        },
        {
          "level": 3,
          "title": "6. HTML5有哪些更新",
          "slug": "_6-html5有哪些更新",
          "normalizedTitle": "6. html5有哪些更新",
          "charIndex": 2401
        },
        {
          "level": 3,
          "title": "7. img的srcset属性的作⽤？",
          "slug": "_7-img的srcset属性的作用",
          "normalizedTitle": "7. img的srcset属性的作⽤？",
          "charIndex": 4972
        },
        {
          "level": 3,
          "title": "8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？",
          "slug": "_8-行内元素有哪些-块级元素有哪些-空-void-元素有那些",
          "normalizedTitle": "8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？",
          "charIndex": null
        },
        {
          "level": 3,
          "title": "9. 说一下 web worker",
          "slug": "_9-说一下-web-worker",
          "normalizedTitle": "9. 说一下 web worker",
          "charIndex": 6003
        },
        {
          "level": 3,
          "title": "10. HTML5的离线储存怎么使用，它的工作原理是什么",
          "slug": "_10-html5的离线储存怎么使用-它的工作原理是什么",
          "normalizedTitle": "10. html5的离线储存怎么使用，它的工作原理是什么",
          "charIndex": 6268
        },
        {
          "level": 3,
          "title": "11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？",
          "slug": "_11-浏览器是如何对-html5-的离线储存资源进行管理和加载",
          "normalizedTitle": "11. 浏览器是如何对 html5 的离线储存资源进行管理和加载？",
          "charIndex": 7508
        },
        {
          "level": 3,
          "title": "12. title与h1的区别、b与strong的区别、i与em的区别？",
          "slug": "_12-title与h1的区别、b与strong的区别、i与em的区别",
          "normalizedTitle": "12. title与h1的区别、b与strong的区别、i与em的区别？",
          "charIndex": 7808
        },
        {
          "level": 3,
          "title": "13. iframe 有那些优点和缺点？",
          "slug": "_13-iframe-有那些优点和缺点",
          "normalizedTitle": "13. iframe 有那些优点和缺点？",
          "charIndex": 8031
        },
        {
          "level": 3,
          "title": "14. label 的作用是什么？如何使用？",
          "slug": "_14-label-的作用是什么-如何使用",
          "normalizedTitle": "14. label 的作用是什么？如何使用？",
          "charIndex": 8212
        },
        {
          "level": 3,
          "title": "15. Canvas和SVG的区别",
          "slug": "_15-canvas和svg的区别",
          "normalizedTitle": "15. canvas和svg的区别",
          "charIndex": 8437
        },
        {
          "level": 3,
          "title": "16. head 标签有什么作用，其中什么标签必不可少？",
          "slug": "_16-head-标签有什么作用-其中什么标签必不可少",
          "normalizedTitle": "16. head 标签有什么作用，其中什么标签必不可少？",
          "charIndex": 9006
        },
        {
          "level": 3,
          "title": "17. 文档声明（Doctype）和<!Doctype html>有何作用? 严格模式与混杂模式如何区分？它们有何意义?",
          "slug": "_17-文档声明-doctype-和-doctype-html-有何作用-严格模式与混杂模式如何区分-它们有何意义",
          "normalizedTitle": "17. 文档声明（doctype）和&lt;!doctype html&gt;有何作用? 严格模式与混杂模式如何区分？它们有何意义?",
          "charIndex": null
        },
        {
          "level": 3,
          "title": "18. 浏览器乱码的原因是什么？如何解决？",
          "slug": "_18-浏览器乱码的原因是什么-如何解决",
          "normalizedTitle": "18. 浏览器乱码的原因是什么？如何解决？",
          "charIndex": 10063
        },
        {
          "level": 3,
          "title": "19. 渐进增强和优雅降级之间的区别",
          "slug": "_19-渐进增强和优雅降级之间的区别",
          "normalizedTitle": "19. 渐进增强和优雅降级之间的区别",
          "charIndex": 10362
        },
        {
          "level": 3,
          "title": "20. 说一下 HTML5 drag API",
          "slug": "_20-说一下-html5-drag-api",
          "normalizedTitle": "20. 说一下 html5 drag api",
          "charIndex": 11095
        }
      ],
      "headersStr": "1. src和href的区别 2. 对HTML语义化的理解 3. DOCTYPE(⽂档类型) 的作⽤ 4. script标签中defer和async的区别 5. 常⽤的meta标签有哪些 6. HTML5有哪些更新 7. img的srcset属性的作⽤？ 8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 9. 说一下 web worker 10. HTML5的离线储存怎么使用，它的工作原理是什么 11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？ 12. title与h1的区别、b与strong的区别、i与em的区别？ 13. iframe 有那些优点和缺点？ 14. label 的作用是什么？如何使用？ 15. Canvas和SVG的区别 16. head 标签有什么作用，其中什么标签必不可少？ 17. 文档声明（Doctype）和<!Doctype html>有何作用? 严格模式与混杂模式如何区分？它们有何意义? 18. 浏览器乱码的原因是什么？如何解决？ 19. 渐进增强和优雅降级之间的区别 20. 说一下 HTML5 drag API",
      "content": "# 1. src和href的区别\n\nsrc和href都是用来引用外部的资源，它们的区别如下：\n\n * src： 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。\n * href： 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。\n\n\n# 2. 对HTML语义化的理解\n\n语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。\n\n语义化的优点如下：\n\n * 对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；\n * 对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。\n\n常见的语义化标签：\n\n<header></header>  头部\n\n<nav></nav>  导航栏\n\n<section></section>  区块（有语义化的div）\n\n<main></main>  主要区域\n\n<article></article>  主要内容\n\n<aside></aside>  侧边栏\n\n<footer></footer>  底部\n\n\n\n# 3. DOCTYPE(⽂档类型) 的作⽤\n\nDOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。\n\n浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是CSS1Compat）：\n\n * CSS1Compat：标准模式（Strick mode），默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。\n * BackCompat：怪异模式(混杂模式)(Quick mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。\n\n\n# 4. script标签中defer和async的区别\n\n如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。\n\ndefer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析，其区别如下：\n\n * 执行顺序： 多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；\n * **脚本是否并行执行：*async属性，表示*后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。\n\n\n# 5. 常⽤的meta标签有哪些\n\nmeta 标签由 name 和 content 属性定义，用来描述网页文档的属性，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些name作为大家使用的共识，开发者还可以自定义name。\n\n常用的meta标签： （1）charset，用来描述HTML文档的编码类型：\n\n<meta charset=\"UTF-8\" >\n\n\n（2） keywords，页面关键词：\n\n<meta name=\"keywords\" content=\"关键词\" />\n\n\n（3）description，页面描述：\n\n<meta name=\"description\" content=\"页面描述内容\" />\n\n\n（4）refresh，页面重定向和刷新：\n\n<meta http-equiv=\"refresh\" content=\"0;url=\" />\n\n\n（5）viewport，适配移动端，可以控制视口的大小和比例：\n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">\n\n\n其中，content 参数有以下几种：\n\n * width viewport ：宽度(数值/device-width)\n * height viewport ：高度(数值/device-height)\n * initial-scale ：初始缩放比例\n * maximum-scale ：最大缩放比例\n * minimum-scale ：最小缩放比例\n * user-scalable ：是否允许用户缩放(yes/no）\n\n（6）搜索引擎索引方式：\n\n<meta name=\"robots\" content=\"index,follow\" />\n\n\n其中，content 参数有以下几种：\n\n * all：文件将被检索，且页面上的链接可以被查询；\n * none：文件将不被检索，且页面上的链接不可以被查询；\n * index：文件将被检索；\n * follow：页面上的链接可以被查询；\n * noindex：文件将不被检索；\n * nofollow：页面上的链接不可以被查询。\n\n\n# 6. HTML5有哪些更新\n\n# 1. 语义化标签\n\n * header：定义文档的页眉（头部）；\n * nav：定义导航链接的部分；\n * footer：定义文档或节的页脚（底部）；\n * article：定义文章内容；\n * section：定义文档中的节（section、区段）；\n * aside：定义其所处内容之外的内容（侧边）；\n\n# 2. 媒体标签\n\n（1） audio：音频\n\n<audio src='' controls autoplay loop='true'></audio>\n\n\n属性：\n\n * controls 控制面板\n * autoplay 自动播放\n * loop=‘true’ 循环播放\n\n（2）video视频\n\n<video src='' poster='imgs/aa.jpg' controls></video>\n\n\n属性：\n\n * poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。\n * controls 控制面板\n * width\n * height\n\n（3）source标签 因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。\n\n<video>\n \t<source src='aa.flv' type='video/flv'></source>\n \t<source src='aa.mp4' type='video/mp4'></source>\n</video>\n\n\n# 3. 表单\n\n表单类型：\n\n * email ：能够验证当前输入的邮箱地址是否合法\n * url ： 验证URL\n * number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。\n * search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。\n * range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值\n * color ： 提供了一个颜色拾取器\n * time ： 时分秒\n * data ： 日期选择年月日\n * datatime ： 时间和日期(目前只有Safari支持)\n * datatime-local ：日期时间控件\n * week ：周控件\n * month：月控件\n\n表单属性：\n\n * placeholder ：提示信息\n * autofocus ：自动获取焦点\n * autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：\n   * 表单必须提交过\n   * 必须有name属性。\n * required：要求输入框不能为空，必须有值才能够提交。\n * pattern=\" \" 里面写入想要的正则模式，例如手机号patte=\"^(+86)?\\d{10}$\"\n * multiple：可以选择多个文件或者多个邮箱\n * form=\" form表单的ID\"\n\n表单事件：\n\n * oninput 每当input里的输入框内容发生变化都会触发此事件。\n * oninvalid 当验证不通过时触发此事件。\n\n# 4. 进度条、度量器\n\n * progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少\n * meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）\n   * high/low：规定被视作高/低的范围\n   * max/min：规定最大/小值\n   * value：规定当前度量值\n\n设置规则：min < low < high < max\n\n# 5.DOM查询操作\n\n * document.querySelector()\n * document.querySelectorAll()\n\n它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)\n\n# 6. Web存储\n\nHTML5 提供了两种在客户端存储数据的新方法：\n\n * localStorage - 没有时间限制的数据存储\n * sessionStorage - 针对一个 session 的数据存储\n\n# 7. 其他\n\n * 拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：\n\n<img draggable=\"true\" />\n\n\n * 画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。\n\n<canvas id=\"myCanvas\" width=\"200\" height=\"100\"></canvas>\n\n\n * SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准\n * 地理定位：Geolocation（地理定位）用于定位用户的位置。‘\n\n总结： （1）新增语义化标签：nav、header、footer、aside、section、article （2）音频、视频标签：audio、video （3）数据存储：localStorage、sessionStorage （4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议） （5）input标签新增属性：placeholder、autocomplete、autofocus、required （6）history API：go、forward、back、pushstate\n\n移除的元素有：\n\n * 纯表现的元素：basefont，big，center，font, s，strike，tt，u;\n * 对可用性产生负面影响的元素：frame，frameset，noframes；\n\n\n# 7. img的srcset属性的作⽤？\n\n响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：\n\n<img src=\"image-128.png\" srcset=\"image-256.png 2x\" />\n\n\n使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。\n\n按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：\n\n<img src=\"image-128.png\"\n     srcset=\"image-128.png 128w, image-256.png 256w, image-512.png 512w\"\n     sizes=\"(max-width: 360px) 340px, 128px\" />\n\n\n其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。\n\nsizes语法如下：\n\nsizes=\"[media query] [length], [media query] [length] ... \"\n\n\nsizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。\n\n\n# 8. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？\n\n * 行内元素有：a b span img input select strong；\n * 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p；\n\n空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：\n\n * 常见的有：<br>、<hr>、<img>、<input>、<link>、<meta>；\n * 鲜见的有：<area>、<base>、<col>、<colgroup>、<command>、<embed>、<keygen>、<param>、<source>、<track>、<wbr>。\n\n\n# 9. 说一下 web worker\n\n在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。\n\n如何创建 web worker：\n\n 1. 检测浏览器对于 web worker 的支持性\n 2. 创建 web worker 文件（js，回传函数等）\n 3. 创建 web worker 对象\n\n\n# 10. HTML5的离线储存怎么使用，它的工作原理是什么\n\n离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n\n**原理：**HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示\n\n使用方法： （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：\n\n<html lang=\"en\" manifest=\"index.manifest\">\n\n\n（2）在 cache.manifest 文件中编写需要离线存储的资源：\n\nCACHE MANIFEST\n    #v0.11\n    CACHE:\n    js/app.js\n    css/style.css\n    NETWORK:\n    resourse/logo.png\n    FALLBACK:\n    / /offline.html\n\n\n * CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。\n * NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。\n * FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。\n\n（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。\n\n如何更新缓存：\n\n（1）更新 manifest 文件\n\n（2）通过 javascript 操作\n\n（3）清除浏览器缓存\n\n注意事项：\n\n（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。\n\n（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。\n\n（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。\n\n（4）FALLBACK 中的资源必须和 manifest 文件同源。\n\n（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。\n\n（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。\n\n（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。\n\n\n# 11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？\n\n * 在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。\n * 离线的情况下，浏览器会直接使用离线存储的资源。\n\n\n# 12. title与h1的区别、b与strong的区别、i与em的区别？\n\n * strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。\n * title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响\n * i内容展示为斜体，em表示强调的文本\n\n\n# 13. iframe 有那些优点和缺点？\n\niframe 元素会创建包含另外一个文档的内联框架（即行内框架）。\n\n优点：\n\n * 用来加载速度较慢的内容（如广告）\n * 可以使脚本可以并行下载\n * 可以实现跨子域通信\n\n缺点：\n\n * iframe 会阻塞主页面的 onload 事件\n * 无法被一些搜索引擎索识别\n * 会产生很多页面，不容易管理\n\n\n# 14. label 的作用是什么？如何使用？\n\nlabel标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。\n\n * 使用方法1：\n\n<label for=\"mobile\">Number:</label>\n<input type=\"text\" id=\"mobile\"/>\n\n\n * 使用方法2：\n\n<label>Date:<input type=\"text\"/></label>\n\n\n\n# 15. Canvas和SVG的区别\n\n（1）SVG： SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。\n\n其特点如下：\n\n * 不依赖分辨率\n * 支持事件处理器\n * 最适合带有大型渲染区域的应用程序（比如谷歌地图）\n * 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）\n * 不适合游戏应用\n\n（2）Canvas： Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。\n\n其特点如下：\n\n * 依赖分辨率\n * 不支持事件处理器\n * 弱的文本渲染能力\n * 能够以 .png 或 .jpg 格式保存结果图像\n * 最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n\n注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。\n\n\n# 16. head 标签有什么作用，其中什么标签必不可少？\n\n标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。\n\n文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。\n\n下面这些标签可用在 head 部分：<base>, <link>, <meta>, <script>, <style>, <title>。\n\n其中 <title> 定义文档的标题，它是 head 部分中唯一必需的元素。\n\n\n# 17. 文档声明（Doctype）和<!Doctype html>有何作用? 严格模式与混杂模式如何区分？它们有何意义?\n\n文档声明的作用： 文档声明是为了告诉浏览器，当前HTML文档使用什么版本的HTML来写的，这样浏览器才能按照声明的版本来正确的解析。\n\n<!Doctype html>的作用：<!doctype html> 的作用就是让浏览器进入标准模式，使用最新的 HTML5 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。\n\n严格模式与混杂模式的区分：\n\n * 严格模式： 又称为标准模式，指浏览器按照W3C标准解析代码；\n * 混杂模式： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；\n\n区分：网页中的DTD，直接影响到使用的是严格模式还是浏览模式，可以说DTD的使用与这两种方式的区别息息相关。\n\n * 如果文档包含严格的DOCTYPE ，那么它一般以严格模式呈现（严格 DTD ——严格模式）；\n * 包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）；\n * DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现（DTD不存在或者格式不正确——混杂模式）；\n * HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(HTML5 没有严格和混杂之分)。\n\n总之，严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。\n\n\n# 18. 浏览器乱码的原因是什么？如何解决？\n\n产生乱码的原因：\n\n * 网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码；\n * html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码；\n * 浏览器不能自动检测网页编码，造成网页乱码。\n\n解决办法：\n\n * 使用软件编辑HTML网页内容；\n * 如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码；\n * 如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。\n\n\n# 19. 渐进增强和优雅降级之间的区别\n\n（1）渐进增强（progressive enhancement）：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。\n\n（2）优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。\n\n两者区别：\n\n * 优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；\n * 降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。\n\n“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。\n\n“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。\n\n\n# 20. 说一下 HTML5 drag API\n\n * dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。\n * darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。\n * dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。\n * dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。\n * dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。\n * drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。\n * dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。",
      "normalizedContent": "# 1. src和href的区别\n\nsrc和href都是用来引用外部的资源，它们的区别如下：\n\n * src： 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。\n * href： 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。\n\n\n# 2. 对html语义化的理解\n\n语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。\n\n语义化的优点如下：\n\n * 对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于seo。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；\n * 对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。\n\n常见的语义化标签：\n\n<header></header>  头部\n\n<nav></nav>  导航栏\n\n<section></section>  区块（有语义化的div）\n\n<main></main>  主要区域\n\n<article></article>  主要内容\n\n<aside></aside>  侧边栏\n\n<footer></footer>  底部\n\n\n\n# 3. doctype(⽂档类型) 的作⽤\n\ndoctype是html5中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 css 代码甚⾄ javascript 脚本的解析。它必须声明在html⽂档的第⼀⾏。\n\n浏览器渲染页面的两种模式（可通过document.compatmode获取，比如，语雀官网的文档类型是css1compat）：\n\n * css1compat：标准模式（strick mode），默认模式，浏览器使用w3c的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。\n * backcompat：怪异模式(混杂模式)(quick mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。\n\n\n# 4. script标签中defer和async的区别\n\n如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。\n\ndefer 和 async属性都是去异步加载外部的js脚本文件，它们都不会阻塞页面的解析，其区别如下：\n\n * 执行顺序： 多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；\n * **脚本是否并行执行：*async属性，表示*后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，domcontentloaded事件触发执行之前。\n\n\n# 5. 常⽤的meta标签有哪些\n\nmeta 标签由 name 和 content 属性定义，用来描述网页文档的属性，比如网页的作者，网页描述，关键词等，除了http标准固定了一些name作为大家使用的共识，开发者还可以自定义name。\n\n常用的meta标签： （1）charset，用来描述html文档的编码类型：\n\n<meta charset=\"utf-8\" >\n\n\n（2） keywords，页面关键词：\n\n<meta name=\"keywords\" content=\"关键词\" />\n\n\n（3）description，页面描述：\n\n<meta name=\"description\" content=\"页面描述内容\" />\n\n\n（4）refresh，页面重定向和刷新：\n\n<meta http-equiv=\"refresh\" content=\"0;url=\" />\n\n\n（5）viewport，适配移动端，可以控制视口的大小和比例：\n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">\n\n\n其中，content 参数有以下几种：\n\n * width viewport ：宽度(数值/device-width)\n * height viewport ：高度(数值/device-height)\n * initial-scale ：初始缩放比例\n * maximum-scale ：最大缩放比例\n * minimum-scale ：最小缩放比例\n * user-scalable ：是否允许用户缩放(yes/no）\n\n（6）搜索引擎索引方式：\n\n<meta name=\"robots\" content=\"index,follow\" />\n\n\n其中，content 参数有以下几种：\n\n * all：文件将被检索，且页面上的链接可以被查询；\n * none：文件将不被检索，且页面上的链接不可以被查询；\n * index：文件将被检索；\n * follow：页面上的链接可以被查询；\n * noindex：文件将不被检索；\n * nofollow：页面上的链接不可以被查询。\n\n\n# 6. html5有哪些更新\n\n# 1. 语义化标签\n\n * header：定义文档的页眉（头部）；\n * nav：定义导航链接的部分；\n * footer：定义文档或节的页脚（底部）；\n * article：定义文章内容；\n * section：定义文档中的节（section、区段）；\n * aside：定义其所处内容之外的内容（侧边）；\n\n# 2. 媒体标签\n\n（1） audio：音频\n\n<audio src='' controls autoplay loop='true'></audio>\n\n\n属性：\n\n * controls 控制面板\n * autoplay 自动播放\n * loop=‘true’ 循环播放\n\n（2）video视频\n\n<video src='' poster='imgs/aa.jpg' controls></video>\n\n\n属性：\n\n * poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。\n * controls 控制面板\n * width\n * height\n\n（3）source标签 因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。\n\n<video>\n \t<source src='aa.flv' type='video/flv'></source>\n \t<source src='aa.mp4' type='video/mp4'></source>\n</video>\n\n\n# 3. 表单\n\n表单类型：\n\n * email ：能够验证当前输入的邮箱地址是否合法\n * url ： 验证url\n * number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。\n * search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。\n * range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值\n * color ： 提供了一个颜色拾取器\n * time ： 时分秒\n * data ： 日期选择年月日\n * datatime ： 时间和日期(目前只有safari支持)\n * datatime-local ：日期时间控件\n * week ：周控件\n * month：月控件\n\n表单属性：\n\n * placeholder ：提示信息\n * autofocus ：自动获取焦点\n * autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：\n   * 表单必须提交过\n   * 必须有name属性。\n * required：要求输入框不能为空，必须有值才能够提交。\n * pattern=\" \" 里面写入想要的正则模式，例如手机号patte=\"^(+86)?\\d{10}$\"\n * multiple：可以选择多个文件或者多个邮箱\n * form=\" form表单的id\"\n\n表单事件：\n\n * oninput 每当input里的输入框内容发生变化都会触发此事件。\n * oninvalid 当验证不通过时触发此事件。\n\n# 4. 进度条、度量器\n\n * progress标签：用来表示任务的进度（ie、safari不支持），max用来表示任务的进度，value表示已完成多少\n * meter属性：用来显示剩余容量或剩余库存（ie、safari不支持）\n   * high/low：规定被视作高/低的范围\n   * max/min：规定最大/小值\n   * value：规定当前度量值\n\n设置规则：min < low < high < max\n\n# 5.dom查询操作\n\n * document.queryselector()\n * document.queryselectorall()\n\n它们选择的对象可以是标签，可以是类(需要加点)，可以是id(需要加#)\n\n# 6. web存储\n\nhtml5 提供了两种在客户端存储数据的新方法：\n\n * localstorage - 没有时间限制的数据存储\n * sessionstorage - 针对一个 session 的数据存储\n\n# 7. 其他\n\n * 拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：\n\n<img draggable=\"true\" />\n\n\n * 画布（canvas ）： canvas 元素使用 javascript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。\n\n<canvas id=\"mycanvas\" width=\"200\" height=\"100\"></canvas>\n\n\n * svg：svg 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 xml 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准\n * 地理定位：geolocation（地理定位）用于定位用户的位置。‘\n\n总结： （1）新增语义化标签：nav、header、footer、aside、section、article （2）音频、视频标签：audio、video （3）数据存储：localstorage、sessionstorage （4）canvas（画布）、geolocation（地理定位）、websocket（通信协议） （5）input标签新增属性：placeholder、autocomplete、autofocus、required （6）history api：go、forward、back、pushstate\n\n移除的元素有：\n\n * 纯表现的元素：basefont，big，center，font, s，strike，tt，u;\n * 对可用性产生负面影响的元素：frame，frameset，noframes；\n\n\n# 7. img的srcset属性的作⽤？\n\n响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：\n\n<img src=\"image-128.png\" srcset=\"image-256.png 2x\" />\n\n\n使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。\n\n按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：\n\n<img src=\"image-128.png\"\n     srcset=\"image-128.png 128w, image-256.png 256w, image-512.png 512w\"\n     sizes=\"(max-width: 360px) 340px, 128px\" />\n\n\n其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。\n\nsizes语法如下：\n\nsizes=\"[media query] [length], [media query] [length] ... \"\n\n\nsizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。\n\n\n# 8. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？\n\n * 行内元素有：a b span img input select strong；\n * 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p；\n\n空元素，即没有内容的html元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：\n\n * 常见的有：<br>、<hr>、<img>、<input>、<link>、<meta>；\n * 鲜见的有：<area>、<base>、<col>、<colgroup>、<command>、<embed>、<keygen>、<param>、<source>、<track>、<wbr>。\n\n\n# 9. 说一下 web worker\n\n在 html 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postmessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。\n\n如何创建 web worker：\n\n 1. 检测浏览器对于 web worker 的支持性\n 2. 创建 web worker 文件（js，回传函数等）\n 3. 创建 web worker 对象\n\n\n# 10. html5的离线储存怎么使用，它的工作原理是什么\n\n离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n\n**原理：**html5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示\n\n使用方法： （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：\n\n<html lang=\"en\" manifest=\"index.manifest\">\n\n\n（2）在 cache.manifest 文件中编写需要离线存储的资源：\n\ncache manifest\n    #v0.11\n    cache:\n    js/app.js\n    css/style.css\n    network:\n    resourse/logo.png\n    fallback:\n    / /offline.html\n\n\n * cache: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。\n * network: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 cache 和 network 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 cache 的优先级更高。\n * fallback: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。\n\n（3）在离线状态时，操作 window.applicationcache 进行离线缓存的操作。\n\n如何更新缓存：\n\n（1）更新 manifest 文件\n\n（2）通过 javascript 操作\n\n（3）清除浏览器缓存\n\n注意事项：\n\n（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5mb）。\n\n（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。\n\n（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。\n\n（4）fallback 中的资源必须和 manifest 文件同源。\n\n（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。\n\n（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。\n\n（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。\n\n\n# 11. 浏览器是如何对 html5 的离线储存资源进行管理和加载？\n\n * 在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。\n * 离线的情况下，浏览器会直接使用离线存储的资源。\n\n\n# 12. title与h1的区别、b与strong的区别、i与em的区别？\n\n * strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。\n * title属性没有明确意义只表示是个标题，h1则表示层次明确的标题，对页面信息的抓取有很大的影响\n * i内容展示为斜体，em表示强调的文本\n\n\n# 13. iframe 有那些优点和缺点？\n\niframe 元素会创建包含另外一个文档的内联框架（即行内框架）。\n\n优点：\n\n * 用来加载速度较慢的内容（如广告）\n * 可以使脚本可以并行下载\n * 可以实现跨子域通信\n\n缺点：\n\n * iframe 会阻塞主页面的 onload 事件\n * 无法被一些搜索引擎索识别\n * 会产生很多页面，不容易管理\n\n\n# 14. label 的作用是什么？如何使用？\n\nlabel标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。\n\n * 使用方法1：\n\n<label for=\"mobile\">number:</label>\n<input type=\"text\" id=\"mobile\"/>\n\n\n * 使用方法2：\n\n<label>date:<input type=\"text\"/></label>\n\n\n\n# 15. canvas和svg的区别\n\n（1）svg： svg可缩放矢量图形（scalable vector graphics）是基于可扩展标记语言xml描述的2d图形的语言，svg基于xml就意味着svg dom中的每个元素都是可用的，可以为某个元素附加javascript事件处理器。在 svg 中，每个被绘制的图形均被视为对象。如果 svg 对象的属性发生变化，那么浏览器能够自动重现图形。\n\n其特点如下：\n\n * 不依赖分辨率\n * 支持事件处理器\n * 最适合带有大型渲染区域的应用程序（比如谷歌地图）\n * 复杂度高会减慢渲染速度（任何过度使用 dom 的应用都不快）\n * 不适合游戏应用\n\n（2）canvas： canvas是画布，通过javascript来绘制2d图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。\n\n其特点如下：\n\n * 依赖分辨率\n * 不支持事件处理器\n * 弱的文本渲染能力\n * 能够以 .png 或 .jpg 格式保存结果图像\n * 最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n\n注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。\n\n\n# 16. head 标签有什么作用，其中什么标签必不可少？\n\n标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。\n\n文档的头部描述了文档的各种属性和信息，包括文档的标题、在 web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。\n\n下面这些标签可用在 head 部分：<base>, <link>, <meta>, <script>, <style>, <title>。\n\n其中 <title> 定义文档的标题，它是 head 部分中唯一必需的元素。\n\n\n# 17. 文档声明（doctype）和<!doctype html>有何作用? 严格模式与混杂模式如何区分？它们有何意义?\n\n文档声明的作用： 文档声明是为了告诉浏览器，当前html文档使用什么版本的html来写的，这样浏览器才能按照声明的版本来正确的解析。\n\n<!doctype html>的作用：<!doctype html> 的作用就是让浏览器进入标准模式，使用最新的 html5 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。\n\n严格模式与混杂模式的区分：\n\n * 严格模式： 又称为标准模式，指浏览器按照w3c标准解析代码；\n * 混杂模式： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；\n\n区分：网页中的dtd，直接影响到使用的是严格模式还是浏览模式，可以说dtd的使用与这两种方式的区别息息相关。\n\n * 如果文档包含严格的doctype ，那么它一般以严格模式呈现（严格 dtd ——严格模式）；\n * 包含过渡 dtd 和 uri 的 doctype ，也以严格模式呈现，但有过渡 dtd 而没有 uri （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（有 uri 的过渡 dtd ——严格模式；没有 uri 的过渡 dtd ——混杂模式）；\n * doctype 不存在或形式不正确会导致文档以混杂模式呈现（dtd不存在或者格式不正确——混杂模式）；\n * html5 没有 dtd ，因此也就没有严格模式与混杂模式的区别，html5 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(html5 没有严格和混杂之分)。\n\n总之，严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。\n\n\n# 18. 浏览器乱码的原因是什么？如何解决？\n\n产生乱码的原因：\n\n * 网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码；\n * html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码；\n * 浏览器不能自动检测网页编码，造成网页乱码。\n\n解决办法：\n\n * 使用软件编辑html网页内容；\n * 如果网页设置编码是gbk，而数据库储存数据编码格式是utf-8，此时需要程序查询数据库数据显示数据前进程序转码；\n * 如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。\n\n\n# 19. 渐进增强和优雅降级之间的区别\n\n（1）渐进增强（progressive enhancement）：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。\n\n（2）优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。\n\n两者区别：\n\n * 优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；\n * 降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。\n\n“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 ie、mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。\n\n“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 yahoo 所采纳并用以构建其“分级式浏览器支持 (graded browser support)”策略的原因所在。\n\n\n# 20. 说一下 html5 drag api\n\n * dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。\n * darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。\n * dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。\n * dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。\n * dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。\n * drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。\n * dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "页面布局",
      "frontmatter": {
        "title": "页面布局",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/highLayout/",
        "article": false
      },
      "regularPath": "/20.%E9%AB%98%E9%A2%91%E7%AF%87/30.CSS%E7%AF%87/20.%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80.html",
      "relativePath": "20.高频篇/30.CSS篇/20.页面布局.md",
      "key": "v-29914dd8",
      "path": "/pages/highLayout/",
      "headers": [
        {
          "level": 3,
          "title": "1. 常见的CSS布局单位",
          "slug": "_1-常见的css布局单位",
          "normalizedTitle": "1. 常见的css布局单位",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. px、em、rem的区别及使用场景",
          "slug": "_2-px、em、rem的区别及使用场景",
          "normalizedTitle": "2. px、em、rem的区别及使用场景",
          "charIndex": 859
        },
        {
          "level": 3,
          "title": "3. 两栏布局的实现",
          "slug": "_3-两栏布局的实现",
          "normalizedTitle": "3. 两栏布局的实现",
          "charIndex": 1171
        },
        {
          "level": 3,
          "title": "4. 三栏布局的实现",
          "slug": "_4-三栏布局的实现",
          "normalizedTitle": "4. 三栏布局的实现",
          "charIndex": 2472
        },
        {
          "level": 3,
          "title": "5. 水平垂直居中的实现",
          "slug": "_5-水平垂直居中的实现",
          "normalizedTitle": "5. 水平垂直居中的实现",
          "charIndex": 4606
        },
        {
          "level": 3,
          "title": "6. 如何根据设计稿进行移动端适配？",
          "slug": "_6-如何根据设计稿进行移动端适配",
          "normalizedTitle": "6. 如何根据设计稿进行移动端适配？",
          "charIndex": 5577
        },
        {
          "level": 3,
          "title": "7. 对Flex布局的理解及其使用场景",
          "slug": "_7-对flex布局的理解及其使用场景",
          "normalizedTitle": "7. 对flex布局的理解及其使用场景",
          "charIndex": 5826
        },
        {
          "level": 3,
          "title": "8. 响应式设计的概念及基本原理",
          "slug": "_8-响应式设计的概念及基本原理",
          "normalizedTitle": "8. 响应式设计的概念及基本原理",
          "charIndex": 7134
        }
      ],
      "headersStr": "1. 常见的CSS布局单位 2. px、em、rem的区别及使用场景 3. 两栏布局的实现 4. 三栏布局的实现 5. 水平垂直居中的实现 6. 如何根据设计稿进行移动端适配？ 7. 对Flex布局的理解及其使用场景 8. 响应式设计的概念及基本原理",
      "content": "# 1. 常见的CSS布局单位\n\n常用的布局单位包括像素（px），百分比（%），em，rem，vw/vh。\n\n（1）像素（px）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：\n\n * CSS像素：为web开发者提供，在CSS中使用的一个抽象单位；\n * 物理像素：只与设备的硬件密度有关，任何设备的物理像素都是固定的。\n\n（2）百分比（%），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。\n\n（3）em和rem相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：em相对于父元素，rem相对于根元素。\n\n * em： 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。\n * rem： rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。\n\n（4）vw/vh是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。\n\n * vw：相对于视窗的宽度，视窗宽度是100vw；\n * vh：相对于视窗的高度，视窗高度是100vh；\n * vmin：vw和vh中的较小值；\n * vmax：vw和vh中的较大值；\n\nvw/vh 和百分比很类似，两者的区别：\n\n * 百分比（%）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)\n * vw/vm：相对于视窗的尺寸\n\n\n# 2. px、em、rem的区别及使用场景\n\n三者的区别：\n\n * px是固定的像素，一旦设置了就无法因为适应页面大小而改变。\n * em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。\n * em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。\n\n使用场景：\n\n * 对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。\n * 对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。\n\n\n# 3. 两栏布局的实现\n\n一般两栏布局指的是左边一栏宽度固定，右边一栏宽度自适应，两栏布局的具体实现：\n\n * 利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。\n\n.outer {\n  height: 100px;\n}\n.left {\n  float: left;\n  width: 200px;\n  background: tomato;\n}\n.right {\n  margin-left: 200px;\n  width: auto;\n  background: gold;\n}\n\n\n * 利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。\n\n.left{\n     width: 100px;\n     height: 200px;\n     background: red;\n     float: left;\n }\n .right{\n     height: 300px;\n     background: blue;\n     overflow: hidden;\n }\n\n\n * 利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。\n\n.outer {\n  display: flex;\n  height: 100px;\n}\n.left {\n  width: 200px;\n  background: tomato;\n}\n.right {\n  flex: 1;\n  background: gold;\n}\n\n\n * 利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。\n\n.outer {\n  position: relative;\n  height: 100px;\n}\n.left {\n  position: absolute;\n  width: 200px;\n  height: 100px;\n  background: tomato;\n}\n.right {\n  margin-left: 200px;\n  background: gold;\n}\n\n\n * 利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。\n\n.outer {\n  position: relative;\n  height: 100px;\n}\n.left {\n  width: 200px;\n  background: tomato;\n}\n.right {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 200px;\n  background: gold;\n}\n\n\n\n# 4. 三栏布局的实现\n\n三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，三栏布局的具体实现：\n\n * 利用绝对定位，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。\n\n.outer {\n  position: relative;\n  height: 100px;\n}\n\n.left {\n  position: absolute;\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  position: absolute;\n  top: 0;\n  right: 0;\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.center {\n  margin-left: 100px;\n  margin-right: 200px;\n  height: 100px;\n  background: lightgreen;\n}\n\n\n * 利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。\n\n.outer {\n  display: flex;\n  height: 100px;\n}\n\n.left {\n  width: 100px;\n  background: tomato;\n}\n\n.right {\n  width: 100px;\n  background: gold;\n}\n\n.center {\n  flex: 1;\n  background: lightgreen;\n}\n\n\n * 利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式**，中间一栏必须放到最后：**\n\n.outer {\n  height: 100px;\n}\n\n.left {\n  float: left;\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  float: right;\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.center {\n  height: 100px;\n  margin-left: 100px;\n  margin-right: 200px;\n  background: lightgreen;\n}\n\n\n * 圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。\n\n.outer {\n  height: 100px;\n  padding-left: 100px;\n  padding-right: 200px;\n}\n\n.left {\n  position: relative;\n  left: -100px;\n\n  float: left;\n  margin-left: -100%;\n\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  position: relative;\n  left: 200px;\n\n  float: right;\n  margin-left: -200px;\n\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.center {\n  float: left;\n\n  width: 100%;\n  height: 100px;\n  background: lightgreen;\n}\n\n\n * 双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。\n\n.outer {\n  height: 100px;\n}\n\n.left {\n  float: left;\n  margin-left: -100%;\n\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  float: left;\n  margin-left: -200px;\n\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.wrapper {\n  float: left;\n\n  width: 100%;\n  height: 100px;\n  background: lightgreen;\n}\n\n.center {\n  margin-left: 100px;\n  margin-right: 200px;\n  height: 100px;\n}\n\n\n\n# 5. 水平垂直居中的实现\n\n * 利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要考虑浏览器兼容问题。\n\n.parent {    position: relative;} .child {    position: absolute;    left: 50%;    top: 50%;    transform: translate(-50%,-50%);}\n\n\n * 利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于盒子有宽高的情况：\n\n.parent {\n    position: relative;\n}\n \n.child {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    margin: auto;\n}\n\n\n * 利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于盒子宽高已知的情况\n\n.parent {\n    position: relative;\n}\n \n.child {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -50px;     /* 自身 height 的一半 */\n    margin-left: -50px;    /* 自身 width 的一半 */\n}\n\n\n * 使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要考虑兼容的问题，该方法在移动端用的较多：\n\n.parent {\n    display: flex;\n    justify-content:center;\n    align-items:center;\n}\n\n\n\n# 6. 如何根据设计稿进行移动端适配？\n\n移动端适配主要有两个维度：\n\n * 适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；\n * 适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。\n\n为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。\n\n\n# 7. 对Flex布局的理解及其使用场景\n\nFlex是FlexibleBox的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。采用Flex布局的元素，称为Flex容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称\"项目\"。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。\n\n以下6个属性设置在容器上：\n\n * flex-direction属性决定主轴的方向（即项目的排列方向）。\n * flex-wrap属性定义，如果一条轴线排不下，如何换行。\n * flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n * justify-content属性定义了项目在主轴上的对齐方式。\n * align-items属性定义项目在交叉轴上如何对齐。\n * align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n以下6个属性设置在项目上：\n\n * order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n * flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n * flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n * flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n * flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。\n * align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\n简单来说： flex布局是CSS3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。\n\n\n# 8. 响应式设计的概念及基本原理\n\n响应式网站设计（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。\n\n关于原理： 基本原理是通过媒体查询（@media）查询检测不同的设备屏幕尺寸做处理。 关于兼容： 页面头部必须有mate声明的viewport。\n\n<meta name=\"’viewport’\" content=\"”width=device-width,\" initial-scale=\"1.\" maximum-scale=\"1,user-scalable=no”\"/>\n",
      "normalizedContent": "# 1. 常见的css布局单位\n\n常用的布局单位包括像素（px），百分比（%），em，rem，vw/vh。\n\n（1）像素（px）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：css像素和物理像素：\n\n * css像素：为web开发者提供，在css中使用的一个抽象单位；\n * 物理像素：只与设备的硬件密度有关，任何设备的物理像素都是固定的。\n\n（2）百分比（%），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。\n\n（3）em和rem相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：em相对于父元素，rem相对于根元素。\n\n * em： 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。\n * rem： rem是css3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。\n\n（4）vw/vh是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。\n\n * vw：相对于视窗的宽度，视窗宽度是100vw；\n * vh：相对于视窗的高度，视窗高度是100vh；\n * vmin：vw和vh中的较小值；\n * vmax：vw和vh中的较大值；\n\nvw/vh 和百分比很类似，两者的区别：\n\n * 百分比（%）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)\n * vw/vm：相对于视窗的尺寸\n\n\n# 2. px、em、rem的区别及使用场景\n\n三者的区别：\n\n * px是固定的像素，一旦设置了就无法因为适应页面大小而改变。\n * em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。\n * em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。\n\n使用场景：\n\n * 对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。\n * 对于需要适配各种移动设备，使用rem，例如需要适配iphone和ipad等分辨率差别比较挺大的设备。\n\n\n# 3. 两栏布局的实现\n\n一般两栏布局指的是左边一栏宽度固定，右边一栏宽度自适应，两栏布局的具体实现：\n\n * 利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。\n\n.outer {\n  height: 100px;\n}\n.left {\n  float: left;\n  width: 200px;\n  background: tomato;\n}\n.right {\n  margin-left: 200px;\n  width: auto;\n  background: gold;\n}\n\n\n * 利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了bfc，bfc的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。\n\n.left{\n     width: 100px;\n     height: 200px;\n     background: red;\n     float: left;\n }\n .right{\n     height: 300px;\n     background: blue;\n     overflow: hidden;\n }\n\n\n * 利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。\n\n.outer {\n  display: flex;\n  height: 100px;\n}\n.left {\n  width: 200px;\n  background: tomato;\n}\n.right {\n  flex: 1;\n  background: gold;\n}\n\n\n * 利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。\n\n.outer {\n  position: relative;\n  height: 100px;\n}\n.left {\n  position: absolute;\n  width: 200px;\n  height: 100px;\n  background: tomato;\n}\n.right {\n  margin-left: 200px;\n  background: gold;\n}\n\n\n * 利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。\n\n.outer {\n  position: relative;\n  height: 100px;\n}\n.left {\n  width: 200px;\n  background: tomato;\n}\n.right {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 200px;\n  background: gold;\n}\n\n\n\n# 4. 三栏布局的实现\n\n三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，三栏布局的具体实现：\n\n * 利用绝对定位，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。\n\n.outer {\n  position: relative;\n  height: 100px;\n}\n\n.left {\n  position: absolute;\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  position: absolute;\n  top: 0;\n  right: 0;\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.center {\n  margin-left: 100px;\n  margin-right: 200px;\n  height: 100px;\n  background: lightgreen;\n}\n\n\n * 利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。\n\n.outer {\n  display: flex;\n  height: 100px;\n}\n\n.left {\n  width: 100px;\n  background: tomato;\n}\n\n.right {\n  width: 100px;\n  background: gold;\n}\n\n.center {\n  flex: 1;\n  background: lightgreen;\n}\n\n\n * 利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式**，中间一栏必须放到最后：**\n\n.outer {\n  height: 100px;\n}\n\n.left {\n  float: left;\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  float: right;\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.center {\n  height: 100px;\n  margin-left: 100px;\n  margin-right: 200px;\n  background: lightgreen;\n}\n\n\n * 圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。\n\n.outer {\n  height: 100px;\n  padding-left: 100px;\n  padding-right: 200px;\n}\n\n.left {\n  position: relative;\n  left: -100px;\n\n  float: left;\n  margin-left: -100%;\n\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  position: relative;\n  left: 200px;\n\n  float: right;\n  margin-left: -200px;\n\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.center {\n  float: left;\n\n  width: 100%;\n  height: 100px;\n  background: lightgreen;\n}\n\n\n * 双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。\n\n.outer {\n  height: 100px;\n}\n\n.left {\n  float: left;\n  margin-left: -100%;\n\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n\n.right {\n  float: left;\n  margin-left: -200px;\n\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n\n.wrapper {\n  float: left;\n\n  width: 100%;\n  height: 100px;\n  background: lightgreen;\n}\n\n.center {\n  margin-left: 100px;\n  margin-right: 200px;\n  height: 100px;\n}\n\n\n\n# 5. 水平垂直居中的实现\n\n * 利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要考虑浏览器兼容问题。\n\n.parent {    position: relative;} .child {    position: absolute;    left: 50%;    top: 50%;    transform: translate(-50%,-50%);}\n\n\n * 利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于盒子有宽高的情况：\n\n.parent {\n    position: relative;\n}\n \n.child {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    margin: auto;\n}\n\n\n * 利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于盒子宽高已知的情况\n\n.parent {\n    position: relative;\n}\n \n.child {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -50px;     /* 自身 height 的一半 */\n    margin-left: -50px;    /* 自身 width 的一半 */\n}\n\n\n * 使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要考虑兼容的问题，该方法在移动端用的较多：\n\n.parent {\n    display: flex;\n    justify-content:center;\n    align-items:center;\n}\n\n\n\n# 6. 如何根据设计稿进行移动端适配？\n\n移动端适配主要有两个维度：\n\n * 适配不同像素密度， 针对不同的像素密度，使用 css 媒体查询，选择不同精度的图片，以保证图片不会失真；\n * 适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。\n\n为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。\n\n\n# 7. 对flex布局的理解及其使用场景\n\nflex是flexiblebox的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为flex布局。行内元素也可以使用flex布局。注意，设为flex布局以后，子元素的float、clear和vertical-align属性将失效。采用flex布局的元素，称为flex容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为flex项目（flex item），简称\"项目\"。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。\n\n以下6个属性设置在容器上：\n\n * flex-direction属性决定主轴的方向（即项目的排列方向）。\n * flex-wrap属性定义，如果一条轴线排不下，如何换行。\n * flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n * justify-content属性定义了项目在主轴上的对齐方式。\n * align-items属性定义项目在交叉轴上如何对齐。\n * align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n以下6个属性设置在项目上：\n\n * order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n * flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n * flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n * flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n * flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。\n * align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\n简单来说： flex布局是css3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。\n\n\n# 8. 响应式设计的概念及基本原理\n\n响应式网站设计（responsive web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。\n\n关于原理： 基本原理是通过媒体查询（@media）查询检测不同的设备屏幕尺寸做处理。 关于兼容： 页面头部必须有mate声明的viewport。\n\n<meta name=\"’viewport’\" content=\"”width=device-width,\" initial-scale=\"1.\" maximum-scale=\"1,user-scalable=no”\"/>\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "定位、浮动与场景应用",
      "frontmatter": {
        "title": "定位、浮动与场景应用",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/highLocation/",
        "article": false
      },
      "regularPath": "/20.%E9%AB%98%E9%A2%91%E7%AF%87/30.CSS%E7%AF%87/30.%E5%AE%9A%E4%BD%8D%E3%80%81%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8.html",
      "relativePath": "20.高频篇/30.CSS篇/30.定位、浮动与场景应用.md",
      "key": "v-7766ee81",
      "path": "/pages/highLocation/",
      "headers": [
        {
          "level": 3,
          "title": "1. 为什么需要清除浮动？清除浮动的方式",
          "slug": "_1-为什么需要清除浮动-清除浮动的方式",
          "normalizedTitle": "1. 为什么需要清除浮动？清除浮动的方式",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 使用 clear 属性清除浮动的原理？",
          "slug": "_2-使用-clear-属性清除浮动的原理",
          "normalizedTitle": "2. 使用 clear 属性清除浮动的原理？",
          "charIndex": 733
        },
        {
          "level": 3,
          "title": "3. 对BFC的理解，如何创建BFC",
          "slug": "_3-对bfc的理解-如何创建bfc",
          "normalizedTitle": "3. 对bfc的理解，如何创建bfc",
          "charIndex": 1434
        },
        {
          "level": 3,
          "title": "4. 什么是margin重叠问题？如何解决？",
          "slug": "_4-什么是margin重叠问题-如何解决",
          "normalizedTitle": "4. 什么是margin重叠问题？如何解决？",
          "charIndex": 2716
        },
        {
          "level": 3,
          "title": "5. 元素的层叠顺序",
          "slug": "_5-元素的层叠顺序",
          "normalizedTitle": "5. 元素的层叠顺序",
          "charIndex": 3219
        },
        {
          "level": 3,
          "title": "6. position的属性有哪些，区别是什么",
          "slug": "_6-position的属性有哪些-区别是什么",
          "normalizedTitle": "6. position的属性有哪些，区别是什么",
          "charIndex": 3557
        },
        {
          "level": 3,
          "title": "7. display、float、position的关系",
          "slug": "_7-display、float、position的关系",
          "normalizedTitle": "7. display、float、position的关系",
          "charIndex": 4003
        },
        {
          "level": 3,
          "title": "8. absolute与fixed共同点与不同点",
          "slug": "_8-absolute与fixed共同点与不同点",
          "normalizedTitle": "8. absolute与fixed共同点与不同点",
          "charIndex": 4615
        },
        {
          "level": 3,
          "title": "9. 对 sticky 定位的理解",
          "slug": "_9-对-sticky-定位的理解",
          "normalizedTitle": "9. 对 sticky 定位的理解",
          "charIndex": 4840
        },
        {
          "level": 3,
          "title": "10. 实现一个三角形",
          "slug": "_10-实现一个三角形",
          "normalizedTitle": "10. 实现一个三角形",
          "charIndex": 5198
        },
        {
          "level": 3,
          "title": "11. 实现一个扇形",
          "slug": "_11-实现一个扇形",
          "normalizedTitle": "11. 实现一个扇形",
          "charIndex": 6294
        },
        {
          "level": 3,
          "title": "12. 实现一个宽高自适应的正方形",
          "slug": "_12-实现一个宽高自适应的正方形",
          "normalizedTitle": "12. 实现一个宽高自适应的正方形",
          "charIndex": 6483
        },
        {
          "level": 3,
          "title": "13. 画一条0.5px的线",
          "slug": "_13-画一条0-5px的线",
          "normalizedTitle": "13. 画一条0.5px的线",
          "charIndex": 6881
        },
        {
          "level": 3,
          "title": "14. 设置小于12px的字体",
          "slug": "_14-设置小于12px的字体",
          "normalizedTitle": "14. 设置小于12px的字体",
          "charIndex": 7174
        },
        {
          "level": 3,
          "title": "15. 如何解决 1px 问题？",
          "slug": "_15-如何解决-1px-问题",
          "normalizedTitle": "15. 如何解决 1px 问题？",
          "charIndex": 7640
        }
      ],
      "headersStr": "1. 为什么需要清除浮动？清除浮动的方式 2. 使用 clear 属性清除浮动的原理？ 3. 对BFC的理解，如何创建BFC 4. 什么是margin重叠问题？如何解决？ 5. 元素的层叠顺序 6. position的属性有哪些，区别是什么 7. display、float、position的关系 8. absolute与fixed共同点与不同点 9. 对 sticky 定位的理解 10. 实现一个三角形 11. 实现一个扇形 12. 实现一个宽高自适应的正方形 13. 画一条0.5px的线 14. 设置小于12px的字体 15. 如何解决 1px 问题？",
      "content": "# 1. 为什么需要清除浮动？清除浮动的方式\n\n浮动的定义： 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。\n\n浮动的工作原理：\n\n * 浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）\n * 浮动元素碰到包含它的边框或者其他浮动元素的边框停留\n\n浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。\n\n浮动元素引起的问题？\n\n * 父元素的高度无法被撑开，影响与父元素同级的元素\n * 与浮动元素同级的非浮动元素会跟随其后\n * 若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构\n\n清除浮动的方式如下：\n\n * 给父级div定义height属性\n * 最后一个浮动元素之后添加一个空的div标签，并添加clear:both样式\n * 包含浮动元素的父级标签添加overflow:hidden或者overflow:auto\n * 使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**\n\n.clearfix:after{\n    content: \"\\200B\";\n    display: table; \n    height: 0;\n    clear: both;\n  }\n  .clearfix{\n    *zoom: 1;\n  }\n\n\n\n# 2. 使用 clear 属性清除浮动的原理？\n\n使用clear属性清除浮动，其语法如下：\n\nclear:none|left|right|both\n\n\n如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。\n\n官方对clear属性解释：“元素盒子的边不能和前面的浮动元素相邻”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。\n\n还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。\n\n一般使用伪元素的方式清除浮动：\n\n.clear::after{  content:'';  display: block;   clear:both;}\n\n\nclear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。\n\n\n# 3. 对BFC的理解，如何创建BFC\n\n先来看两个相关的概念：\n\n * Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。\n * Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。\n\n块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。\n\n通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。\n\n创建BFC的条件：\n\n * 根元素：body；\n * 元素设置浮动：float 除 none 以外的值；\n * 元素设置绝对定位：position (absolute、fixed)；\n * display 值为：inline-block、table-cell、table-caption、flex等；\n * overflow 值为：hidden、auto、scroll；\n\nBFC的特点：\n\n * 垂直方向上，自上而下排列，和文档流的排列方式一致。\n * 在BFC中上下相邻的两个容器的margin会重叠\n * 计算BFC的高度时，需要计算浮动元素的高度\n * BFC区域不会与浮动的容器发生重叠\n * BFC是独立的容器，容器内部元素不会影响外部元素\n * 每个元素的左margin值和容器的左border相接触\n\nBFC的作用：\n\n * 解决margin的重叠问题：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。\n * 解决高度塌陷的问题：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置overflow:hidden。\n * 创建自适应两栏布局：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。\n\n.left{\n     width: 100px;\n     height: 200px;\n     background: red;\n     float: left;\n }\n .right{\n     height: 300px;\n     background: blue;\n     overflow: hidden;\n }\n \n<div class=\"left\"></div>\n<div class=\"right\"></div>\n\n\n左侧设置float:left，右侧设置overflow: hidden。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。\n\n\n# 4. 什么是margin重叠问题？如何解决？\n\n问题描述： 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。重叠只会出现在垂直方向。\n\n计算原则： 折叠合并后外边距的计算原则如下：\n\n * 如果两者都是正数，那么就去最大者\n * 如果是一正一负，就会正值减去负值的绝对值\n * 两个都是负值时，用0减去两个中绝对值大的那个\n\n解决办法： 对于折叠的情况，主要有两种：兄弟之间重叠和父子之间重叠 （1）兄弟之间重叠\n\n * 底部元素变为行内盒子：display: inline-block\n * 底部元素设置浮动：float\n * 底部元素的position的值为absolute/fixed\n\n（2）父子之间重叠\n\n * 父元素加入：overflow: hidden\n * 父元素添加透明边框：border:1px solid transparent\n * 子元素变为行内盒子：display: inline-block\n * 子元素加入浮动属性或定位\n\n\n# 5. 元素的层叠顺序\n\n层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则： 对于上图，由上到下分别是： （1）背景和边框：建立当前层叠上下文元素的背景和边框。 （2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。 （3）块级盒：文档流内非行内级非定位后代元素。 （4）浮动盒：非定位浮动元素。 （5）行内盒：文档流内行内级非定位后代元素。 （6）z-index:0：层叠级数为0的定位元素。 （7）正z-index：z-index属性值为正的定位元素。\n\n注意: 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。\n\n\n# 6. position的属性有哪些，区别是什么\n\nposition有以下属性值：\n\n属性值        概述\nabsolute   生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。\nrelative   生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。\nfixed      生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。\nstatic     默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者\n           z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。\ninherit    规定从父元素继承position属性的值\n\n\n# 7. display、float、position的关系\n\n（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。\n\n（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。\n\n（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。\n\n（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。\n\n总的来说，可以把它看作是一个类似优先级的机制，\"position:absolute\"和\"position:fixed\"优先级最高，有它存在的时候，浮动不起作用，'display'的值也需要调整；其次，元素的'float'特性的值不是\"none\"的时候或者它是根元素的时候，调整'display'的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display'特性值同设置值。\n\n\n# 8. absolute与fixed共同点与不同点\n\n共同点：\n\n * 改变行内元素的呈现方式，将display置为inline-block\n * 使元素脱离普通文档流，不再占据文档物理空间\n * 覆盖非定位文档元素\n\n不同点：\n\n * abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。\n * 在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。\n\n\n# 9. 对 sticky 定位的理解\n\nsticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。\n\n粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\n\n\n# 10. 实现一个三角形\n\nCSS绘制三角形主要用到的是border属性，也就是边框。\n\n平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是右三角形组成的，下面看一个例子：\n\ndiv {\n    width: 0;\n    height: 0;\n    border: 100px solid;\n    border-color: orange blue red green;\n}\n\n\n将元素的长宽都设置为0，显示出来的效果是这样的： 所以可以根据border这个特性来绘制三角形： （1）三角1\n\ndiv {    width: 0;    height: 0;    border-top: 50px solid red;    border-right: 50px solid transparent;    border-left: 50px solid transparent;}\n\n\n（2）三角2\n\ndiv {\n    width: 0;\n    height: 0;\n    border-bottom: 50px solid red;\n    border-right: 50px solid transparent;\n    border-left: 50px solid transparent;\n}\n\n\n（3）三角3\n\ndiv {\n    width: 0;\n    height: 0;\n    border-left: 50px solid red;\n    border-top: 50px solid transparent;\n    border-bottom: 50px solid transparent;\n}\n\n\n（4）三角4\n\ndiv {\n    width: 0;\n    height: 0;\n    border-right: 50px solid red;\n    border-top: 50px solid transparent;\n    border-bottom: 50px solid transparent;\n}\n\n\n（5）三角5\n\ndiv {\n    width: 0;\n    height: 0;\n    border-top: 100px solid red;\n    border-right: 100px solid transparent;\n}\n\n\n还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。\n\n\n# 11. 实现一个扇形\n\n用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：\n\ndiv{\n    border: 100px solid transparent;\n    width: 0;\n    heigt: 0;\n    border-radius: 100px;\n    border-top-color: red;\n}\n\n\n\n\n\n# 12. 实现一个宽高自适应的正方形\n\n * 利用vw来实现：\n\n.square {\n  width: 10%;\n  height: 10vw;\n  background: tomato;\n}\n\n\n * 利用元素的margin/padding百分比是相对父元素width的性质来实现：\n\n.square {\n  width: 20%;\n  height: 0;\n  padding-top: 20%;\n  background: orange;\n}\n\n\n * 利用子元素的margin-top的值来实现：\n\n.square {\n  width: 30%;\n  overflow: hidden;\n  background: yellow;\n}\n.square::after {\n  content: '';\n  display: block;\n  margin-top: 100%;\n}\n\n\n\n# 13. 画一条0.5px的线\n\n * 采用transform: scale()的方式，该方法用来定义元素的2D 缩放转换：\n\ntransform: scale(0.5,0.5);\n\n\n * 采用meta viewport的方式\n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5\"/>\n\n\n这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果\n\n\n# 14. 设置小于12px的字体\n\n在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。\n\n解决办法：\n\n * 使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。\n * 使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/...；\n * 使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。\n\n\n# 15. 如何解决 1px 问题？\n\n1px 问题指的是：在一些 Retina屏幕 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：\n\nwindow.devicePixelRatio = 设备的物理像素 / CSS像素。\n\n\n打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 devicePixelRatio 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2： 这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。 解决1px 问题的三种思路：\n\n# 思路一：直接写 0.5px\n\n如果之前 1px 的样式这样写：\n\nborder:1px solid #333\n\n\n可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：\n\n<div id=\"container\" data-device={{window.devicePixelRatio}}></div>\n\n\n然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为2的情况：\n\n#container[data-device=\"2\"] {\n  border:0.5px solid #333\n}\n\n\n直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。\n\n# 思路二：伪元素先放大后缩小\n\n这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。\n\n思路是先放大、后缩小：在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为 1px。接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。\n\n代码如下：\n\n#container[data-device=\"2\"] {\n    position: relative;\n}\n#container[data-device=\"2\"]::after{\n      position:absolute;\n      top: 0;\n      left: 0;\n      width: 200%;\n      height: 200%;\n      content:\"\";\n      transform: scale(0.5);\n      transform-origin: left top;\n      box-sizing: border-box;\n      border: 1px solid #333;\n    }\n}\n\n\n# 思路三：viewport 缩放来解决\n\n这个思路就是对 meta 标签里几个关键属性下手：\n\n<meta name=\"viewport\" content=\"initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no\">\n\n\n这里针对像素比为2的页面，把整个页面缩放为了原来的1/2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：\n\nconst scale = 1 / window.devicePixelRatio;\n// 这里 metaEl 指的是 meta 标签对应的 Dom\nmetaEl.setAttribute('content', `width=device-width,user-scalable=no,initial-scale=${scale},maximum-scale=${scale},minimum-scale=${scale}`);\n\n\n这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。",
      "normalizedContent": "# 1. 为什么需要清除浮动？清除浮动的方式\n\n浮动的定义： 非ie浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。\n\n浮动的工作原理：\n\n * 浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）\n * 浮动元素碰到包含它的边框或者其他浮动元素的边框停留\n\n浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。\n\n浮动元素引起的问题？\n\n * 父元素的高度无法被撑开，影响与父元素同级的元素\n * 与浮动元素同级的非浮动元素会跟随其后\n * 若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构\n\n清除浮动的方式如下：\n\n * 给父级div定义height属性\n * 最后一个浮动元素之后添加一个空的div标签，并添加clear:both样式\n * 包含浮动元素的父级标签添加overflow:hidden或者overflow:auto\n * 使用 :after 伪元素。由于ie6-7不支持 :after，使用 zoom:1 触发 haslayout**\n\n.clearfix:after{\n    content: \"\\200b\";\n    display: table; \n    height: 0;\n    clear: both;\n  }\n  .clearfix{\n    *zoom: 1;\n  }\n\n\n\n# 2. 使用 clear 属性清除浮动的原理？\n\n使用clear属性清除浮动，其语法如下：\n\nclear:none|left|right|both\n\n\n如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。\n\n官方对clear属性解释：“元素盒子的边不能和前面的浮动元素相邻”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。\n\n还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在css世界中是如此，直接使用clear:both吧。\n\n一般使用伪元素的方式清除浮动：\n\n.clear::after{  content:'';  display: block;   clear:both;}\n\n\nclear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。\n\n\n# 3. 对bfc的理解，如何创建bfc\n\n先来看两个相关的概念：\n\n * box: box 是 css 布局的对象和基本单位，⼀个⻚⾯是由很多个 box 组成的，这个box就是我们所说的盒模型。\n * formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。\n\n块格式化上下文（block formatting context，bfc）是web页面的可视化css渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。\n\n通俗来讲：bfc是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发bfc的条件，则bfc中的元素布局不受外部影响。\n\n创建bfc的条件：\n\n * 根元素：body；\n * 元素设置浮动：float 除 none 以外的值；\n * 元素设置绝对定位：position (absolute、fixed)；\n * display 值为：inline-block、table-cell、table-caption、flex等；\n * overflow 值为：hidden、auto、scroll；\n\nbfc的特点：\n\n * 垂直方向上，自上而下排列，和文档流的排列方式一致。\n * 在bfc中上下相邻的两个容器的margin会重叠\n * 计算bfc的高度时，需要计算浮动元素的高度\n * bfc区域不会与浮动的容器发生重叠\n * bfc是独立的容器，容器内部元素不会影响外部元素\n * 每个元素的左margin值和容器的左border相接触\n\nbfc的作用：\n\n * 解决margin的重叠问题：由于bfc是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个bfc，就解决了margin重叠的问题。\n * 解决高度塌陷的问题：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个bfc。常用的办法是给父元素设置overflow:hidden。\n * 创建自适应两栏布局：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。\n\n.left{\n     width: 100px;\n     height: 200px;\n     background: red;\n     float: left;\n }\n .right{\n     height: 300px;\n     background: blue;\n     overflow: hidden;\n }\n \n<div class=\"left\"></div>\n<div class=\"right\"></div>\n\n\n左侧设置float:left，右侧设置overflow: hidden。这样右边就触发了bfc，bfc的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。\n\n\n# 4. 什么是margin重叠问题？如何解决？\n\n问题描述： 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。重叠只会出现在垂直方向。\n\n计算原则： 折叠合并后外边距的计算原则如下：\n\n * 如果两者都是正数，那么就去最大者\n * 如果是一正一负，就会正值减去负值的绝对值\n * 两个都是负值时，用0减去两个中绝对值大的那个\n\n解决办法： 对于折叠的情况，主要有两种：兄弟之间重叠和父子之间重叠 （1）兄弟之间重叠\n\n * 底部元素变为行内盒子：display: inline-block\n * 底部元素设置浮动：float\n * 底部元素的position的值为absolute/fixed\n\n（2）父子之间重叠\n\n * 父元素加入：overflow: hidden\n * 父元素添加透明边框：border:1px solid transparent\n * 子元素变为行内盒子：display: inline-block\n * 子元素加入浮动属性或定位\n\n\n# 5. 元素的层叠顺序\n\n层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则： 对于上图，由上到下分别是： （1）背景和边框：建立当前层叠上下文元素的背景和边框。 （2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。 （3）块级盒：文档流内非行内级非定位后代元素。 （4）浮动盒：非定位浮动元素。 （5）行内盒：文档流内行内级非定位后代元素。 （6）z-index:0：层叠级数为0的定位元素。 （7）正z-index：z-index属性值为正的定位元素。\n\n注意: 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。\n\n\n# 6. position的属性有哪些，区别是什么\n\nposition有以下属性值：\n\n属性值        概述\nabsolute   生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。\nrelative   生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。\nfixed      生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。\nstatic     默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者\n           z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。\ninherit    规定从父元素继承position属性的值\n\n\n# 7. display、float、position的关系\n\n（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。\n\n（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。\n\n（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。\n\n（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。\n\n总的来说，可以把它看作是一个类似优先级的机制，\"position:absolute\"和\"position:fixed\"优先级最高，有它存在的时候，浮动不起作用，'display'的值也需要调整；其次，元素的'float'特性的值不是\"none\"的时候或者它是根元素的时候，调整'display'的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display'特性值同设置值。\n\n\n# 8. absolute与fixed共同点与不同点\n\n共同点：\n\n * 改变行内元素的呈现方式，将display置为inline-block\n * 使元素脱离普通文档流，不再占据文档物理空间\n * 覆盖非定位文档元素\n\n不同点：\n\n * abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。\n * 在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。\n\n\n# 9. 对 sticky 定位的理解\n\nsticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。\n\n粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\n\n\n# 10. 实现一个三角形\n\ncss绘制三角形主要用到的是border属性，也就是边框。\n\n平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是右三角形组成的，下面看一个例子：\n\ndiv {\n    width: 0;\n    height: 0;\n    border: 100px solid;\n    border-color: orange blue red green;\n}\n\n\n将元素的长宽都设置为0，显示出来的效果是这样的： 所以可以根据border这个特性来绘制三角形： （1）三角1\n\ndiv {    width: 0;    height: 0;    border-top: 50px solid red;    border-right: 50px solid transparent;    border-left: 50px solid transparent;}\n\n\n（2）三角2\n\ndiv {\n    width: 0;\n    height: 0;\n    border-bottom: 50px solid red;\n    border-right: 50px solid transparent;\n    border-left: 50px solid transparent;\n}\n\n\n（3）三角3\n\ndiv {\n    width: 0;\n    height: 0;\n    border-left: 50px solid red;\n    border-top: 50px solid transparent;\n    border-bottom: 50px solid transparent;\n}\n\n\n（4）三角4\n\ndiv {\n    width: 0;\n    height: 0;\n    border-right: 50px solid red;\n    border-top: 50px solid transparent;\n    border-bottom: 50px solid transparent;\n}\n\n\n（5）三角5\n\ndiv {\n    width: 0;\n    height: 0;\n    border-top: 100px solid red;\n    border-right: 100px solid transparent;\n}\n\n\n还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。\n\n\n# 11. 实现一个扇形\n\n用css实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：\n\ndiv{\n    border: 100px solid transparent;\n    width: 0;\n    heigt: 0;\n    border-radius: 100px;\n    border-top-color: red;\n}\n\n\n\n\n\n# 12. 实现一个宽高自适应的正方形\n\n * 利用vw来实现：\n\n.square {\n  width: 10%;\n  height: 10vw;\n  background: tomato;\n}\n\n\n * 利用元素的margin/padding百分比是相对父元素width的性质来实现：\n\n.square {\n  width: 20%;\n  height: 0;\n  padding-top: 20%;\n  background: orange;\n}\n\n\n * 利用子元素的margin-top的值来实现：\n\n.square {\n  width: 30%;\n  overflow: hidden;\n  background: yellow;\n}\n.square::after {\n  content: '';\n  display: block;\n  margin-top: 100%;\n}\n\n\n\n# 13. 画一条0.5px的线\n\n * 采用transform: scale()的方式，该方法用来定义元素的2d 缩放转换：\n\ntransform: scale(0.5,0.5);\n\n\n * 采用meta viewport的方式\n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5\"/>\n\n\n这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果\n\n\n# 14. 设置小于12px的字体\n\n在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。\n\n解决办法：\n\n * 使用webkit的内核的-webkit-text-size-adjust的私有css属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。\n * 使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/...；\n * 使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。\n\n\n# 15. 如何解决 1px 问题？\n\n1px 问题指的是：在一些 retina屏幕 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——css 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：\n\nwindow.devicepixelratio = 设备的物理像素 / css像素。\n\n\n打开 chrome 浏览器，启动移动端调试模式，在控制台去输出这个 devicepixelratio 的值。这里选中 iphone6/7/8 这系列的机型，输出的结果就是2： 这就意味着设置的 1px css 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。 解决1px 问题的三种思路：\n\n# 思路一：直接写 0.5px\n\n如果之前 1px 的样式这样写：\n\nborder:1px solid #333\n\n\n可以先在 js 中拿到 window.devicepixelratio 的值，然后把这个值通过 jsx 或者模板语法给到 css 的 data 里，达到这样的效果（这里用 jsx 语法做示范）：\n\n<div id=\"container\" data-device={{window.devicepixelratio}}></div>\n\n\n然后就可以在 css 中用属性选择器来命中 devicepixelratio 为某一值的情况，比如说这里尝试命中 devicepixelratio 为2的情况：\n\n#container[data-device=\"2\"] {\n  border:0.5px solid #333\n}\n\n\n直接把 1px 改成 1/devicepixelratio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，ios 系统需要8及以上的版本，安卓系统则直接不兼容。\n\n# 思路二：伪元素先放大后缩小\n\n这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。\n\n思路是先放大、后缩小：在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为 1px。接着借助 css 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。\n\n代码如下：\n\n#container[data-device=\"2\"] {\n    position: relative;\n}\n#container[data-device=\"2\"]::after{\n      position:absolute;\n      top: 0;\n      left: 0;\n      width: 200%;\n      height: 200%;\n      content:\"\";\n      transform: scale(0.5);\n      transform-origin: left top;\n      box-sizing: border-box;\n      border: 1px solid #333;\n    }\n}\n\n\n# 思路三：viewport 缩放来解决\n\n这个思路就是对 meta 标签里几个关键属性下手：\n\n<meta name=\"viewport\" content=\"initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no\">\n\n\n这里针对像素比为2的页面，把整个页面缩放为了原来的1/2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：\n\nconst scale = 1 / window.devicepixelratio;\n// 这里 metael 指的是 meta 标签对应的 dom\nmetael.setattribute('content', `width=device-width,user-scalable=no,initial-scale=${scale},maximum-scale=${scale},minimum-scale=${scale}`);\n\n\n这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "css基础",
      "frontmatter": {
        "title": "css基础",
        "date": "2022-08-03T21:31:15.000Z",
        "permalink": "/pages/highCss/",
        "article": false
      },
      "regularPath": "/20.%E9%AB%98%E9%A2%91%E7%AF%87/30.CSS%E7%AF%87/10.css%E5%9F%BA%E7%A1%80.html",
      "relativePath": "20.高频篇/30.CSS篇/10.css基础.md",
      "key": "v-212da54e",
      "path": "/pages/highCss/",
      "headers": [
        {
          "level": 3,
          "title": "1. CSS选择器及其优先级",
          "slug": "_1-css选择器及其优先级",
          "normalizedTitle": "1. css选择器及其优先级",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. CSS中可继承与不可继承属性有哪些",
          "slug": "_2-css中可继承与不可继承属性有哪些",
          "normalizedTitle": "2. css中可继承与不可继承属性有哪些",
          "charIndex": 612
        },
        {
          "level": 3,
          "title": "3. display的属性值及其作用",
          "slug": "_3-display的属性值及其作用",
          "normalizedTitle": "3. display的属性值及其作用",
          "charIndex": 1770
        },
        {
          "level": 3,
          "title": "4. display的block、inline和inline-block的区别",
          "slug": "_4-display的block、inline和inline-block的区别",
          "normalizedTitle": "4. display的block、inline和inline-block的区别",
          "charIndex": 2075
        },
        {
          "level": 3,
          "title": "5. 隐藏元素的方法有哪些",
          "slug": "_5-隐藏元素的方法有哪些",
          "normalizedTitle": "5. 隐藏元素的方法有哪些",
          "charIndex": 2522
        },
        {
          "level": 3,
          "title": "6. link和@import的区别",
          "slug": "_6-link和-import的区别",
          "normalizedTitle": "6. link和@import的区别",
          "charIndex": 2954
        },
        {
          "level": 3,
          "title": "7. transition和animation的区别",
          "slug": "_7-transition和animation的区别",
          "normalizedTitle": "7. transition和animation的区别",
          "charIndex": 3212
        },
        {
          "level": 3,
          "title": "8. display:none与visibility:hidden的区别",
          "slug": "_8-display-none与visibility-hidden的区别",
          "normalizedTitle": "8. display:none与visibility:hidden的区别",
          "charIndex": 3439
        },
        {
          "level": 3,
          "title": "9. 伪元素和伪类的区别和作用？",
          "slug": "_9-伪元素和伪类的区别和作用",
          "normalizedTitle": "9. 伪元素和伪类的区别和作用？",
          "charIndex": 3891
        },
        {
          "level": 3,
          "title": "10. 对requestAnimationframe的理解",
          "slug": "_10-对requestanimationframe的理解",
          "normalizedTitle": "10. 对requestanimationframe的理解",
          "charIndex": 4275
        },
        {
          "level": 3,
          "title": "11. 对盒模型的理解",
          "slug": "_11-对盒模型的理解",
          "normalizedTitle": "11. 对盒模型的理解",
          "charIndex": 5602
        },
        {
          "level": 3,
          "title": "12. 为什么有时候⽤translate来改变位置⽽不是定位？",
          "slug": "_12-为什么有时候用translate来改变位置而不是定位",
          "normalizedTitle": "12. 为什么有时候⽤translate来改变位置⽽不是定位？",
          "charIndex": 5869
        },
        {
          "level": 3,
          "title": "13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？",
          "slug": "_13-li-与-li-之间有看不见的空白间隔是什么原因引起的-如何解决",
          "normalizedTitle": "13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？",
          "charIndex": 6153
        },
        {
          "level": 3,
          "title": "14. CSS3中有哪些新特性",
          "slug": "_14-css3中有哪些新特性",
          "normalizedTitle": "14. css3中有哪些新特性",
          "charIndex": 6564
        },
        {
          "level": 3,
          "title": "15. 替换元素的概念及计算规则",
          "slug": "_15-替换元素的概念及计算规则",
          "normalizedTitle": "15. 替换元素的概念及计算规则",
          "charIndex": 6827
        },
        {
          "level": 3,
          "title": "16. 常见的图片格式及使用场景",
          "slug": "_16-常见的图片格式及使用场景",
          "normalizedTitle": "16. 常见的图片格式及使用场景",
          "charIndex": 7817
        },
        {
          "level": 3,
          "title": "17. 对 CSSSprites 的理解",
          "slug": "_17-对-csssprites-的理解",
          "normalizedTitle": "17. 对 csssprites 的理解",
          "charIndex": 8923
        },
        {
          "level": 3,
          "title": "18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？",
          "slug": "_18-什么是物理像素-逻辑像素和像素密度-为什么在移动端开发时需要用到-3x-2x这种图片",
          "normalizedTitle": "18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？",
          "charIndex": 9473
        },
        {
          "level": 3,
          "title": "19. margin 和 padding 的使用场景",
          "slug": "_19-margin-和-padding-的使用场景",
          "normalizedTitle": "19. margin 和 padding 的使用场景",
          "charIndex": 9910
        },
        {
          "level": 3,
          "title": "20. 对line-height 的理解及其赋值方式",
          "slug": "_20-对line-height-的理解及其赋值方式",
          "normalizedTitle": "20. 对line-height 的理解及其赋值方式",
          "charIndex": 10030
        },
        {
          "level": 3,
          "title": "21. CSS 优化和提高性能的方法有哪些？",
          "slug": "_21-css-优化和提高性能的方法有哪些",
          "normalizedTitle": "21. css 优化和提高性能的方法有哪些？",
          "charIndex": 10473
        },
        {
          "level": 3,
          "title": "22. CSS预处理器/后处理器是什么？为什么要使用它们？",
          "slug": "_22-css预处理器-后处理器是什么-为什么要使用它们",
          "normalizedTitle": "22. css预处理器/后处理器是什么？为什么要使用它们？",
          "charIndex": 11618
        },
        {
          "level": 3,
          "title": "23. ::before 和 :after 的双冒号和单冒号有什么区别？",
          "slug": "_23-before-和-after-的双冒号和单冒号有什么区别",
          "normalizedTitle": "23. ::before 和 :after 的双冒号和单冒号有什么区别？",
          "charIndex": 12098
        },
        {
          "level": 3,
          "title": "24. display:inline-block 什么时候会显示间隙？",
          "slug": "_24-display-inline-block-什么时候会显示间隙",
          "normalizedTitle": "24. display:inline-block 什么时候会显示间隙？",
          "charIndex": 12354
        },
        {
          "level": 3,
          "title": "25. 单行、多行文本溢出隐藏",
          "slug": "_25-单行、多行文本溢出隐藏",
          "normalizedTitle": "25. 单行、多行文本溢出隐藏",
          "charIndex": 12511
        },
        {
          "level": 3,
          "title": "26. Sass、Less 是什么？为什么要使用他们？",
          "slug": "_26-sass、less-是什么-为什么要使用他们",
          "normalizedTitle": "26. sass、less 是什么？为什么要使用他们？",
          "charIndex": 12964
        },
        {
          "level": 3,
          "title": "27. 对媒体查询的理解？",
          "slug": "_27-对媒体查询的理解",
          "normalizedTitle": "27. 对媒体查询的理解？",
          "charIndex": 13326
        },
        {
          "level": 3,
          "title": "28. 对 CSS 工程化的理解",
          "slug": "_28-对-css-工程化的理解",
          "normalizedTitle": "28. 对 css 工程化的理解",
          "charIndex": 13973
        },
        {
          "level": 3,
          "title": "29. 如何判断元素是否到达可视区域",
          "slug": "_29-如何判断元素是否到达可视区域",
          "normalizedTitle": "29. 如何判断元素是否到达可视区域",
          "charIndex": 15933
        },
        {
          "level": 3,
          "title": "30. z-index属性在什么情况下会失效",
          "slug": "_30-z-index属性在什么情况下会失效",
          "normalizedTitle": "30. z-index属性在什么情况下会失效",
          "charIndex": 16198
        }
      ],
      "headersStr": "1. CSS选择器及其优先级 2. CSS中可继承与不可继承属性有哪些 3. display的属性值及其作用 4. display的block、inline和inline-block的区别 5. 隐藏元素的方法有哪些 6. link和@import的区别 7. transition和animation的区别 8. display:none与visibility:hidden的区别 9. 伪元素和伪类的区别和作用？ 10. 对requestAnimationframe的理解 11. 对盒模型的理解 12. 为什么有时候⽤translate来改变位置⽽不是定位？ 13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？ 14. CSS3中有哪些新特性 15. 替换元素的概念及计算规则 16. 常见的图片格式及使用场景 17. 对 CSSSprites 的理解 18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？ 19. margin 和 padding 的使用场景 20. 对line-height 的理解及其赋值方式 21. CSS 优化和提高性能的方法有哪些？ 22. CSS预处理器/后处理器是什么？为什么要使用它们？ 23. ::before 和 :after 的双冒号和单冒号有什么区别？ 24. display:inline-block 什么时候会显示间隙？ 25. 单行、多行文本溢出隐藏 26. Sass、Less 是什么？为什么要使用他们？ 27. 对媒体查询的理解？ 28. 对 CSS 工程化的理解 29. 如何判断元素是否到达可视区域 30. z-index属性在什么情况下会失效",
      "content": "# 1. CSS选择器及其优先级\n\n选择器       格式              优先级权重\nid选择器     #id             100\n类选择器      #classname      10\n属性选择器     a[ref=“eee”]    10\n伪类选择器     li:last-child   10\n标签选择器     div             1\n伪元素选择器    li:after        1\n相邻兄弟选择器   h1+p            0\n子选择器      ul>li           0\n后代选择器     li a            0\n通配符选择器    *               0\n\n对于选择器的优先级：\n\n * 标签选择器、伪元素选择器：1\n * 类选择器、伪类选择器、属性选择器：10\n * id 选择器：100\n * 内联样式：1000\n\n注意事项：\n\n * !important声明的样式的优先级最高；\n * 如果优先级相同，则最后出现的样式生效；\n * 继承得到的样式的优先级最低；\n * 通用选择器（*）、子选择器（>）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；\n * 样式表的来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式。\n\n\n# 2. CSS中可继承与不可继承属性有哪些\n\n一、无继承性的属性\n\n 1. display：规定元素应该生成的框的类型\n 2. 文本属性：\n\n * vertical-align：垂直文本对齐\n * text-decoration：规定添加到文本的装饰\n * text-shadow：文本阴影效果\n * white-space：空白符的处理\n * unicode-bidi：设置文本的方向\n\n 1. 盒子模型的属性：width、height、margin、border、padding\n 2. 背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment\n 3. 定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index\n 4. 生成内容属性：content、counter-reset、counter-increment\n 5. 轮廓样式属性：outline-style、outline-width、outline-color、outline\n 6. 页面样式属性：size、page-break-before、page-break-after\n 7. 声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during\n\n二、有继承性的属性\n\n 1. 字体系列属性\n\n * font-family：字体系列\n * font-weight：字体的粗细\n * font-size：字体的大小\n * font-style：字体的风格\n\n 1. 文本系列属性\n\n * text-indent：文本缩进\n * text-align：文本水平对齐\n * line-height：行高\n * word-spacing：单词之间的间距\n * letter-spacing：中文或者字母之间的间距\n * text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）\n * color：文本颜色\n\n 1. 元素可见性\n\n * visibility：控制元素显示隐藏\n\n 1. 列表布局属性\n\n * list-style：列表风格，包括list-style-type、list-style-image等\n\n 1. 光标属性\n\n * cursor：光标显示为何种形态\n\n\n# 3. display的属性值及其作用\n\n属性值            作用\nnone           元素不显示，并且会从文档流中移除。\nblock          块类型。默认宽度为父元素宽度，可设置宽高，换行显示。\ninline         行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。\ninline-block   默认宽度为内容宽度，可以设置宽高，同行显示。\nlist-item      像块类型元素一样显示，并添加样式列表标记。\ntable          此元素会作为块级表格来显示。\ninherit        规定应该从父元素继承display属性的值。\n\n\n# 4. display的block、inline和inline-block的区别\n\n（1）block： 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；\n\n（2）inline： 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；\n\n（3）inline-block： 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。\n\n对于行内元素和块级元素，其特点如下：\n\n（1）行内元素\n\n * 设置宽高无效；\n * 可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；\n * 不会自动换行；\n\n（2）块级元素\n\n * 可以设置宽高；\n * 设置margin和padding都有效；\n * 可以自动换行；\n * 多个块状，默认排列从上到下。\n\n\n# 5. 隐藏元素的方法有哪些\n\n * display: none：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。\n * visibility: hidden：元素在页面中仍占据空间，但是不会响应绑定的监听事件。\n * opacity: 0：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。\n * position: absolute：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。\n * z-index: 负值：来使其他元素遮盖住该元素，以此来实现隐藏。\n * clip/clip-path ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。\n * transform: scale(0,0)：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。\n\n\n# 6. link和@import的区别\n\n两者都是外部引用CSS的方式，它们的区别如下：\n\n * link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。\n * link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。\n * link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。\n * link支持使用Javascript控制DOM去改变样式；而@import不支持。\n\n\n# 7. transition和animation的区别\n\n * transition是过度属性，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。\n * animation是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。\n\n\n# 8. display:none与visibility:hidden的区别\n\n这两个属性都是让元素隐藏，不可见。两者区别如下：\n\n（1）在渲染树中\n\n * display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；\n * visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。\n\n（2）是否是继承属性\n\n * display:none是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；\n * visibility:hidden是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示； （3）修改常规文档流中元素的 display 通常会造成文档的重排，但是修改visibility属性只会造成本元素的重绘；\n\n（4）如果使用读屏器，设置为display:none的内容不会被读取，设置为visibility:hidden的内容会被读取。\n\n\n# 9. 伪元素和伪类的区别和作用？\n\n * 伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：\n\np::before {content:\"第一章：\";}\np::after {content:\"Hot!\";}\np::first-line {background:red;}\np::first-letter {font-size:30px;}\n\n\n * 伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：\n\na:hover {color: #FF00FF}\np:first-child {color: red}\n\n\n总结： 伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。\n\n\n# 10. 对requestAnimationframe的理解\n\n实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是请求动画帧。\n\nMDN对该方法的描述：\n\n> window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。\n\n语法： window.requestAnimationFrame(callback); 其中，callback是下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于宏任务，所以会在执行完微任务之后再去执行。\n\n取消动画： 使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。\n\n优势：\n\n * CPU节能：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。\n * 函数节流：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。\n * 减少DOM操作：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。\n\nsetTimeout执行动画的缺点：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：\n\n * settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；\n * settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。\n\n\n# 11. 对盒模型的理解\n\n标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：\n\n * 标准盒模型的width和height属性的范围只包含了content，\n * IE盒模型的width和height属性的范围包含了border、padding和content。\n\n可以通过修改元素的box-sizing属性来改变元素的盒模型：\n\n * box-sizeing: content-box表示标准盒模型（默认值）\n * box-sizeing: border-box表示IE盒模型（怪异盒模型）\n\n\n# 12. 为什么有时候⽤translate来改变位置⽽不是定位？\n\ntranslate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。\n\n\n# 13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？\n\n浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个<li>放在一行，这导致<li>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。\n\n解决办法：\n\n（1）为<li>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。\n\n（2）将所有<li>写在同一行。不足：代码不美观。\n\n（3）将<ul>内的字符尺寸直接设为0，即font-size:0。不足：<ul>中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。\n\n（4）消除<ul>的字符间隔letter-spacing:-8px，不足：这也设置了<li>内的字符间隔，因此需要将<li>内的字符间隔设为默认letter-spacing:normal。\n\n\n# 14. CSS3中有哪些新特性\n\n * 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）\n * 圆角 （border-radius:8px）\n * 多列布局 （multi-column layout）\n * 阴影和反射 （Shadoweflect）\n * 文字特效 （text-shadow）\n * 文字渲染 （Text-decoration）\n * 线性渐变 （gradient）\n * 旋转 （transform）\n * 增加了旋转,缩放,定位,倾斜,动画,多背景\n\n\n# 15. 替换元素的概念及计算规则\n\n通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。\n\n替换元素除了内容可替换这一特性以外，还有以下特性：\n\n * 内容的外观不受页面上的CSS的影响：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。\n * 有自己的尺寸：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如\n * 在很多CSS属性上有自己的一套表现规则：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。\n * 所有的替换元素都是内联水平元素：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。\n\n替换元素的尺寸从内而外分为三类：\n\n * 固有尺寸： 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。\n * HTML尺寸： 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。\n * CSS尺寸： 特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。\n\n这三层结构的计算规则具体如下： （1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。 （2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。 （3）如果有CSS尺寸，则最终尺寸由CSS属性决定。 （4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。 （5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。 （6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。\n\n\n# 16. 常见的图片格式及使用场景\n\n（1）BMP，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。\n\n（2）GIF是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。\n\n（3）JPEG是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。\n\n（4）PNG-8是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。\n\n（5）PNG-24是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。\n\n（6）SVG是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。\n\n（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。\n\n * 在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；\n * 在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；\n * WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。\n\n\n# 17. 对 CSSSprites 的理解\n\nCSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。\n\n优点：\n\n * 利用CSS Sprites能很好地减少网页的http请求，从而大大提高了页面的性能，这是CSS Sprites最大的优点；\n * CSS Sprites能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。\n\n缺点：\n\n * 在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；\n * CSSSprites在开发的时候相对来说有点麻烦，需要借助photoshop或其他工具来对每个背景单元测量其准确的位置。\n * 维护方面：CSS Sprites在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的CSS，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动CSS。\n\n\n# 18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？\n\n以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px & 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；\n\n而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。\n\n还可以使用 CSS 媒体查询来判断不同的像素密度，从而选择不同的图片:\n\nmy-image { background: (low.png); }\n@media only screen and (min-device-pixel-ratio: 1.5) {\n  #my-image { background: (high.png); }\n}\n\n\n\n# 19. margin 和 padding 的使用场景\n\n * 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\n * 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。\n\n\n# 20. 对line-height 的理解及其赋值方式\n\n（1）line-height的概念：\n\n * line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；\n * 如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；\n * 一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；\n * 把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；\n * line-height 和 height 都能撑开一个高度；\n\n（2）line-height 的赋值方式：\n\n * 带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高\n * 纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px\n * 百分比：将计算后的值传递给后代\n\n\n# 21. CSS 优化和提高性能的方法有哪些？\n\n加载性能：\n\n（1）css压缩：将写好的css进行打包压缩，可以减小文件体积。\n\n（2）css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。\n\n（3）减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。\n\n选择器性能：\n\n（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；\n\n（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。\n\n（3）避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。\n\n（4）尽量少的去对标签进行选择，而是用class。\n\n（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。\n\n（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。\n\n渲染性能：\n\n（1）慎重使用高性能属性：浮动、定位。\n\n（2）尽量减少页面重排、重绘。\n\n（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。\n\n（4）属性值为0时，不加单位。\n\n（5）属性值为浮动小数0.**，可以省略小数点之前的0。\n\n（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。\n\n（7）不使用@import前缀，它会影响css的加载速度。\n\n（8）选择器优化嵌套，尽量避免层级过深。\n\n（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。\n\n（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。\n\n（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。\n\n可维护性、健壮性：\n\n（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。\n\n（2）样式与内容分离：将css代码定义到外部css中。\n\n\n# 22. CSS预处理器/后处理器是什么？为什么要使用它们？\n\n预处理器， 如：less，sass，stylus，用来预编译sass或者less，增加了css代码的复用性。层级，mixin， 变量，循环， 函数等对编写以及开发UI组件都极为方便。\n\n后处理器， 如： postCss，通常是在完成的样式表中根据css规范处理css，让其更加有效。目前最常做的是给css属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。\n\ncss预处理器为css增加一些编程特性，无需考虑浏览器的兼容问题，可以在CSS中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让css更加的简洁，增加适应性以及可读性，可维护性等。\n\n其它css预处理器语言：Sass（Scss）, Less, Stylus, Turbine, Swithch css, CSS Cacheer, DT Css。\n\n使用原因：\n\n * 结构清晰， 便于扩展\n * 可以很方便的屏蔽浏览器私有语法的差异\n * 可以轻松实现多重继承\n * 完美的兼容了CSS代码，可以应用到老项目中\n\n\n# 23. ::before 和 :after 的双冒号和单冒号有什么区别？\n\n（1）冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。\n\n注意： :before和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before、::after。\n\n\n# 24. display:inline-block 什么时候会显示间隙？\n\n * 有空格时会有间隙，可以删除空格解决；\n * margin正值时，可以让margin使用负值解决；\n * 使用font-size时，可通过设置font-size:0、letter-spacing、word-spacing解决；\n\n\n# 25. 单行、多行文本溢出隐藏\n\n * 单行文本溢出\n\noverflow: hidden;            // 溢出隐藏\ntext-overflow: ellipsis;      // 溢出用省略号显示\nwhite-space: nowrap;         // 规定段落中的文本不进行换行\n\n\n * 多行文本溢出\n\noverflow: hidden;            // 溢出隐藏\ntext-overflow: ellipsis;     // 溢出用省略号显示\ndisplay:-webkit-box;         // 作为弹性伸缩盒子模型显示。\n-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列\n-webkit-line-clamp:3;        // 显示的行数\n\n\n注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个-webkit- 来兼容一部分浏览器。\n\n\n# 26. Sass、Less 是什么？为什么要使用他们？\n\n他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。\n\n为什么要使用它们？\n\n * 结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。\n * 可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。\n\n\n# 27. 对媒体查询的理解？\n\n媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。\n\n媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。\n\n<!-- link元素中的CSS媒体查询 --> \n<link rel=\"stylesheet\" media=\"(max-width: 800px)\" href=\"example.css\" /> \n<!-- 样式表中的CSS媒体查询 --> \n<style> \n@media (max-width: 600px) { \n  .facet_sidebar { \n    display: none; \n  } \n}\n</style>\n\n\n简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。\n\n\n# 28. 对 CSS 工程化的理解\n\nCSS 工程化是为了解决以下问题：\n\n 1. 宏观设计：CSS 代码如何组织、如何拆分、模块结构怎样设计？\n 2. 编码优化：怎样写出更好的 CSS？\n 3. 构建：如何处理我的 CSS，才能让它的打包结果最优？\n 4. 可维护性：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？\n\n以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：\n\n * 预处理器：Less、 Sass 等；\n * 重要的工程化插件： PostCss；\n * Webpack loader 等 。\n\n基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：\n\n（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？\n\n预处理器，其实就是 CSS 世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码。\n\n那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：\n\n 1. 宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；\n 2. 编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；\n 3. 可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。\n\n这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：\n\n * 嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；\n * 支持定义 css 变量；\n * 提供计算函数；\n * 允许对代码片段进行 extend 和 mixin；\n * 支持循环语句的使用；\n * 支持将 CSS 文件模块化，实现复用。\n\n（2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？\n\n它和预处理器的不同就在于，预处理器处理的是 类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。\n\nPostCss 在业务中的使用场景非常多：\n\n * 提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；\n * 当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 Autoprefixer 插件可以帮助我们自动增加浏览器前缀；\n * 允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；\n\n（3）Webpack 能处理 CSS 吗？如何实现？ Webpack 能处理 CSS 吗：\n\n * Webpack 在裸奔的状态下，是不能处理 CSS 的，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；\n * Webpack 在 loader 的辅助下，是可以处理 CSS 的。\n\n如何用 Webpack 实现对 CSS 的处理：\n\n * Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader\n * 注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：\n   * css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；\n   * style-loader：创建style标签，把 CSS 内容写入标签。\n\n在实际使用中，css-loader 的执行顺序一定要安排在 style-loader 的前面。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。\n\n\n# 29. 如何判断元素是否到达可视区域\n\n以图片显示为例：\n\n * window.innerHeight 是浏览器可视区的高度；\n * document.body.scrollTop || document.documentElement.scrollTop 是浏览器滚动的过的距离；\n * imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）；\n * 内容达到显示区域的：img.offsetTop < window.innerHeight + document.body.scrollTop;\n\n\n# 30. z-index属性在什么情况下会失效\n\n通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。\n\nz-index属性在下列情况下会失效：\n\n * 父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；\n * 元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；\n * 元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；",
      "normalizedContent": "# 1. css选择器及其优先级\n\n选择器       格式              优先级权重\nid选择器     #id             100\n类选择器      #classname      10\n属性选择器     a[ref=“eee”]    10\n伪类选择器     li:last-child   10\n标签选择器     div             1\n伪元素选择器    li:after        1\n相邻兄弟选择器   h1+p            0\n子选择器      ul>li           0\n后代选择器     li a            0\n通配符选择器    *               0\n\n对于选择器的优先级：\n\n * 标签选择器、伪元素选择器：1\n * 类选择器、伪类选择器、属性选择器：10\n * id 选择器：100\n * 内联样式：1000\n\n注意事项：\n\n * !important声明的样式的优先级最高；\n * 如果优先级相同，则最后出现的样式生效；\n * 继承得到的样式的优先级最低；\n * 通用选择器（*）、子选择器（>）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；\n * 样式表的来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式。\n\n\n# 2. css中可继承与不可继承属性有哪些\n\n一、无继承性的属性\n\n 1. display：规定元素应该生成的框的类型\n 2. 文本属性：\n\n * vertical-align：垂直文本对齐\n * text-decoration：规定添加到文本的装饰\n * text-shadow：文本阴影效果\n * white-space：空白符的处理\n * unicode-bidi：设置文本的方向\n\n 1. 盒子模型的属性：width、height、margin、border、padding\n 2. 背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment\n 3. 定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index\n 4. 生成内容属性：content、counter-reset、counter-increment\n 5. 轮廓样式属性：outline-style、outline-width、outline-color、outline\n 6. 页面样式属性：size、page-break-before、page-break-after\n 7. 声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during\n\n二、有继承性的属性\n\n 1. 字体系列属性\n\n * font-family：字体系列\n * font-weight：字体的粗细\n * font-size：字体的大小\n * font-style：字体的风格\n\n 1. 文本系列属性\n\n * text-indent：文本缩进\n * text-align：文本水平对齐\n * line-height：行高\n * word-spacing：单词之间的间距\n * letter-spacing：中文或者字母之间的间距\n * text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）\n * color：文本颜色\n\n 1. 元素可见性\n\n * visibility：控制元素显示隐藏\n\n 1. 列表布局属性\n\n * list-style：列表风格，包括list-style-type、list-style-image等\n\n 1. 光标属性\n\n * cursor：光标显示为何种形态\n\n\n# 3. display的属性值及其作用\n\n属性值            作用\nnone           元素不显示，并且会从文档流中移除。\nblock          块类型。默认宽度为父元素宽度，可设置宽高，换行显示。\ninline         行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。\ninline-block   默认宽度为内容宽度，可以设置宽高，同行显示。\nlist-item      像块类型元素一样显示，并添加样式列表标记。\ntable          此元素会作为块级表格来显示。\ninherit        规定应该从父元素继承display属性的值。\n\n\n# 4. display的block、inline和inline-block的区别\n\n（1）block： 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；\n\n（2）inline： 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；\n\n（3）inline-block： 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。\n\n对于行内元素和块级元素，其特点如下：\n\n（1）行内元素\n\n * 设置宽高无效；\n * 可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；\n * 不会自动换行；\n\n（2）块级元素\n\n * 可以设置宽高；\n * 设置margin和padding都有效；\n * 可以自动换行；\n * 多个块状，默认排列从上到下。\n\n\n# 5. 隐藏元素的方法有哪些\n\n * display: none：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。\n * visibility: hidden：元素在页面中仍占据空间，但是不会响应绑定的监听事件。\n * opacity: 0：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。\n * position: absolute：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。\n * z-index: 负值：来使其他元素遮盖住该元素，以此来实现隐藏。\n * clip/clip-path ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。\n * transform: scale(0,0)：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。\n\n\n# 6. link和@import的区别\n\n两者都是外部引用css的方式，它们的区别如下：\n\n * link是xhtml标签，除了加载css外，还可以定义rss等其他事务；@import属于css范畴，只能加载css。\n * link引用css时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。\n * link是xhtml标签，无兼容问题；@import是在css2.1提出的，低版本的浏览器不支持。\n * link支持使用javascript控制dom去改变样式；而@import不支持。\n\n\n# 7. transition和animation的区别\n\n * transition是过度属性，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。\n * animation是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。\n\n\n# 8. display:none与visibility:hidden的区别\n\n这两个属性都是让元素隐藏，不可见。两者区别如下：\n\n（1）在渲染树中\n\n * display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；\n * visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。\n\n（2）是否是继承属性\n\n * display:none是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；\n * visibility:hidden是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示； （3）修改常规文档流中元素的 display 通常会造成文档的重排，但是修改visibility属性只会造成本元素的重绘；\n\n（4）如果使用读屏器，设置为display:none的内容不会被读取，设置为visibility:hidden的内容会被读取。\n\n\n# 9. 伪元素和伪类的区别和作用？\n\n * 伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：\n\np::before {content:\"第一章：\";}\np::after {content:\"hot!\";}\np::first-line {background:red;}\np::first-letter {font-size:30px;}\n\n\n * 伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：\n\na:hover {color: #ff00ff}\np:first-child {color: red}\n\n\n总结： 伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。\n\n\n# 10. 对requestanimationframe的理解\n\n实现动画效果的方法比较多，javascript 中可以通过定时器 settimeout 来实现，css3 中可以使用 transition 和 animation 来实现，html5 中的 canvas 也可以实现。除此之外，html5 提供一个专门用于请求动画的api，那就是 requestanimationframe，顾名思义就是请求动画帧。\n\nmdn对该方法的描述：\n\n> window.requestanimationframe() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。\n\n语法： window.requestanimationframe(callback); 其中，callback是下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入domhighrestimestamp参数，它表示requestanimationframe() 开始去执行回调函数的时刻。该方法属于宏任务，所以会在执行完微任务之后再去执行。\n\n取消动画： 使用cancelanimationframe()来取消执行动画，该方法接收一个参数——requestanimationframe默认返回的id，只需要传入这个id就可以取消动画了。\n\n优势：\n\n * cpu节能：使用settinterval 实现的动画，当页面被隐藏或最小化时，settinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费cpu资源。而requestanimationframe则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的requestanimationframe也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了cpu开销。\n * 函数节流：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，requestanimationframe可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。\n * 减少dom操作：requestanimationframe 会把每一帧中的所有dom操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。\n\nsettimeout执行动画的缺点：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：\n\n * settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；\n * settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。\n\n\n# 11. 对盒模型的理解\n\n标准盒模型和ie盒模型的区别在于设置width和height时，所对应的范围不同：\n\n * 标准盒模型的width和height属性的范围只包含了content，\n * ie盒模型的width和height属性的范围包含了border、padding和content。\n\n可以通过修改元素的box-sizing属性来改变元素的盒模型：\n\n * box-sizeing: content-box表示标准盒模型（默认值）\n * box-sizeing: border-box表示ie盒模型（怪异盒模型）\n\n\n# 12. 为什么有时候⽤translate来改变位置⽽不是定位？\n\ntranslate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 gpu 图层，但改变绝对定位会使⽤到 cpu。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。\n\n\n# 13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？\n\n浏览器会把inline内联元素间的空白字符（空格、换行、tab等）渲染成一个空格。为了美观，通常是一个<li>放在一行，这导致<li>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。\n\n解决办法：\n\n（1）为<li>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。\n\n（2）将所有<li>写在同一行。不足：代码不美观。\n\n（3）将<ul>内的字符尺寸直接设为0，即font-size:0。不足：<ul>中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在safari浏览器依然会出现空白间隔。\n\n（4）消除<ul>的字符间隔letter-spacing:-8px，不足：这也设置了<li>内的字符间隔，因此需要将<li>内的字符间隔设为默认letter-spacing:normal。\n\n\n# 14. css3中有哪些新特性\n\n * 新增各种css选择器 （: not(.input)：所有 class 不是“input”的节点）\n * 圆角 （border-radius:8px）\n * 多列布局 （multi-column layout）\n * 阴影和反射 （shadoweflect）\n * 文字特效 （text-shadow）\n * 文字渲染 （text-decoration）\n * 线性渐变 （gradient）\n * 旋转 （transform）\n * 增加了旋转,缩放,定位,倾斜,动画,多背景\n\n\n# 15. 替换元素的概念及计算规则\n\n通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。\n\n替换元素除了内容可替换这一特性以外，还有以下特性：\n\n * 内容的外观不受页面上的css的影响：用专业的话讲就是在样式表现在css作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。\n * 有自己的尺寸：在web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如\n * 在很多css属性上有自己的一套表现规则：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。\n * 所有的替换元素都是内联水平元素：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。\n\n替换元素的尺寸从内而外分为三类：\n\n * 固有尺寸： 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。\n * html尺寸： 只能通过html原生属性改变，这些html原生属性包括的width和height属性、的size属性。\n * css尺寸： 特指可以通过css的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。\n\n这三层结构的计算规则具体如下： （1）如果没有css尺寸和html尺寸，则使用固有尺寸作为最终的宽高。 （2）如果没有css尺寸，则使用html尺寸作为最终的宽高。 （3）如果有css尺寸，则最终尺寸由css属性决定。 （4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。 （5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。 （6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。\n\n\n# 16. 常见的图片格式及使用场景\n\n（1）bmp，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以bmp格式的图片通常是较大的文件。\n\n（2）gif是无损的、采用索引色的点阵图。采用lzw压缩算法进行编码。文件小，是gif格式的优点，同时，gif格式还具有支持动画以及透明的优点。但是gif格式仅支持8bit的索引色，所以gif格式适用于对色彩要求不高同时需要文件体积较小的场景。\n\n（3）jpeg是有损的、采用直接色的点阵图。jpeg的图片的优点是采用了直接色，得益于更丰富的色彩，jpeg非常适合用来存储照片，与gif相比，jpeg不适合用来存储企业logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较gif更大。\n\n（4）png-8是无损的、使用索引色的点阵图。png是一种比较新的图片格式，png-8是非常好的gif格式替代者，在可能的情况下，应该尽可能的使用png-8而不是gif，因为在相同的图片效果下，png-8具有更小的文件体积。除此之外，png-8还支持透明度的调节，而gif并不支持。除非需要动画的支持，否则没有理由使用gif而不是png-8。\n\n（5）png-24是无损的、使用直接色的点阵图。png-24的优点在于它压缩了图片的数据，使得同样效果的图片，png-24格式的文件大小要比bmp小得多。当然，png24的图片还是要比jpeg、gif、png-8大得多。\n\n（6）svg是无损的矢量图。svg是矢量图意味着svg图片由直线和曲线以及绘制它们的方法组成。当放大svg图片时，看到的还是线和曲线，而不会出现像素点。svg图片在放大时，不会失真，所以它适合用来绘制logo、icon等。\n\n（7）webp是谷歌开发的一种新图片格式，webp是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为web而生的，什么叫为web而生呢？就是说相同质量的图片，webp具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有chrome浏览器和opera浏览器支持webp格式，兼容性不太好。\n\n * 在无损压缩的情况下，相同质量的webp图片，文件大小要比png小26%；\n * 在有损压缩的情况下，具有相同图片精度的webp图片，文件大小要比jpeg小25%~34%；\n * webp图片格式支持图片透明度，一个无损压缩的webp图片，如果要支持透明度只需要22%的格外文件大小。\n\n\n# 17. 对 csssprites 的理解\n\ncsssprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用css的 background-image，background-repeat，background-position属性的组合进行背景定位。\n\n优点：\n\n * 利用css sprites能很好地减少网页的http请求，从而大大提高了页面的性能，这是css sprites最大的优点；\n * css sprites能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。\n\n缺点：\n\n * 在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；\n * csssprites在开发的时候相对来说有点麻烦，需要借助photoshop或其他工具来对每个背景单元测量其准确的位置。\n * 维护方面：css sprites在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的css，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动css。\n\n\n# 18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？\n\n以 iphone xs 为例，当写 css 代码时，针对于单位 px，其宽度为 414px & 896px，也就是说当赋予一个 div元素宽度为 414px，这个 div 就会填满手机的宽度；\n\n而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。\n\n还可以使用 css 媒体查询来判断不同的像素密度，从而选择不同的图片:\n\nmy-image { background: (low.png); }\n@media only screen and (min-device-pixel-ratio: 1.5) {\n  #my-image { background: (high.png); }\n}\n\n\n\n# 19. margin 和 padding 的使用场景\n\n * 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；\n * 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。\n\n\n# 20. 对line-height 的理解及其赋值方式\n\n（1）line-height的概念：\n\n * line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；\n * 如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；\n * 一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；\n * 把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；\n * line-height 和 height 都能撑开一个高度；\n\n（2）line-height 的赋值方式：\n\n * 带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高\n * 纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px\n * 百分比：将计算后的值传递给后代\n\n\n# 21. css 优化和提高性能的方法有哪些？\n\n加载性能：\n\n（1）css压缩：将写好的css进行打包压缩，可以减小文件体积。\n\n（2）css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。\n\n（3）减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。\n\n选择器性能：\n\n（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。css选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；\n\n（2）如果规则拥有id选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。\n\n（3）避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。\n\n（4）尽量少的去对标签进行选择，而是用class。\n\n（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。\n\n（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。\n\n渲染性能：\n\n（1）慎重使用高性能属性：浮动、定位。\n\n（2）尽量减少页面重排、重绘。\n\n（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。\n\n（4）属性值为0时，不加单位。\n\n（5）属性值为浮动小数0.**，可以省略小数点之前的0。\n\n（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。\n\n（7）不使用@import前缀，它会影响css的加载速度。\n\n（8）选择器优化嵌套，尽量避免层级过深。\n\n（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。\n\n（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。\n\n（11）不滥用web字体。对于中文网站来说webfonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。\n\n可维护性、健壮性：\n\n（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。\n\n（2）样式与内容分离：将css代码定义到外部css中。\n\n\n# 22. css预处理器/后处理器是什么？为什么要使用它们？\n\n预处理器， 如：less，sass，stylus，用来预编译sass或者less，增加了css代码的复用性。层级，mixin， 变量，循环， 函数等对编写以及开发ui组件都极为方便。\n\n后处理器， 如： postcss，通常是在完成的样式表中根据css规范处理css，让其更加有效。目前最常做的是给css属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。\n\ncss预处理器为css增加一些编程特性，无需考虑浏览器的兼容问题，可以在css中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让css更加的简洁，增加适应性以及可读性，可维护性等。\n\n其它css预处理器语言：sass（scss）, less, stylus, turbine, swithch css, css cacheer, dt css。\n\n使用原因：\n\n * 结构清晰， 便于扩展\n * 可以很方便的屏蔽浏览器私有语法的差异\n * 可以轻松实现多重继承\n * 完美的兼容了css代码，可以应用到老项目中\n\n\n# 23. ::before 和 :after 的双冒号和单冒号有什么区别？\n\n（1）冒号(:)用于css3伪类，双冒号(::)用于css3伪元素。 （2）::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。\n\n注意： :before和 :after 这两个伪元素，是在css2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着web的进化，在css3的规范里，伪元素的语法被修改成使用双冒号，成为::before、::after。\n\n\n# 24. display:inline-block 什么时候会显示间隙？\n\n * 有空格时会有间隙，可以删除空格解决；\n * margin正值时，可以让margin使用负值解决；\n * 使用font-size时，可通过设置font-size:0、letter-spacing、word-spacing解决；\n\n\n# 25. 单行、多行文本溢出隐藏\n\n * 单行文本溢出\n\noverflow: hidden;            // 溢出隐藏\ntext-overflow: ellipsis;      // 溢出用省略号显示\nwhite-space: nowrap;         // 规定段落中的文本不进行换行\n\n\n * 多行文本溢出\n\noverflow: hidden;            // 溢出隐藏\ntext-overflow: ellipsis;     // 溢出用省略号显示\ndisplay:-webkit-box;         // 作为弹性伸缩盒子模型显示。\n-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列\n-webkit-line-clamp:3;        // 显示的行数\n\n\n注意：由于上面的三个属性都是 css3 的属性，没有浏览器可以兼容，所以要在前面加一个-webkit- 来兼容一部分浏览器。\n\n\n# 26. sass、less 是什么？为什么要使用他们？\n\n他们都是 css 预处理器，是 css 上的一种抽象层。他们是一种特殊的语法/语言编译成 css。 例如 less 是一种动态样式语言，将 css 赋予了动态语言的特性，如变量，继承，运算， 函数，less 既可以在客户端上运行 (支持 ie 6+, webkit, firefox)，也可以在服务端运行 (借助 node.js)。\n\n为什么要使用它们？\n\n * 结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。\n * 可以轻松实现多重继承。 完全兼容 css 代码，可以方便地应用到老项目中。less 只是在 css 语法上做了扩展，所以老的 css 代码也可以与 less 代码一同编译。\n\n\n# 27. 对媒体查询的理解？\n\n媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃css3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。\n\n媒体查询包含⼀个可选的媒体类型和满⾜css3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。\n\n<!-- link元素中的css媒体查询 --> \n<link rel=\"stylesheet\" media=\"(max-width: 800px)\" href=\"example.css\" /> \n<!-- 样式表中的css媒体查询 --> \n<style> \n@media (max-width: 600px) { \n  .facet_sidebar { \n    display: none; \n  } \n}\n</style>\n\n\n简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。\n\n\n# 28. 对 css 工程化的理解\n\ncss 工程化是为了解决以下问题：\n\n 1. 宏观设计：css 代码如何组织、如何拆分、模块结构怎样设计？\n 2. 编码优化：怎样写出更好的 css？\n 3. 构建：如何处理我的 css，才能让它的打包结果最优？\n 4. 可维护性：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？\n\n以下三个方向都是时下比较流行的、普适性非常好的 css 工程化实践：\n\n * 预处理器：less、 sass 等；\n * 重要的工程化插件： postcss；\n * webpack loader 等 。\n\n基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：\n\n（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？\n\n预处理器，其实就是 css 世界的“轮子”。预处理器支持我们写一种类似 css、但实际并不是 css 的语言，然后把它编译成 css 代码。\n\n那为什么写 css 代码写得好好的，偏偏要转去写“类 css”呢？这就和本来用 js 也可以实现所有功能，但最后却写 react 的 jsx 或者 vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 css 有多不爽。随着前端业务复杂度的提高，前端工程中对 css 提出了以下的诉求：\n\n 1. 宏观设计上：我们希望能优化 css 文件的目录结构，对现有的 css 文件实现复用；\n 2. 编码优化上：我们希望能写出结构清晰、简明易懂的 css，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；\n 3. 可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。\n\n这三点是传统 css 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：\n\n * 嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；\n * 支持定义 css 变量；\n * 提供计算函数；\n * 允许对代码片段进行 extend 和 mixin；\n * 支持循环语句的使用；\n * 支持将 css 文件模块化，实现复用。\n\n（2）postcss：postcss 是如何工作的？我们在什么场景下会使用 postcss？\n\n它和预处理器的不同就在于，预处理器处理的是 类css，而 postcss 处理的就是 css 本身。babel 可以将高版本的 js 代码转换为低版本的 js 代码。postcss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 css 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 postcss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 css 的能力。\n\npostcss 在业务中的使用场景非常多：\n\n * 提高 css 代码的可读性：postcss 其实可以做类似预处理器能做的工作；\n * 当我们的 css 代码需要适配低版本浏览器时，postcss 的 autoprefixer 插件可以帮助我们自动增加浏览器前缀；\n * 允许我们编写面向未来的 css：postcss 能够帮助我们编译 css next 代码；\n\n（3）webpack 能处理 css 吗？如何实现？ webpack 能处理 css 吗：\n\n * webpack 在裸奔的状态下，是不能处理 css 的，webpack 本身是一个面向 javascript 且只能处理 javascript 代码的模块化打包工具；\n * webpack 在 loader 的辅助下，是可以处理 css 的。\n\n如何用 webpack 实现对 css 的处理：\n\n * webpack 中操作 css 需要使用的两个关键的 loader：css-loader 和 style-loader\n * 注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：\n   * css-loader：导入 css 模块，对 css 代码进行编译处理；\n   * style-loader：创建style标签，把 css 内容写入标签。\n\n在实际使用中，css-loader 的执行顺序一定要安排在 style-loader 的前面。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。\n\n\n# 29. 如何判断元素是否到达可视区域\n\n以图片显示为例：\n\n * window.innerheight 是浏览器可视区的高度；\n * document.body.scrolltop || document.documentelement.scrolltop 是浏览器滚动的过的距离；\n * imgs.offsettop 是元素顶部距离文档顶部的高度（包括滚动条的距离）；\n * 内容达到显示区域的：img.offsettop < window.innerheight + document.body.scrolltop;\n\n\n# 30. z-index属性在什么情况下会失效\n\n通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。\n\nz-index属性在下列情况下会失效：\n\n * 父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；\n * 元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；\n * 元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "生命周期",
      "frontmatter": {
        "title": "生命周期",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/frameLifeCycle/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/10.vue%E7%AF%87/20.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",
      "relativePath": "30.框架篇/10.vue篇/20.生命周期.md",
      "key": "v-413eb6ee",
      "path": "/pages/frameLifeCycle/",
      "headers": [
        {
          "level": 3,
          "title": "1. 说一下Vue的生命周期",
          "slug": "_1-说一下vue的生命周期",
          "normalizedTitle": "1. 说一下vue的生命周期",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. Vue 子组件和父组件执行顺序",
          "slug": "_2-vue-子组件和父组件执行顺序",
          "normalizedTitle": "2. vue 子组件和父组件执行顺序",
          "charIndex": 1074
        },
        {
          "level": 3,
          "title": "3. created和mounted的区别",
          "slug": "_3-created和mounted的区别",
          "normalizedTitle": "3. created和mounted的区别",
          "charIndex": 1423
        },
        {
          "level": 3,
          "title": "4. 一般在哪个生命周期请求异步数据",
          "slug": "_4-一般在哪个生命周期请求异步数据",
          "normalizedTitle": "4. 一般在哪个生命周期请求异步数据",
          "charIndex": 1557
        },
        {
          "level": 3,
          "title": "5. keep-alive 中的生命周期哪些",
          "slug": "_5-keep-alive-中的生命周期哪些",
          "normalizedTitle": "5. keep-alive 中的生命周期哪些",
          "charIndex": 1809
        }
      ],
      "headersStr": "1. 说一下Vue的生命周期 2. Vue 子组件和父组件执行顺序 3. created和mounted的区别 4. 一般在哪个生命周期请求异步数据 5. keep-alive 中的生命周期哪些",
      "content": "# 1. 说一下Vue的生命周期\n\nVue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。\n\n 1. beforeCreate（创建前）：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。\n 2. created（创建后） ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el 属性。\n 3. beforeMount（挂载前）：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。\n 4. mounted（挂载后）：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。\n 5. beforeUpdate（更新前）：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。\n 6. updated（更新后） ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。\n 7. beforeDestroy（销毁前）：实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。\n 8. destroyed（销毁后）：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。\n\n另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。\n\n\n# 2. Vue 子组件和父组件执行顺序\n\n加载渲染过程：\n\n 1. 父组件 beforeCreate\n 2. 父组件 created\n 3. 父组件 beforeMount\n 4. 子组件 beforeCreate\n 5. 子组件 created\n 6. 子组件 beforeMount\n 7. 子组件 mounted\n 8. 父组件 mounted\n\n更新过程：\n\n 1. 父组件 beforeUpdate\n 2. 子组件 beforeUpdate\n 3. 子组件 updated\n 4. 父组件 updated\n\n销毁过程：\n\n 1. 父组件 beforeDestroy\n 2. 子组件 beforeDestroy\n 3. 子组件 destroyed\n 4. 父组件 destoryed\n\n\n# 3. created和mounted的区别\n\n * created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。\n * mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。\n\n\n# 4. 一般在哪个生命周期请求异步数据\n\n我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。\n\n推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：\n\n * 能更快获取到服务端数据，减少页面加载时间，用户体验更好；\n * SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。\n\n\n# 5. keep-alive 中的生命周期哪些\n\nkeep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。\n\n如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。\n\n当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。",
      "normalizedContent": "# 1. 说一下vue的生命周期\n\nvue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载dom -> 渲染、更新 -> 渲染、卸载 等⼀系列过程，称这是vue的⽣命周期。\n\n 1. beforecreate（创建前）：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。\n 2. created（创建后） ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 dom，所以不能访问到 $el 属性。\n 3. beforemount（挂载前）：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。\n 4. mounted（挂载后）：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的dom对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。\n 5. beforeupdate（更新前）：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 dom 还没有被渲染。\n 6. updated（更新后） ：在由于数据更改导致的虚拟dom重新渲染和打补丁之后调用。此时 dom 已经根据响应式数据的变化更新了。调用时，组件 dom已经更新，所以可以执行依赖于dom的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。\n 7. beforedestroy（销毁前）：实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。\n 8. destroyed（销毁后）：实例销毁后调用，调用后，vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。\n\n另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。\n\n\n# 2. vue 子组件和父组件执行顺序\n\n加载渲染过程：\n\n 1. 父组件 beforecreate\n 2. 父组件 created\n 3. 父组件 beforemount\n 4. 子组件 beforecreate\n 5. 子组件 created\n 6. 子组件 beforemount\n 7. 子组件 mounted\n 8. 父组件 mounted\n\n更新过程：\n\n 1. 父组件 beforeupdate\n 2. 子组件 beforeupdate\n 3. 子组件 updated\n 4. 父组件 updated\n\n销毁过程：\n\n 1. 父组件 beforedestroy\n 2. 子组件 beforedestroy\n 3. 子组件 destroyed\n 4. 父组件 destoryed\n\n\n# 3. created和mounted的区别\n\n * created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。\n * mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。\n\n\n# 4. 一般在哪个生命周期请求异步数据\n\n我们可以在钩子函数 created、beforemount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。\n\n推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：\n\n * 能更快获取到服务端数据，减少页面加载时间，用户体验更好；\n * ssr不支持 beforemount 、mounted 钩子函数，放在 created 中有助于一致性。\n\n\n# 5. keep-alive 中的生命周期哪些\n\nkeep-alive是 vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染dom。\n\n如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforedestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。\n\n当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "组件通信",
      "frontmatter": {
        "title": "组件通信",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/frameComponent/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/10.vue%E7%AF%87/30.%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html",
      "relativePath": "30.框架篇/10.vue篇/30.组件通信.md",
      "key": "v-22e7faf2",
      "path": "/pages/frameComponent/",
      "headers": [
        {
          "level": 3,
          "title": "（1） props  /  $emit",
          "slug": "_1-props-emit",
          "normalizedTitle": "（1） props  /  $emit",
          "charIndex": null
        },
        {
          "level": 3,
          "title": "（2）eventBus事件总线（$emit / $on）",
          "slug": "_2-eventbus事件总线-emit-on",
          "normalizedTitle": "（2）eventbus事件总线（$emit / $on）",
          "charIndex": 1715
        },
        {
          "level": 3,
          "title": "（3）依赖注入（provide / inject）",
          "slug": "_3-依赖注入-provide-inject",
          "normalizedTitle": "（3）依赖注入（provide / inject）",
          "charIndex": 2952
        },
        {
          "level": 3,
          "title": "（4）ref / $refs",
          "slug": "_4-ref-refs",
          "normalizedTitle": "（4）ref / $refs",
          "charIndex": 3469
        },
        {
          "level": 3,
          "title": "（5）$parent / $children",
          "slug": "_5-parent-children",
          "normalizedTitle": "（5）$parent / $children",
          "charIndex": 4014
        },
        {
          "level": 3,
          "title": "（6）$attrs / $listeners",
          "slug": "_6-attrs-listeners",
          "normalizedTitle": "（6）$attrs / $listeners",
          "charIndex": 5124
        },
        {
          "level": 3,
          "title": "（7）总结",
          "slug": "_7-总结",
          "normalizedTitle": "（7）总结",
          "charIndex": 6979
        }
      ],
      "headersStr": "（1） props  /  $emit （2）eventBus事件总线（$emit / $on） （3）依赖注入（provide / inject） （4）ref / $refs （5）$parent / $children （6）$attrs / $listeners （7）总结",
      "content": "组件通信的方式如下：\n\n\n# （1） props / $emit\n\n父组件通过props向子组件传递数据，子组件通过$emit和父组件通信\n\n# 1. 父组件向子组件传值\n\n * props只能是父组件向子组件进行传值，props使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。\n * props 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。\n * props属性名规则：若在props中使用驼峰形式，模板中需要使用短横线的形式\n\n// 父组件\n<template>\n    <div id=\"father\">\n        <son :msg=\"msgData\" :fn=\"myFunction\"></son>\n    </div>\n</template>\n\n<script>\nimport son from \"./son.vue\";\nexport default {\n    name: father,\n    data() {\n        msgData: \"父组件数据\";\n    },\n    methods: {\n        myFunction() {\n            console.log(\"vue\");\n        }\n    },\n    components: {\n        son\n    }\n};\n</script>\n\n\n// 子组件\n<template>\n    <div id=\"son\">\n        <p>{{msg}}</p>\n        <button @click=\"fn\">按钮</button>\n    </div>\n</template>\n<script>\nexport default {\n    name: \"son\",\n    props: [\"msg\", \"fn\"]\n};\n</script>\n\n\n# 2. 子组件向父组件传值\n\n * $emit绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过v-on监听并接收参数。\n\n// 父组件\n<template>\n  <div class=\"section\">\n    <com-article :articles=\"articleList\" @onEmitIndex=\"onEmitIndex\"></com-article>\n    <p>{{currentIndex}}</p>\n  </div>\n</template>\n\n<script>\nimport comArticle from './test/article.vue'\nexport default {\n  name: 'comArticle',\n  components: { comArticle },\n  data() {\n    return {\n      currentIndex: -1,\n      articleList: ['红楼梦', '西游记', '三国演义']\n    }\n  },\n  methods: {\n    onEmitIndex(idx) {\n      this.currentIndex = idx\n    }\n  }\n}\n</script>\n\n\n//子组件\n<template>\n  <div>\n    <div v-for=\"(item, index) in articles\" :key=\"index\" @click=\"emitIndex(index)\">{{item}}</div>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['articles'],\n  methods: {\n    emitIndex(index) {\n      this.$emit('onEmitIndex', index) // 触发父组件的方法，并传递参数index\n    }\n  }\n}\n</script>\n\n\n\n# （2）eventBus事件总线（$emit / $on）\n\neventBus事件总线适用于父子组件、非父子组件等之间的通信，使用步骤如下： （1）创建事件中心管理组件之间的通信\n\n// event-bus.js\n\nimport Vue from 'vue'\nexport const EventBus = new Vue()\n\n\n（2）发送事件 假设有两个兄弟组件firstCom和secondCom：\n\n<template>\n  <div>\n    <first-com></first-com>\n    <second-com></second-com>\n  </div>\n</template>\n\n<script>\nimport firstCom from './firstCom.vue'\nimport secondCom from './secondCom.vue'\nexport default {\n  components: { firstCom, secondCom }\n}\n</script>\n\n\n在firstCom组件中发送事件：\n\n<template>\n  <div>\n    <button @click=\"add\">加法</button>    \n  </div>\n</template>\n\n<script>\nimport {EventBus} from './event-bus.js' // 引入事件中心\n\nexport default {\n  data(){\n    return{\n      num:0\n    }\n  },\n  methods:{\n    add(){\n      EventBus.$emit('addition', {\n        num:this.num++\n      })\n    }\n  }\n}\n</script>\n\n\n（3）接收事件 在secondCom组件中发送事件：\n\n<template>\n  <div>求和: {{count}}</div>\n</template>\n\n<script>\nimport { EventBus } from './event-bus.js'\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  mounted() {\n    EventBus.$on('addition', param => {\n      this.count = this.count + param.num;\n    })\n  }\n}\n</script>\n\n\n在上述代码中，这就相当于将num值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。\n\n虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。\n\n\n# （3）依赖注入（provide / inject）\n\n这种方式就是Vue中的依赖注入，该方法用于父子组件之间的通信。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。\n\nprovide / inject是Vue提供的两个钩子，和data、methods是同级的。并且provide的书写形式和data一样。\n\n * provide 钩子用来发送数据或方法\n * inject钩子用来接收数据或方法\n\n在父组件中：\n\nprovide() { \n    return {     \n        num: this.num  \n    };\n}\n\n\n在子组件中：\n\ninject: ['num']\n\n\n还可以这样写，这样写就可以访问父组件中的所有属性：\n\nprovide() {\n return {\n    app: this\n  };\n}\ndata() {\n return {\n    num: 1\n  };\n}\n\ninject: ['app']\nconsole.log(this.app.num)\n\n\n注意： 依赖注入所提供的属性是非响应式的。\n\n\n# （4）ref / $refs\n\n这种方式也是实现父子组件之间的通信。\n\nref： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。\n\n在子组件中：\n\nexport default {\n  data () {\n    return {\n      name: 'JavaScript'\n    }\n  },\n  methods: {\n    sayHello () {\n      console.log('hello')\n    }\n  }\n}\n\n\n在父组件中：\n\n<template>\n  <child ref=\"child\"></component-a>\n</template>\n<script>\n  import child from './child.vue'\n  export default {\n    components: { child },\n    mounted () {\n      console.log(this.$refs.child.name);  // JavaScript\n      this.$refs.child.sayHello();  // hello\n    }\n  }\n</script>\n\n\n\n# （5）$parent / $children\n\n * 使用$parent可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）\n * 使用$children可以让组件访问子组件的实例，但是，$children并不能保证顺序，并且访问的数据也不是响应式的。\n\n在子组件中：\n\n<template>\n  <div>\n    <span>{{message}}</span>\n    <p>获取父组件的值为:  {{parentVal}}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      message: 'Vue'\n    }\n  },\n  computed:{\n    parentVal(){\n      return this.$parent.msg;\n    }\n  }\n}\n</script>\n\n\n在父组件中：\n\n// 父组件中\n<template>\n  <div class=\"hello_world\">\n    <div>{{msg}}</div>\n    <child></child>\n    <button @click=\"change\">点击改变子组件值</button>\n  </div>\n</template>\n\n<script>\nimport child from './child.vue'\nexport default {\n  components: { child },\n  data() {\n    return {\n      msg: 'Welcome'\n    }\n  },\n  methods: {\n    change() {\n      // 获取到子组件\n      this.$children[0].message = 'JavaScript'\n    }\n  }\n}\n</script>\n\n\n在上面的代码中，子组件获取到了父组件的parentVal值，父组件改变了子组件中message的值。 需要注意：\n\n * 通过$parent访问到的是上一级父组件的实例，可以使用$root来访问根组件的实例\n * 在组件中使用$children拿到的是所有的子组件的实例，它是一个数组，并且是无序的\n * 在根组件#app上拿$parent得到的是new Vue()的实例，在这实例上再拿$parent得到的是undefined，而在最底层的子组件拿$children是个空数组\n * $children 的值是数组，而$parent是个对象\n\n\n# （6）$attrs / $listeners\n\n考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？\n\n如果是用props/$emit来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。\n\n针对上述情况，Vue引入了$attrs / $listeners，实现组件之间的跨代通信。\n\n先来看一下inheritAttrs，它的默认值true，继承所有的父组件属性除props之外的所有属性；inheritAttrs：false 只继承class属性 。\n\n * $attrs：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上\n * $listeners：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 v-on=\"$listeners\" 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）\n\nA组件（APP.vue）：\n\n<template>\n    <div id=\"app\">\n        //此处监听了两个事件，可以在B组件或者C组件中直接触发 \n        <child1 :p-child1=\"child1\" :p-child2=\"child2\" @test1=\"onTest1\" @test2=\"onTest2\"></child1>\n    </div>\n</template>\n<script>\nimport Child1 from './Child1.vue';\nexport default {\n    components: { Child1 },\n    methods: {\n        onTest1() {\n            console.log('test1 running');\n        },\n        onTest2() {\n            console.log('test2 running');\n        }\n    }\n};\n</script>\n\n\nB组件（Child1.vue）：\n\n<template>\n    <div class=\"child-1\">\n        <p>props: {{pChild1}}</p>\n        <p>$attrs: {{$attrs}}</p>\n        <child2 v-bind=\"$attrs\" v-on=\"$listeners\"></child2>\n    </div>\n</template>\n<script>\nimport Child2 from './Child2.vue';\nexport default {\n    props: ['pChild1'],\n    components: { Child2 },\n    inheritAttrs: false,\n    mounted() {\n        this.$emit('test1'); // 触发APP.vue中的test1方法\n    }\n};\n</script>\n\n\nC 组件 (Child2.vue)：\n\n<template>\n    <div class=\"child-2\">\n        <p>props: {{pChild2}}</p>\n        <p>$attrs: {{$attrs}}</p>\n    </div>\n</template>\n<script>\nexport default {\n    props: ['pChild2'],\n    inheritAttrs: false,\n    mounted() {\n        this.$emit('test2');// 触发APP.vue中的test2方法\n    }\n};\n</script>\n\n\n在上述代码中：\n\n * C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性\n * 在B组件中通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）\n\n\n# （7）总结\n\n（1）父子组件间通信\n\n * 子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。\n * 通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。\n * 使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。\n\n（2）兄弟组件间通信\n\n * 使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。\n * 通过 $parent/$refs 来获取到兄弟组件，也可以进行通信。\n\n（3）任意组件之间\n\n * 使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。\n\n如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。",
      "normalizedContent": "组件通信的方式如下：\n\n\n# （1） props / $emit\n\n父组件通过props向子组件传递数据，子组件通过$emit和父组件通信\n\n# 1. 父组件向子组件传值\n\n * props只能是父组件向子组件进行传值，props使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。\n * props 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。\n * props属性名规则：若在props中使用驼峰形式，模板中需要使用短横线的形式\n\n// 父组件\n<template>\n    <div id=\"father\">\n        <son :msg=\"msgdata\" :fn=\"myfunction\"></son>\n    </div>\n</template>\n\n<script>\nimport son from \"./son.vue\";\nexport default {\n    name: father,\n    data() {\n        msgdata: \"父组件数据\";\n    },\n    methods: {\n        myfunction() {\n            console.log(\"vue\");\n        }\n    },\n    components: {\n        son\n    }\n};\n</script>\n\n\n// 子组件\n<template>\n    <div id=\"son\">\n        <p>{{msg}}</p>\n        <button @click=\"fn\">按钮</button>\n    </div>\n</template>\n<script>\nexport default {\n    name: \"son\",\n    props: [\"msg\", \"fn\"]\n};\n</script>\n\n\n# 2. 子组件向父组件传值\n\n * $emit绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过v-on监听并接收参数。\n\n// 父组件\n<template>\n  <div class=\"section\">\n    <com-article :articles=\"articlelist\" @onemitindex=\"onemitindex\"></com-article>\n    <p>{{currentindex}}</p>\n  </div>\n</template>\n\n<script>\nimport comarticle from './test/article.vue'\nexport default {\n  name: 'comarticle',\n  components: { comarticle },\n  data() {\n    return {\n      currentindex: -1,\n      articlelist: ['红楼梦', '西游记', '三国演义']\n    }\n  },\n  methods: {\n    onemitindex(idx) {\n      this.currentindex = idx\n    }\n  }\n}\n</script>\n\n\n//子组件\n<template>\n  <div>\n    <div v-for=\"(item, index) in articles\" :key=\"index\" @click=\"emitindex(index)\">{{item}}</div>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['articles'],\n  methods: {\n    emitindex(index) {\n      this.$emit('onemitindex', index) // 触发父组件的方法，并传递参数index\n    }\n  }\n}\n</script>\n\n\n\n# （2）eventbus事件总线（$emit / $on）\n\neventbus事件总线适用于父子组件、非父子组件等之间的通信，使用步骤如下： （1）创建事件中心管理组件之间的通信\n\n// event-bus.js\n\nimport vue from 'vue'\nexport const eventbus = new vue()\n\n\n（2）发送事件 假设有两个兄弟组件firstcom和secondcom：\n\n<template>\n  <div>\n    <first-com></first-com>\n    <second-com></second-com>\n  </div>\n</template>\n\n<script>\nimport firstcom from './firstcom.vue'\nimport secondcom from './secondcom.vue'\nexport default {\n  components: { firstcom, secondcom }\n}\n</script>\n\n\n在firstcom组件中发送事件：\n\n<template>\n  <div>\n    <button @click=\"add\">加法</button>    \n  </div>\n</template>\n\n<script>\nimport {eventbus} from './event-bus.js' // 引入事件中心\n\nexport default {\n  data(){\n    return{\n      num:0\n    }\n  },\n  methods:{\n    add(){\n      eventbus.$emit('addition', {\n        num:this.num++\n      })\n    }\n  }\n}\n</script>\n\n\n（3）接收事件 在secondcom组件中发送事件：\n\n<template>\n  <div>求和: {{count}}</div>\n</template>\n\n<script>\nimport { eventbus } from './event-bus.js'\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  mounted() {\n    eventbus.$on('addition', param => {\n      this.count = this.count + param.num;\n    })\n  }\n}\n</script>\n\n\n在上述代码中，这就相当于将num值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。\n\n虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。\n\n\n# （3）依赖注入（provide / inject）\n\n这种方式就是vue中的依赖注入，该方法用于父子组件之间的通信。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。\n\nprovide / inject是vue提供的两个钩子，和data、methods是同级的。并且provide的书写形式和data一样。\n\n * provide 钩子用来发送数据或方法\n * inject钩子用来接收数据或方法\n\n在父组件中：\n\nprovide() { \n    return {     \n        num: this.num  \n    };\n}\n\n\n在子组件中：\n\ninject: ['num']\n\n\n还可以这样写，这样写就可以访问父组件中的所有属性：\n\nprovide() {\n return {\n    app: this\n  };\n}\ndata() {\n return {\n    num: 1\n  };\n}\n\ninject: ['app']\nconsole.log(this.app.num)\n\n\n注意： 依赖注入所提供的属性是非响应式的。\n\n\n# （4）ref / $refs\n\n这种方式也是实现父子组件之间的通信。\n\nref： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。\n\n在子组件中：\n\nexport default {\n  data () {\n    return {\n      name: 'javascript'\n    }\n  },\n  methods: {\n    sayhello () {\n      console.log('hello')\n    }\n  }\n}\n\n\n在父组件中：\n\n<template>\n  <child ref=\"child\"></component-a>\n</template>\n<script>\n  import child from './child.vue'\n  export default {\n    components: { child },\n    mounted () {\n      console.log(this.$refs.child.name);  // javascript\n      this.$refs.child.sayhello();  // hello\n    }\n  }\n</script>\n\n\n\n# （5）$parent / $children\n\n * 使用$parent可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）\n * 使用$children可以让组件访问子组件的实例，但是，$children并不能保证顺序，并且访问的数据也不是响应式的。\n\n在子组件中：\n\n<template>\n  <div>\n    <span>{{message}}</span>\n    <p>获取父组件的值为:  {{parentval}}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      message: 'vue'\n    }\n  },\n  computed:{\n    parentval(){\n      return this.$parent.msg;\n    }\n  }\n}\n</script>\n\n\n在父组件中：\n\n// 父组件中\n<template>\n  <div class=\"hello_world\">\n    <div>{{msg}}</div>\n    <child></child>\n    <button @click=\"change\">点击改变子组件值</button>\n  </div>\n</template>\n\n<script>\nimport child from './child.vue'\nexport default {\n  components: { child },\n  data() {\n    return {\n      msg: 'welcome'\n    }\n  },\n  methods: {\n    change() {\n      // 获取到子组件\n      this.$children[0].message = 'javascript'\n    }\n  }\n}\n</script>\n\n\n在上面的代码中，子组件获取到了父组件的parentval值，父组件改变了子组件中message的值。 需要注意：\n\n * 通过$parent访问到的是上一级父组件的实例，可以使用$root来访问根组件的实例\n * 在组件中使用$children拿到的是所有的子组件的实例，它是一个数组，并且是无序的\n * 在根组件#app上拿$parent得到的是new vue()的实例，在这实例上再拿$parent得到的是undefined，而在最底层的子组件拿$children是个空数组\n * $children 的值是数组，而$parent是个对象\n\n\n# （6）$attrs / $listeners\n\n考虑一种场景，如果a是b组件的父组件，b是c组件的父组件。如果想要组件a给组件c传递数据，这种隔代的数据，该使用哪种方式呢？\n\n如果是用props/$emit来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。\n\n针对上述情况，vue引入了$attrs / $listeners，实现组件之间的跨代通信。\n\n先来看一下inheritattrs，它的默认值true，继承所有的父组件属性除props之外的所有属性；inheritattrs：false 只继承class属性 。\n\n * $attrs：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上\n * $listeners：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 v-on=\"$listeners\" 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）\n\na组件（app.vue）：\n\n<template>\n    <div id=\"app\">\n        //此处监听了两个事件，可以在b组件或者c组件中直接触发 \n        <child1 :p-child1=\"child1\" :p-child2=\"child2\" @test1=\"ontest1\" @test2=\"ontest2\"></child1>\n    </div>\n</template>\n<script>\nimport child1 from './child1.vue';\nexport default {\n    components: { child1 },\n    methods: {\n        ontest1() {\n            console.log('test1 running');\n        },\n        ontest2() {\n            console.log('test2 running');\n        }\n    }\n};\n</script>\n\n\nb组件（child1.vue）：\n\n<template>\n    <div class=\"child-1\">\n        <p>props: {{pchild1}}</p>\n        <p>$attrs: {{$attrs}}</p>\n        <child2 v-bind=\"$attrs\" v-on=\"$listeners\"></child2>\n    </div>\n</template>\n<script>\nimport child2 from './child2.vue';\nexport default {\n    props: ['pchild1'],\n    components: { child2 },\n    inheritattrs: false,\n    mounted() {\n        this.$emit('test1'); // 触发app.vue中的test1方法\n    }\n};\n</script>\n\n\nc 组件 (child2.vue)：\n\n<template>\n    <div class=\"child-2\">\n        <p>props: {{pchild2}}</p>\n        <p>$attrs: {{$attrs}}</p>\n    </div>\n</template>\n<script>\nexport default {\n    props: ['pchild2'],\n    inheritattrs: false,\n    mounted() {\n        this.$emit('test2');// 触发app.vue中的test2方法\n    }\n};\n</script>\n\n\n在上述代码中：\n\n * c组件中能直接触发test的原因在于 b组件调用c组件时 使用 v-on 绑定了$listeners 属性\n * 在b组件中通过v-bind 绑定$attrs属性，c组件可以直接获取到a组件中传递下来的props（除了b组件中props声明的）\n\n\n# （7）总结\n\n（1）父子组件间通信\n\n * 子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。\n * 通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。\n * 使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。\n\n（2）兄弟组件间通信\n\n * 使用 eventbus 的方法，它的本质是通过创建一个空的 vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。\n * 通过 $parent/$refs 来获取到兄弟组件，也可以进行通信。\n\n（3）任意组件之间\n\n * 使用 eventbus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。\n\n如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "Vuex",
      "frontmatter": {
        "title": "Vuex",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/frameVuex/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/10.vue%E7%AF%87/50.Vuex.html",
      "relativePath": "30.框架篇/10.vue篇/50.Vuex.md",
      "key": "v-d7d762a2",
      "path": "/pages/frameVuex/",
      "headers": [
        {
          "level": 3,
          "title": "1. Vuex 的原理",
          "slug": "_1-vuex-的原理",
          "normalizedTitle": "1. vuex 的原理",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. Vuex中action和mutation的区别",
          "slug": "_2-vuex中action和mutation的区别",
          "normalizedTitle": "2. vuex中action和mutation的区别",
          "charIndex": 1265
        },
        {
          "level": 3,
          "title": "3. Vuex 和 localStorage 的区别",
          "slug": "_3-vuex-和-localstorage-的区别",
          "normalizedTitle": "3. vuex 和 localstorage 的区别",
          "charIndex": 2375
        },
        {
          "level": 3,
          "title": "4. Redux 和 Vuex 有什么区别，它们的共同思想",
          "slug": "_4-redux-和-vuex-有什么区别-它们的共同思想",
          "normalizedTitle": "4. redux 和 vuex 有什么区别，它们的共同思想",
          "charIndex": 2872
        },
        {
          "level": 3,
          "title": "5. 为什么要用 Vuex 或者 Redux",
          "slug": "_5-为什么要用-vuex-或者-redux",
          "normalizedTitle": "5. 为什么要用 vuex 或者 redux",
          "charIndex": 3396
        },
        {
          "level": 3,
          "title": "6. Vuex有哪几种属性？",
          "slug": "_6-vuex有哪几种属性",
          "normalizedTitle": "6. vuex有哪几种属性？",
          "charIndex": 3655
        },
        {
          "level": 3,
          "title": "7. Vuex和单纯的全局对象有什么区别？",
          "slug": "_7-vuex和单纯的全局对象有什么区别",
          "normalizedTitle": "7. vuex和单纯的全局对象有什么区别？",
          "charIndex": 3867
        },
        {
          "level": 3,
          "title": "8. 为什么 Vuex 的 mutation 中不能做异步操作？",
          "slug": "_8-为什么-vuex-的-mutation-中不能做异步操作",
          "normalizedTitle": "8. 为什么 vuex 的 mutation 中不能做异步操作？",
          "charIndex": 4082
        },
        {
          "level": 3,
          "title": "9. Vuex的严格模式是什么,有什么作用，如何开启？",
          "slug": "_9-vuex的严格模式是什么-有什么作用-如何开启",
          "normalizedTitle": "9. vuex的严格模式是什么,有什么作用，如何开启？",
          "charIndex": 4352
        },
        {
          "level": 3,
          "title": "10. 如何在组件中批量使用Vuex的getter属性",
          "slug": "_10-如何在组件中批量使用vuex的getter属性",
          "normalizedTitle": "10. 如何在组件中批量使用vuex的getter属性",
          "charIndex": 4529
        },
        {
          "level": 3,
          "title": "11. 如何在组件中重复使用Vuex的mutation",
          "slug": "_11-如何在组件中重复使用vuex的mutation",
          "normalizedTitle": "11. 如何在组件中重复使用vuex的mutation",
          "charIndex": 4733
        }
      ],
      "headersStr": "1. Vuex 的原理 2. Vuex中action和mutation的区别 3. Vuex 和 localStorage 的区别 4. Redux 和 Vuex 有什么区别，它们的共同思想 5. 为什么要用 Vuex 或者 Redux 6. Vuex有哪几种属性？ 7. Vuex和单纯的全局对象有什么区别？ 8. 为什么 Vuex 的 mutation 中不能做异步操作？ 9. Vuex的严格模式是什么,有什么作用，如何开启？ 10. 如何在组件中批量使用Vuex的getter属性 11. 如何在组件中重复使用Vuex的mutation",
      "content": "# 1. Vuex 的原理\n\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\n\n * Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n * 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。\n\nVuex为Vue Components建立起了一个完整的生态圈，包括开发中的API调用一环。 （1）核心流程中的主要功能：\n\n * Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;\n * 在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;\n * 然后 Mutations 就去改变（Mutate）State 中的数据;\n * 当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。\n\n（2）各模块在核心流程中的主要功能：\n\n * Vue Components∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。\n * dispatch∶操作行为触发方法，是唯一能执行action的方法。\n * actions∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。\n * commit∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。\n * mutations∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。\n * state∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。\n * getters∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。\n\n\n# 2. Vuex中action和mutation的区别\n\nmutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：\n\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      state.count++      // 变更状态\n    }\n  }\n})\n\n\n当触发一个类型为 increment 的 mutation 时，需要调用此函数：\n\nstore.commit('increment')\n\n\n而Action类似于mutation，不同点在于：\n\n * Action 可以包含任意异步操作。\n * Action 提交的是 mutation，而不是直接变更状态。\n\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n\n\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 所以，两者的不同点如下：\n\n * Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。\n * Mutation：必须同步执行；Action：可以异步，但不能直接操作State。\n * 在视图更新时，先触发actions，actions再触发mutation\n * mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters\n\n\n# 3. Vuex 和 localStorage 的区别\n\n（1）最重要的区别\n\n * vuex存储在内存中\n * localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快\n\n（2）应用场景\n\n * Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。\n * localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。\n * Vuex能做到数据的响应式，localstorage不能\n\n（3）永久性\n\n刷新页面时vuex存储的值会丢失，localstorage不会。\n\n注意： 对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。\n\n\n# 4. Redux 和 Vuex 有什么区别，它们的共同思想\n\n（1）Redux 和 Vuex区别\n\n * Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可\n * Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可\n * Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）\n\n通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;\n\n（2）共同思想\n\n * 单—的数据源\n * 变化可以预测\n\n本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案; 形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;\n\n\n# 5. 为什么要用 Vuex 或者 Redux\n\n由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。\n\n所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的\"视图\"，不管在树的哪个位置，任何组件都能获取状态或者触发行为。\n\n另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。\n\n\n# 6. Vuex有哪几种属性？\n\n有五种，分别是 State、 Getter、Mutation 、Action、 Module\n\n * state => 基本数据(数据源存放地)\n * getters => 从基本数据派生出来的数据\n * mutations => 提交更改数据的方法，同步\n * actions => 像一个装饰器，包裹mutations，使之可以异步。\n * modules => 模块化Vuex\n\n\n# 7. Vuex和单纯的全局对象有什么区别？\n\n * Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n * 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。\n\n\n# 8. 为什么 Vuex 的 mutation 中不能做异步操作？\n\n * Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。\n * 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。\n\n\n# 9. Vuex的严格模式是什么,有什么作用，如何开启？\n\n在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。\n\n在Vuex.Store 构造器选项中开启,如下\n\nconst store = new Vuex.Store({\n    strict:true,\n})\n\n\n\n# 10. 如何在组件中批量使用Vuex的getter属性\n\n使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中\n\nimport {mapGetters} from 'vuex'\nexport default{\n    computed:{\n        ...mapGetters(['total','discountTotal'])\n    }\n}\n\n\n\n# 11. 如何在组件中重复使用Vuex的mutation\n\n使用mapMutations辅助函数,在组件中这么使用\n\nimport { mapMutations } from 'vuex'\nmethods:{\n    ...mapMutations({\n        setNumber:'SET_NUMBER',\n    })\n}\n\n\n然后调用this.setNumber(10)相当调用this.$store.commit('SET_NUMBER',10)",
      "normalizedContent": "# 1. vuex 的原理\n\nvuex 是一个专为 vue.js 应用程序开发的状态管理模式。每一个 vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\n\n * vuex 的状态存储是响应式的。当 vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n * 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。\n\nvuex为vue components建立起了一个完整的生态圈，包括开发中的api调用一环。 （1）核心流程中的主要功能：\n\n * vue components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 actions;\n * 在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（commit）到 mutations 中;\n * 然后 mutations 就去改变（mutate）state 中的数据;\n * 当 state 中的数据被改变之后，就会重新渲染（render）到 vue components 中去，组件展示更新后的数据，完成一个流程。\n\n（2）各模块在核心流程中的主要功能：\n\n * vue components∶ vue组件。html页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。\n * dispatch∶操作行为触发方法，是唯一能执行action的方法。\n * actions∶ 操作行为处理模块。负责处理vue components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台api请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了promise的封装，以支持action的链式触发。\n * commit∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。\n * mutations∶状态改变操作方法。是vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。\n * state∶ 页面状态管理容器对象。集中存储vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用vue的细粒度数据响应机制来进行高效的状态更新。\n * getters∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，vue components通过该方法读取全局state对象。\n\n\n# 2. vuex中action和mutation的区别\n\nmutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：\n\nconst store = new vuex.store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      state.count++      // 变更状态\n    }\n  }\n})\n\n\n当触发一个类型为 increment 的 mutation 时，需要调用此函数：\n\nstore.commit('increment')\n\n\n而action类似于mutation，不同点在于：\n\n * action 可以包含任意异步操作。\n * action 提交的是 mutation，而不是直接变更状态。\n\nconst store = new vuex.store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n\n\naction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 所以，两者的不同点如下：\n\n * mutation专注于修改state，理论上是修改state的唯一途径；action业务代码、异步请求。\n * mutation：必须同步执行；action：可以异步，但不能直接操作state。\n * 在视图更新时，先触发actions，actions再触发mutation\n * mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters\n\n\n# 3. vuex 和 localstorage 的区别\n\n（1）最重要的区别\n\n * vuex存储在内存中\n * localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 json的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快\n\n（2）应用场景\n\n * vuex 是一个专为 vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。\n * localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。\n * vuex能做到数据的响应式，localstorage不能\n\n（3）永久性\n\n刷新页面时vuex存储的值会丢失，localstorage不会。\n\n注意： 对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。\n\n\n# 4. redux 和 vuex 有什么区别，它们的共同思想\n\n（1）redux 和 vuex区别\n\n * vuex改进了redux中的action和reducer函数，以mutations变化函数取代reducer，无需switch，只需在对应的mutation函数里改变state值即可\n * vuex由于vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的state即可\n * vuex数据流的顺序是∶view调用store.commit提交对应的请求到store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）\n\n通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;\n\n（2）共同思想\n\n * 单—的数据源\n * 变化可以预测\n\n本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案; 形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;\n\n\n# 5. 为什么要用 vuex 或者 redux\n\n由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。\n\n所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的\"视图\"，不管在树的哪个位置，任何组件都能获取状态或者触发行为。\n\n另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。\n\n\n# 6. vuex有哪几种属性？\n\n有五种，分别是 state、 getter、mutation 、action、 module\n\n * state => 基本数据(数据源存放地)\n * getters => 从基本数据派生出来的数据\n * mutations => 提交更改数据的方法，同步\n * actions => 像一个装饰器，包裹mutations，使之可以异步。\n * modules => 模块化vuex\n\n\n# 7. vuex和单纯的全局对象有什么区别？\n\n * vuex 的状态存储是响应式的。当 vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n * 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。\n\n\n# 8. 为什么 vuex 的 mutation 中不能做异步操作？\n\n * vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。\n * 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。\n\n\n# 9. vuex的严格模式是什么,有什么作用，如何开启？\n\n在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。\n\n在vuex.store 构造器选项中开启,如下\n\nconst store = new vuex.store({\n    strict:true,\n})\n\n\n\n# 10. 如何在组件中批量使用vuex的getter属性\n\n使用mapgetters辅助函数, 利用对象展开运算符将getter混入computed 对象中\n\nimport {mapgetters} from 'vuex'\nexport default{\n    computed:{\n        ...mapgetters(['total','discounttotal'])\n    }\n}\n\n\n\n# 11. 如何在组件中重复使用vuex的mutation\n\n使用mapmutations辅助函数,在组件中这么使用\n\nimport { mapmutations } from 'vuex'\nmethods:{\n    ...mapmutations({\n        setnumber:'set_number',\n    })\n}\n\n\n然后调用this.setnumber(10)相当调用this.$store.commit('set_number',10)",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "vue基础",
      "frontmatter": {
        "title": "vue基础",
        "date": "2022-10-20T10:31:15.000Z",
        "permalink": "/pages/frameVue/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/10.vue%E7%AF%87/10.vue%E5%9F%BA%E7%A1%80.html",
      "relativePath": "30.框架篇/10.vue篇/10.vue基础.md",
      "key": "v-6e6bed5f",
      "path": "/pages/frameVue/",
      "headers": [
        {
          "level": 3,
          "title": "1. Vue的基本原理",
          "slug": "_1-vue的基本原理",
          "normalizedTitle": "1. vue的基本原理",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 双向数据绑定的原理",
          "slug": "_2-双向数据绑定的原理",
          "normalizedTitle": "2. 双向数据绑定的原理",
          "charIndex": 227
        },
        {
          "level": 3,
          "title": "3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？",
          "slug": "_3-使用-object-defineproperty-来进行数据劫持有什么缺点",
          "normalizedTitle": "3. 使用 object.defineproperty() 来进行数据劫持有什么缺点？",
          "charIndex": 879
        },
        {
          "level": 3,
          "title": "4. MVVM、MVC、MVP的区别",
          "slug": "_4-mvvm、mvc、mvp的区别",
          "normalizedTitle": "4. mvvm、mvc、mvp的区别",
          "charIndex": 1194
        },
        {
          "level": 3,
          "title": "5. Computed 和 Watch 的区别",
          "slug": "_5-computed-和-watch-的区别",
          "normalizedTitle": "5. computed 和 watch 的区别",
          "charIndex": 2475
        },
        {
          "level": 3,
          "title": "6. Computed 和 Methods 的区别",
          "slug": "_6-computed-和-methods-的区别",
          "normalizedTitle": "6. computed 和 methods 的区别",
          "charIndex": 3490
        },
        {
          "level": 3,
          "title": "7. slot是什么？有什么作用？原理是什么？",
          "slug": "_7-slot是什么-有什么作用-原理是什么",
          "normalizedTitle": "7. slot是什么？有什么作用？原理是什么？",
          "charIndex": 3648
        },
        {
          "level": 3,
          "title": "8. 过滤器的作用，如何实现一个过滤器",
          "slug": "_8-过滤器的作用-如何实现一个过滤器",
          "normalizedTitle": "8. 过滤器的作用，如何实现一个过滤器",
          "charIndex": 4187
        },
        {
          "level": 3,
          "title": "9. 如何保存页面的当前的状态",
          "slug": "_9-如何保存页面的当前的状态",
          "normalizedTitle": "9. 如何保存页面的当前的状态",
          "charIndex": 4688
        },
        {
          "level": 3,
          "title": "10. 常见的事件修饰符及其作用",
          "slug": "_10-常见的事件修饰符及其作用",
          "normalizedTitle": "10. 常见的事件修饰符及其作用",
          "charIndex": 6178
        },
        {
          "level": 3,
          "title": "11. v-if、v-show、v-html 的原理",
          "slug": "_11-v-if、v-show、v-html-的原理",
          "normalizedTitle": "11. v-if、v-show、v-html 的原理",
          "charIndex": 6438
        },
        {
          "level": 3,
          "title": "12. MVVM的优缺点?",
          "slug": "_12-mvvm的优缺点",
          "normalizedTitle": "12. mvvm的优缺点?",
          "charIndex": 6695
        },
        {
          "level": 3,
          "title": "13. v-if和v-show的区别",
          "slug": "_13-v-if和v-show的区别",
          "normalizedTitle": "13. v-if和v-show的区别",
          "charIndex": 7267
        },
        {
          "level": 3,
          "title": "14. v-model 是如何实现的，语法糖实际是什么？",
          "slug": "_14-v-model-是如何实现的-语法糖实际是什么",
          "normalizedTitle": "14. v-model 是如何实现的，语法糖实际是什么？",
          "charIndex": 7609
        },
        {
          "level": 3,
          "title": "15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？",
          "slug": "_15-v-model-可以被用在自定义组件上吗-如果可以-如何使用",
          "normalizedTitle": "15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？",
          "charIndex": 8756
        },
        {
          "level": 3,
          "title": "16. data为什么是一个函数而不是对象",
          "slug": "_16-data为什么是一个函数而不是对象",
          "normalizedTitle": "16. data为什么是一个函数而不是对象",
          "charIndex": 9453
        },
        {
          "level": 3,
          "title": "17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？",
          "slug": "_17-对keep-alive的理解-它是如何实现的-具体缓存的是什么",
          "normalizedTitle": "17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？",
          "charIndex": 9715
        },
        {
          "level": 3,
          "title": "18. $nextTick 原理及作用",
          "slug": "_18-nexttick-原理及作用",
          "normalizedTitle": "18. $nexttick 原理及作用",
          "charIndex": 15671
        },
        {
          "level": 3,
          "title": "19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？",
          "slug": "_19-vue-中给-data-中的对象属性添加一个新的属性时会发生什么-如何解决",
          "normalizedTitle": "19. vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？",
          "charIndex": 16711
        },
        {
          "level": 3,
          "title": "20. Vue中封装的数组方法有哪些，其如何实现页面更新",
          "slug": "_20-vue中封装的数组方法有哪些-其如何实现页面更新",
          "normalizedTitle": "20. vue中封装的数组方法有哪些，其如何实现页面更新",
          "charIndex": 17501
        },
        {
          "level": 3,
          "title": "21. Vue 单页应用与多页应用的区别",
          "slug": "_21-vue-单页应用与多页应用的区别",
          "normalizedTitle": "21. vue 单页应用与多页应用的区别",
          "charIndex": 18905
        },
        {
          "level": 3,
          "title": "22. Vue template 到 render 的过程",
          "slug": "_22-vue-template-到-render-的过程",
          "normalizedTitle": "22. vue template 到 render 的过程",
          "charIndex": 19152
        },
        {
          "level": 3,
          "title": "23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？",
          "slug": "_23-vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗",
          "normalizedTitle": "23. vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？",
          "charIndex": 19983
        },
        {
          "level": 3,
          "title": "24. 简述 mixin、extends 的覆盖逻辑",
          "slug": "_24-简述-mixin、extends-的覆盖逻辑",
          "normalizedTitle": "24. 简述 mixin、extends 的覆盖逻辑",
          "charIndex": 20267
        },
        {
          "level": 3,
          "title": "25. 描述下Vue自定义指令",
          "slug": "_25-描述下vue自定义指令",
          "normalizedTitle": "25. 描述下vue自定义指令",
          "charIndex": 21005
        },
        {
          "level": 3,
          "title": "26. 子组件可以直接改变父组件的数据吗？",
          "slug": "_26-子组件可以直接改变父组件的数据吗",
          "normalizedTitle": "26. 子组件可以直接改变父组件的数据吗？",
          "charIndex": 22067
        },
        {
          "level": 3,
          "title": "27. Vue是如何收集依赖的？",
          "slug": "_27-vue是如何收集依赖的",
          "normalizedTitle": "27. vue是如何收集依赖的？",
          "charIndex": 22349
        },
        {
          "level": 3,
          "title": "28. 对 React 和 Vue 的理解，它们的异同",
          "slug": "_28-对-react-和-vue-的理解-它们的异同",
          "normalizedTitle": "28. 对 react 和 vue 的理解，它们的异同",
          "charIndex": 24462
        },
        {
          "level": 3,
          "title": "29. Vue的优点",
          "slug": "_29-vue的优点",
          "normalizedTitle": "29. vue的优点",
          "charIndex": 25699
        },
        {
          "level": 3,
          "title": "30. assets和static的区别",
          "slug": "_30-assets和static的区别",
          "normalizedTitle": "30. assets和static的区别",
          "charIndex": 26076
        },
        {
          "level": 3,
          "title": "31. delete和Vue.delete删除数组的区别",
          "slug": "_31-delete和vue-delete删除数组的区别",
          "normalizedTitle": "31. delete和vue.delete删除数组的区别",
          "charIndex": 26630
        },
        {
          "level": 3,
          "title": "32. vue如何监听对象或者数组某个属性的变化",
          "slug": "_32-vue如何监听对象或者数组某个属性的变化",
          "normalizedTitle": "32. vue如何监听对象或者数组某个属性的变化",
          "charIndex": 26748
        },
        {
          "level": 3,
          "title": "33. 什么是 mixin ？",
          "slug": "_33-什么是-mixin",
          "normalizedTitle": "33. 什么是 mixin ？",
          "charIndex": 27446
        },
        {
          "level": 3,
          "title": "34. Vue模版编译原理",
          "slug": "_34-vue模版编译原理",
          "normalizedTitle": "34. vue模版编译原理",
          "charIndex": 27642
        },
        {
          "level": 3,
          "title": "35. 对SSR的理解",
          "slug": "_35-对ssr的理解",
          "normalizedTitle": "35. 对ssr的理解",
          "charIndex": 28027
        },
        {
          "level": 3,
          "title": "36. Vue的性能优化有哪些",
          "slug": "_36-vue的性能优化有哪些",
          "normalizedTitle": "36. vue的性能优化有哪些",
          "charIndex": 28257
        },
        {
          "level": 3,
          "title": "37. 对 SPA 单页面的理解，它的优缺点分别是什么？",
          "slug": "_37-对-spa-单页面的理解-它的优缺点分别是什么",
          "normalizedTitle": "37. 对 spa 单页面的理解，它的优缺点分别是什么？",
          "charIndex": 28733
        },
        {
          "level": 3,
          "title": "38. template和jsx的有什么分别？",
          "slug": "_38-template和jsx的有什么分别",
          "normalizedTitle": "38. template和jsx的有什么分别？",
          "charIndex": 29230
        },
        {
          "level": 3,
          "title": "39. vue初始化页面闪动问题",
          "slug": "_39-vue初始化页面闪动问题",
          "normalizedTitle": "39. vue初始化页面闪动问题",
          "charIndex": 29651
        },
        {
          "level": 3,
          "title": "40. extend 有什么作用",
          "slug": "_40-extend-有什么作用",
          "normalizedTitle": "40. extend 有什么作用",
          "charIndex": 29906
        }
      ],
      "headersStr": "1. Vue的基本原理 2. 双向数据绑定的原理 3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？ 4. MVVM、MVC、MVP的区别 5. Computed 和 Watch 的区别 6. Computed 和 Methods 的区别 7. slot是什么？有什么作用？原理是什么？ 8. 过滤器的作用，如何实现一个过滤器 9. 如何保存页面的当前的状态 10. 常见的事件修饰符及其作用 11. v-if、v-show、v-html 的原理 12. MVVM的优缺点? 13. v-if和v-show的区别 14. v-model 是如何实现的，语法糖实际是什么？ 15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？ 16. data为什么是一个函数而不是对象 17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？ 18. $nextTick 原理及作用 19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？ 20. Vue中封装的数组方法有哪些，其如何实现页面更新 21. Vue 单页应用与多页应用的区别 22. Vue template 到 render 的过程 23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？ 24. 简述 mixin、extends 的覆盖逻辑 25. 描述下Vue自定义指令 26. 子组件可以直接改变父组件的数据吗？ 27. Vue是如何收集依赖的？ 28. 对 React 和 Vue 的理解，它们的异同 29. Vue的优点 30. assets和static的区别 31. delete和Vue.delete删除数组的区别 32. vue如何监听对象或者数组某个属性的变化 33. 什么是 mixin ？ 34. Vue模版编译原理 35. 对SSR的理解 36. Vue的性能优化有哪些 37. 对 SPA 单页面的理解，它的优缺点分别是什么？ 38. template和jsx的有什么分别？ 39. vue初始化页面闪动问题 40. extend 有什么作用",
      "content": "# 1. Vue的基本原理\n\n当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。\n\n\n# 2. 双向数据绑定的原理\n\nVue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：\n\n 1. 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化\n 2. compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\n 3. Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。\n 4. MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。\n\n\n\n\n# 3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？\n\n在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。\n\n在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。\n\n\n# 4. MVVM、MVC、MVP的区别\n\nMVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。\n\n在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。\n\n（1）MVC\n\nMVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。\n\n（2）MVVM\n\nMVVM 分为 Model、View、ViewModel：\n\n * Model代表数据模型，数据和业务逻辑都在Model层中定义；\n * View代表UI视图，负责数据的展示；\n * ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；\n\nModel和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。\n\n这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。\n\n（3）MVP\n\nMVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。\n\n\n# 5. Computed 和 Watch 的区别\n\n对于Computed：\n\n * 它支持缓存，只有依赖的数据发生了变化，才会重新计算\n * 不支持异步，当Computed中有异步操作时，无法监听数据的变化\n * computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。\n * 如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed\n * 如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。\n\n对于Watch：\n\n * 它不支持缓存，数据变化时，它就会触发相应的操作\n * 支持异步监听\n * 监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值\n * 当一个属性发生变化时，就需要执行相应的操作\n * 监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：\n   * immediate：组件加载立即触发回调函数\n   * deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。\n\n当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。\n\n总结：\n\n * computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。\n * watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。\n\n运用场景：\n\n * 当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。\n * 当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\n\n\n# 6. Computed 和 Methods 的区别\n\n可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的\n\n不同点：\n\n * computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；\n * method 调用总会执行该函数。\n\n\n# 7. slot是什么？有什么作用？原理是什么？\n\nslot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。\n\n * 默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。\n * 具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。\n * 作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。\n\n实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。\n\n\n# 8. 过滤器的作用，如何实现一个过滤器\n\n根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用filters来过滤数据，filters不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示）。\n\n使用场景：\n\n * 需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。\n * 比如后端返回一个 年月日的日期字符串，前端需要展示为 多少天前 的数据格式，此时就可以用fliters过滤器来处理数据。\n\n过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在插值表达式 *{{ }} 和 v-bind* 表达式 中，然后放在操作符“ | ”后面进行指示。\n\n例如，在显示金额，给商品价格添加单位：\n\n<li>商品价格：{{item.price | filterPrice}}</li>\n\n filters: {\n    filterPrice (price) {\n      return price ? ('￥' + price) : '--'\n    }\n  }\n\n\n\n# 9. 如何保存页面的当前的状态\n\n既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：\n\n * 前组件会被卸载\n * 前组件不会被卸载\n\n那么可以按照这两种情况分别得到以下方法：\n\n组件会被卸载：\n\n（1）将状态存储在LocalStorage / SessionStorage\n\n只需要在组件即将被销毁的生命周期 componentWillUnmount （react）中在 LocalStorage / SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。\n\n比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。\n\n优点：\n\n * 兼容性好，不需要额外库或工具。\n * 简单快捷，基本可以满足大部分需求。\n\n缺点：\n\n * 状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）\n * 如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象\n\n（2）路由传值\n\n通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。\n\n在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。\n\n优点：\n\n * 简单快捷，不会污染 LocalStorage / SessionStorage。\n * 可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）\n\n缺点：\n\n * 如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。\n\n组件不会被卸载：\n\n（1）单页面渲染\n\n要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。\n\n优点：\n\n * 代码量少\n * 不需要考虑状态传递过程中的错误\n\n缺点：\n\n * 增加 A 组件维护成本\n * 需要传入额外的 prop 到 B 组件\n * 无法利用路由定位页面\n\n除此之外，在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行 被包裹在keep-alive中的组件的状态将会被保留：\n\n<keep-alive>\n\t<router-view v-if=\"$route.meta.keepAlive\"></router-view>\n</kepp-alive>\n\n\nrouter.js\n\n{\n  path: '/',\n  name: 'xxx',\n  component: ()=>import('../src/views/xxx.vue'),\n  meta:{\n    keepAlive: true // 需要被缓存\n  }\n},\n\n\n\n# 10. 常见的事件修饰符及其作用\n\n * .stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；\n * .prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；\n * .capture ：与事件冒泡的方向相反，事件捕获由外到内；\n * .self ：只会触发自己范围内的事件，不包含子元素；\n * .once ：只会触发一次。\n\n\n# 11. v-if、v-show、v-html 的原理\n\n * v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；\n * v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；\n * v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。\n\n\n# 12. MVVM的优缺点?\n\n优点:\n\n * 分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的\"View\"上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑\n * 提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码\n * ⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放\n\n缺点:\n\n * Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的\n * ⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存\n * 对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。\n\n\n# 13. v-if和v-show的区别\n\n * 手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；\n * 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；\n * 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；\n * 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；\n * 使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。\n\n\n# 14. v-model 是如何实现的，语法糖实际是什么？\n\n（1）作用在表单元素上 动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：\n\n<input v-model=\"sth\" />\n//  等同于\n<input \n    v-bind:value=\"message\" \n    v-on:input=\"message=$event.target.value\"\n>\n//$event 指代当前触发的事件对象;\n//$event.target 指代当前触发的事件对象的dom;\n//$event.target.value 就是当前dom的value值;\n//在@input方法中，value => sth;\n//在:value中,sth => value;\n\n\n（2）作用在组件上 在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件\n\n本质是一个父子组件通信的语法糖，通过prop和$.emit实现。 因此父组件 v-model 语法糖本质上可以修改为：\n\n<child :value=\"message\"  @input=\"function(e){message = e}\"></child>\n\n\n在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。 例子：\n\n// 父组件\n<aa-input v-model=\"aa\"></aa-input>\n// 等价于\n<aa-input v-bind:value=\"aa\" v-on:input=\"aa=$event.target.value\"></aa-input>\n\n// 子组件：\n<input v-bind:value=\"aa\" v-on:input=\"onmessage\"></aa-input>\n\nprops:{value:aa,}\nmethods:{\n    onmessage(e){\n        $emit('input',e.target.value)\n    }\n}\n\n\n默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input $emit过来的值。\n\n\n# 15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？\n\n可以。v-model 实际上是一个语法糖，如：\n\n<input v-model=\"searchText\">\n\n\n实际上相当于：\n\n<input\n  v-bind:value=\"searchText\"\n  v-on:input=\"searchText = $event.target.value\"\n>\n\n\n用在自定义组件上也是同理：\n\n<custom-input v-model=\"searchText\">\n\n\n相当于：\n\n<custom-input\n  v-bind:value=\"searchText\"\n  v-on:input=\"searchText = $event\"\n></custom-input>\n\n\n显然，custom-input 与父组件的交互如下：\n\n 1. 父组件将searchText变量传入custom-input 组件，使用的 prop 名为value；\n 2. custom-input 组件向父组件传出名为input的事件，父组件将接收到的值赋值给searchText；\n\n所以，custom-input 组件的实现应该类似于这样：\n\nVue.component('custom-input', {\n  props: ['value'],\n  template: `\n    <input\n      v-bind:value=\"value\"\n      v-on:input=\"$emit('input', $event.target.value)\"\n    >\n  `\n})\n\n\n\n# 16. data为什么是一个函数而不是对象\n\nJavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。\n\n而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。\n\n所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。\n\n\n# 17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？\n\n如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。\n\n（1）keep-alive\n\nkeep-alive有以下三个属性：\n\n * include 字符串或正则表达式，只有名称匹配的组件会被匹配；\n * exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；\n * max 数字，最多可以缓存多少组件实例。\n\n注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。\n\n主要流程\n\n 1. 判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。\n 2. 获取组件实例 key ，如果有获取实例的 key，否则重新生成。\n 3. key生成规则，cid +\"∶∶\"+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。\n 4. 如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。\n\n（2）keep-alive 的实现\n\nconst patternTypes: Array<Function> = [String, RegExp, Array] // 接收：字符串，正则，数组\n\nexport default {\n  name: 'keep-alive',\n  abstract: true, // 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。\n\n  props: {\n    include: patternTypes, // 匹配的组件，缓存\n    exclude: patternTypes, // 不去匹配的组件，不缓存\n    max: [String, Number], // 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限\n  },\n\n  created() {\n    // 用于初始化缓存虚拟DOM数组和vnode的key\n    this.cache = Object.create(null)\n    this.keys = []\n  },\n\n  destroyed() {\n    // 销毁缓存cache的组件实例\n    for (const key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys)\n    }\n  },\n\n  mounted() {\n    // prune 削减精简[v.]\n    // 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容\n    this.$watch('include', (val) => {\n      pruneCache(this, (name) => matches(val, name))\n    })\n    this.$watch('exclude', (val) => {\n      pruneCache(this, (name) => !matches(val, name))\n    })\n  },\n}\n\n\nrender函数：\n\n 1. 会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件\n 2. keep-alive 只对第一个组件有效，所以获取第一个子组件。\n 3. 和 keep-alive 搭配使用的一般有：动态组件 和router-view\n\nrender () {\n  //\n  function getFirstComponentChild (children: ?Array<VNode>): ?VNode {\n    if (Array.isArray(children)) {\n  for (let i = 0; i < children.length; i++) {\n    const c = children[i]\n    if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n      return c\n    }\n  }\n  }\n  }\n  const slot = this.$slots.default // 获取默认插槽\n  const vnode: VNode = getFirstComponentChild(slot)// 获取第一个子组件\n  const componentOptions: ?VNodeComponentOptions = vnode && vnode.componentOptions // 组件参数\n  if (componentOptions) { // 是否有组件参数\n    // check pattern\n    const name: ?string = getComponentName(componentOptions) // 获取组件名\n    const { include, exclude } = this\n    if (\n      // not included\n      (include && (!name || !matches(include, name))) ||\n      // excluded\n      (exclude && name && matches(exclude, name))\n    ) {\n      // 如果不匹配当前组件的名字和include以及exclude\n      // 那么直接返回组件的实例\n      return vnode\n    }\n\n    const { cache, keys } = this\n\n    // 获取这个组件的key\n    const key: ?string = vnode.key == null\n      // same constructor may get registered as different local components\n      // so cid alone is not enough (#3269)\n      ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')\n      : vnode.key\n\n    if (cache[key]) {\n      // LRU缓存策略执行\n      vnode.componentInstance = cache[key].componentInstance // 组件初次渲染的时候componentInstance为undefined\n\n      // make current key freshest\n      remove(keys, key)\n      keys.push(key)\n      // 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面\n    } else {\n      // 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除\n      // 使用时间间隔最长的一个\n      cache[key] = vnode\n      keys.push(key)\n      // prune oldest entry\n      if (this.max && keys.length > parseInt(this.max)) {\n        pruneCacheEntry(cache, keys[0], keys, this._vnode)\n      }\n    }\n    // 将组件的keepAlive属性设置为true\n    vnode.data.keepAlive = true // 作用：判断是否要执行组件的created、mounted生命周期函数\n  }\n  return vnode || (slot && slot[0])\n}\n\n\nkeep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。\n\n实现步骤：\n\n 1. 获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名\n 2. 通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode\n 3. 需要缓存，判断他当前是否在缓存数组里面：\n\n * 存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）\n * 不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key\n\n 1. 最后将这个组件的 keepAlive 设置为 true\n\n（3）keep-alive 本身的创建过程和 patch 过程\n\n缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。\n\n首次渲染\n\n * 组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM\n\n// core/instance/lifecycle\nfunction initLifecycle (vm: Component) {\n  const options = vm.$options\n\n  // locate first non-abstract parent\n  let parent = options.parent\n  if (parent && !options.abstract) { // 判断组件的abstract属性，才往父组件里面挂载DOM\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent\n    }\n    parent.$children.push(vm)\n  }\n\n  vm.$parent = parent\n  vm.$root = parent ? parent.$root : vm\n\n  vm.$children = []\n  vm.$refs = {}\n\n  vm._watcher = null\n  vm._inactive = null\n  vm._directInactive = false\n  vm._isMounted = false\n  vm._isDestroyed = false\n  vm._isBeingDestroyed = false\n}\n\n\n * 判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance\n\n// core/vdom/create-component\ninit (vnode: VNodeWithData, hydrating: boolean): ?boolean {\n    if (\n      vnode.componentInstance &&\n      !vnode.componentInstance._isDestroyed &&\n      vnode.data.keepAlive\n    ) { // componentInstance在初次是undefined!!!\n      // kept-alive components, treat as a patch\n      const mountedNode: any = vnode // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode) // prepatch函数执行的是组件更新的过程\n    } else {\n      const child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance\n      )\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating)\n    }\n  },\n\n\nprepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入\n\n（4）LRU （least recently used）缓存策略\n\nLRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。 LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 \"如果数据最近被访问过，那么将来被访问的几率也更高\"。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶\n\n * 新数据插入到链表头部\n * 每当缓存命中（即缓存数据被访问），则将数据移到链表头部\n * 链表满的时候，将链表尾部的数据丢弃。\n\n\n# 18. $nextTick 原理及作用\n\nVue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。\n\nnextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。\n\nnextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理\n\nnextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶\n\n * 如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染\n * 同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要\n\nVue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。\n\n由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在$nextTick中。\n\nthis.$nextTick(() => {    // 获取数据的操作...})\n\n\n所以，在以下情况下，会用到nextTick：\n\n * 在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在nextTick()的回调函数中。\n * 在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在nextTick()的回调函数中。\n\n因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。\n\n\n# 19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？\n\n<template> \n   <div>\n      <ul>\n         <li v-for=\"value in obj\" :key=\"value\"> {{value}} </li> \n      </ul> \n      <button @click=\"addObjB\">添加 obj.b</button> \n   </div>\n</template>\n\n<script>\n    export default { \n       data () { \n          return { \n              obj: { \n                  a: 'obj.a' \n              } \n          } \n       },\n       methods: { \n          addObjB () { \n              this.obj.b = 'obj.b' \n              console.log(this.obj) \n          } \n      }\n   }\n</script>\n\n\n点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api $set()：\n\naddObjB () (\n   this.$set(this.obj, 'b', 'obj.b')\n   console.log(this.obj)\n}\n\n\n$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。\n\n\n# 20. Vue中封装的数组方法有哪些，其如何实现页面更新\n\n在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。 那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：\n\n// 缓存数组原型\nconst arrayProto = Array.prototype;\n// 实现 arrayMethods.__proto__ === Array.prototype\nexport const arrayMethods = Object.create(arrayProto);\n// 需要进行功能拓展的方法\nconst methodsToPatch = [\n  \"push\",\n  \"pop\",\n  \"shift\",\n  \"unshift\",\n  \"splice\",\n  \"sort\",\n  \"reverse\"\n];\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function(method) {\n  // 缓存原生数组方法\n  const original = arrayProto[method];\n  def(arrayMethods, method, function mutator(...args) {\n    // 执行并缓存原生数组功能\n    const result = original.apply(this, args);\n    // 响应式处理\n    const ob = this.__ob__;\n    let inserted;\n    switch (method) {\n    // push、unshift会新增索引，所以要手动observer\n      case \"push\":\n      case \"unshift\":\n        inserted = args;\n        break;\n      // splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。\n      case \"splice\":\n        inserted = args.slice(2);\n        break;\n    }\n    // \n    if (inserted) ob.observeArray(inserted);// 获取插入的值，并设置响应式监听\n    // notify change\n    ob.dep.notify();// 通知依赖更新\n    // 返回原生数组方法的执行结果\n    return result;\n  });\n});\n\n\n简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过target__proto__ == arrayMethods来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。\n\n\n# 21. Vue 单页应用与多页应用的区别\n\n概念：\n\n * SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。\n * MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。\n\n区别：\n\n\n# 22. Vue template 到 render 的过程\n\nvue的模版编译过程主要如下：template -> ast -> render函数\n\nvue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：\n\n// 将模板编译为render函数const { render, staticRenderFns } = compileToFunctions(template,options//省略}, this)\n\n\nCompileToFunctions中的主要逻辑如下∶ （1）调用parse方法将template转化为ast（抽象语法树）\n\nconstast = parse(template.trim(), options)\n\n\n * parse的目标：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。\n * 解析过程：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。\n\nAST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本\n\n（2）对静态节点做优化\n\noptimize(ast,options)\n\n\n这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化\n\n深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。\n\n（3）生成代码\n\nconst code = generate(ast, options)\n\n\ngenerate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 new Function(`` render``) 生成render函数。\n\n\n# 23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？\n\n不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。\n\n如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。\n\n\n# 24. 简述 mixin、extends 的覆盖逻辑\n\n（1）mixin 和 extends mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。\n\n * mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。\n * extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。\n\n（2）mergeOptions 的执行过程\n\n * 规范化选项（normalizeProps、normalizelnject、normalizeDirectives)\n * 对未合并的选项，进行判断\n\nif(!child._base) {    if(child.extends) {        parent = mergeOptions(parent, child.extends, vm)    }    if(child.mixins) {        for(let i = 0, l = child.mixins.length; i < l; i++){            parent = mergeOptions(parent, child.mixins[i], vm)        }    }}\n\n\n * 合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。\n * 返回合并结果 options。\n\n\n# 25. 描述下Vue自定义指令\n\n在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据;\n\n（1）自定义指令基本内容\n\n * 全局定义：Vue.directive(\"focus\",{})\n\n * 局部定义：directives:{focus:{}}\n\n * 钩子函数：指令定义对象提供钩子函数\n   \n   o bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n   \n   o inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。\n   \n   o update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。\n   \n   o ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。\n   \n   o unbind：只调用一次，指令与元素解绑时调用。\n\n * 钩子函数参数 o el：绑定元素\n   \n   o bing： 指令核心对象，描述指令全部信息属性\n   \n   o name\n   \n   o value\n   \n   o oldValue\n   \n   o expression\n   \n   o arg\n   \n   o modifers\n   \n   o vnode 虚拟节点\n   \n   o oldVnode：上一个虚拟节点（更新钩子函数中才有用）\n\n（2）使用场景\n\n * 普通DOM元素进行底层操作的时候，可以使用自定义指令\n * 自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。\n\n（3）使用案例\n\n初级应用：\n\n * 鼠标聚焦\n * 下拉菜单\n * 相对时间转换\n * 滚动动画\n\n高级应用：\n\n * 自定义指令实现图片懒加载\n * 自定义指令集成第三方插件\n\n\n# 26. 子组件可以直接改变父组件的数据吗？\n\n子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。\n\nVue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。\n\n只能通过 *$emit* 派发一个自定义事件，父组件接收到后，由父组件修改。\n\n\n# 27. Vue是如何收集依赖的？\n\n在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶\n\nfunction defieneReactive (obj, key, val){\n  const dep = new Dep();\n  ...\n  Object.defineProperty(obj, key, {\n    ...\n    get: function reactiveGetter () {\n      if(Dep.target){\n        dep.depend();\n        ...\n      }\n      return val\n    }\n    ...\n  })\n}\n\n\n以上只保留了关键代码，主要就是 const dep = new Dep()实例化一个 Dep 的实例，然后在 get 函数中通过 dep.depend() 进行依赖收集。 （1）Dep Dep是整个依赖收集的核心，其关键代码如下：\n\nclass Dep {\n  static target;\n  subs;\n\n  constructor () {\n    ...\n    this.subs = [];\n  }\n  addSub (sub) {\n    this.subs.push(sub)\n  }\n  removeSub (sub) {\n    remove(this.sub, sub)\n  }\n  depend () {\n    if(Dep.target){\n      Dep.target.addDep(this)\n    }\n  }\n  notify () {\n    const subs = this.subds.slice();\n    for(let i = 0;i < subs.length; i++){\n      subs[i].update()\n    }\n  }\n}\n\n\nDep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶\n\n（2）Watcher\n\nclass Watcher {\n  getter;\n  ...\n  constructor (vm, expression){\n    ...\n    this.getter = expression;\n    this.get();\n  }\n  get () {\n    pushTarget(this);\n    value = this.getter.call(vm, vm)\n    ...\n    return value\n  }\n  addDep (dep){\n        ...\n    dep.addSub(this)\n  }\n  ...\n}\nfunction pushTarget (_target) {\n  Dep.target = _target\n}\n\n\nWatcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。\n\n（3）过程\n\n在实例化 Vue 时，依赖收集的相关过程如下∶ 初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。 初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，\n\nupdateComponent = () => {\n  vm._update(vm._render())\n}\nnew Watcher(vm, updateComponent)\n\n\nget 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。\n\nthis.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。\n\n\n# 28. 对 React 和 Vue 的理解，它们的异同\n\n相似之处：\n\n * 都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；\n * 都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；\n * 都使用了Virtual DOM（虚拟DOM）提高重绘性能；\n * 都有props的概念，允许组件间的数据传递；\n * 都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。\n\n不同之处 ：\n\n1）数据流\n\nVue默认支持数据双向绑定，而React一直提倡单向数据流\n\n2）虚拟DOM\n\nVue2.x开始引入\"Virtual DOM\"，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。\n\n * Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\n * 对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。\n\n3）组件化\n\nReact与Vue最大的不同是模板的编写。\n\n * Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。\n * React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。\n\n具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。 4）监听数据变化的实现原理不同\n\n * Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能\n * React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。\n\n5）高阶组件\n\nreact可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。\n\n高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。\n\n6）构建工具\n\n两者都有自己的构建工具：\n\n * React ==> Create React APP\n * Vue ==> vue-cli\n\n7）跨平台\n\n * React ==> React Native\n * Vue ==> Weex\n\n\n# 29. Vue的优点\n\n * 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；\n * 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；\n * 双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；\n * 组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；\n * 视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；\n * 虚拟DOM：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；\n * 运行速度更快：相比较于 react 而言，同样是操作虚拟 dom，就性能而言， vue 存在很大的优势。\n\n\n# 30. assets和static的区别\n\n相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点\n\n不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。\n\n建议： 将项目中 template需要的样式文件js文件等都可以放置在 assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。\n\n\n# 31. delete和Vue.delete删除数组的区别\n\n * delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。\n * Vue.delete 直接删除了数组 改变了数组的键值。\n\n\n# 32. vue如何监听对象或者数组某个属性的变化\n\n当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。\n\n解决方式：\n\n * this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)\n\nthis.$set(this.arr, 0, \"OBKoro1\"); // 改变数组this.$set(this.obj, \"c\", \"OBKoro1\"); // 改变对象\n\n\n * 调用以下几个数组的方法\n\nsplice()、 push()、pop()、shift()、unshift()、sort()、reverse()\n\n\nvue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作\n\nvm.$set 的实现原理是：\n\n * 如果目标是数组，直接使用数组的 splice 方法触发相应式；\n * 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）\n\n\n# 33. 什么是 mixin ？\n\n * Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。\n * 如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。\n * 然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。\n\n\n# 34. Vue模版编译原理\n\nvue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。\n\n * 解析阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。\n * 优化阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。\n * 生成阶段：将最终的AST转化为render函数字符串。\n\n\n# 35. 对SSR的理解\n\nSSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端\n\nSSR的优势：\n\n * 更好的SEO\n * 首屏加载速度更快\n\nSSR的缺点：\n\n * 开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；\n * 当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；\n * 更多的服务端负载。\n\n\n# 36. Vue的性能优化有哪些\n\n（1）编码阶段\n\n * 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher\n * v-if和v-for不能连用\n * 如果需要使用v-for给每项元素绑定事件时使用事件代理\n * SPA 页面采用keep-alive缓存组件\n * 在更多的情况下，使用v-if替代v-show\n * key保证唯一\n * 使用路由懒加载、异步组件\n * 防抖、节流\n * 第三方模块按需导入\n * 长列表滚动到可视区域动态加载\n * 图片懒加载\n\n（2）SEO优化\n\n * 预渲染\n * 服务端渲染SSR\n\n（3）打包优化\n\n * 压缩代码\n * Tree Shaking/Scope Hoisting\n * 使用cdn加载第三方模块\n * 多线程打包happypack\n * splitChunks抽离公共文件\n * sourceMap优化\n\n（4）用户体验\n\n * 骨架屏\n * PWA\n * 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。\n\n\n# 37. 对 SPA 单页面的理解，它的优缺点分别是什么？\n\nSPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。\n\n优点：\n\n * 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\n * 基于上面一点，SPA 相对对服务器压力小；\n * 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；\n\n缺点：\n\n * 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；\n * 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；\n * SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。\n\n\n# 38. template和jsx的有什么分别？\n\n对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。\n\n所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。\n\n\n# 39. vue初始化页面闪动问题\n\n使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于{{message}}的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。\n\n首先：在css里加上以下代码：\n\n[v-cloak] {    display: none;}\n\n\n如果没有彻底解决问题，则在根元素加上style=\"display: none;\" :style=\"{display: 'block'}\"\n\n\n# 40. extend 有什么作用\n\n这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 $mount 一起使用。\n\n// 创建组件构造器let Component = Vue.extend({  template: '<div>test</div>'})// 挂载到 #app 上new Component().$mount('#app')// 除了上面的方式，还可以用来扩展已有的组件let SuperComponent = Vue.extend(Component)new SuperComponent({    created() {        console.log(1)    }})new SuperComponent().$mount('#app')\n",
      "normalizedContent": "# 1. vue的基本原理\n\n当一个vue实例创建时，vue会遍历data中的属性，用 object.defineproperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。\n\n\n# 2. 双向数据绑定的原理\n\nvue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过object.defineproperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：\n\n 1. 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化\n 2. compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\n 3. watcher订阅者是observer和compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发compile中绑定的回调，则功成身退。\n 4. mvvm作为数据绑定的入口，整合observer、compile和watcher三者，通过observer来监听自己的model数据变化，通过compile来解析编译模板指令，最终利用watcher搭起observer和compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。\n\n\n\n\n# 3. 使用 object.defineproperty() 来进行数据劫持有什么缺点？\n\n在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 object.defineproperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 vue 内部通过重写函数的方式解决了这个问题。\n\n在 vue3.0 中已经不使用这种方式了，而是通过使用 proxy 对对象进行代理，从而实现数据劫持。使用proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 proxy 是 es6 的语法。\n\n\n# 4. mvvm、mvc、mvp的区别\n\nmvc、mvp 和 mvvm 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。\n\n在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。\n\n（1）mvc\n\nmvc 通过分离 model、view 和 controller 的方式来组织代码结构。其中 view 负责页面的显示逻辑，model 负责存储页面的业务数据，以及对相应数据的操作。并且 view 和 model 应用了观察者模式，当 model 层发生改变的时候它会通知有关 view 层更新页面。controller 层是 view 层和 model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，controller 中的事件触发器就开始工作了，通过调用 model 层，来完成对 model 的修改，然后 model 层再去通知 view 层更新。\n\n（2）mvvm\n\nmvvm 分为 model、view、viewmodel：\n\n * model代表数据模型，数据和业务逻辑都在model层中定义；\n * view代表ui视图，负责数据的展示；\n * viewmodel负责监听model中数据的改变并且控制视图的更新，处理用户交互操作；\n\nmodel和view并无直接关联，而是通过viewmodel来进行联系的，model和viewmodel之间有着双向数据绑定的联系。因此当model中的数据改变时会触发view层的刷新，view中由于用户交互操作而改变的数据也会在model中同步。\n\n这种模式实现了 model和view的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作dom。\n\n（3）mvp\n\nmvp 模式与 mvc 唯一不同的在于 presenter 和 controller。在 mvc 模式中使用观察者模式，来实现当 model 层数据发生变化的时候，通知 view 层的更新。这样 view 层和 model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。mvp 的模式通过使用 presenter 来实现对 view 层和 model 层的解耦。mvc 中的controller 只知道 model 的接口，因此它没有办法控制 view 层的更新，mvp 模式中，view 层的接口暴露给了 presenter 因此可以在 presenter 中将 model 的变化和 view 的变化绑定在一起，以此来实现 view 和 model 的同步更新。这样就实现了对 view 和 model 的解耦，presenter 还包含了其他的响应逻辑。\n\n\n# 5. computed 和 watch 的区别\n\n对于computed：\n\n * 它支持缓存，只有依赖的数据发生了变化，才会重新计算\n * 不支持异步，当computed中有异步操作时，无法监听数据的变化\n * computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。\n * 如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed\n * 如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。\n\n对于watch：\n\n * 它不支持缓存，数据变化时，它就会触发相应的操作\n * 支持异步监听\n * 监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值\n * 当一个属性发生变化时，就需要执行相应的操作\n * 监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：\n   * immediate：组件加载立即触发回调函数\n   * deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。\n\n当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。\n\n总结：\n\n * computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。\n * watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。\n\n运用场景：\n\n * 当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。\n * 当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 api )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\n\n\n# 6. computed 和 methods 的区别\n\n可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的\n\n不同点：\n\n * computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；\n * method 调用总会执行该函数。\n\n\n# 7. slot是什么？有什么作用？原理是什么？\n\nslot又名插槽，是vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。\n\n * 默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。\n * 具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。\n * 作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。\n\n实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。\n\n\n# 8. 过滤器的作用，如何实现一个过滤器\n\n根据过滤器的名称，过滤器是用来过滤数据的，在vue中使用filters来过滤数据，filters不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示）。\n\n使用场景：\n\n * 需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。\n * 比如后端返回一个 年月日的日期字符串，前端需要展示为 多少天前 的数据格式，此时就可以用fliters过滤器来处理数据。\n\n过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在插值表达式 *{{ }} 和 v-bind* 表达式 中，然后放在操作符“ | ”后面进行指示。\n\n例如，在显示金额，给商品价格添加单位：\n\n<li>商品价格：{{item.price | filterprice}}</li>\n\n filters: {\n    filterprice (price) {\n      return price ? ('￥' + price) : '--'\n    }\n  }\n\n\n\n# 9. 如何保存页面的当前的状态\n\n既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：\n\n * 前组件会被卸载\n * 前组件不会被卸载\n\n那么可以按照这两种情况分别得到以下方法：\n\n组件会被卸载：\n\n（1）将状态存储在localstorage / sessionstorage\n\n只需要在组件即将被销毁的生命周期 componentwillunmount （react）中在 localstorage / sessionstorage 中把当前组件的 state 通过 json.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。\n\n比如从 b 组件跳转到 a 组件的时候，a 组件需要更新自身的状态。但是如果从别的组件跳转到 b 组件的时候，实际上是希望 b 组件重新渲染的，也就是不要从 storage 中读取信息。所以需要在 storage 中的状态加入一个 flag 属性，用来控制 a 组件是否读取 storage 中的状态。\n\n优点：\n\n * 兼容性好，不需要额外库或工具。\n * 简单快捷，基本可以满足大部分需求。\n\n缺点：\n\n * 状态通过 json 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 date 对象、regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 json 深拷贝的缺点）\n * 如果 b 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 a 组件页面时 a 组件会重新读取 storage，会造成很奇怪的现象\n\n（2）路由传值\n\n通过 react-router 的 link 组件的 prop —— to 可以实现路由间传递参数的效果。\n\n在这里需要用到 state 参数，在 b 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 a 组件时再次携带 state 达到路由状态保持的效果。\n\n优点：\n\n * 简单快捷，不会污染 localstorage / sessionstorage。\n * 可以传递 date、regexp 等特殊对象（不用担心 json.stringify / parse 的不足）\n\n缺点：\n\n * 如果 a 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。\n\n组件不会被卸载：\n\n（1）单页面渲染\n\n要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。\n\n优点：\n\n * 代码量少\n * 不需要考虑状态传递过程中的错误\n\n缺点：\n\n * 增加 a 组件维护成本\n * 需要传入额外的 prop 到 b 组件\n * 无法利用路由定位页面\n\n除此之外，在vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行 被包裹在keep-alive中的组件的状态将会被保留：\n\n<keep-alive>\n\t<router-view v-if=\"$route.meta.keepalive\"></router-view>\n</kepp-alive>\n\n\nrouter.js\n\n{\n  path: '/',\n  name: 'xxx',\n  component: ()=>import('../src/views/xxx.vue'),\n  meta:{\n    keepalive: true // 需要被缓存\n  }\n},\n\n\n\n# 10. 常见的事件修饰符及其作用\n\n * .stop：等同于 javascript 中的 event.stoppropagation() ，防止事件冒泡；\n * .prevent ：等同于 javascript 中的 event.preventdefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；\n * .capture ：与事件冒泡的方向相反，事件捕获由外到内；\n * .self ：只会触发自己范围内的事件，不包含子元素；\n * .once ：只会触发一次。\n\n\n# 11. v-if、v-show、v-html 的原理\n\n * v-if会调用addifcondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；\n * v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；\n * v-html会先移除节点下的所有节点，调用html方法，通过addprop添加innerhtml属性，归根结底还是设置innerhtml为v-html的值。\n\n\n# 12. mvvm的优缺点?\n\n优点:\n\n * 分离视图（view）和模型（model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（view）可以独⽴于model变化和修改，⼀个viewmodel可以绑定不同的\"view\"上，当view变化的时候model不可以不变，当model变化的时候view也可以不变。你可以把⼀些视图逻辑放在⼀个viewmodel⾥⾯，让很多view重⽤这段视图逻辑\n * 提⾼可测试性: viewmodel的存在可以帮助开发者更好地编写测试代码\n * ⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放\n\n缺点:\n\n * bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你view的代码有bug，也可能是model的代码有问题。数据绑定使得⼀个位置的bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在view的模版当中的，这些内容是没办法去打断点debug的\n * ⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存\n * 对于⼤型的图形应⽤程序，视图状态较多，viewmodel的构建和维护的成本都会⽐较⾼。\n\n\n# 13. v-if和v-show的区别\n\n * 手段：v-if是动态的向dom树内添加或者删除dom元素；v-show是通过设置dom元素的display样式属性控制显隐；\n * 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；\n * 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且dom元素保留；\n * 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；\n * 使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。\n\n\n# 14. v-model 是如何实现的，语法糖实际是什么？\n\n（1）作用在表单元素上 动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：\n\n<input v-model=\"sth\" />\n//  等同于\n<input \n    v-bind:value=\"message\" \n    v-on:input=\"message=$event.target.value\"\n>\n//$event 指代当前触发的事件对象;\n//$event.target 指代当前触发的事件对象的dom;\n//$event.target.value 就是当前dom的value值;\n//在@input方法中，value => sth;\n//在:value中,sth => value;\n\n\n（2）作用在组件上 在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件\n\n本质是一个父子组件通信的语法糖，通过prop和$.emit实现。 因此父组件 v-model 语法糖本质上可以修改为：\n\n<child :value=\"message\"  @input=\"function(e){message = e}\"></child>\n\n\n在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。 例子：\n\n// 父组件\n<aa-input v-model=\"aa\"></aa-input>\n// 等价于\n<aa-input v-bind:value=\"aa\" v-on:input=\"aa=$event.target.value\"></aa-input>\n\n// 子组件：\n<input v-bind:value=\"aa\" v-on:input=\"onmessage\"></aa-input>\n\nprops:{value:aa,}\nmethods:{\n    onmessage(e){\n        $emit('input',e.target.value)\n    }\n}\n\n\n默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input $emit过来的值。\n\n\n# 15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？\n\n可以。v-model 实际上是一个语法糖，如：\n\n<input v-model=\"searchtext\">\n\n\n实际上相当于：\n\n<input\n  v-bind:value=\"searchtext\"\n  v-on:input=\"searchtext = $event.target.value\"\n>\n\n\n用在自定义组件上也是同理：\n\n<custom-input v-model=\"searchtext\">\n\n\n相当于：\n\n<custom-input\n  v-bind:value=\"searchtext\"\n  v-on:input=\"searchtext = $event\"\n></custom-input>\n\n\n显然，custom-input 与父组件的交互如下：\n\n 1. 父组件将searchtext变量传入custom-input 组件，使用的 prop 名为value；\n 2. custom-input 组件向父组件传出名为input的事件，父组件将接收到的值赋值给searchtext；\n\n所以，custom-input 组件的实现应该类似于这样：\n\nvue.component('custom-input', {\n  props: ['value'],\n  template: `\n    <input\n      v-bind:value=\"value\"\n      v-on:input=\"$emit('input', $event.target.value)\"\n    >\n  `\n})\n\n\n\n# 16. data为什么是一个函数而不是对象\n\njavascript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。\n\n而在vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。\n\n所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。\n\n\n# 17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？\n\n如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。\n\n（1）keep-alive\n\nkeep-alive有以下三个属性：\n\n * include 字符串或正则表达式，只有名称匹配的组件会被匹配；\n * exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；\n * max 数字，最多可以缓存多少组件实例。\n\n注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。\n\n主要流程\n\n 1. 判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。\n 2. 获取组件实例 key ，如果有获取实例的 key，否则重新生成。\n 3. key生成规则，cid +\"∶∶\"+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。\n 4. 如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。\n\n（2）keep-alive 的实现\n\nconst patterntypes: array<function> = [string, regexp, array] // 接收：字符串，正则，数组\n\nexport default {\n  name: 'keep-alive',\n  abstract: true, // 抽象组件，是一个抽象组件：它自身不会渲染一个 dom 元素，也不会出现在父组件链中。\n\n  props: {\n    include: patterntypes, // 匹配的组件，缓存\n    exclude: patterntypes, // 不去匹配的组件，不缓存\n    max: [string, number], // 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限\n  },\n\n  created() {\n    // 用于初始化缓存虚拟dom数组和vnode的key\n    this.cache = object.create(null)\n    this.keys = []\n  },\n\n  destroyed() {\n    // 销毁缓存cache的组件实例\n    for (const key in this.cache) {\n      prunecacheentry(this.cache, key, this.keys)\n    }\n  },\n\n  mounted() {\n    // prune 削减精简[v.]\n    // 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容\n    this.$watch('include', (val) => {\n      prunecache(this, (name) => matches(val, name))\n    })\n    this.$watch('exclude', (val) => {\n      prunecache(this, (name) => !matches(val, name))\n    })\n  },\n}\n\n\nrender函数：\n\n 1. 会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件\n 2. keep-alive 只对第一个组件有效，所以获取第一个子组件。\n 3. 和 keep-alive 搭配使用的一般有：动态组件 和router-view\n\nrender () {\n  //\n  function getfirstcomponentchild (children: ?array<vnode>): ?vnode {\n    if (array.isarray(children)) {\n  for (let i = 0; i < children.length; i++) {\n    const c = children[i]\n    if (isdef(c) && (isdef(c.componentoptions) || isasyncplaceholder(c))) {\n      return c\n    }\n  }\n  }\n  }\n  const slot = this.$slots.default // 获取默认插槽\n  const vnode: vnode = getfirstcomponentchild(slot)// 获取第一个子组件\n  const componentoptions: ?vnodecomponentoptions = vnode && vnode.componentoptions // 组件参数\n  if (componentoptions) { // 是否有组件参数\n    // check pattern\n    const name: ?string = getcomponentname(componentoptions) // 获取组件名\n    const { include, exclude } = this\n    if (\n      // not included\n      (include && (!name || !matches(include, name))) ||\n      // excluded\n      (exclude && name && matches(exclude, name))\n    ) {\n      // 如果不匹配当前组件的名字和include以及exclude\n      // 那么直接返回组件的实例\n      return vnode\n    }\n\n    const { cache, keys } = this\n\n    // 获取这个组件的key\n    const key: ?string = vnode.key == null\n      // same constructor may get registered as different local components\n      // so cid alone is not enough (#3269)\n      ? componentoptions.ctor.cid + (componentoptions.tag ? `::${componentoptions.tag}` : '')\n      : vnode.key\n\n    if (cache[key]) {\n      // lru缓存策略执行\n      vnode.componentinstance = cache[key].componentinstance // 组件初次渲染的时候componentinstance为undefined\n\n      // make current key freshest\n      remove(keys, key)\n      keys.push(key)\n      // 根据lru缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面\n    } else {\n      // 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除\n      // 使用时间间隔最长的一个\n      cache[key] = vnode\n      keys.push(key)\n      // prune oldest entry\n      if (this.max && keys.length > parseint(this.max)) {\n        prunecacheentry(cache, keys[0], keys, this._vnode)\n      }\n    }\n    // 将组件的keepalive属性设置为true\n    vnode.data.keepalive = true // 作用：判断是否要执行组件的created、mounted生命周期函数\n  }\n  return vnode || (slot && slot[0])\n}\n\n\nkeep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。\n\n实现步骤：\n\n 1. 获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名\n 2. 通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vnode\n 3. 需要缓存，判断他当前是否在缓存数组里面：\n\n * 存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（lru）\n * 不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key\n\n 1. 最后将这个组件的 keepalive 设置为 true\n\n（3）keep-alive 本身的创建过程和 patch 过程\n\n缓存渲染的时候，会根据 vnode.componentinstance（首次渲染 vnode.componentinstance 为 undefined） 和 keepalive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 dom 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。\n\n首次渲染\n\n * 组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 dom\n\n// core/instance/lifecycle\nfunction initlifecycle (vm: component) {\n  const options = vm.$options\n\n  // locate first non-abstract parent\n  let parent = options.parent\n  if (parent && !options.abstract) { // 判断组件的abstract属性，才往父组件里面挂载dom\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent\n    }\n    parent.$children.push(vm)\n  }\n\n  vm.$parent = parent\n  vm.$root = parent ? parent.$root : vm\n\n  vm.$children = []\n  vm.$refs = {}\n\n  vm._watcher = null\n  vm._inactive = null\n  vm._directinactive = false\n  vm._ismounted = false\n  vm._isdestroyed = false\n  vm._isbeingdestroyed = false\n}\n\n\n * 判断当前 keepalive 和 componentinstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance\n\n// core/vdom/create-component\ninit (vnode: vnodewithdata, hydrating: boolean): ?boolean {\n    if (\n      vnode.componentinstance &&\n      !vnode.componentinstance._isdestroyed &&\n      vnode.data.keepalive\n    ) { // componentinstance在初次是undefined!!!\n      // kept-alive components, treat as a patch\n      const mountednode: any = vnode // work around flow\n      componentvnodehooks.prepatch(mountednode, mountednode) // prepatch函数执行的是组件更新的过程\n    } else {\n      const child = vnode.componentinstance = createcomponentinstanceforvnode(\n        vnode,\n        activeinstance\n      )\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating)\n    }\n  },\n\n\nprepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 dom 插入\n\n（4）lru （least recently used）缓存策略\n\nlru 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。 lru（least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 \"如果数据最近被访问过，那么将来被访问的几率也更高\"。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶\n\n * 新数据插入到链表头部\n * 每当缓存命中（即缓存数据被访问），则将数据移到链表头部\n * 链表满的时候，将链表尾部的数据丢弃。\n\n\n# 18. $nexttick 原理及作用\n\nvue 的 nexttick 其本质是对 javascript 执行原理 eventloop 的一种应用。\n\nnexttick 的核心是利用了如 promise 、mutationobserver、setimmediate、settimeout的原生 javascript 方法来模拟对应的微/宏任务的实现，本质是为了利用 javascript 的这些异步回调任务队列来实现 vue 框架中自己的异步回调队列。\n\nnexttick 不仅是 vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 dom 更新数据时机的后续逻辑处理\n\nnexttick 是典型的将底层 javascript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶\n\n * 如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 ui/dom 的渲染，可以减少一些无用渲染\n * 同时由于 virtualdom 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 virtualdom 进行计算得出需要更新的具体的 dom 节点，然后对 dom 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要\n\nvue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作dom。有时候，可能遇到这样的情况，dom1的数据发生了变化，而dom2需要从dom1中获取数据，那这时就会发现dom2的视图并没有更新，这时就需要用到了nexttick了。\n\n由于vue的dom操作是异步的，所以，在上面的情况中，就要将dom2获取数据的操作写在$nexttick中。\n\nthis.$nexttick(() => {    // 获取数据的操作...})\n\n\n所以，在以下情况下，会用到nexttick：\n\n * 在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的dom结构的时候，这个操作就需要方法在nexttick()的回调函数中。\n * 在vue生命周期中，如果在created()钩子进行dom操作，也一定要放在nexttick()的回调函数中。\n\n因为在created()钩子函数中，页面的dom还未渲染，这时候也没办法操作dom，所以，此时如果想要操作dom，必须将操作的代码放在nexttick()的回调函数中。\n\n\n# 19. vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？\n\n<template> \n   <div>\n      <ul>\n         <li v-for=\"value in obj\" :key=\"value\"> {{value}} </li> \n      </ul> \n      <button @click=\"addobjb\">添加 obj.b</button> \n   </div>\n</template>\n\n<script>\n    export default { \n       data () { \n          return { \n              obj: { \n                  a: 'obj.a' \n              } \n          } \n       },\n       methods: { \n          addobjb () { \n              this.obj.b = 'obj.b' \n              console.log(this.obj) \n          } \n      }\n   }\n</script>\n\n\n点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在vue实例创建时，obj.b并未声明，因此就没有被vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用vue的全局 api $set()：\n\naddobjb () (\n   this.$set(this.obj, 'b', 'obj.b')\n   console.log(this.obj)\n}\n\n\n$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。\n\n\n# 20. vue中封装的数组方法有哪些，其如何实现页面更新\n\n在vue中，对响应式处理利用的是object.defineproperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让vue能监听到其中的变化。 那vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是vue中对这些方法的封装：\n\n// 缓存数组原型\nconst arrayproto = array.prototype;\n// 实现 arraymethods.__proto__ === array.prototype\nexport const arraymethods = object.create(arrayproto);\n// 需要进行功能拓展的方法\nconst methodstopatch = [\n  \"push\",\n  \"pop\",\n  \"shift\",\n  \"unshift\",\n  \"splice\",\n  \"sort\",\n  \"reverse\"\n];\n\n/**\n * intercept mutating methods and emit events\n */\nmethodstopatch.foreach(function(method) {\n  // 缓存原生数组方法\n  const original = arrayproto[method];\n  def(arraymethods, method, function mutator(...args) {\n    // 执行并缓存原生数组功能\n    const result = original.apply(this, args);\n    // 响应式处理\n    const ob = this.__ob__;\n    let inserted;\n    switch (method) {\n    // push、unshift会新增索引，所以要手动observer\n      case \"push\":\n      case \"unshift\":\n        inserted = args;\n        break;\n      // splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。\n      case \"splice\":\n        inserted = args.slice(2);\n        break;\n    }\n    // \n    if (inserted) ob.observearray(inserted);// 获取插入的值，并设置响应式监听\n    // notify change\n    ob.dep.notify();// 通知依赖更新\n    // 返回原生数组方法的执行结果\n    return result;\n  });\n});\n\n\n简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的observer对象，如果有新的值，就调用observearray继续对新的值观察变化（也就是通过target__proto__ == arraymethods来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。\n\n\n# 21. vue 单页应用与多页应用的区别\n\n概念：\n\n * spa单页面应用（singlepage web application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。\n * mpa多页面应用 （multipage application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。\n\n区别：\n\n\n# 22. vue template 到 render 的过程\n\nvue的模版编译过程主要如下：template -> ast -> render函数\n\nvue 在模版编译版本的码中会执行 compiletofunctions 将template转化为render函数：\n\n// 将模板编译为render函数const { render, staticrenderfns } = compiletofunctions(template,options//省略}, this)\n\n\ncompiletofunctions中的主要逻辑如下∶ （1）调用parse方法将template转化为ast（抽象语法树）\n\nconstast = parse(template.trim(), options)\n\n\n * parse的目标：把tamplate转换为ast树，它是一种用 javascript对象的形式来描述整个模板。\n * 解析过程：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造ast树的目的。\n\nast元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本\n\n（2）对静态节点做优化\n\noptimize(ast,options)\n\n\n这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化\n\n深度遍历ast，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的dom永远不会改变，这对运行时模板更新起到了极大的优化作用。\n\n（3）生成代码\n\nconst code = generate(ast, options)\n\n\ngenerate将ast抽象语法树编译成 render字符串并将静态部分放到 staticrenderfns 中，最后通过 new function(`` render``) 生成render函数。\n\n\n# 23. vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？\n\n不会立即同步执行重新渲染。vue 实现响应式并不是数据发生变化之后 dom 立即变化，而是按一定的策略进行 dom 的更新。vue 在更新 dom 时是异步执行的。只要侦听到数据变化， vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。\n\n如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 dom 操作是非常重要的。然后，在下一个的事件循环tick中，vue 刷新队列并执行实际（已去重的）工作。\n\n\n# 24. 简述 mixin、extends 的覆盖逻辑\n\n（1）mixin 和 extends mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeoptions 方法实现合并。\n\n * mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。\n * extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。\n\n（2）mergeoptions 的执行过程\n\n * 规范化选项（normalizeprops、normalizelnject、normalizedirectives)\n * 对未合并的选项，进行判断\n\nif(!child._base) {    if(child.extends) {        parent = mergeoptions(parent, child.extends, vm)    }    if(child.mixins) {        for(let i = 0, l = child.mixins.length; i < l; i++){            parent = mergeoptions(parent, child.mixins[i], vm)        }    }}\n\n\n * 合并处理。根据一个通用 vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。\n * 返回合并结果 options。\n\n\n# 25. 描述下vue自定义指令\n\n在 vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 dom 元素进行底层操作，这时候就会用到自定义指令。 一般需要对dom元素进行底层操作时使用，尽量只用来操作 dom展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据;\n\n（1）自定义指令基本内容\n\n * 全局定义：vue.directive(\"focus\",{})\n\n * 局部定义：directives:{focus:{}}\n\n * 钩子函数：指令定义对象提供钩子函数\n   \n   o bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n   \n   o inserted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。\n   \n   o update：所在组件的vnode更新时调用，但是可能发生在其子vnode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。\n   \n   o componentupdate：指令所在组件的 vnode及其子vnode全部更新后调用。\n   \n   o unbind：只调用一次，指令与元素解绑时调用。\n\n * 钩子函数参数 o el：绑定元素\n   \n   o bing： 指令核心对象，描述指令全部信息属性\n   \n   o name\n   \n   o value\n   \n   o oldvalue\n   \n   o expression\n   \n   o arg\n   \n   o modifers\n   \n   o vnode 虚拟节点\n   \n   o oldvnode：上一个虚拟节点（更新钩子函数中才有用）\n\n（2）使用场景\n\n * 普通dom元素进行底层操作的时候，可以使用自定义指令\n * 自定义指令是用来操作dom的。尽管vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的dom操作，并且是可复用的。\n\n（3）使用案例\n\n初级应用：\n\n * 鼠标聚焦\n * 下拉菜单\n * 相对时间转换\n * 滚动动画\n\n高级应用：\n\n * 自定义指令实现图片懒加载\n * 自定义指令集成第三方插件\n\n\n# 26. 子组件可以直接改变父组件的数据吗？\n\n子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，vue 会在浏览器的控制台中发出警告。\n\nvue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。\n\n只能通过 *$emit* 派发一个自定义事件，父组件接收到后，由父组件修改。\n\n\n# 27. vue是如何收集依赖的？\n\n在初始化 vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶\n\nfunction defienereactive (obj, key, val){\n  const dep = new dep();\n  ...\n  object.defineproperty(obj, key, {\n    ...\n    get: function reactivegetter () {\n      if(dep.target){\n        dep.depend();\n        ...\n      }\n      return val\n    }\n    ...\n  })\n}\n\n\n以上只保留了关键代码，主要就是 const dep = new dep()实例化一个 dep 的实例，然后在 get 函数中通过 dep.depend() 进行依赖收集。 （1）dep dep是整个依赖收集的核心，其关键代码如下：\n\nclass dep {\n  static target;\n  subs;\n\n  constructor () {\n    ...\n    this.subs = [];\n  }\n  addsub (sub) {\n    this.subs.push(sub)\n  }\n  removesub (sub) {\n    remove(this.sub, sub)\n  }\n  depend () {\n    if(dep.target){\n      dep.target.adddep(this)\n    }\n  }\n  notify () {\n    const subs = this.subds.slice();\n    for(let i = 0;i < subs.length; i++){\n      subs[i].update()\n    }\n  }\n}\n\n\ndep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 watcher 的数组，所以 dep 实际上就是对 watcher 的管理，再看看 watcher 的相关代码∶\n\n（2）watcher\n\nclass watcher {\n  getter;\n  ...\n  constructor (vm, expression){\n    ...\n    this.getter = expression;\n    this.get();\n  }\n  get () {\n    pushtarget(this);\n    value = this.getter.call(vm, vm)\n    ...\n    return value\n  }\n  adddep (dep){\n        ...\n    dep.addsub(this)\n  }\n  ...\n}\nfunction pushtarget (_target) {\n  dep.target = _target\n}\n\n\nwatcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、adddep 等。\n\n（3）过程\n\n在实例化 vue 时，依赖收集的相关过程如下∶ 初 始 化 状 态 initstate ， 这 中 间 便 会 通 过 definereactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。 初始化最终会走 mount 过程，其中会实例化 watcher ，进入 watcher 中，便会执行 this.get() 方法，\n\nupdatecomponent = () => {\n  vm._update(vm._render())\n}\nnew watcher(vm, updatecomponent)\n\n\nget 方法中的 pushtarget 实际上就是把 dep.target 赋值为当前的 watcher。\n\nthis.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 dep.target.adddep(this)。刚才 dep.target 已经被赋值为 watcher，于是便会执行 adddep 方法，然后走到 dep.addsub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。\n\n\n# 28. 对 react 和 vue 的理解，它们的异同\n\n相似之处：\n\n * 都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；\n * 都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；\n * 都使用了virtual dom（虚拟dom）提高重绘性能；\n * 都有props的概念，允许组件间的数据传递；\n * 都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。\n\n不同之处 ：\n\n1）数据流\n\nvue默认支持数据双向绑定，而react一直提倡单向数据流\n\n2）虚拟dom\n\nvue2.x开始引入\"virtual dom\"，消除了和react在这方面的差异，但是在具体的细节还是有各自的特点。\n\n * vue宣称可以更快地计算出virtual dom的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\n * 对于react而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 purecomponent/shouldcomponentupdate这个生命周期方法来进行控制，但vue将此视为默认的优化。\n\n3）组件化\n\nreact与vue最大的不同是模板的编写。\n\n * vue鼓励写近似常规html的模板。写起来很接近标准 html元素，只是多了一些属性。\n * react推荐你所有的模板通用javascript的语法扩展——jsx书写。\n\n具体来讲：react中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。 4）监听数据变化的实现原理不同\n\n * vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能\n * react 默认是通过比较引用的方式进行的，如果不优化（purecomponent/shouldcomponentupdate）可能导致大量不必要的vdom的重新渲染。这是因为 vue 使用的是可变数据，而react更强调数据的不可变。\n\n5）高阶组件\n\nreact可以通过高阶组件（hoc）来扩展，而vue需要通过mixins来扩展。\n\n高阶组件就是高阶函数，而react的组件本身就是纯粹的函数，所以高阶函数对react来说易如反掌。相反vue.js使用html模板创建视图组件，这时模板无法有效的编译，因此vue不能采用hoc来实现。\n\n6）构建工具\n\n两者都有自己的构建工具：\n\n * react ==> create react app\n * vue ==> vue-cli\n\n7）跨平台\n\n * react ==> react native\n * vue ==> weex\n\n\n# 29. vue的优点\n\n * 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；\n * 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；\n * 双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；\n * 组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；\n * 视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；\n * 虚拟dom：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；\n * 运行速度更快：相比较于 react 而言，同样是操作虚拟 dom，就性能而言， vue 存在很大的优势。\n\n\n# 30. assets和static的区别\n\n相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点\n\n不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。\n\n建议： 将项目中 template需要的样式文件js文件等都可以放置在 assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。\n\n\n# 31. delete和vue.delete删除数组的区别\n\n * delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。\n * vue.delete 直接删除了数组 改变了数组的键值。\n\n\n# 32. vue如何监听对象或者数组某个属性的变化\n\n当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为object.defineproperty()限制，监听不到变化。\n\n解决方式：\n\n * this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)\n\nthis.$set(this.arr, 0, \"obkoro1\"); // 改变数组this.$set(this.obj, \"c\", \"obkoro1\"); // 改变对象\n\n\n * 调用以下几个数组的方法\n\nsplice()、 push()、pop()、shift()、unshift()、sort()、reverse()\n\n\nvue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作\n\nvm.$set 的实现原理是：\n\n * 如果目标是数组，直接使用数组的 splice 方法触发相应式；\n * 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 definereactive 方法进行响应式处理（ definereactive 方法就是 vue 在初始化对象时，给对象属性采用 object.defineproperty 动态添加 getter 和 setter 的功能所调用的方法）\n\n\n# 33. 什么是 mixin ？\n\n * mixin 使我们能够为 vue 组件编写可插拔和可重用的功能。\n * 如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。\n * 然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。\n\n\n# 34. vue模版编译原理\n\nvue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的html语法，所有需要将template转化成一个javascript函数，这样浏览器就可以执行这一个函数并渲染出对应的html元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。\n\n * 解析阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树ast。\n * 优化阶段：遍历ast，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。\n * 生成阶段：将最终的ast转化为render函数字符串。\n\n\n# 35. 对ssr的理解\n\nssr也就是服务端渲染，也就是将vue在客户端把标签渲染成html的工作放在服务端完成，然后再把html直接返回给客户端\n\nssr的优势：\n\n * 更好的seo\n * 首屏加载速度更快\n\nssr的缺点：\n\n * 开发条件会受到限制，服务器端渲染只支持beforecreate和created两个钩子；\n * 当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于node.js的运行环境；\n * 更多的服务端负载。\n\n\n# 36. vue的性能优化有哪些\n\n（1）编码阶段\n\n * 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher\n * v-if和v-for不能连用\n * 如果需要使用v-for给每项元素绑定事件时使用事件代理\n * spa 页面采用keep-alive缓存组件\n * 在更多的情况下，使用v-if替代v-show\n * key保证唯一\n * 使用路由懒加载、异步组件\n * 防抖、节流\n * 第三方模块按需导入\n * 长列表滚动到可视区域动态加载\n * 图片懒加载\n\n（2）seo优化\n\n * 预渲染\n * 服务端渲染ssr\n\n（3）打包优化\n\n * 压缩代码\n * tree shaking/scope hoisting\n * 使用cdn加载第三方模块\n * 多线程打包happypack\n * splitchunks抽离公共文件\n * sourcemap优化\n\n（4）用户体验\n\n * 骨架屏\n * pwa\n * 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。\n\n\n# 37. 对 spa 单页面的理解，它的优缺点分别是什么？\n\nspa（ single-page application ）仅在 web 页面初始化时加载相应的 html、javascript 和 css。一旦页面加载完成，spa 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 html 内容的变换，ui 与用户的交互，避免页面的重新加载。\n\n优点：\n\n * 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\n * 基于上面一点，spa 相对对服务器压力小；\n * 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；\n\n缺点：\n\n * 初次加载耗时多：为实现单页 web 应用功能及显示效果，需要在加载页面的时候将 javascript、css 统一加载，部分页面按需加载；\n * 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；\n * seo 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 seo 上其有着天然的弱势。\n\n\n# 38. template和jsx的有什么分别？\n\n对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。\n\n所以，template和jsx的都是render的一种表现形式，不同的是：jsx相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。\n\n\n# 39. vue初始化页面闪动问题\n\n使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于{{message}}的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。\n\n首先：在css里加上以下代码：\n\n[v-cloak] {    display: none;}\n\n\n如果没有彻底解决问题，则在根元素加上style=\"display: none;\" :style=\"{display: 'block'}\"\n\n\n# 40. extend 有什么作用\n\n这个 api 很少用到，作用是扩展组件生成一个构造器，通常会与 $mount 一起使用。\n\n// 创建组件构造器let component = vue.extend({  template: '<div>test</div>'})// 挂载到 #app 上new component().$mount('#app')// 除了上面的方式，还可以用来扩展已有的组件let supercomponent = vue.extend(component)new supercomponent({    created() {        console.log(1)    }})new supercomponent().$mount('#app')\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "Vue3",
      "frontmatter": {
        "title": "Vue3",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/frameVue3/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/10.vue%E7%AF%87/60.Vue%203.0.html",
      "relativePath": "30.框架篇/10.vue篇/60.Vue 3.0.md",
      "key": "v-3aa97234",
      "path": "/pages/frameVue3/",
      "headers": [
        {
          "level": 3,
          "title": "1. Vue3.0有什么更新",
          "slug": "_1-vue3-0有什么更新",
          "normalizedTitle": "1. vue3.0有什么更新",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. defineProperty和proxy的区别",
          "slug": "_2-defineproperty和proxy的区别",
          "normalizedTitle": "2. defineproperty和proxy的区别",
          "charIndex": 694
        },
        {
          "level": 3,
          "title": "3. Vue3.0 为什么要用 proxy？",
          "slug": "_3-vue3-0-为什么要用-proxy",
          "normalizedTitle": "3. vue3.0 为什么要用 proxy？",
          "charIndex": 1232
        },
        {
          "level": 3,
          "title": "4.  Vue 3.0 中的 Vue Composition API？",
          "slug": "_4-vue-3-0-中的-vue-composition-api",
          "normalizedTitle": "4.  vue 3.0 中的 vue composition api？",
          "charIndex": null
        },
        {
          "level": 3,
          "title": "5. Composition API与React Hook很像，区别是什么",
          "slug": "_5-composition-api与react-hook很像-区别是什么",
          "normalizedTitle": "5. composition api与react hook很像，区别是什么",
          "charIndex": 2756
        }
      ],
      "headersStr": "1. Vue3.0有什么更新 2. defineProperty和proxy的区别 3. Vue3.0 为什么要用 proxy？ 4.  Vue 3.0 中的 Vue Composition API？ 5. Composition API与React Hook很像，区别是什么",
      "content": "# 1. Vue3.0有什么更新\n\n（1）监测机制的改变\n\n * 3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。\n * 消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：\n\n（2）只能监测属性，不能监测对象\n\n * 检测属性的添加和删除；\n * 检测数组索引和长度的变更；\n * 支持 Map、Set、WeakMap 和 WeakSet。\n\n（3）模板\n\n * 作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。\n * 同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。\n\n（4）对象式的组件声明方式\n\n * vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。\n * 3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易\n\n（5）其它方面的更改\n\n * 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。\n * 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。\n * 基于 tree shaking 优化，提供了更多的内置功能。\n\n\n# 2. defineProperty和proxy的区别\n\nVue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。\n\nObject.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。\n\n但是这样做有以下问题：\n\n 1. 添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过$set 来调用Object.defineProperty()处理。\n 2. 无法监控到数组下标和长度的变化。\n\nVue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于Object.defineProperty()，其有以下特点：\n\n 1. Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。\n 2. Proxy 可以监听数组的变化。\n\n\n# 3. Vue3.0 为什么要用 proxy？\n\n在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶\n\n * 不需用使用 Vue.$set 或 Vue.$delete 触发响应式。\n * 全方位的数组变化检测，消除了Vue2 无效的边界情况。\n * 支持 Map，Set，WeakMap 和 WeakSet。\n\nProxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶\n\n * get 收集依赖\n * Set、delete 等触发依赖\n * 对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。\n\n\n# 4. Vue 3.0 中的 Vue Composition API？\n\n在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。这种风格使得 Vue 相对于 React极为容易上手，同时也造成了几个问题：\n\n 1. 由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。\n 2. Vue 组件过于依赖this上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在methods 中的this竟然指向组件实例来不指向methods所在的对象。这也使得 TypeScript 在Vue2 中很不好用。\n\n于是在 Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。\n\n如下，是一个使用了 Vue Composition API 的 Vue3 组件：\n\n<template>\n  <button @click=\"increment\">\n    Count: {{ count }}\n  </button>\n</template>\n \n<script>\n// Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数\nimport { ref, computed, onMounted } from 'vue'\n \nexport default {\n  setup() {\n// 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数\n    const count = ref(0)\n \n// Vue2中需要在methods option中声明的函数，现在直接声明\n    function increment() {\n      count.value++\n    }\n // 对应于Vue2中的mounted声明周期\n    onMounted(() => console.log('component mounted!'))\n \n    return {\n      count,\n      increment\n    }\n  }\n}\n</script>\n\n\n显而易见，Vue Composition API 使得 Vue3 的开发风格更接近于原生 JavaScript，带给开发者更多地灵活性\n\n\n# 5. Composition API与React Hook很像，区别是什么\n\n从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制\n\n * 不能在循环、条件、嵌套函数中调用Hook\n * 必须确保总是在你的React函数的顶层调用Hook\n * useEffect、useMemo等函数必须手动确定依赖关系\n\n而Composition API是基于Vue的响应式系统实现的，与React Hook的相比\n\n * 声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢\n * Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用\n * 响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。\n\n虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。",
      "normalizedContent": "# 1. vue3.0有什么更新\n\n（1）监测机制的改变\n\n * 3.0 将带来基于代理 proxy的 observer 实现，提供全语言覆盖的反应性跟踪。\n * 消除了 vue 2 当中基于 object.defineproperty 的实现所存在的很多限制：\n\n（2）只能监测属性，不能监测对象\n\n * 检测属性的添加和删除；\n * 检测数组索引和长度的变更；\n * 支持 map、set、weakmap 和 weakset。\n\n（3）模板\n\n * 作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。\n * 同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。\n\n（4）对象式的组件声明方式\n\n * vue2.x 中的组件是通过声明的方式传入一系列 option，和 typescript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。\n * 3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 typescript 的结合变得很容易\n\n（5）其它方面的更改\n\n * 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。\n * 支持 fragment（多个根节点）和 protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。\n * 基于 tree shaking 优化，提供了更多的内置功能。\n\n\n# 2. defineproperty和proxy的区别\n\nvue 在实例初始化时遍历 data 中的所有属性，并使用 object.defineproperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。\n\nobject.defineproperty 是 es5 中一个无法 shim 的特性，这也就是 vue 不支持 ie8 以及更低版本浏览器的原因。\n\n但是这样做有以下问题：\n\n 1. 添加或删除对象的属性时，vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过$set 来调用object.defineproperty()处理。\n 2. 无法监控到数组下标和长度的变化。\n\nvue3 使用 proxy 来监控数据的变化。proxy 是 es6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于object.defineproperty()，其有以下特点：\n\n 1. proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。\n 2. proxy 可以监听数组的变化。\n\n\n# 3. vue3.0 为什么要用 proxy？\n\n在 vue2 中， 0bject.defineproperty 会改变原始数据，而 proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteproperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶\n\n * 不需用使用 vue.$set 或 vue.$delete 触发响应式。\n * 全方位的数组变化检测，消除了vue2 无效的边界情况。\n * 支持 map，set，weakmap 和 weakset。\n\nproxy 实现的响应式原理与 vue2的实现原理相同，实现方式大同小异∶\n\n * get 收集依赖\n * set、delete 等触发依赖\n * 对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。\n\n\n# 4. vue 3.0 中的 vue composition api？\n\n在 vue2 中，代码是 options api 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 vue 组件。这种风格使得 vue 相对于 react极为容易上手，同时也造成了几个问题：\n\n 1. 由于 options api 不够灵活的开发方式，使得vue开发缺乏优雅的方法来在组件间共用代码。\n 2. vue 组件过于依赖this上下文，vue 背后的一些小技巧使得 vue 组件的开发看起来与 javascript 的开发原则相悖，比如在methods 中的this竟然指向组件实例来不指向methods所在的对象。这也使得 typescript 在vue2 中很不好用。\n\n于是在 vue3 中，舍弃了 options api，转而投向 composition api。composition api本质上是将 options api 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 vue3 更适合于 typescript 结合。\n\n如下，是一个使用了 vue composition api 的 vue3 组件：\n\n<template>\n  <button @click=\"increment\">\n    count: {{ count }}\n  </button>\n</template>\n \n<script>\n// composition api 将组件属性暴露为函数，因此第一步是导入所需的函数\nimport { ref, computed, onmounted } from 'vue'\n \nexport default {\n  setup() {\n// 使用 ref 函数声明了称为 count 的响应属性，对应于vue2中的data函数\n    const count = ref(0)\n \n// vue2中需要在methods option中声明的函数，现在直接声明\n    function increment() {\n      count.value++\n    }\n // 对应于vue2中的mounted声明周期\n    onmounted(() => console.log('component mounted!'))\n \n    return {\n      count,\n      increment\n    }\n  }\n}\n</script>\n\n\n显而易见，vue composition api 使得 vue3 的开发风格更接近于原生 javascript，带给开发者更多地灵活性\n\n\n# 5. composition api与react hook很像，区别是什么\n\n从react hook的实现角度看，react hook是根据usestate调用的顺序来确定下一次重渲染时的state是来源于哪个usestate，所以出现了以下限制\n\n * 不能在循环、条件、嵌套函数中调用hook\n * 必须确保总是在你的react函数的顶层调用hook\n * useeffect、usememo等函数必须手动确定依赖关系\n\n而composition api是基于vue的响应式系统实现的，与react hook的相比\n\n * 声明在setup函数内，一次组件实例化只调用一次setup，而react hook每次重渲染都需要调用hook，使得react的gc比vue更有压力，性能也相对于vue来说也较慢\n * compositon api的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用\n * 响应式系统自动实现了依赖收集，进而组件的部分的性能优化由vue内部自己完成，而react hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useeffect、usememo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。\n\n虽然compositon api看起来比react hook好用，但是其设计思想也是借鉴react hook的。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "虚拟DOM",
      "frontmatter": {
        "title": "虚拟DOM",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/frameDom/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/10.vue%E7%AF%87/70.%E8%99%9A%E6%8B%9FDOM.html",
      "relativePath": "30.框架篇/10.vue篇/70.虚拟DOM.md",
      "key": "v-657a9336",
      "path": "/pages/frameDom/",
      "headers": [
        {
          "level": 3,
          "title": "1. 对虚拟DOM的理解？",
          "slug": "_1-对虚拟dom的理解",
          "normalizedTitle": "1. 对虚拟dom的理解？",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 虚拟DOM的解析过程",
          "slug": "_2-虚拟dom的解析过程",
          "normalizedTitle": "2. 虚拟dom的解析过程",
          "charIndex": 576
        },
        {
          "level": 3,
          "title": "3. 为什么要用虚拟DOM",
          "slug": "_3-为什么要用虚拟dom",
          "normalizedTitle": "3. 为什么要用虚拟dom",
          "charIndex": 860
        },
        {
          "level": 3,
          "title": "4. 虚拟DOM真的比真实DOM性能好吗",
          "slug": "_4-虚拟dom真的比真实dom性能好吗",
          "normalizedTitle": "4. 虚拟dom真的比真实dom性能好吗",
          "charIndex": 1279
        },
        {
          "level": 3,
          "title": "5. DIFF算法的原理",
          "slug": "_5-diff算法的原理",
          "normalizedTitle": "5. diff算法的原理",
          "charIndex": 1392
        },
        {
          "level": 3,
          "title": "6. Vue中key的作用",
          "slug": "_6-vue中key的作用",
          "normalizedTitle": "6. vue中key的作用",
          "charIndex": 1745
        },
        {
          "level": 3,
          "title": "7. 为什么不建议用index作为key?",
          "slug": "_7-为什么不建议用index作为key",
          "normalizedTitle": "7. 为什么不建议用index作为key?",
          "charIndex": 2381
        }
      ],
      "headersStr": "1. 对虚拟DOM的理解？ 2. 虚拟DOM的解析过程 3. 为什么要用虚拟DOM 4. 虚拟DOM真的比真实DOM性能好吗 5. DIFF算法的原理 6. Vue中key的作用 7. 为什么不建议用index作为key?",
      "content": "# 1. 对虚拟DOM的理解？\n\n从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。\n\n虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。\n\n另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。\n\n\n# 2. 虚拟DOM的解析过程\n\n虚拟DOM的解析过程：\n\n * 首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。\n * 当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。\n * 最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。\n\n\n# 3. 为什么要用虚拟DOM\n\n（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能 看一下页面渲染的流程：解析HTML -> 生成DOM -> 生成 CSSOM -> Layout -> Paint -> Compiler 下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶\n\n * 真实DOM∶ 生成HTML字符串＋重建所有的DOM元素\n * 虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新\n\nVirtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。 （2）跨平台 Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。\n\n\n# 4. 虚拟DOM真的比真实DOM性能好吗\n\n * 首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。\n * 正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。\n\n\n# 5. DIFF算法的原理\n\n在新老虚拟DOM对比时：\n\n * 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换\n * 如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)\n * 比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。\n * 匹配时，找到相同的子节点，递归比较子节点\n\n在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。\n\n\n# 6. Vue中key的作用\n\nvue 中 key 值的作用可以分为两种情况来考虑：\n\n * 第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。\n * 第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。\n\nkey 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速\n\n * 更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。\n * 更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快\n\n\n# 7. 为什么不建议用index作为key?\n\n使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。",
      "normalizedContent": "# 1. 对虚拟dom的理解？\n\n从本质上来说，virtual dom是一个javascript对象，通过对象的方式来表示dom结构。将页面的状态抽象为js对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次dom修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改dom的重绘重排次数，提高渲染性能。\n\n虚拟dom是对dom的抽象，这个对象是更加轻量级的对 dom的描述。它设计的最初目的，就是更好的跨平台，比如node.js就没有dom，如果想实现ssr，那么一个方式就是借助虚拟dom，因为虚拟dom本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 dom）。以对象的形式来描述真实dom结构，最终渲染到页面。在每次数据发生变化前，虚拟dom都会缓存一份，变化之时，现在的虚拟dom会与缓存的虚拟dom进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。\n\n另外现代前端框架的一个基本要求就是无须手动操作dom，一方面是因为手动操作dom无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动dom操作可以大大提高开发效率。\n\n\n# 2. 虚拟dom的解析过程\n\n虚拟dom的解析过程：\n\n * 首先对将要插入到文档中的 dom 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 tagname、props 和 children 这些属性。然后将这个 js 对象树给保存下来，最后再将 dom 片段插入到文档中。\n * 当页面的状态发生改变，需要对页面的 dom 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。\n * 最后将记录的有差异的地方应用到真正的 dom 树中去，这样视图就更新了。\n\n\n# 3. 为什么要用虚拟dom\n\n（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能 看一下页面渲染的流程：解析html -> 生成dom -> 生成 cssom -> layout -> paint -> compiler 下面对比一下修改dom时真实dom操作和virtual dom的过程，来看一下它们重排重绘的性能消耗∶\n\n * 真实dom∶ 生成html字符串＋重建所有的dom元素\n * 虚拟dom∶ 生成vnode+ domdiff＋必要的dom更新\n\nvirtual dom的更新dom的准备工作耗费更多的时间，也就是js层面，相比于更多的dom操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。 （2）跨平台 virtual dom本质上是javascript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。\n\n\n# 4. 虚拟dom真的比真实dom性能好吗\n\n * 首次渲染大量dom时，由于多了一层虚拟dom的计算，会比innerhtml插入慢。\n * 正如它能保证性能下限，在真实dom操作的时候进行针对性的优化时，还是更快的。\n\n\n# 5. diff算法的原理\n\n在新老虚拟dom对比时：\n\n * 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换\n * 如果为相同节点，进行patchvnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)\n * 比较如果都有子节点，则进行updatechildren，判断如何对这些新老节点的子节点进行操作（diff核心）。\n * 匹配时，找到相同的子节点，递归比较子节点\n\n在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从o(n3)降低值o(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的diff算法进行同层级比较。\n\n\n# 6. vue中key的作用\n\nvue 中 key 值的作用可以分为两种情况来考虑：\n\n * 第一种情况是 v-if 中使用 key。由于 vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。\n * 第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，vue 不会移动 dom 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 dom。\n\nkey 是为 vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速\n\n * 更准确：因为带 key 就不是就地复用了，在 samenode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。\n * 更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快\n\n\n# 7. 为什么不建议用index作为key?\n\n使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 vue 会复用错误的旧子节点，做很多额外的工作。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "数据管理",
      "frontmatter": {
        "title": "数据管理",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/frameDataManagement/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/20.react%E7%AF%87/20.%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86.html",
      "relativePath": "30.框架篇/20.react篇/20.数据管理.md",
      "key": "v-703e2a85",
      "path": "/pages/frameDataManagement/",
      "headers": [
        {
          "level": 3,
          "title": "1. React setState 调用的原理",
          "slug": "_1-react-setstate-调用的原理",
          "normalizedTitle": "1. react setstate 调用的原理",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. React setState 调用之后发生了什么？是同步还是异步？",
          "slug": "_2-react-setstate-调用之后发生了什么-是同步还是异步",
          "normalizedTitle": "2. react setstate 调用之后发生了什么？是同步还是异步？",
          "charIndex": 1774
        },
        {
          "level": 3,
          "title": "3. React中的setState批量更新的过程是什么？",
          "slug": "_3-react中的setstate批量更新的过程是什么",
          "normalizedTitle": "3. react中的setstate批量更新的过程是什么？",
          "charIndex": 2854
        },
        {
          "level": 3,
          "title": "4.  React中有使用过getDefaultProps吗？它有什么作用？",
          "slug": "_4-react中有使用过getdefaultprops吗-它有什么作用",
          "normalizedTitle": "4.  react中有使用过getdefaultprops吗？它有什么作用？",
          "charIndex": null
        },
        {
          "level": 3,
          "title": "5. React中setState的第二个参数作用是什么？",
          "slug": "_5-react中setstate的第二个参数作用是什么",
          "normalizedTitle": "5. react中setstate的第二个参数作用是什么？",
          "charIndex": 3853
        },
        {
          "level": 3,
          "title": "6. React中的setState和replaceState的区别是什么？",
          "slug": "_6-react中的setstate和replacestate的区别是什么",
          "normalizedTitle": "6. react中的setstate和replacestate的区别是什么？",
          "charIndex": 4132
        },
        {
          "level": 3,
          "title": "7. 在React中组件的this.state和setState有什么区别？",
          "slug": "_7-在react中组件的this-state和setstate有什么区别",
          "normalizedTitle": "7. 在react中组件的this.state和setstate有什么区别？",
          "charIndex": 4820
        },
        {
          "level": 3,
          "title": "8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程",
          "slug": "_8-state-是怎么注入到组件的-从-reducer-到组件经历了什么样的过程",
          "normalizedTitle": "8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程",
          "charIndex": 5054
        },
        {
          "level": 3,
          "title": "9. React组件的state和props有什么区别？",
          "slug": "_9-react组件的state和props有什么区别",
          "normalizedTitle": "9. react组件的state和props有什么区别？",
          "charIndex": 7474
        },
        {
          "level": 3,
          "title": "10. React中的props为什么是只读的？",
          "slug": "_10-react中的props为什么是只读的",
          "normalizedTitle": "10. react中的props为什么是只读的？",
          "charIndex": 7954
        },
        {
          "level": 3,
          "title": "11. 在React中组件的props改变时更新组件的有哪些方法？",
          "slug": "_11-在react中组件的props改变时更新组件的有哪些方法",
          "normalizedTitle": "11. 在react中组件的props改变时更新组件的有哪些方法？",
          "charIndex": 8187
        },
        {
          "level": 3,
          "title": "12. React中怎么检验props？验证props的目的是什么？",
          "slug": "_12-react中怎么检验props-验证props的目的是什么",
          "normalizedTitle": "12. react中怎么检验props？验证props的目的是什么？",
          "charIndex": 9312
        }
      ],
      "headersStr": "1. React setState 调用的原理 2. React setState 调用之后发生了什么？是同步还是异步？ 3. React中的setState批量更新的过程是什么？ 4.  React中有使用过getDefaultProps吗？它有什么作用？ 5. React中setState的第二个参数作用是什么？ 6. React中的setState和replaceState的区别是什么？ 7. 在React中组件的this.state和setState有什么区别？ 8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程 9. React组件的state和props有什么区别？ 10. React中的props为什么是只读的？ 11. 在React中组件的props改变时更新组件的有哪些方法？ 12. React中怎么检验props？验证props的目的是什么？",
      "content": "# 1. React setState 调用的原理\n\n具体的执行过程如下（源码级解析）：\n\n * 首先调用了setState 入口函数，入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去；\n\nReactComponent.prototype.setState = function (partialState, callback) {\n  this.updater.enqueueSetState(this, partialState);\n  if (callback) {\n    this.updater.enqueueCallback(this, callback, 'setState');\n  }\n};\n\n\n * enqueueSetState 方法将新的 state 放进组件的状态队列里，并调用 enqueueUpdate 来处理将要更新的实例对象；\n\nenqueueSetState: function (publicInstance, partialState) {\n  // 根据 this 拿到对应的组件实例\n  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');\n  // 这个 queue 对应的就是一个组件实例的 state 数组\n  var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);\n  queue.push(partialState);\n  //  enqueueUpdate 用来处理当前的组件实例\n  enqueueUpdate(internalInstance);\n}\n\n\n * 在 enqueueUpdate 方法中引出了一个关键的对象——batchingStrategy，该对象所具备的isBatchingUpdates 属性直接决定了当下是要走更新流程，还是应该排队等待；如果轮到执行，就调用 batchedUpdates 方法来直接发起更新流程。由此可以推测，batchingStrategy 或许正是 React 内部专门用于管控批量更新的对象。\n\nfunction enqueueUpdate(component) {\n  ensureInjected();\n  // 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段\n  if (!batchingStrategy.isBatchingUpdates) {\n    // 若当前没有处于批量创建/更新组件的阶段，则立即更新组件\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n  // 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”\n  dirtyComponents.push(component);\n  if (component._updateBatchNumber == null) {\n    component._updateBatchNumber = updateBatchNumber + 1;\n  }\n}\n\n\n注意：batchingStrategy 对象可以理解为“锁管理器”。这里的“锁”，是指 React 全局唯一的 isBatchingUpdates 变量，isBatchingUpdates 的初始值是 false，意味着“当前并未进行任何批量更新操作”。每当 React 调用 batchedUpdate 去执行更新动作时，会先把这个锁给“锁上”（置为 true），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 dirtyComponents 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。\n\n\n# 2. React setState 调用之后发生了什么？是同步还是异步？\n\n（1）React中setState后发生了什么\n\n在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发调和过程(Reconciliation)。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。\n\n在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。\n\n如果在短时间内频繁setState。React会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。\n\n（2）setState 是同步还是异步的\n\n假如所有setState是同步的，意味着每执行一次setState时（有可能一个同步代码中，多次setState），都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setState合并成一次组件更新。所以默认是异步的，但是在一些情况下是同步的。\n\nsetState 并不是单纯同步/异步的，它的表现会因调用场景的不同而不同。在源码中，通过 isBatchingUpdates 来判断setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。\n\n * 异步： 在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。\n * 同步： 在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。\n\n一般认为，做异步设计是为了性能优化、减少渲染次数：\n\n * setState设计为异步，可以显著的提升性能。如果每次调用 setState都进行一次更新，那么意味着render函数会被频繁调用，界面重新渲染，这样效率是很低的；最好的办法应该是获取到多个更新，之后进行批量更新；\n * 如果同步更新了state，但是还没有执行render函数，那么state和props不能保持同步。state和props不能保持一致性，会在开发中产生很多的问题；\n\n\n# 3. React中的setState批量更新的过程是什么？\n\n调用 setState 时，组件的 state 并不会立即改变， setState 只是把要修改的 state 放入一个队列， React 会优化真正的执行时机，并出于性能原因，会将 React 事件处理程序中的多次React 事件处理程序中的多次 setState 的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。\n\nthis.setState({\n  count: this.state.count + 1    ===>    入队，[count+1的任务]\n});\nthis.setState({\n  count: this.state.count + 1    ===>    入队，[count+1的任务，count+1的任务]\n});\n                                          ↓\n                                         合并 state，[count+1的任务]\n                                          ↓\n                                         执行 count+1的任务\n\n\n需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。\n\n\n# 4. React中有使用过getDefaultProps吗？它有什么作用？\n\n通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：\n\nvar ShowTitle = React.createClass({\n  getDefaultProps:function(){\n    return{\n      title : \"React\"\n    }\n  },\n  render : function(){\n    return <h1>{this.props.title}</h1>\n  }\n});\n\n\n\n# 5. React中setState的第二个参数作用是什么？\n\nsetState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值：\n\nthis.setState({\n    key1: newState1,\n    key2: newState2,\n    ...\n}, callback) // 第二个参数是 state 更新完成后的回调函数\n\n\n\n# 6. React中的setState和replaceState的区别是什么？\n\n（1）setState() setState()用于设置状态对象，其语法如下：\n\nsetState(object nextState[, function callback])\n\n\n * nextState，将要设置的新状态，该状态会和当前的state合并\n * callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。\n\n合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。\n\n（2）replaceState() replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下：\n\nreplaceState(object nextState[, function callback])\n\n\n * nextState，将要设置的新状态，该状态会替换当前的state。\n * callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。\n\n总结： setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。\n\n\n# 7. 在React中组件的this.state和setState有什么区别？\n\nthis.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。\n\n\n# 8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程\n\n通过connect和mapStateToProps将state注入到组件中：\n\nimport { connect } from 'react-redux'\nimport { setVisibilityFilter } from '@/reducers/Todo/actions'\nimport Link from '@/containers/Todo/components/Link'\n\nconst mapStateToProps = (state, ownProps) => ({\n    active: ownProps.filter === state.visibilityFilter\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n    setFilter: () => {\n        dispatch(setVisibilityFilter(ownProps.filter))\n    }\n})\n\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps\n)(Link)\n\n\n上面代码中，active就是注入到Link组件中的状态。 mapStateToProps（state，ownProps）中带有两个参数，含义是∶\n\n * state-store管理的全局状态对象，所有都组件状态数据都存储在该对象中。\n * ownProps 组件通过props传入的参数。\n\nreducer 到组件经历的过程：\n\n * reducer对action对象处理，更新组件状态，并将新的状态值返回store。\n * 通过connect（mapStateToProps，mapDispatchToProps）（Component）对组件 Component进行升级，此时将状态值从store取出并作为props参数传递到组件。\n\n高阶组件实现源码∶\n\nimport React from 'react'\nimport PropTypes from 'prop-types'\n\n// 高阶组件 contect \nexport const connect = (mapStateToProps, mapDispatchToProps) => (WrappedComponent) => {\n    class Connect extends React.Component {\n        // 通过对context调用获取store\n        static contextTypes = {\n            store: PropTypes.object\n        }\n\n        constructor() {\n            super()\n            this.state = {\n                allProps: {}\n            }\n        }\n\n        // 第一遍需初始化所有组件初始状态\n        componentWillMount() {\n            const store = this.context.store\n            this._updateProps()\n            store.subscribe(() => this._updateProps()); // 加入_updateProps()至store里的监听事件列表\n        }\n\n        // 执行action后更新props，使组件可以更新至最新状态（类似于setState）\n        _updateProps() {\n            const store = this.context.store;\n            let stateProps = mapStateToProps ?\n                mapStateToProps(store.getState(), this.props) : {} // 防止 mapStateToProps 没有传入\n            let dispatchProps = mapDispatchToProps ?\n                mapDispatchToProps(store.dispatch, this.props) : {\n                                    dispatch: store.dispatch\n                                } // 防止 mapDispatchToProps 没有传入\n            this.setState({\n                allProps: {\n                    ...stateProps,\n                    ...dispatchProps,\n                    ...this.props\n                }\n            })\n        }\n\n        render() {\n            return <WrappedComponent {...this.state.allProps} />\n        }\n    }\n    return Connect\n}\n\n\n\n# 9. React组件的state和props有什么区别？\n\n（1）props\n\nprops是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。\n\n（2）state\n\nstate的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。\n\n（3）区别\n\n * props 是传递给组件的（类似于函数的形参），而state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。\n * props 是不可修改的，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。\n * state 是在组件中创建的，一般在 constructor中初始化 state。state 是多变的、可以修改，每次setState都异步更新的。\n\n\n# 10. React中的props为什么是只读的？\n\nthis.props是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。React具有浓重的函数式编程的思想。\n\n提到函数式编程就要提一个概念：纯函数。它有几个特点：\n\n * 给定相同的输入，总是返回相同的输出。\n * 过程没有副作用。\n * 不依赖外部状态。\n\nthis.props就是汲取了纯函数的思想。props的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用\n\n\n# 11. 在React中组件的props改变时更新组件的有哪些方法？\n\n在一个组件传入的props更新时重新渲染该组件常用的方法是在componentWillReceiveProps中将新的props更新到组件的state中（这种state被成为派生状态（Derived State）），从而实现重新渲染。React 16.3中还引入了一个新的钩子函数getDerivedStateFromProps来专门实现这一需求。\n\n（1）componentWillReceiveProps（已废弃）\n\n在react的componentWillReceiveProps(nextProps)生命周期中，可以在子组件的render函数执行前，通过this.props获取旧的属性，通过nextProps获取新的props，对比两次props是否相同，从而更新子组件自己的state。\n\n这样的好处是，可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。\n\n（2）getDerivedStateFromProps（16.3引入）\n\n这个生命周期函数是为了替代componentWillReceiveProps存在的，所以在需要使用componentWillReceiveProps时，就可以考虑使用getDerivedStateFromProps来进行替代。\n\n两者的参数是不相同的，而getDerivedStateFromProps是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。\n\n需要注意的是，如果props传入的内容不需要影响到你的state，那么就需要返回一个null，这个返回值是必须的，所以尽量将其写到函数的末尾：\n\nstatic getDerivedStateFromProps(nextProps, prevState) {\n    const {type} = nextProps;\n    // 当传入的type发生变化的时候，更新state\n    if (type !== prevState.type) {\n        return {\n            type,\n        };\n    }\n    // 否则，对于state不进行任何操作\n    return null;\n}\n\n\n\n# 12. React中怎么检验props？验证props的目的是什么？\n\nReact为我们提供了PropTypes以供验证使用。当我们向Props传入的数据无效（向Props传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的问题。并且，它还可以让程序变得更易读。\n\nimport PropTypes from 'prop-types';\n\nclass Greeting extends React.Component {\n  render() {\n    return (\n      <h1>Hello, {this.props.name}</h1>\n    );\n  }\n}\n\nGreeting.propTypes = {\n  name: PropTypes.string\n};\n\n\n当然，如果项目汇中使用了TypeScript，那么就可以不用PropTypes来校验，而使用TypeScript定义接口来校验props。",
      "normalizedContent": "# 1. react setstate 调用的原理\n\n具体的执行过程如下（源码级解析）：\n\n * 首先调用了setstate 入口函数，入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去；\n\nreactcomponent.prototype.setstate = function (partialstate, callback) {\n  this.updater.enqueuesetstate(this, partialstate);\n  if (callback) {\n    this.updater.enqueuecallback(this, callback, 'setstate');\n  }\n};\n\n\n * enqueuesetstate 方法将新的 state 放进组件的状态队列里，并调用 enqueueupdate 来处理将要更新的实例对象；\n\nenqueuesetstate: function (publicinstance, partialstate) {\n  // 根据 this 拿到对应的组件实例\n  var internalinstance = getinternalinstancereadyforupdate(publicinstance, 'setstate');\n  // 这个 queue 对应的就是一个组件实例的 state 数组\n  var queue = internalinstance._pendingstatequeue || (internalinstance._pendingstatequeue = []);\n  queue.push(partialstate);\n  //  enqueueupdate 用来处理当前的组件实例\n  enqueueupdate(internalinstance);\n}\n\n\n * 在 enqueueupdate 方法中引出了一个关键的对象——batchingstrategy，该对象所具备的isbatchingupdates 属性直接决定了当下是要走更新流程，还是应该排队等待；如果轮到执行，就调用 batchedupdates 方法来直接发起更新流程。由此可以推测，batchingstrategy 或许正是 react 内部专门用于管控批量更新的对象。\n\nfunction enqueueupdate(component) {\n  ensureinjected();\n  // 注意这一句是问题的关键，isbatchingupdates标识着当前是否处于批量创建/更新组件的阶段\n  if (!batchingstrategy.isbatchingupdates) {\n    // 若当前没有处于批量创建/更新组件的阶段，则立即更新组件\n    batchingstrategy.batchedupdates(enqueueupdate, component);\n    return;\n  }\n  // 否则，先把组件塞入 dirtycomponents 队列里，让它“再等等”\n  dirtycomponents.push(component);\n  if (component._updatebatchnumber == null) {\n    component._updatebatchnumber = updatebatchnumber + 1;\n  }\n}\n\n\n注意：batchingstrategy 对象可以理解为“锁管理器”。这里的“锁”，是指 react 全局唯一的 isbatchingupdates 变量，isbatchingupdates 的初始值是 false，意味着“当前并未进行任何批量更新操作”。每当 react 调用 batchedupdate 去执行更新动作时，会先把这个锁给“锁上”（置为 true），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 dirtycomponents 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 react 面对大量状态仍然能够实现有序分批处理的基石。\n\n\n# 2. react setstate 调用之后发生了什么？是同步还是异步？\n\n（1）react中setstate后发生了什么\n\n在代码中调用setstate函数之后，react 会将传入的参数对象与组件当前的状态合并，然后触发调和过程(reconciliation)。经过调和过程，react 会以相对高效的方式根据新的状态构建 react 元素树并且着手重新渲染整个ui界面。\n\n在 react 得到元素树之后，react 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，react 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。\n\n如果在短时间内频繁setstate。react会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。\n\n（2）setstate 是同步还是异步的\n\n假如所有setstate是同步的，意味着每执行一次setstate时（有可能一个同步代码中，多次setstate），都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setstate合并成一次组件更新。所以默认是异步的，但是在一些情况下是同步的。\n\nsetstate 并不是单纯同步/异步的，它的表现会因调用场景的不同而不同。在源码中，通过 isbatchingupdates 来判断setstate 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。\n\n * 异步： 在 react 可以控制的地方，就为 true，比如在 react 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。\n * 同步： 在 react 无法控制的地方，比如原生事件，具体就是在 addeventlistener 、settimeout、setinterval 等事件中，就只能同步更新。\n\n一般认为，做异步设计是为了性能优化、减少渲染次数：\n\n * setstate设计为异步，可以显著的提升性能。如果每次调用 setstate都进行一次更新，那么意味着render函数会被频繁调用，界面重新渲染，这样效率是很低的；最好的办法应该是获取到多个更新，之后进行批量更新；\n * 如果同步更新了state，但是还没有执行render函数，那么state和props不能保持同步。state和props不能保持一致性，会在开发中产生很多的问题；\n\n\n# 3. react中的setstate批量更新的过程是什么？\n\n调用 setstate 时，组件的 state 并不会立即改变， setstate 只是把要修改的 state 放入一个队列， react 会优化真正的执行时机，并出于性能原因，会将 react 事件处理程序中的多次react 事件处理程序中的多次 setstate 的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。\n\nthis.setstate({\n  count: this.state.count + 1    ===>    入队，[count+1的任务]\n});\nthis.setstate({\n  count: this.state.count + 1    ===>    入队，[count+1的任务，count+1的任务]\n});\n                                          ↓\n                                         合并 state，[count+1的任务]\n                                          ↓\n                                         执行 count+1的任务\n\n\n需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setstate 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，react 只会为其保留最后一次的更新）。\n\n\n# 4. react中有使用过getdefaultprops吗？它有什么作用？\n\n通过实现组件的getdefaultprops，对属性设置默认值（es5的写法）：\n\nvar showtitle = react.createclass({\n  getdefaultprops:function(){\n    return{\n      title : \"react\"\n    }\n  },\n  render : function(){\n    return <h1>{this.props.title}</h1>\n  }\n});\n\n\n\n# 5. react中setstate的第二个参数作用是什么？\n\nsetstate 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentdidupdate 生命周期内执行。通常建议使用 componentdidupdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值：\n\nthis.setstate({\n    key1: newstate1,\n    key2: newstate2,\n    ...\n}, callback) // 第二个参数是 state 更新完成后的回调函数\n\n\n\n# 6. react中的setstate和replacestate的区别是什么？\n\n（1）setstate() setstate()用于设置状态对象，其语法如下：\n\nsetstate(object nextstate[, function callback])\n\n\n * nextstate，将要设置的新状态，该状态会和当前的state合并\n * callback，可选参数，回调函数。该函数会在setstate设置成功，且组件重新渲染后调用。\n\n合并nextstate和当前state，并重新渲染组件。setstate是react事件处理函数中和请求回调函数中触发ui更新的主要方法。\n\n（2）replacestate() replacestate()方法与setstate()类似，但是方法只会保留nextstate中状态，原state不在nextstate中的状态都会被删除。其语法如下：\n\nreplacestate(object nextstate[, function callback])\n\n\n * nextstate，将要设置的新状态，该状态会替换当前的state。\n * callback，可选参数，回调函数。该函数会在replacestate设置成功，且组件重新渲染后调用。\n\n总结： setstate 是修改其中的部分状态，相当于 object.assign，只是覆盖，不会减少原来的状态。而replacestate 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。\n\n\n# 7. 在react中组件的this.state和setstate有什么区别？\n\nthis.state通常是用来初始化state的，this.setstate是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setstate，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setstate，而不能直接修改state，直接修改state之后页面是不会更新的。\n\n\n# 8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程\n\n通过connect和mapstatetoprops将state注入到组件中：\n\nimport { connect } from 'react-redux'\nimport { setvisibilityfilter } from '@/reducers/todo/actions'\nimport link from '@/containers/todo/components/link'\n\nconst mapstatetoprops = (state, ownprops) => ({\n    active: ownprops.filter === state.visibilityfilter\n})\n\nconst mapdispatchtoprops = (dispatch, ownprops) => ({\n    setfilter: () => {\n        dispatch(setvisibilityfilter(ownprops.filter))\n    }\n})\n\nexport default connect(\n    mapstatetoprops,\n    mapdispatchtoprops\n)(link)\n\n\n上面代码中，active就是注入到link组件中的状态。 mapstatetoprops（state，ownprops）中带有两个参数，含义是∶\n\n * state-store管理的全局状态对象，所有都组件状态数据都存储在该对象中。\n * ownprops 组件通过props传入的参数。\n\nreducer 到组件经历的过程：\n\n * reducer对action对象处理，更新组件状态，并将新的状态值返回store。\n * 通过connect（mapstatetoprops，mapdispatchtoprops）（component）对组件 component进行升级，此时将状态值从store取出并作为props参数传递到组件。\n\n高阶组件实现源码∶\n\nimport react from 'react'\nimport proptypes from 'prop-types'\n\n// 高阶组件 contect \nexport const connect = (mapstatetoprops, mapdispatchtoprops) => (wrappedcomponent) => {\n    class connect extends react.component {\n        // 通过对context调用获取store\n        static contexttypes = {\n            store: proptypes.object\n        }\n\n        constructor() {\n            super()\n            this.state = {\n                allprops: {}\n            }\n        }\n\n        // 第一遍需初始化所有组件初始状态\n        componentwillmount() {\n            const store = this.context.store\n            this._updateprops()\n            store.subscribe(() => this._updateprops()); // 加入_updateprops()至store里的监听事件列表\n        }\n\n        // 执行action后更新props，使组件可以更新至最新状态（类似于setstate）\n        _updateprops() {\n            const store = this.context.store;\n            let stateprops = mapstatetoprops ?\n                mapstatetoprops(store.getstate(), this.props) : {} // 防止 mapstatetoprops 没有传入\n            let dispatchprops = mapdispatchtoprops ?\n                mapdispatchtoprops(store.dispatch, this.props) : {\n                                    dispatch: store.dispatch\n                                } // 防止 mapdispatchtoprops 没有传入\n            this.setstate({\n                allprops: {\n                    ...stateprops,\n                    ...dispatchprops,\n                    ...this.props\n                }\n            })\n        }\n\n        render() {\n            return <wrappedcomponent {...this.state.allprops} />\n        }\n    }\n    return connect\n}\n\n\n\n# 9. react组件的state和props有什么区别？\n\n（1）props\n\nprops是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。\n\n（2）state\n\nstate的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setstate来修改，修改state属性会导致组件的重新渲染。\n\n（3）区别\n\n * props 是传递给组件的（类似于函数的形参），而state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。\n * props 是不可修改的，所有 react 组件都必须像纯函数一样保护它们的 props 不被更改。\n * state 是在组件中创建的，一般在 constructor中初始化 state。state 是多变的、可以修改，每次setstate都异步更新的。\n\n\n# 10. react中的props为什么是只读的？\n\nthis.props是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。react具有浓重的函数式编程的思想。\n\n提到函数式编程就要提一个概念：纯函数。它有几个特点：\n\n * 给定相同的输入，总是返回相同的输出。\n * 过程没有副作用。\n * 不依赖外部状态。\n\nthis.props就是汲取了纯函数的思想。props的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用\n\n\n# 11. 在react中组件的props改变时更新组件的有哪些方法？\n\n在一个组件传入的props更新时重新渲染该组件常用的方法是在componentwillreceiveprops中将新的props更新到组件的state中（这种state被成为派生状态（derived state）），从而实现重新渲染。react 16.3中还引入了一个新的钩子函数getderivedstatefromprops来专门实现这一需求。\n\n（1）componentwillreceiveprops（已废弃）\n\n在react的componentwillreceiveprops(nextprops)生命周期中，可以在子组件的render函数执行前，通过this.props获取旧的属性，通过nextprops获取新的props，对比两次props是否相同，从而更新子组件自己的state。\n\n这样的好处是，可以将数据请求放在这里进行执行，需要传的参数则从componentwillreceiveprops(nextprops)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。\n\n（2）getderivedstatefromprops（16.3引入）\n\n这个生命周期函数是为了替代componentwillreceiveprops存在的，所以在需要使用componentwillreceiveprops时，就可以考虑使用getderivedstatefromprops来进行替代。\n\n两者的参数是不相同的，而getderivedstatefromprops是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextprops以及prevstate来进行判断，根据新传入的props来映射到state。\n\n需要注意的是，如果props传入的内容不需要影响到你的state，那么就需要返回一个null，这个返回值是必须的，所以尽量将其写到函数的末尾：\n\nstatic getderivedstatefromprops(nextprops, prevstate) {\n    const {type} = nextprops;\n    // 当传入的type发生变化的时候，更新state\n    if (type !== prevstate.type) {\n        return {\n            type,\n        };\n    }\n    // 否则，对于state不进行任何操作\n    return null;\n}\n\n\n\n# 12. react中怎么检验props？验证props的目的是什么？\n\nreact为我们提供了proptypes以供验证使用。当我们向props传入的数据无效（向props传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的问题。并且，它还可以让程序变得更易读。\n\nimport proptypes from 'prop-types';\n\nclass greeting extends react.component {\n  render() {\n    return (\n      <h1>hello, {this.props.name}</h1>\n    );\n  }\n}\n\ngreeting.proptypes = {\n  name: proptypes.string\n};\n\n\n当然，如果项目汇中使用了typescript，那么就可以不用proptypes来校验，而使用typescript定义接口来校验props。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "组件基础",
      "frontmatter": {
        "title": "组件基础",
        "date": "2022-10-20T10:31:15.000Z",
        "permalink": "/pages/frameReact/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/20.react%E7%AF%87/10.%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80.html",
      "relativePath": "30.框架篇/20.react篇/10.组件基础.md",
      "key": "v-44f9a0c6",
      "path": "/pages/frameReact/",
      "headers": [
        {
          "level": 3,
          "title": "1. React 事件机制",
          "slug": "_1-react-事件机制",
          "normalizedTitle": "1. react 事件机制",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. React的事件和普通的HTML事件有什么不同？",
          "slug": "_2-react的事件和普通的html事件有什么不同",
          "normalizedTitle": "2. react的事件和普通的html事件有什么不同？",
          "charIndex": 824
        },
        {
          "level": 3,
          "title": "3. React 组件中怎么做事件代理？它的原理是什么？",
          "slug": "_3-react-组件中怎么做事件代理-它的原理是什么",
          "normalizedTitle": "3. react 组件中怎么做事件代理？它的原理是什么？",
          "charIndex": 1251
        },
        {
          "level": 3,
          "title": "4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代",
          "slug": "_4-react-高阶组件、render-props、hooks-有什么区别-为什么要不断迭代",
          "normalizedTitle": "4. react 高阶组件、render props、hooks 有什么区别，为什么要不断迭代",
          "charIndex": 1561
        },
        {
          "level": 3,
          "title": "5. 对React-Fiber的理解，它解决了什么问题？",
          "slug": "_5-对react-fiber的理解-它解决了什么问题",
          "normalizedTitle": "5. 对react-fiber的理解，它解决了什么问题？",
          "charIndex": 4078
        },
        {
          "level": 3,
          "title": "6. React.Component 和 React.PureComponent 的区别",
          "slug": "_6-react-component-和-react-purecomponent-的区别",
          "normalizedTitle": "6. react.component 和 react.purecomponent 的区别",
          "charIndex": 4703
        },
        {
          "level": 3,
          "title": "7. Component, Element, Instance 之间有什么区别和联系？",
          "slug": "_7-component-element-instance-之间有什么区别和联系",
          "normalizedTitle": "7. component, element, instance 之间有什么区别和联系？",
          "charIndex": 5281
        },
        {
          "level": 3,
          "title": "8. React.createClass和extends Component的区别有哪些？",
          "slug": "_8-react-createclass和extends-component的区别有哪些",
          "normalizedTitle": "8. react.createclass和extends component的区别有哪些？",
          "charIndex": 5803
        },
        {
          "level": 3,
          "title": "9. React 高阶组件是什么，和普通组件有什么区别，适用什么场景",
          "slug": "_9-react-高阶组件是什么-和普通组件有什么区别-适用什么场景",
          "normalizedTitle": "9. react 高阶组件是什么，和普通组件有什么区别，适用什么场景",
          "charIndex": 6627
        },
        {
          "level": 3,
          "title": "10. 对componentWillReceiveProps 的理解",
          "slug": "_10-对componentwillreceiveprops-的理解",
          "normalizedTitle": "10. 对componentwillreceiveprops 的理解",
          "charIndex": 10522
        },
        {
          "level": 3,
          "title": "11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？",
          "slug": "_11-哪些方法会触发-react-重新渲染-重新渲染-render-会做些什么",
          "normalizedTitle": "11. 哪些方法会触发 react 重新渲染？重新渲染 render 会做些什么？",
          "charIndex": 10966
        },
        {
          "level": 3,
          "title": "12. React如何判断什么时候重新渲染组件？",
          "slug": "_12-react如何判断什么时候重新渲染组件",
          "normalizedTitle": "12. react如何判断什么时候重新渲染组件？",
          "charIndex": 12198
        },
        {
          "level": 3,
          "title": "13. React声明组件有哪几种方法，有什么不同？",
          "slug": "_13-react声明组件有哪几种方法-有什么不同",
          "normalizedTitle": "13. react声明组件有哪几种方法，有什么不同？",
          "charIndex": 12534
        },
        {
          "level": 3,
          "title": "14. 对有状态组件和无状态组件的理解及使用场景",
          "slug": "_14-对有状态组件和无状态组件的理解及使用场景",
          "normalizedTitle": "14. 对有状态组件和无状态组件的理解及使用场景",
          "charIndex": 13638
        },
        {
          "level": 3,
          "title": "15. 对React中Fragment的理解，它的使用场景是什么？",
          "slug": "_15-对react中fragment的理解-它的使用场景是什么",
          "normalizedTitle": "15. 对react中fragment的理解，它的使用场景是什么？",
          "charIndex": 14540
        },
        {
          "level": 3,
          "title": "16. React如何获取组件对应的DOM元素？",
          "slug": "_16-react如何获取组件对应的dom元素",
          "normalizedTitle": "16. react如何获取组件对应的dom元素？",
          "charIndex": 15042
        },
        {
          "level": 3,
          "title": "17. React中可以在render访问refs吗？为什么？",
          "slug": "_17-react中可以在render访问refs吗-为什么",
          "normalizedTitle": "17. react中可以在render访问refs吗？为什么？",
          "charIndex": 15329
        },
        {
          "level": 3,
          "title": "18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景",
          "slug": "_18-对react的插槽-portals-的理解-如何使用-有哪些使用场景",
          "normalizedTitle": "18. 对react的插槽(portals)的理解，如何使用，有哪些使用场景",
          "charIndex": 15569
        },
        {
          "level": 3,
          "title": "19. 在React中如何避免不必要的render？",
          "slug": "_19-在react中如何避免不必要的render",
          "normalizedTitle": "19. 在react中如何避免不必要的render？",
          "charIndex": 16430
        },
        {
          "level": 3,
          "title": "20. 对 React-Intl 的理解，它的工作原理？",
          "slug": "_20-对-react-intl-的理解-它的工作原理",
          "normalizedTitle": "20. 对 react-intl 的理解，它的工作原理？",
          "charIndex": 17029
        },
        {
          "level": 3,
          "title": "21. 对 React context 的理解",
          "slug": "_21-对-react-context-的理解",
          "normalizedTitle": "21. 对 react context 的理解",
          "charIndex": 17312
        },
        {
          "level": 3,
          "title": "22. 为什么React并不推荐优先考虑使用Context？",
          "slug": "_22-为什么react并不推荐优先考虑使用context",
          "normalizedTitle": "22. 为什么react并不推荐优先考虑使用context？",
          "charIndex": 17917
        },
        {
          "level": 3,
          "title": "23. React中什么是受控组件和非控组件？",
          "slug": "_23-react中什么是受控组件和非控组件",
          "normalizedTitle": "23. react中什么是受控组件和非控组件？",
          "charIndex": 18382
        },
        {
          "level": 3,
          "title": "24. React中refs的作用是什么？有哪些应用场景？",
          "slug": "_24-react中refs的作用是什么-有哪些应用场景",
          "normalizedTitle": "24. react中refs的作用是什么？有哪些应用场景？",
          "charIndex": 19839
        },
        {
          "level": 3,
          "title": "25. 类组件与函数组件有什么异同？",
          "slug": "_25-类组件与函数组件有什么异同",
          "normalizedTitle": "25. 类组件与函数组件有什么异同？",
          "charIndex": 21267
        },
        {
          "level": 3,
          "title": "26. React组件的构造函数有什么作用？它是必须的吗？",
          "slug": "_26-react组件的构造函数有什么作用-它是必须的吗",
          "normalizedTitle": "26. react组件的构造函数有什么作用？它是必须的吗？",
          "charIndex": 22041
        },
        {
          "level": 3,
          "title": "27. React.forwardRef是什么？它有什么作用？",
          "slug": "_27-react-forwardref是什么-它有什么作用",
          "normalizedTitle": "27. react.forwardref是什么？它有什么作用？",
          "charIndex": 22988
        }
      ],
      "headersStr": "1. React 事件机制 2. React的事件和普通的HTML事件有什么不同？ 3. React 组件中怎么做事件代理？它的原理是什么？ 4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代 5. 对React-Fiber的理解，它解决了什么问题？ 6. React.Component 和 React.PureComponent 的区别 7. Component, Element, Instance 之间有什么区别和联系？ 8. React.createClass和extends Component的区别有哪些？ 9. React 高阶组件是什么，和普通组件有什么区别，适用什么场景 10. 对componentWillReceiveProps 的理解 11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？ 12. React如何判断什么时候重新渲染组件？ 13. React声明组件有哪几种方法，有什么不同？ 14. 对有状态组件和无状态组件的理解及使用场景 15. 对React中Fragment的理解，它的使用场景是什么？ 16. React如何获取组件对应的DOM元素？ 17. React中可以在render访问refs吗？为什么？ 18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景 19. 在React中如何避免不必要的render？ 20. 对 React-Intl 的理解，它的工作原理？ 21. 对 React context 的理解 22. 为什么React并不推荐优先考虑使用Context？ 23. React中什么是受控组件和非控组件？ 24. React中refs的作用是什么？有哪些应用场景？ 25. 类组件与函数组件有什么异同？ 26. React组件的构造函数有什么作用？它是必须的吗？ 27. React.forwardRef是什么？它有什么作用？",
      "content": "# 1. React 事件机制\n\n<div onClick={this.handleClick.bind(this)}>点我</div>\n\n\nReact并不是将click事件绑定到了div的真实DOM上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组件挂在销毁时统一订阅和移除事件。\n\n除此之外，冒泡到document上的事件也不是原生的浏览器事件，而是由react自己实现的合成事件（SyntheticEvent）。因此如果不想要是事件冒泡的话应该调用event.preventDefault()方法，而不是调用event.stopProppagation()方法。 JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 document 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。\n\n另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。\n\n实现合成事件的目的如下：\n\n * 合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力；\n * 对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。\n\n\n# 2. React的事件和普通的HTML事件有什么不同？\n\n区别：\n\n * 对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；\n * 对于事件函数处理语法，原生事件为字符串，react 事件为函数；\n * react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。\n\n合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：\n\n * 兼容所有浏览器，更好的跨平台；\n * 将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。\n * 方便 react 统一管理和事务机制。\n\n事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。\n\n\n# 3. React 组件中怎么做事件代理？它的原理是什么？\n\nReact基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。\n\n在React底层，主要对合成事件做了两件事：\n\n * 事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。\n * 自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。\n\n\n# 4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代\n\n这三者是目前react解决代码复用的主要方式：\n\n * 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。\n * render props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。\n * 通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 renderltem 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。\n\n（1）HOC 官方解释∶\n\n> 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。\n\n简言之，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。\n\n// hoc的定义\nfunction withSubscription(WrappedComponent, selectData) {\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        data: selectData(DataSource, props)\n      };\n    }\n    // 一些通用的逻辑处理\n    render() {\n      // ... 并使用新数据渲染被包装的组件!\n      return <WrappedComponent data={this.state.data} {...this.props} />;\n    }\n  };\n\n// 使用\nconst BlogPostWithSubscription = withSubscription(BlogPost,\n  (DataSource, props) => DataSource.getBlogPost(props.id));\n\n\nHOC的优缺点∶\n\n * 优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。\n * 缺点∶ hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖\n\n（2）Render props 官方解释∶\n\n> \"render prop\"是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术\n\n具有render prop 的组件接受一个返回React元素的函数，将render的渲染逻辑注入到组件内部。在这里，\"render\"的命名可以是任何其他有效的标识符。\n\n// DataProvider组件内部的渲染逻辑如下\nclass DataProvider extends React.Components {\n     state = {\n    name: 'Tom'\n  }\n\n    render() {\n    return (\n        <div>\n          <p>共享数据组件自己内部的渲染逻辑</p>\n          { this.props.render(this.state) }\n      </div>\n    );\n  }\n}\n\n// 调用方式\n<DataProvider render={data => (\n  <h1>Hello {data.name}</h1>\n)}/>\n\n\n\n由此可以看到，render props的优缺点也很明显∶\n\n * 优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。\n * 缺点：无法在 return 语句外访问数据、嵌套写法不够优雅\n\n（3）Hooks 官方解释∶\n\n> Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。通过自定义hook，可以复用代码逻辑。\n\n// 自定义一个获取订阅数据的hook\nfunction useSubscription() {\n  const data = DataSource.getComments();\n  return [data];\n}\n// \nfunction CommentList(props) {\n  const {data} = props;\n  const [subData] = useSubscription();\n    ...\n}\n// 使用\n<CommentList data='hello' />\n\n\n以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题。hook的优点如下∶\n\n * 使用直观；\n * 解决hoc的prop 重名问题；\n * 解决render props 因共享数据 而出现嵌套地狱的问题；\n * 能在return之外使用数据的问题。\n\n需要注意的是：hook只能在组件顶层使用，不可在分支语句中使用。\n\n总结∶ Hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。\n\n\n# 5. 对React-Fiber的理解，它解决了什么问题？\n\nReact V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，导致用户感觉到卡顿。\n\n为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。\n\n所以 React 通过Fiber 架构，让这个执行过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:\n\n * 分批延时对DOM进行操作，避免一次性操作大量 DOM 节点，可以得到更好的用户体验；\n * 给浏览器一点喘息的机会，它会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。\n\n核心思想: Fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。\n\n\n# 6. React.Component 和 React.PureComponent 的区别\n\nPureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。\n\n在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。\n\n不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。\n\n使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。\n\n\n# 7. Component, Element, Instance 之间有什么区别和联系？\n\n * 元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。\n * 组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。\n * 实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。\n\n函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。\n\n\n# 8. React.createClass和extends Component的区别有哪些？\n\nReact.createClass和extends Component的bai区别主要在于：\n\n（1）语法区别\n\n * createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。\n * createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。\n\n（2）propType 和 getDefaultProps\n\n * React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.\n * React.Component：通过设置两个属性propTypes和defaultProps\n\n（3）状态的区别\n\n * React.createClass：通过getInitialState()方法返回一个包含初始值的对象\n * React.Component：通过constructor设置初始状态\n\n（4）this区别\n\n * React.createClass：会正确绑定this\n * React.Component：由于使用了 ES6，这里会有些微不同，属性并不会自动绑定到 React 类的实例上。\n\n（5）Mixins\n\n * React.createClass：使用 React.createClass 的话，可以在创建组件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组的形式赋给 mixins。\n * 如果使用 ES6 的方式来创建组件，那么 React mixins 的特性将不能被使用了。\n\n\n# 9. React 高阶组件是什么，和普通组件有什么区别，适用什么场景\n\n官方解释∶\n\n> 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。\n\n高阶组件（HOC）就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种组件的设计模式，这种设计模式是由react自身的组合性质必然产生的。我们将它们称为纯组件，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。\n\n// hoc的定义\nfunction withSubscription(WrappedComponent, selectData) {\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        data: selectData(DataSource, props)\n      };\n    }\n    // 一些通用的逻辑处理\n    render() {\n      // ... 并使用新数据渲染被包装的组件!\n      return <WrappedComponent data={this.state.data} {...this.props} />;\n    }\n  };\n\n// 使用\nconst BlogPostWithSubscription = withSubscription(BlogPost,\n  (DataSource, props) => DataSource.getBlogPost(props.id));\n\n\n1）HOC的优缺点\n\n * 优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。\n * 缺点∶hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖\n\n2）适用场景\n\n * 代码复用，逻辑抽象\n * 渲染劫持\n * State 抽象和更改\n * Props 更改\n\n3）具体应用例子\n\n * 权限控制： 利用高阶组件的 条件渲染 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别和 页面元素级别\n\n// HOC.js\nfunction withAdminAuth(WrappedComponent) {\n    return class extends React.Component {\n        state = {\n            isAdmin: false,\n        }\n        async UNSAFE_componentWillMount() {\n            const currentRole = await getCurrentUserRole();\n            this.setState({\n                isAdmin: currentRole === 'Admin',\n            });\n        }\n        render() {\n            if (this.state.isAdmin) {\n                return <WrappedComponent {...this.props} />;\n            } else {\n                return (<div>您没有权限查看该页面，请联系管理员！</div>);\n            }\n        }\n    };\n}\n\n// pages/page-a.js\nclass PageA extends React.Component {\n    constructor(props) {\n        super(props);\n        // something here...\n    }\n    UNSAFE_componentWillMount() {\n        // fetching data\n    }\n    render() {\n        // render page with data\n    }\n}\nexport default withAdminAuth(PageA);\n\n\n// pages/page-b.js\nclass PageB extends React.Component {\n    constructor(props) {\n        super(props);\n    // something here...\n        }\n    UNSAFE_componentWillMount() {\n    // fetching data\n    }\n    render() {\n    // render page with data\n    }\n}\nexport default withAdminAuth(PageB);\n\n\n * 组件渲染性能追踪： 借助父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录∶\n\nclass Home extends React.Component {\n        render() {\n            return (<h1>Hello World.</h1>);\n        }\n    }\n    function withTiming(WrappedComponent) {\n        return class extends WrappedComponent {\n            constructor(props) {\n                super(props);\n                this.start = 0;\n                this.end = 0;\n            }\n            UNSAFE_componentWillMount() {\n                super.componentWillMount && super.componentWillMount();\n                this.start = Date.now();\n            }\n            componentDidMount() {\n                super.componentDidMount && super.componentDidMount();\n                this.end = Date.now();\n                console.log(`${WrappedComponent.name} 组件渲染时间为 ${this.end - this.start} ms`);\n            }\n            render() {\n                return super.render();\n            }\n        };\n    }\n\n    export default withTiming(Home);   \n\n\n\n\n注意：withTiming 是利用 反向继承 实现的一个高阶组件，功能是计算被包裹组件（这里是 Home 组件）的渲染时间。\n\n * 页面复用\n\nconst withFetching = fetching => WrappedComponent => {\n    return class extends React.Component {\n        state = {\n            data: [],\n        }\n        async UNSAFE_componentWillMount() {\n            const data = await fetching();\n            this.setState({\n                data,\n            });\n        }\n        render() {\n            return <WrappedComponent data={this.state.data} {...this.props} />;\n        }\n    }\n}\n\n// pages/page-a.js\nexport default withFetching(fetching('science-fiction'))(MovieList);\n// pages/page-b.js\nexport default withFetching(fetching('action'))(MovieList);\n// pages/page-other.js\nexport default withFetching(fetching('some-other-type'))(MovieList);\n\n\n\n# 10. 对componentWillReceiveProps 的理解\n\n该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。\n\n使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。\n\ncomponentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。\n\n\n# 11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？\n\n（1）哪些方法会触发 react 重新渲染?\n\n * setState（）方法被调用\n\nsetState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。\n\nclass App extends React.Component {\n  state = {\n    a: 1\n  };\n\n  render() {\n    console.log(\"render\");\n    return (\n      <React.Fragement>\n        <p>{this.state.a}</p>\n        <button\n          onClick={() => {\n            this.setState({ a: 1 }); // 这里并没有改变 a 的值\n          }}\n        >\n          Click me\n        </button>\n        <button onClick={() => this.setState(null)}>setState null</button>\n        <Child />\n      </React.Fragement>\n    );\n  }\n}\n\n\n * 父组件重新渲染\n\n只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render\n\n（2）重新渲染 render 会做些什么?\n\n * 会对新旧 VNode 进行对比，也就是我们所说的Diff算法。\n * 对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面\n * 遍历差异对象，根据差异的类型，根据对应对规则更新VNode\n\nReact 的处理 render 的基本思维模式是每次一有变动就会去重新渲染整个应用。在 Virtual DOM 没有出现之前，最简单的方法就是直接调用 innerHTML。Virtual DOM厉害的地方并不是说它比直接操作 DOM 快，而是说不管数据怎么变，都会尽量以最小的代价去更新 DOM。React 将 render 函数返回的虚拟 DOM 树与老的进行比较，从而确定 DOM 要不要更新、怎么更新。当 DOM 树很大时，遍历两棵树进行各种比对还是相当耗性能的，特别是在顶层 setState 一个微小的修改，默认会去遍历整棵树。尽管 React 使用高度优化的 Diff 算法，但是这个过程仍然会损耗性能.\n\n\n# 12. React如何判断什么时候重新渲染组件？\n\n组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的shouldComponentUpdate方法默认返回true，这就是导致每次更新都重新渲染的原因。\n\n当React将要渲染组件时会执行shouldComponentUpdate方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写shouldComponentUpdate方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。\n\n\n# 13. React声明组件有哪几种方法，有什么不同？\n\nReact 声明组件的三种方式：\n\n * 函数式定义的无状态组件\n * ES5原生方式React.createClass定义的组件\n * ES6形式的extends React.Component定义的组件\n\n（1）无状态函数式组件 它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到state状态的操作 组件不会被实例化，整体渲染性能得到提升，不能访问this对象，不能访问生命周期的方法\n\n（2）ES5 原生方式 React.createClass // RFC React.createClass会自绑定函数方法，导致不必要的性能开销，增加代码过时的可能性。\n\n（3）E6继承形式 React.Component // RCC 目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用。\n\n无状态组件相对于于后者的区别： 与无状态组件相比，React.createClass和React.Component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。\n\nReact.createClass与React.Component区别：\n\n① 函数this自绑定\n\n * React.createClass创建的组件，其每一个成员函数的this都有React自动绑定，函数中的this会被正确设置。\n * React.Component创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。\n\n② 组件属性类型propTypes及其默认props属性defaultProps配置不同\n\n * React.createClass在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置，其中defaultProps是使用getDefaultProps的方法来获取默认组件属性的\n * React.Component在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。\n\n③ 组件初始状态state的配置不同\n\n * React.createClass创建的组件，其状态state是通过getInitialState方法来配置组件相关的状态；\n * React.Component创建的组件，其状态state是在constructor中像初始化组件属性一样声明的。\n\n\n# 14. 对有状态组件和无状态组件的理解及使用场景\n\n（1）有状态组件\n\n特点：\n\n * 是类组件\n * 有继承\n * 可以使用this\n * 可以使用react的生命周期\n * 使用较多，容易频繁触发生命周期钩子函数，影响性能\n * 内部使用 state，维护自身状态的变化，有状态组件根据外部组件传入的 props 和自身的 state进行渲染。\n\n使用场景：\n\n * 需要使用到状态的。\n * 需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可实现）\n\n总结： 类组件可以维护自身的状态变量，即组件的 state ，类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件则既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可称为无状态组件。\n\n（2）无状态组件 特点：\n\n * 不依赖自身的状态state\n * 可以是类组件或者函数组件。\n * 可以完全避免使用 this 关键字。（由于使用的是箭头函数事件无需绑定）\n * 有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件\n * 组件内部不维护 state ，只根据外部组件传入的 props 进行渲染的组件，当 props 改变时，组件重新渲染。\n\n使用场景：\n\n * 组件不需要管理 state，纯展示\n\n优点：\n\n * 简化代码、专注于 render\n * 组件不需要被实例化，无生命周期，提升性能。 输出（渲染）只取决于输入（属性），无副作用\n * 视图和数据的解耦分离\n\n缺点：\n\n * 无法使用 ref\n * 无生命周期方法\n * 无法控制组件的重渲染，因为无法使用shouldComponentUpdate 方法，当组件接受到新的属性时则会重渲染\n\n总结： 组件内部状态且与外部无关的组件，可以考虑用状态组件，这样状态树就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。比如自定义的 <Button/>、 <Input /> 等组件。\n\n\n# 15. 对React中Fragment的理解，它的使用场景是什么？\n\n在React中，组件返回的元素只能有一个根元素。为了不添加多余的DOM节点，我们可以使用Fragment标签来包裹所有的元素，Fragment标签不会渲染出任何元素。React官方对Fragment的解释：\n\n> React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。\n\nimport React, { Component, Fragment } from 'react'\n\n// 一般形式\nrender() {\n  return (\n    <React.Fragment>\n      <ChildA />\n      <ChildB />\n      <ChildC />\n    </React.Fragment>\n  );\n}\n// 也可以写成以下形式\nrender() {\n  return (\n    <>\n      <ChildA />\n      <ChildB />\n      <ChildC />\n    </>\n  );\n}\n\n\n\n# 16. React如何获取组件对应的DOM元素？\n\n可以用ref来获取某个子节点的实例，然后通过当前class组件实例的一些特定属性来直接获取子节点实例。ref有三种实现方法:\n\n * 字符串格式：字符串格式，这是React16版本之前用得最多的，例如：<p ref=\"info\">span</p>\n * 函数格式：ref对应一个方法，该方法有一个参数，也就是对应的节点实例，例如：<p ref={ele => this.info = ele}></p>\n * createRef方法：React 16提供的一个API，使用React.createRef()来实现\n\n\n# 17. React中可以在render访问refs吗？为什么？\n\n<>\n  <span id=\"name\" ref={this.spanRef}>{this.state.title}</span>\n  <span>{\n     this.spanRef.current ? '有值' : '无值'\n  }</span>\n</>\n\n\n不可以，render 阶段 DOM 还没有生成，无法获取 DOM。DOM 的获取需要在 pre-commit 阶段和 commit 阶段：\n\n\n# 18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景\n\nReact 官方对 Portals 的定义：\n\n> Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案\n\nPortals 是React 16提供的官方解决方案，使得组件可以脱离父组件层级挂载在DOM树的任何位置。通俗来讲，就是我们 render 一个组件，但这个组件的 DOM 结构并不在本组件内。\n\nPortals语法如下：\n\nReactDOM.createPortal(child, container);\n\n\n * 第一个参数 child 是可渲染的 React 子项，比如元素，字符串或者片段等;\n * 第二个参数 container 是一个 DOM 元素。\n\n一般情况下，组件的render函数返回的元素会被挂载在它的父级组件上：\n\nimport DemoComponent from './DemoComponent';\nrender() {\n  // DemoComponent元素会被挂载在id为parent的div的元素上\n  return (\n    <div id=\"parent\">\n        <DemoComponent />\n    </div>\n  );\n}\n\n\n然而，有些元素需要被挂载在更高层级的位置。最典型的应用场景：当父组件具有overflow: hidden或者z-index的样式设置时，组件有可能被其他元素遮挡，这时就可以考虑要不要使用Portal使组件的挂载脱离父组件。例如：对话框，模态窗。\n\nimport DemoComponent from './DemoComponent';\nrender() {\n  // DemoComponent元素会被挂载在id为parent的div的元素上\n  return (\n    <div id=\"parent\">\n        <DemoComponent />\n    </div>\n  );\n}\n\n\n\n# 19. 在React中如何避免不必要的render？\n\nReact 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点：\n\n * shouldComponentUpdate 和 PureComponent\n\n在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。\n\n * 利用高阶组件\n\n在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能\n\n * 使用 React.memo\n\nReact.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。\n\n\n# 20. 对 React-Intl 的理解，它的工作原理？\n\nReact-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。\n\nReact-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。\n\n在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。\n\n\n# 21. 对 React context 的理解\n\n在React中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递显然，这样做太繁琐了。\n\nContext 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。\n\n可以把context当做是特定一个组件树内共享的store，用来做数据传递。简单说就是，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。\n\nJS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数。\n\n假如以JS的作用域链作为类比，React组件提供的Context对象其实就好比一个提供给子组件访问的作用域，而 Context对象的属性可以看成作用域上的活动对象。由于组件 的 Context 由其父节点链上所有组件通 过 getChildContext（）返回的Context对象组合而成，所以，组件通过Context是可以访问到其父组件链上所有节点组件提供的Context的属性。\n\n\n# 22. 为什么React并不推荐优先考虑使用Context？\n\n * Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。\n * 尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context\n * 对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。\n * context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注\n\n\n# 23. React中什么是受控组件和非控组件？\n\n（1）受控组件 在使用表单来收集用户输入时，例如<input><select><textearea>等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onChange事件，更新组件的state。这种组件在React中被称为受控组件，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。\n\n受控组件更新state的流程：\n\n * 可以通过初始state中设置表单的默认值\n * 每当表单的值发生变化时，调用onChange事件处理器\n * 事件处理器通过事件对象e拿到改变后的状态，并更新组件的state\n * 一旦通过setState方法更新state，就会触发视图的重新渲染，完成表单组件的更新\n\n受控组件缺陷： 表单元素的值都是由React组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。\n\n（2）非受控组件 如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从DOM获得表单值。而不是为每个状态更新编写一个事件处理程序。\n\nReact官方的解释：\n\n> 要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以使用 ref来从 DOM 节点中获取表单数据。 因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。\n\n例如，下面的代码在非受控组件中接收单个属性：\n\nclass NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n  handleSubmit(event) {\n    alert('A name was submitted: ' + this.input.value);\n    event.preventDefault();\n  }\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" ref={(input) => this.input = input} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n\n\n总结： 页面中所有输入类的DOM如果是现用现取的称为非受控组件，而通过setState将输入的值维护到了state中，需要时再从state中取出，这里的数据就受到了state的控制，称为受控组件。\n\n\n# 24. React中refs的作用是什么？有哪些应用场景？\n\nRefs 提供了一种方式，用于访问在 render 方法中创建的 React 元素或 DOM 节点。Refs 应该谨慎使用，如下场景使用 Refs 比较适合：\n\n * 处理焦点、文本选择或者媒体的控制\n * 触发必要的动画\n * 集成第三方 DOM 库\n\nRefs 是使用 React.createRef() 方法创建的，他通过 ref 属性附加到 React 元素上。要在整个组件中使用 Refs，需要将 ref 在构造函数中分配给其实例属性：\n\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.myRef = React.createRef()\n  }\n  render() {\n    return <div ref={this.myRef} />\n  }\n}\n\n\n由于函数组件没有实例，因此不能在函数组件上直接使用 ref：\n\nfunction MyFunctionalComponent() {\n  return <input />;\n}\nclass Parent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.textInput = React.createRef();\n  }\n  render() {\n    // 这将不会工作！\n    return (\n      <MyFunctionalComponent ref={this.textInput} />\n    );\n  }\n}\n\n\n但可以通过闭合的帮助在函数组件内部进行使用 Refs：\n\nfunction CustomTextInput(props) {\n  // 这里必须声明 textInput，这样 ref 回调才可以引用它\n  let textInput = null;\n  function handleClick() {\n    textInput.focus();\n  }\n  return (\n    <div>\n      <input\n        type=\"text\"\n        ref={(input) => { textInput = input; }} />\n      <input\n        type=\"button\"\n        value=\"Focus the text input\"\n        onClick={handleClick}\n      />\n    </div>\n  );  \n}\n\n\n注意：\n\n * 不应该过度的使用 Refs\n\n * ref\n   \n   \n   的返回值取决于节点的类型：\n   \n   * 当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为他的 current 属性以创建 ref。\n   * 当 ref 属性被用于一个自定义的类组件时，ref 对象将接收该组件已挂载的实例作为他的 current。\n\n * 当在父组件中需要访问子组件中的 ref 时可使用传递 Refs 或回调 Refs。\n\n\n# 25. 类组件与函数组件有什么异同？\n\n相同点： 组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。\n\n我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。\n\n不同点：\n\n * 它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。\n * 之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。\n * 性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。\n * 从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。\n * 类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。\n\n\n# 26. React组件的构造函数有什么作用？它是必须的吗？\n\n构造函数主要用于两个目的：\n\n * 通过将对象分配给this.state来初始化本地状态\n * 将事件处理程序方法绑定到实例上\n\n所以，当在React class中需要设置state的初始值或者绑定事件时，需要加上构造函数，官方Demo：\n\nclass LikeButton extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      liked: false\n    };\n    this.handleClick = this.handleClick.bind(this);\n  }\n  handleClick() {\n    this.setState({liked: !this.state.liked});\n  }\n  render() {\n    const text = this.state.liked ? 'liked' : 'haven liked';\n    return (\n      <div onClick={this.handleClick}>\n        You {text} this. Click to toggle.\n      </div>\n    );\n  }\n}\nReactDOM.render(\n  <LikeButton />,\n  document.getElementById('example')\n);\n\n\n构造函数用来新建父类的this对象；子类必须在constructor方法中调用super方法；否则新建实例时会报错；因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法；子类就得不到this对象。\n\n注意：\n\n * constructor () 必须配上 super(), 如果要在constructor 内部使用 this.props 就要 传入props , 否则不用\n * JavaScript中的 bind 每次都会返回一个新的函数, 为了性能等考虑, 尽量在constructor中绑定事件\n\n\n# 27. React.forwardRef是什么？它有什么作用？\n\nReact.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：\n\n * 转发 refs 到 DOM 组件\n * 在高阶组件中转发 refs",
      "normalizedContent": "# 1. react 事件机制\n\n<div onclick={this.handleclick.bind(this)}>点我</div>\n\n\nreact并不是将click事件绑定到了div的真实dom上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，react将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组件挂在销毁时统一订阅和移除事件。\n\n除此之外，冒泡到document上的事件也不是原生的浏览器事件，而是由react自己实现的合成事件（syntheticevent）。因此如果不想要是事件冒泡的话应该调用event.preventdefault()方法，而不是调用event.stopproppagation()方法。 jsx 上写的事件并没有绑定在对应的真实 dom 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 document 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。\n\n另外冒泡到 document 上的事件也不是原生浏览器事件，而是 react 自己实现的合成事件（syntheticevent）。因此我们如果不想要事件冒泡的话，调用 event.stoppropagation 是无效的，而应该调用 event.preventdefault。\n\n实现合成事件的目的如下：\n\n * 合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力；\n * 对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。\n\n\n# 2. react的事件和普通的html事件有什么不同？\n\n区别：\n\n * 对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；\n * 对于事件函数处理语法，原生事件为字符串，react 事件为函数；\n * react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventdefault()来阻止默认行为。\n\n合成事件是 react 模拟原生 dom 事件所有能力的一个事件对象，其优点如下：\n\n * 兼容所有浏览器，更好的跨平台；\n * 将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。\n * 方便 react 统一管理和事务机制。\n\n事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。\n\n\n# 3. react 组件中怎么做事件代理？它的原理是什么？\n\nreact基于virtual dom实现了一个syntheticevent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合w3c标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。\n\n在react底层，主要对合成事件做了两件事：\n\n * 事件委派： react会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。\n * 自动绑定： react组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。\n\n\n# 4. react 高阶组件、render props、hooks 有什么区别，为什么要不断迭代\n\n这三者是目前react解决代码复用的主要方式：\n\n * 高阶组件（hoc）是 react 中用于复用组件逻辑的一种高级技巧。hoc 自身不是 react api 的一部分，它是一种基于 react 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。\n * render props是指一种在 react 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。\n * 通常，render props 和高阶组件只渲染一个子节点。让 hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 renderltem 属性，或是一个可见的容器组件或许会有它自己的 dom 结构）。但在大部分场景下，hook 足够了，并且能够帮助减少嵌套。\n\n（1）hoc 官方解释∶\n\n> 高阶组件（hoc）是 react 中用于复用组件逻辑的一种高级技巧。hoc 自身不是 react api 的一部分，它是一种基于 react 的组合特性而形成的设计模式。\n\n简言之，hoc是一种组件的设计模式，hoc接受一个组件和额外的参数（如果需要），返回一个新的组件。hoc 是纯函数，没有副作用。\n\n// hoc的定义\nfunction withsubscription(wrappedcomponent, selectdata) {\n  return class extends react.component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        data: selectdata(datasource, props)\n      };\n    }\n    // 一些通用的逻辑处理\n    render() {\n      // ... 并使用新数据渲染被包装的组件!\n      return <wrappedcomponent data={this.state.data} {...this.props} />;\n    }\n  };\n\n// 使用\nconst blogpostwithsubscription = withsubscription(blogpost,\n  (datasource, props) => datasource.getblogpost(props.id));\n\n\nhoc的优缺点∶\n\n * 优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。\n * 缺点∶ hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖\n\n（2）render props 官方解释∶\n\n> \"render prop\"是指一种在 react 组件之间使用一个值为函数的 prop 共享代码的简单技术\n\n具有render prop 的组件接受一个返回react元素的函数，将render的渲染逻辑注入到组件内部。在这里，\"render\"的命名可以是任何其他有效的标识符。\n\n// dataprovider组件内部的渲染逻辑如下\nclass dataprovider extends react.components {\n     state = {\n    name: 'tom'\n  }\n\n    render() {\n    return (\n        <div>\n          <p>共享数据组件自己内部的渲染逻辑</p>\n          { this.props.render(this.state) }\n      </div>\n    );\n  }\n}\n\n// 调用方式\n<dataprovider render={data => (\n  <h1>hello {data.name}</h1>\n)}/>\n\n\n\n由此可以看到，render props的优缺点也很明显∶\n\n * 优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。\n * 缺点：无法在 return 语句外访问数据、嵌套写法不够优雅\n\n（3）hooks 官方解释∶\n\n> hook是 react 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 react 特性。通过自定义hook，可以复用代码逻辑。\n\n// 自定义一个获取订阅数据的hook\nfunction usesubscription() {\n  const data = datasource.getcomments();\n  return [data];\n}\n// \nfunction commentlist(props) {\n  const {data} = props;\n  const [subdata] = usesubscription();\n    ...\n}\n// 使用\n<commentlist data='hello' />\n\n\n以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题。hook的优点如下∶\n\n * 使用直观；\n * 解决hoc的prop 重名问题；\n * 解决render props 因共享数据 而出现嵌套地狱的问题；\n * 能在return之外使用数据的问题。\n\n需要注意的是：hook只能在组件顶层使用，不可在分支语句中使用。\n\n总结∶ hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的api，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。\n\n\n# 5. 对react-fiber的理解，它解决了什么问题？\n\nreact v15 在渲染时，会递归比对 virtualdom 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， react 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，导致用户感觉到卡顿。\n\n为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 html 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 cpu 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。\n\n所以 react 通过fiber 架构，让这个执行过程变成可被中断。“适时”地让出 cpu 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:\n\n * 分批延时对dom进行操作，避免一次性操作大量 dom 节点，可以得到更好的用户体验；\n * 给浏览器一点喘息的机会，它会对代码进行编译优化（jit）及进行热代码优化，或者对 reflow 进行修正。\n\n核心思想: fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 cpu 的执行权，让 cpu 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。\n\n\n# 6. react.component 和 react.purecomponent 的区别\n\npurecomponent表示一个纯组件，可以用来优化react程序，减少render函数执行的次数，从而提高组件的性能。\n\n在react中，当prop或者state发生变化时，可以通过在shouldcomponentupdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。react.purecomponent会自动执行 shouldcomponentupdate。\n\n不过，purecomponent中的 shouldcomponentupdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。purecomponent一般会用在一些纯展示组件上。\n\n使用purecomponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟dom的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。\n\n\n# 7. component, element, instance 之间有什么区别和联系？\n\n * 元素： 一个元素element是一个普通对象(plain object)，描述了对于一个dom节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个react元素element成本很低。元素element创建之后是不可变的。\n * 组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。\n * 实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。\n\n函数式组件(functional component)根本没有实例instance。类组件(class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为react帮我们做了这些。\n\n\n# 8. react.createclass和extends component的区别有哪些？\n\nreact.createclass和extends component的bai区别主要在于：\n\n（1）语法区别\n\n * createclass本质上是一个工厂函数，extends的方式更加接近最新的es6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。\n * createclass方式的方法定义使用逗号，隔开，因为creatclass本质上是一个函数，传递给它的是一个object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是es6 class的语法规范。\n\n（2）proptype 和 getdefaultprops\n\n * react.createclass：通过protypes对象和getdefaultprops()方法来设置和获取props.\n * react.component：通过设置两个属性proptypes和defaultprops\n\n（3）状态的区别\n\n * react.createclass：通过getinitialstate()方法返回一个包含初始值的对象\n * react.component：通过constructor设置初始状态\n\n（4）this区别\n\n * react.createclass：会正确绑定this\n * react.component：由于使用了 es6，这里会有些微不同，属性并不会自动绑定到 react 类的实例上。\n\n（5）mixins\n\n * react.createclass：使用 react.createclass 的话，可以在创建组件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组的形式赋给 mixins。\n * 如果使用 es6 的方式来创建组件，那么 react mixins 的特性将不能被使用了。\n\n\n# 9. react 高阶组件是什么，和普通组件有什么区别，适用什么场景\n\n官方解释∶\n\n> 高阶组件（hoc）是 react 中用于复用组件逻辑的一种高级技巧。hoc 自身不是 react api 的一部分，它是一种基于 react 的组合特性而形成的设计模式。\n\n高阶组件（hoc）就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种组件的设计模式，这种设计模式是由react自身的组合性质必然产生的。我们将它们称为纯组件，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。\n\n// hoc的定义\nfunction withsubscription(wrappedcomponent, selectdata) {\n  return class extends react.component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        data: selectdata(datasource, props)\n      };\n    }\n    // 一些通用的逻辑处理\n    render() {\n      // ... 并使用新数据渲染被包装的组件!\n      return <wrappedcomponent data={this.state.data} {...this.props} />;\n    }\n  };\n\n// 使用\nconst blogpostwithsubscription = withsubscription(blogpost,\n  (datasource, props) => datasource.getblogpost(props.id));\n\n\n1）hoc的优缺点\n\n * 优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。\n * 缺点∶hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖\n\n2）适用场景\n\n * 代码复用，逻辑抽象\n * 渲染劫持\n * state 抽象和更改\n * props 更改\n\n3）具体应用例子\n\n * 权限控制： 利用高阶组件的 条件渲染 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别和 页面元素级别\n\n// hoc.js\nfunction withadminauth(wrappedcomponent) {\n    return class extends react.component {\n        state = {\n            isadmin: false,\n        }\n        async unsafe_componentwillmount() {\n            const currentrole = await getcurrentuserrole();\n            this.setstate({\n                isadmin: currentrole === 'admin',\n            });\n        }\n        render() {\n            if (this.state.isadmin) {\n                return <wrappedcomponent {...this.props} />;\n            } else {\n                return (<div>您没有权限查看该页面，请联系管理员！</div>);\n            }\n        }\n    };\n}\n\n// pages/page-a.js\nclass pagea extends react.component {\n    constructor(props) {\n        super(props);\n        // something here...\n    }\n    unsafe_componentwillmount() {\n        // fetching data\n    }\n    render() {\n        // render page with data\n    }\n}\nexport default withadminauth(pagea);\n\n\n// pages/page-b.js\nclass pageb extends react.component {\n    constructor(props) {\n        super(props);\n    // something here...\n        }\n    unsafe_componentwillmount() {\n    // fetching data\n    }\n    render() {\n    // render page with data\n    }\n}\nexport default withadminauth(pageb);\n\n\n * 组件渲染性能追踪： 借助父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录∶\n\nclass home extends react.component {\n        render() {\n            return (<h1>hello world.</h1>);\n        }\n    }\n    function withtiming(wrappedcomponent) {\n        return class extends wrappedcomponent {\n            constructor(props) {\n                super(props);\n                this.start = 0;\n                this.end = 0;\n            }\n            unsafe_componentwillmount() {\n                super.componentwillmount && super.componentwillmount();\n                this.start = date.now();\n            }\n            componentdidmount() {\n                super.componentdidmount && super.componentdidmount();\n                this.end = date.now();\n                console.log(`${wrappedcomponent.name} 组件渲染时间为 ${this.end - this.start} ms`);\n            }\n            render() {\n                return super.render();\n            }\n        };\n    }\n\n    export default withtiming(home);   \n\n\n\n\n注意：withtiming 是利用 反向继承 实现的一个高阶组件，功能是计算被包裹组件（这里是 home 组件）的渲染时间。\n\n * 页面复用\n\nconst withfetching = fetching => wrappedcomponent => {\n    return class extends react.component {\n        state = {\n            data: [],\n        }\n        async unsafe_componentwillmount() {\n            const data = await fetching();\n            this.setstate({\n                data,\n            });\n        }\n        render() {\n            return <wrappedcomponent data={this.state.data} {...this.props} />;\n        }\n    }\n}\n\n// pages/page-a.js\nexport default withfetching(fetching('science-fiction'))(movielist);\n// pages/page-b.js\nexport default withfetching(fetching('action'))(movielist);\n// pages/page-other.js\nexport default withfetching(fetching('some-other-type'))(movielist);\n\n\n\n# 10. 对componentwillreceiveprops 的理解\n\n该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setstate()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。\n\n使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentwillreceiveprops(nextprops)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。\n\ncomponentwillreceiveprops在初始化render的时候不会执行，它会在component接受到新的状态(props)时被触发，一般用于父组件状态更新时子组件的重新渲染。\n\n\n# 11. 哪些方法会触发 react 重新渲染？重新渲染 render 会做些什么？\n\n（1）哪些方法会触发 react 重新渲染?\n\n * setstate（）方法被调用\n\nsetstate 是 react 中最常用的命令，通常情况下，执行 setstate 会触发 render。但是这里有个点值得关注，执行 setstate 的时候不一定会重新渲染。当 setstate 传入 null 时，并不会触发 render。\n\nclass app extends react.component {\n  state = {\n    a: 1\n  };\n\n  render() {\n    console.log(\"render\");\n    return (\n      <react.fragement>\n        <p>{this.state.a}</p>\n        <button\n          onclick={() => {\n            this.setstate({ a: 1 }); // 这里并没有改变 a 的值\n          }}\n        >\n          click me\n        </button>\n        <button onclick={() => this.setstate(null)}>setstate null</button>\n        <child />\n      </react.fragement>\n    );\n  }\n}\n\n\n * 父组件重新渲染\n\n只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render\n\n（2）重新渲染 render 会做些什么?\n\n * 会对新旧 vnode 进行对比，也就是我们所说的diff算法。\n * 对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面\n * 遍历差异对象，根据差异的类型，根据对应对规则更新vnode\n\nreact 的处理 render 的基本思维模式是每次一有变动就会去重新渲染整个应用。在 virtual dom 没有出现之前，最简单的方法就是直接调用 innerhtml。virtual dom厉害的地方并不是说它比直接操作 dom 快，而是说不管数据怎么变，都会尽量以最小的代价去更新 dom。react 将 render 函数返回的虚拟 dom 树与老的进行比较，从而确定 dom 要不要更新、怎么更新。当 dom 树很大时，遍历两棵树进行各种比对还是相当耗性能的，特别是在顶层 setstate 一个微小的修改，默认会去遍历整棵树。尽管 react 使用高度优化的 diff 算法，但是这个过程仍然会损耗性能.\n\n\n# 12. react如何判断什么时候重新渲染组件？\n\n组件状态的改变可以因为props的改变，或者直接通过setstate方法改变。组件获得新的状态，然后react决定是否应该重新渲染组件。只要组件的state发生变化，react就会对组件进行重新渲染。这是因为react中的shouldcomponentupdate方法默认返回true，这就是导致每次更新都重新渲染的原因。\n\n当react将要渲染组件时会执行shouldcomponentupdate方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写shouldcomponentupdate方法让它根据情况返回true或者false来告诉react什么时候重新渲染什么时候跳过重新渲染。\n\n\n# 13. react声明组件有哪几种方法，有什么不同？\n\nreact 声明组件的三种方式：\n\n * 函数式定义的无状态组件\n * es5原生方式react.createclass定义的组件\n * es6形式的extends react.component定义的组件\n\n（1）无状态函数式组件 它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到state状态的操作 组件不会被实例化，整体渲染性能得到提升，不能访问this对象，不能访问生命周期的方法\n\n（2）es5 原生方式 react.createclass // rfc react.createclass会自绑定函数方法，导致不必要的性能开销，增加代码过时的可能性。\n\n（3）e6继承形式 react.component // rcc 目前极为推荐的创建有状态组件的方式，最终会取代react.createclass形式；相对于 react.createclass可以更好实现代码复用。\n\n无状态组件相对于于后者的区别： 与无状态组件相比，react.createclass和react.component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。\n\nreact.createclass与react.component区别：\n\n① 函数this自绑定\n\n * react.createclass创建的组件，其每一个成员函数的this都有react自动绑定，函数中的this会被正确设置。\n * react.component创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。\n\n② 组件属性类型proptypes及其默认props属性defaultprops配置不同\n\n * react.createclass在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置，其中defaultprops是使用getdefaultprops的方法来获取默认组件属性的\n * react.component在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。\n\n③ 组件初始状态state的配置不同\n\n * react.createclass创建的组件，其状态state是通过getinitialstate方法来配置组件相关的状态；\n * react.component创建的组件，其状态state是在constructor中像初始化组件属性一样声明的。\n\n\n# 14. 对有状态组件和无状态组件的理解及使用场景\n\n（1）有状态组件\n\n特点：\n\n * 是类组件\n * 有继承\n * 可以使用this\n * 可以使用react的生命周期\n * 使用较多，容易频繁触发生命周期钩子函数，影响性能\n * 内部使用 state，维护自身状态的变化，有状态组件根据外部组件传入的 props 和自身的 state进行渲染。\n\n使用场景：\n\n * 需要使用到状态的。\n * 需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可实现）\n\n总结： 类组件可以维护自身的状态变量，即组件的 state ，类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件则既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可称为无状态组件。\n\n（2）无状态组件 特点：\n\n * 不依赖自身的状态state\n * 可以是类组件或者函数组件。\n * 可以完全避免使用 this 关键字。（由于使用的是箭头函数事件无需绑定）\n * 有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件\n * 组件内部不维护 state ，只根据外部组件传入的 props 进行渲染的组件，当 props 改变时，组件重新渲染。\n\n使用场景：\n\n * 组件不需要管理 state，纯展示\n\n优点：\n\n * 简化代码、专注于 render\n * 组件不需要被实例化，无生命周期，提升性能。 输出（渲染）只取决于输入（属性），无副作用\n * 视图和数据的解耦分离\n\n缺点：\n\n * 无法使用 ref\n * 无生命周期方法\n * 无法控制组件的重渲染，因为无法使用shouldcomponentupdate 方法，当组件接受到新的属性时则会重渲染\n\n总结： 组件内部状态且与外部无关的组件，可以考虑用状态组件，这样状态树就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。比如自定义的 <button/>、 <input /> 等组件。\n\n\n# 15. 对react中fragment的理解，它的使用场景是什么？\n\n在react中，组件返回的元素只能有一个根元素。为了不添加多余的dom节点，我们可以使用fragment标签来包裹所有的元素，fragment标签不会渲染出任何元素。react官方对fragment的解释：\n\n> react 中的一个常见模式是一个组件返回多个元素。fragments 允许你将子列表分组，而无需向 dom 添加额外节点。\n\nimport react, { component, fragment } from 'react'\n\n// 一般形式\nrender() {\n  return (\n    <react.fragment>\n      <childa />\n      <childb />\n      <childc />\n    </react.fragment>\n  );\n}\n// 也可以写成以下形式\nrender() {\n  return (\n    <>\n      <childa />\n      <childb />\n      <childc />\n    </>\n  );\n}\n\n\n\n# 16. react如何获取组件对应的dom元素？\n\n可以用ref来获取某个子节点的实例，然后通过当前class组件实例的一些特定属性来直接获取子节点实例。ref有三种实现方法:\n\n * 字符串格式：字符串格式，这是react16版本之前用得最多的，例如：<p ref=\"info\">span</p>\n * 函数格式：ref对应一个方法，该方法有一个参数，也就是对应的节点实例，例如：<p ref={ele => this.info = ele}></p>\n * createref方法：react 16提供的一个api，使用react.createref()来实现\n\n\n# 17. react中可以在render访问refs吗？为什么？\n\n<>\n  <span id=\"name\" ref={this.spanref}>{this.state.title}</span>\n  <span>{\n     this.spanref.current ? '有值' : '无值'\n  }</span>\n</>\n\n\n不可以，render 阶段 dom 还没有生成，无法获取 dom。dom 的获取需要在 pre-commit 阶段和 commit 阶段：\n\n\n# 18. 对react的插槽(portals)的理解，如何使用，有哪些使用场景\n\nreact 官方对 portals 的定义：\n\n> portal 提供了一种将子节点渲染到存在于父组件以外的 dom 节点的优秀的方案\n\nportals 是react 16提供的官方解决方案，使得组件可以脱离父组件层级挂载在dom树的任何位置。通俗来讲，就是我们 render 一个组件，但这个组件的 dom 结构并不在本组件内。\n\nportals语法如下：\n\nreactdom.createportal(child, container);\n\n\n * 第一个参数 child 是可渲染的 react 子项，比如元素，字符串或者片段等;\n * 第二个参数 container 是一个 dom 元素。\n\n一般情况下，组件的render函数返回的元素会被挂载在它的父级组件上：\n\nimport democomponent from './democomponent';\nrender() {\n  // democomponent元素会被挂载在id为parent的div的元素上\n  return (\n    <div id=\"parent\">\n        <democomponent />\n    </div>\n  );\n}\n\n\n然而，有些元素需要被挂载在更高层级的位置。最典型的应用场景：当父组件具有overflow: hidden或者z-index的样式设置时，组件有可能被其他元素遮挡，这时就可以考虑要不要使用portal使组件的挂载脱离父组件。例如：对话框，模态窗。\n\nimport democomponent from './democomponent';\nrender() {\n  // democomponent元素会被挂载在id为parent的div的元素上\n  return (\n    <div id=\"parent\">\n        <democomponent />\n    </div>\n  );\n}\n\n\n\n# 19. 在react中如何避免不必要的render？\n\nreact 基于虚拟 dom 和高效 diff 算法的完美配合，实现了对 dom 最小粒度的更新。大多数情况下，react 对 dom 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（render）。这里提下优化的点：\n\n * shouldcomponentupdate 和 purecomponent\n\n在 react 类组件中，可以利用 shouldcomponentupdate或者 purecomponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldcomponentupdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。\n\n * 利用高阶组件\n\n在函数组件中，并没有 shouldcomponentupdate 这个生命周期，可以利用高阶组件，封装一个类似 purecomponet 的功能\n\n * 使用 react.memo\n\nreact.memo 是 react 16.6 新的一个 api，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 purecomponent 十分类似，但不同的是， react.memo只能用于函数组件。\n\n\n# 20. 对 react-intl 的理解，它的工作原理？\n\nreact-intl是雅虎的语言国际化开源项目formatjs的一部分，通过其提供的组件和api可以与reactjs绑定。\n\nreact-intl提供了两种使用方法，一种是引用react组件，另一种是直接调取api，官方更加推荐在react项目中使用前者，只有在无法使用react组件的地方，才应该调用框架提供的api。它提供了一系列的react组件，包括数字格式化、字符串格式化、日期格式化等。\n\n在react-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。\n\n\n# 21. 对 react context 的理解\n\n在react中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递显然，这样做太繁琐了。\n\ncontext 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。\n\n可以把context当做是特定一个组件树内共享的store，用来做数据传递。简单说就是，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用context来实现跨层级的组件数据传递。\n\njs的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时js代码块执行期间所能访问的活动对象，包括变量和函数，js程序通过作用域链访问到代码块内部或者外部的变量和函数。\n\n假如以js的作用域链作为类比，react组件提供的context对象其实就好比一个提供给子组件访问的作用域，而 context对象的属性可以看成作用域上的活动对象。由于组件 的 context 由其父节点链上所有组件通 过 getchildcontext（）返回的context对象组合而成，所以，组件通过context是可以访问到其父组件链上所有节点组件提供的context的属性。\n\n\n# 22. 为什么react并不推荐优先考虑使用context？\n\n * context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。\n * 尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context\n * 对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。\n * context的更新需要通过setstate()触发，但是这并不是很可靠的，context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldcomponentupdate() 返回false 那么不能保证context的更新一定可以使用context的子组件，因此，context的可靠性需要关注\n\n\n# 23. react中什么是受控组件和非控组件？\n\n（1）受控组件 在使用表单来收集用户输入时，例如<input><select><textearea>等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onchange事件，更新组件的state。这种组件在react中被称为受控组件，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。\n\n受控组件更新state的流程：\n\n * 可以通过初始state中设置表单的默认值\n * 每当表单的值发生变化时，调用onchange事件处理器\n * 事件处理器通过事件对象e拿到改变后的状态，并更新组件的state\n * 一旦通过setstate方法更新state，就会触发视图的重新渲染，完成表单组件的更新\n\n受控组件缺陷： 表单元素的值都是由react组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。\n\n（2）非受控组件 如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从dom获得表单值。而不是为每个状态更新编写一个事件处理程序。\n\nreact官方的解释：\n\n> 要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以使用 ref来从 dom 节点中获取表单数据。 因为非受控组件将真实数据储存在 dom 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 react 和非 react 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。\n\n例如，下面的代码在非受控组件中接收单个属性：\n\nclass nameform extends react.component {\n  constructor(props) {\n    super(props);\n    this.handlesubmit = this.handlesubmit.bind(this);\n  }\n  handlesubmit(event) {\n    alert('a name was submitted: ' + this.input.value);\n    event.preventdefault();\n  }\n  render() {\n    return (\n      <form onsubmit={this.handlesubmit}>\n        <label>\n          name:\n          <input type=\"text\" ref={(input) => this.input = input} />\n        </label>\n        <input type=\"submit\" value=\"submit\" />\n      </form>\n    );\n  }\n}\n\n\n总结： 页面中所有输入类的dom如果是现用现取的称为非受控组件，而通过setstate将输入的值维护到了state中，需要时再从state中取出，这里的数据就受到了state的控制，称为受控组件。\n\n\n# 24. react中refs的作用是什么？有哪些应用场景？\n\nrefs 提供了一种方式，用于访问在 render 方法中创建的 react 元素或 dom 节点。refs 应该谨慎使用，如下场景使用 refs 比较适合：\n\n * 处理焦点、文本选择或者媒体的控制\n * 触发必要的动画\n * 集成第三方 dom 库\n\nrefs 是使用 react.createref() 方法创建的，他通过 ref 属性附加到 react 元素上。要在整个组件中使用 refs，需要将 ref 在构造函数中分配给其实例属性：\n\nclass mycomponent extends react.component {\n  constructor(props) {\n    super(props)\n    this.myref = react.createref()\n  }\n  render() {\n    return <div ref={this.myref} />\n  }\n}\n\n\n由于函数组件没有实例，因此不能在函数组件上直接使用 ref：\n\nfunction myfunctionalcomponent() {\n  return <input />;\n}\nclass parent extends react.component {\n  constructor(props) {\n    super(props);\n    this.textinput = react.createref();\n  }\n  render() {\n    // 这将不会工作！\n    return (\n      <myfunctionalcomponent ref={this.textinput} />\n    );\n  }\n}\n\n\n但可以通过闭合的帮助在函数组件内部进行使用 refs：\n\nfunction customtextinput(props) {\n  // 这里必须声明 textinput，这样 ref 回调才可以引用它\n  let textinput = null;\n  function handleclick() {\n    textinput.focus();\n  }\n  return (\n    <div>\n      <input\n        type=\"text\"\n        ref={(input) => { textinput = input; }} />\n      <input\n        type=\"button\"\n        value=\"focus the text input\"\n        onclick={handleclick}\n      />\n    </div>\n  );  \n}\n\n\n注意：\n\n * 不应该过度的使用 refs\n\n * ref\n   \n   \n   的返回值取决于节点的类型：\n   \n   * 当 ref 属性被用于一个普通的 html 元素时，react.createref() 将接收底层 dom 元素作为他的 current 属性以创建 ref。\n   * 当 ref 属性被用于一个自定义的类组件时，ref 对象将接收该组件已挂载的实例作为他的 current。\n\n * 当在父组件中需要访问子组件中的 ref 时可使用传递 refs 或回调 refs。\n\n\n# 25. 类组件与函数组件有什么异同？\n\n相同点： 组件是 react 可复用的最小代码片段，它们会返回要在页面中渲染的 react 元素。也正因为组件是 react 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。\n\n我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。\n\n不同点：\n\n * 它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。\n * 之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 react hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。\n * 性能优化上，类组件主要依靠 shouldcomponentupdate 阻断渲染来提升性能，而函数组件依靠 react.memo 缓存渲染结果来提升性能。\n * 从上手程度而言，类组件更容易上手，从未来趋势上看，由于react hooks 的推出，函数组件成了社区未来主推的方案。\n * 类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 react 的未来发展。\n\n\n# 26. react组件的构造函数有什么作用？它是必须的吗？\n\n构造函数主要用于两个目的：\n\n * 通过将对象分配给this.state来初始化本地状态\n * 将事件处理程序方法绑定到实例上\n\n所以，当在react class中需要设置state的初始值或者绑定事件时，需要加上构造函数，官方demo：\n\nclass likebutton extends react.component {\n  constructor() {\n    super();\n    this.state = {\n      liked: false\n    };\n    this.handleclick = this.handleclick.bind(this);\n  }\n  handleclick() {\n    this.setstate({liked: !this.state.liked});\n  }\n  render() {\n    const text = this.state.liked ? 'liked' : 'haven liked';\n    return (\n      <div onclick={this.handleclick}>\n        you {text} this. click to toggle.\n      </div>\n    );\n  }\n}\nreactdom.render(\n  <likebutton />,\n  document.getelementbyid('example')\n);\n\n\n构造函数用来新建父类的this对象；子类必须在constructor方法中调用super方法；否则新建实例时会报错；因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法；子类就得不到this对象。\n\n注意：\n\n * constructor () 必须配上 super(), 如果要在constructor 内部使用 this.props 就要 传入props , 否则不用\n * javascript中的 bind 每次都会返回一个新的函数, 为了性能等考虑, 尽量在constructor中绑定事件\n\n\n# 27. react.forwardref是什么？它有什么作用？\n\nreact.forwardref 会创建一个react组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：\n\n * 转发 refs 到 dom 组件\n * 在高阶组件中转发 refs",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "生命周期",
      "frontmatter": {
        "title": "生命周期",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/frameReactLifeCycle/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/20.react%E7%AF%87/30.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",
      "relativePath": "30.框架篇/20.react篇/30.生命周期.md",
      "key": "v-5fa57737",
      "path": "/pages/frameReactLifeCycle/",
      "headers": [
        {
          "level": 3,
          "title": "1. React的生命周期有哪些？",
          "slug": "_1-react的生命周期有哪些",
          "normalizedTitle": "1. react的生命周期有哪些？",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. React 废弃了哪些生命周期？为什么？",
          "slug": "_2-react-废弃了哪些生命周期-为什么",
          "normalizedTitle": "2. react 废弃了哪些生命周期？为什么？",
          "charIndex": 6193
        },
        {
          "level": 3,
          "title": "3. React 16.X 中 props 改变后在哪个生命周期中处理",
          "slug": "_3-react-16-x-中-props-改变后在哪个生命周期中处理",
          "normalizedTitle": "3. react 16.x 中 props 改变后在哪个生命周期中处理",
          "charIndex": 8779
        },
        {
          "level": 3,
          "title": "4. React 性能优化在哪个生命周期？它优化的原理是什么？",
          "slug": "_4-react-性能优化在哪个生命周期-它优化的原理是什么",
          "normalizedTitle": "4. react 性能优化在哪个生命周期？它优化的原理是什么？",
          "charIndex": 9433
        },
        {
          "level": 3,
          "title": "5. state 和 props 触发更新的生命周期分别有什么区别？",
          "slug": "_5-state-和-props-触发更新的生命周期分别有什么区别",
          "normalizedTitle": "5. state 和 props 触发更新的生命周期分别有什么区别？",
          "charIndex": 10397
        },
        {
          "level": 3,
          "title": "6. React中发起网络请求应该在哪个生命周期中进行？为什么？",
          "slug": "_6-react中发起网络请求应该在哪个生命周期中进行-为什么",
          "normalizedTitle": "6. react中发起网络请求应该在哪个生命周期中进行？为什么？",
          "charIndex": 11556
        },
        {
          "level": 3,
          "title": "7. React 16中新生命周期有哪些",
          "slug": "_7-react-16中新生命周期有哪些",
          "normalizedTitle": "7. react 16中新生命周期有哪些",
          "charIndex": 12584
        }
      ],
      "headersStr": "1. React的生命周期有哪些？ 2. React 废弃了哪些生命周期？为什么？ 3. React 16.X 中 props 改变后在哪个生命周期中处理 4. React 性能优化在哪个生命周期？它优化的原理是什么？ 5. state 和 props 触发更新的生命周期分别有什么区别？ 6. React中发起网络请求应该在哪个生命周期中进行？为什么？ 7. React 16中新生命周期有哪些",
      "content": "# 1. React的生命周期有哪些？\n\nReact 通常将组件生命周期分为三个阶段：\n\n * 装载阶段（Mount），组件第一次在DOM树中被渲染的过程；\n * 更新过程（Update），组件状态发生变化，重新更新渲染的过程；\n * 卸载过程（Unmount），组件从DOM树中被移除的过程；\n\n\n\n# 1）组件挂载阶段\n\n挂载阶段组件被创建，然后组件实例插入到 DOM 中，完成组件的第一次渲染，该过程只会发生一次，在此阶段会依次调用以下这些方法：\n\n * constructor\n * getDerivedStateFromProps\n * render\n * componentDidMount\n\n# （1）constructor\n\n组件的构造函数，第一个被执行，若没有显式定义它，会有一个默认的构造函数，但是若显式定义了构造函数，我们必须在构造函数中执行 super(props)，否则无法在构造函数中拿到this。\n\n如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数Constructor。\n\nconstructor中通常只做两件事：\n\n * 初始化组件的 state\n * 给事件处理方法绑定 this\n\nconstructor(props) {\n  super(props);\n  // 不要在构造函数中调用 setState，可以直接给 state 设置初始值\n  this.state = { counter: 0 }\n  this.handleClick = this.handleClick.bind(this)\n}\n\n\n# （2）getDerivedStateFromProps\n\nstatic getDerivedStateFromProps(props, state)\n\n\n这是个静态方法，所以不能在这个函数里使用 this，有两个参数 props 和 state，分别指接收到的新参数和当前组件的 state 对象，这个函数会返回一个对象用来更新当前的 state 对象，如果不需要更新可以返回 null。\n\n该函数会在装载时，接收到新的 props 或者调用了 setState 和 forceUpdate 时被调用。如当接收到新的属性想修改 state ，就可以使用。\n\n// 当 props.counter 变化时，赋值给 state \nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      counter: 0\n    }\n  }\n  static getDerivedStateFromProps(props, state) {\n    if (props.counter !== state.counter) {\n      return {\n        counter: props.counter\n      }\n    }\n    return null\n  }\n  \n  handleClick = () => {\n    this.setState({\n      counter: this.state.counter + 1\n    })\n  }\n  render() {\n    return (\n      <div>\n        <h1 onClick={this.handleClick}>Hello, world!{this.state.counter}</h1>\n      </div>\n    )\n  }\n}\n\n\n现在可以显式传入 counter ，但是这里有个问题，如果想要通过点击实现 state.counter 的增加，但这时会发现值不会发生任何变化，一直保持 props 传进来的值。这是由于在 React 16.4^ 的版本中 setState 和 forceUpdate 也会触发这个生命周期，所以当组件内部 state 变化后，就会重新走这个方法，同时会把 state 值赋值为 props 的值。因此需要多加一个字段来记录之前的 props 值，这样就会解决上述问题。具体如下：\n\n// 这里只列出需要变化的地方\nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      // 增加一个 preCounter 来记录之前的 props 传来的值\n      preCounter: 0,\n      counter: 0\n    }\n  }\n  static getDerivedStateFromProps(props, state) {\n    // 跟 state.preCounter 进行比较\n    if (props.counter !== state.preCounter) {\n      return {\n        counter: props.counter,\n        preCounter: props.counter\n      }\n    }\n    return null\n  }\n  handleClick = () => {\n    this.setState({\n      counter: this.state.counter + 1\n    })\n  }\n  render() {\n    return (\n      <div>\n        <h1 onClick={this.handleClick}>Hello, world!{this.state.counter}</h1>\n      </div>\n    )\n  }\n}\n\n\n# （3）render\n\nrender是React 中最核心的方法，一个组件中必须要有这个方法，它会根据状态 state 和属性 props 渲染组件。这个函数只做一件事，就是返回需要渲染的内容，所以不要在这个函数内做其他业务逻辑，通常调用该方法会返回以下类型中一个：\n\n * React 元素：这里包括原生的 DOM 以及 React 组件；\n * 数组和 Fragment（片段）：可以返回多个元素；\n * Portals（插槽）：可以将子元素渲染到不同的 DOM 子树种；\n * 字符串和数字：被渲染成 DOM 中的 text 节点；\n * 布尔值或 null：不渲染任何内容。\n\n# （4）componentDidMount()\n\ncomponentDidMount()会在组件挂载后（插入 DOM 树中）立即调。该阶段通常进行以下操作：\n\n * 执行依赖于DOM的操作；\n * 发送网络请求；（官方建议）\n * 添加订阅消息（会在componentWillUnmount取消订阅）；\n\n如果在 componentDidMount 中调用 setState ，就会触发一次额外的渲染，多调用了一次 render 函数，由于它是在浏览器刷新屏幕前执行的，所以用户对此是没有感知的，但是我应当避免这样使用，这样会带来一定的性能问题，尽量是在 constructor 中初始化 state 对象。\n\n在组件装载之后，将计数数字变为1：\n\nclass App extends React.Component  {\n  constructor(props) {\n    super(props)\n    this.state = {\n      counter: 0\n    }\n  }\n  componentDidMount () {\n    this.setState({\n      counter: 1\n    })\n  }\n  render ()  {\n    return (\n      <div className=\"counter\">\n        counter值: { this.state.counter }\n      </div>\n    )\n  }\n}\n\n\n# 2）组件更新阶段\n\n当组件的 props 改变了，或组件内部调用了 setState/forceUpdate，会触发更新重新渲染，这个过程可能会发生多次。这个阶段会依次调用下面这些方法：\n\n * getDerivedStateFromProps\n * shouldComponentUpdate\n * render\n * getSnapshotBeforeUpdate\n * componentDidUpdate\n\n# （1）shouldComponentUpdate\n\nshouldComponentUpdate(nextProps, nextState)\n\n\n在说这个生命周期函数之前，来看两个问题：\n\n * setState 函数在任何情况下都会导致组件重新渲染吗？例如下面这种情况：\n\nthis.setState({number: this.state.number})\n\n\n * 如果没有调用 setState，props 值也没有变化，是不是组件就不会重新渲染？\n\n第一个问题答案是 会 ，第二个问题如果是父组件重新渲染时，不管传入的 props 有没有变化，都会引起子组件的重新渲染。\n\n那么有没有什么方法解决在这两个场景下不让组件重新渲染进而提升性能呢？这个时候 shouldComponentUpdate 登场了，这个生命周期函数是用来提升速度的，它是在重新渲染组件开始前触发的，默认返回 true，可以比较 this.props 和 nextProps ，this.state 和 nextState 值是否变化，来确认返回 true 或者 false。当返回 false 时，组件的更新过程停止，后续的 render、componentDidUpdate 也不会被调用。\n\n注意： 添加 shouldComponentUpdate 方法时，不建议使用深度相等检查（如使用 JSON.stringify()），因为深比较效率很低，可能会比重新渲染组件效率还低。而且该方法维护比较困难，建议使用该方法会产生明显的性能提升时使用。\n\n# （2）getSnapshotBeforeUpdate\n\ngetSnapshotBeforeUpdate(prevProps, prevState)\n\n\n这个方法在 render 之后，componentDidUpdate 之前调用，有两个参数 prevProps 和 prevState，表示更新之前的 props 和 state，这个函数必须要和 componentDidUpdate 一起使用，并且要有一个返回值，默认是 null，这个返回值作为第三个参数传给 componentDidUpdate。\n\n# （3）componentDidUpdate\n\ncomponentDidUpdate() 会在更新后会被立即调用，首次渲染不会执行此方法。 该阶段通常进行以下操作：\n\n * 当组件更新后，对 DOM 进行操作；\n * 如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。\n\ncomponentDidUpdate(prevProps, prevState, snapshot){}\n\n\n该方法有三个参数：\n\n * prevProps: 更新前的props\n * prevState: 更新前的state\n * snapshot: getSnapshotBeforeUpdate()生命周期的返回值\n\n# 3）组件卸载阶段\n\n卸载阶段只有一个生命周期函数，componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作：\n\n * 清除 timer，取消网络请求或清除\n * 取消在 componentDidMount() 中创建的订阅等；\n\n这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 setState，因为组件一旦被卸载，就不会再装载，也就不会重新渲染。\n\n# 4）错误处理阶段\n\ncomponentDidCatch(error, info)，此生命周期在后代组件抛出错误后被调用。 它接收两个参数∶\n\n * error：抛出的错误。\n * info：带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息\n\nReact常见的生命周期如下： React常见生命周期的过程大致如下：\n\n * 挂载阶段，首先执行constructor构造方法，来创建组件\n * 创建完成之后，就会执行render方法，该方法会返回需要渲染的内容\n * 随后，React会将需要渲染的内容挂载到DOM树上\n * 挂载完成之后就会执行componentDidMount生命周期函数\n * 如果我们给组件创建一个props（用于组件通信）、调用setState（更改state中的数据）、调用forceUpdate（强制更新组件）时，都会重新调用render函数\n * render函数重新执行之后，就会重新进行DOM树的挂载\n * 挂载完成之后就会执行componentDidUpdate生命周期函数\n * 当移除组件时，就会执行componentWillUnmount生命周期函数\n\nReact主要生命周期总结：\n\n 1. getDefaultProps：这个函数会在组件创建之前被调用一次（有且仅有一次），它被用来初始化组件的 Props；\n 2. getInitialState：用于初始化组件的 state 值；\n 3. componentWillMount：在组件创建后、render 之前，会走到 componentWillMount 阶段。这个阶段我个人一直没用过、非常鸡肋。后来React 官方已经不推荐大家在 componentWillMount 里做任何事情、到现在 React16 直接废弃了这个生命周期，足见其鸡肋程度了；\n 4. render：这是所有生命周期中唯一一个你必须要实现的方法。一般来说需要返回一个 jsx 元素，这时 React 会根据 props 和 state 来把组件渲染到界面上；不过有时，你可能不想渲染任何东西，这种情况下让它返回 null 或者 false 即可；\n 5. componentDidMount：会在组件挂载后（插入 DOM 树中后）立即调用，标志着组件挂载完成。一些操作如果依赖获取到 DOM 节点信息，我们就会放在这个阶段来做。此外，这还是 React 官方推荐的发起 ajax 请求的时机。该方法和 componentWillMount 一样，有且仅有一次调用。\n\n\n# 2. React 废弃了哪些生命周期？为什么？\n\n被废弃的三个函数都是在render之前，因为fber的出现，很可能因为高优先级任务的出现而打断现有任务导致它们会被执行多次。另外的一个原因则是，React想约束使用者，好的框架能够让人不得已写出容易维护和扩展的代码，这一点又是从何谈起，可以从新增加以及即将废弃的生命周期分析入手\n\n1) componentWillMount\n\n首先这个函数的功能完全可以使用componentDidMount和 constructor来代替，异步获取的数据的情况上面已经说明了，而如果抛去异步获取数据，其余的即是初始化而已，这些功能都可以在constructor中执行，除此之外，如果在 willMount 中订阅事件，但在服务端这并不会执行 willUnMount事件，也就是说服务端会导致内存泄漏所以componentWilIMount完全可以不使用，但使用者有时候难免因为各 种各样的情况在 componentWilMount中做一些操作，那么React为了约束开发者，干脆就抛掉了这个API\n\n2) componentWillReceiveProps\n\n在老版本的 React 中，如果组件自身的某个 state 跟其 props 密切相关的话，一直都没有一种很优雅的处理方式去更新 state，而是需要在 componentWilReceiveProps 中判断前后两个 props 是否相同，如果不同再将新的 props更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。类似的业务需求也有很多，如一个可以横向滑动的列表，当前高亮的 Tab 显然隶属于列表自身的时，根据传入的某个值，直接定位到某个 Tab。为了解决这些问题，React引入了第一个新的生命周期：getDerivedStateFromProps。它有以下的优点∶\n\n * getDSFP是静态方法，在这里不能使用this，也就是一个纯函数，开发者不能写出副作用的代码\n * 开发者只能通过prevState而不是prevProps来做对比，保证了state和props之间的简单关系以及不需要处理第一次渲染时prevProps为空的情况\n * 基于第一点，将状态变化（setState）和昂贵操作（tabChange）区分开，更加便于 render 和 commit 阶段操作或者说优化。\n\n3) componentWillUpdate\n\n与 componentWillReceiveProps 类似，许多开发者也会在 componentWillUpdate 中根据 props 的变化去触发一些回调 。 但不论是 componentWilReceiveProps 还 是 componentWilUpdate，都有可能在一次更新中被调用多次，也就是说写在这里的回调函数也有可能会被调用多次，这显然是不可取的。与 componentDidMount 类 似， componentDidUpdate 也不存在这样的问题，一次更新中 componentDidUpdate 只会被调用一次，所以将原先写在 componentWillUpdate 中 的 回 调 迁 移 至 componentDidUpdate 就可以解决这个问题。\n\n另外一种情况则是需要获取DOM元素状态，但是由于在fber中，render可打断，可能在wilMount中获取到的元素状态很可能与实际需要的不同，这个通常可以使用第二个新增的生命函数的解决 getSnapshotBeforeUpdate(prevProps, prevState)\n\n4) getSnapshotBeforeUpdate(prevProps, prevState)\n\n返回的值作为componentDidUpdate的第三个参数。与willMount不同的是，getSnapshotBeforeUpdate会在最终确定的render执行之前执行，也就是能保证其获取到的元素状态与didUpdate中获取到的元素状态相同。官方参考代码：\n\nclass ScrollingList extends React.Component {\n  constructor(props) {\n    super(props);\n    this.listRef = React.createRef();\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // 我们是否在 list 中添加新的 items ？\n    // 捕获滚动位置以便我们稍后调整滚动位置。\n    if (prevProps.list.length < this.props.list.length) {\n      const list = this.listRef.current;\n      return list.scrollHeight - list.scrollTop;\n    }\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，\n    // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。\n    //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）\n    if (snapshot !== null) {\n      const list = this.listRef.current;\n      list.scrollTop = list.scrollHeight - snapshot;\n    }\n  }\n\n  render() {\n    return (\n      <div ref={this.listRef}>{/* ...contents... */}</div>\n    );\n  }\n}\n\n\n\n# 3. React 16.X 中 props 改变后在哪个生命周期中处理\n\n在getDerivedStateFromProps中进行处理。\n\n这个生命周期函数是为了替代componentWillReceiveProps存在的，所以在需要使用componentWillReceiveProps时，就可以考虑使用getDerivedStateFromProps来进行替代。\n\n两者的参数是不相同的，而getDerivedStateFromProps是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。\n\n需要注意的是，如果props传入的内容不需要影响到你的state，那么就需要返回一个null，这个返回值是必须的，所以尽量将其写到函数的末尾：\n\nstatic getDerivedStateFromProps(nextProps, prevState) {\n    const {type} = nextProps;\n    // 当传入的type发生变化的时候，更新state\n    if (type !== prevState.type) {\n        return {\n            type,\n        };\n    }\n    // 否则，对于state不进行任何操作\n    return null;\n}\n\n\n\n# 4. React 性能优化在哪个生命周期？它优化的原理是什么？\n\nreact的父级组件的render函数重新渲染会引起子组件的render方法的重新渲染。但是，有的时候子组件的接受父组件的数据没有变动。子组件render的执行会影响性能，这时就可以使用shouldComponentUpdate来解决这个问题。\n\n使用方法如下：\n\nshouldComponentUpdate(nexrProps) {\n    if (this.props.num === nexrProps.num) {\n        return false\n    }\n    return true;\n}\n\n\nshouldComponentUpdate提供了两个参数nextProps和nextState，表示下一次props和一次state的值，当函数返回false时候，render()方法不执行，组件也就不会渲染，返回true时，组件照常重渲染。此方法就是拿当前props中值和下一次props中的值进行对比，数据相等时，返回false，反之返回true。\n\n需要注意，在进行新旧对比的时候，是**浅对比，**也就是说如果比较的数据时引用数据类型，只要数据的引用的地址没变，即使内容变了，也会被判定为true。\n\n面对这个问题，可以使用如下方法进行解决： （1）使用setState改变数据之前，先采用ES6中assgin进行拷贝，但是assgin只深拷贝的数据的第一层，所以说不是最完美的解决办法：\n\nconst o2 = Object.assign({},this.state.obj)\n    o2.student.count = '00000';\n    this.setState({\n        obj: o2,\n    })\n\n\n（2）使用JSON.parse(JSON.stringfy())进行深拷贝，但是遇到数据为undefined和函数时就会错。\n\nconst o2 = JSON.parse(JSON.stringify(this.state.obj))\n    o2.student.count = '00000';\n    this.setState({\n        obj: o2,\n    })\n\n\n\n# 5. state 和 props 触发更新的生命周期分别有什么区别？\n\nstate 更新流程： 这个过程当中涉及的函数：\n\n 1. shouldComponentUpdate: 当组件的 state 或 props 发生改变时，都会首先触发这个生命周期函数。它会接收两个参数：nextProps, nextState——它们分别代表传入的新 props 和新的 state 值。拿到这两个值之后，我们就可以通过一些对比逻辑来决定是否有 re-render（重渲染）的必要了。如果该函数的返回值为 false，则生命周期终止，反之继续；\n\n> 注意：此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。应该考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()\n\n 1. componentWillUpdate：当组件的 state 或 props 发生改变时，会在渲染之前调用 componentWillUpdate。componentWillUpdate 是 React16 废弃的三个生命周期之一。过去，我们可能希望能在这个阶段去收集一些必要的信息（比如更新前的 DOM 信息等等），现在我们完全可以在 React16 的 getSnapshotBeforeUpdate 中去做这些事；\n 2. componentDidUpdate：componentDidUpdate() 会在UI更新后会被立即调用。它接收 prevProps（上一次的 props 值）作为入参，也就是说在此处我们仍然可以进行 props 值对比（再次说明 componentWillUpdate 确实鸡肋哈）。\n\n----------------------------------------\n\nprops 更新流程： 相对于 state 更新，props 更新后唯一的区别是增加了对 componentWillReceiveProps 的调用。关于 componentWillReceiveProps，需要知道这些事情：\n\n * componentWillReceiveProps：它在Component接受到新的 props 时被触发。componentWillReceiveProps 会接收一个名为 nextProps 的参数（对应新的 props 值）。该生命周期是 React16 废弃掉的三个生命周期之一。在它被废弃前，可以用它来比较 this.props 和 nextProps 来重新setState。在 React16 中，用一个类似的新生命周期 getDerivedStateFromProps 来代替它。\n\n\n# 6. React中发起网络请求应该在哪个生命周期中进行？为什么？\n\n对于异步请求，最好放在componentDidMount中去操作，对于同步的状态改变，可以放在componentWillMount中，一般用的比较少。\n\n如果认为在componentWillMount里发起请求能提早获得结果，这种想法其实是错误的，通常componentWillMount比componentDidMount早不了多少微秒，网络上任何一点延迟，这一点差异都可忽略不计。\n\nreact的生命周期： constructor() -> componentWillMount() -> render() -> componentDidMount()\n\n上面这些方法的调用是有次序的，由上而下依次调用。\n\n * constructor被调用是在组件准备要挂载的最开始，此时组件尚未挂载到网页上。\n * componentWillMount方法的调用在constructor之后，在render之前，在这方法里的代码调用setState方法不会触发重新render，所以它一般不会用来作加载数据之用。\n * componentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setState方法，会触发重新渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。与组件上的数据无关的加载，也可以在constructor里做，但constructor是做组件state初绐化工作，并不是做加载数据这工作的，constructor里也不能setState，还有加载的时间太长或者出错，页面就无法加载出来。所以有副作用的代码都会集中在componentDidMount方法里。\n\n总结：\n\n * 跟服务器端渲染（同构）有关系，如果在componentWillMount里面获取数据，fetch data会执行两次，一次在服务器端一次在客户端。在componentDidMount中可以解决这个问题，componentWillMount同样也会render两次。\n * 在componentWillMount中fetch data，数据一定在render后才能到达，如果忘记了设置初始状态，用户体验不好。\n * react16.0以后，componentWillMount可能会被执行多次。\n\n\n# 7. React 16中新生命周期有哪些\n\n关于 React16 开始应用的新生命周期： 可以看出，React16 自上而下地对生命周期做了另一种维度的解读：\n\n * Render 阶段：用于计算一些必要的状态信息。这个阶段可能会被 React 暂停，这一点和 React16 引入的 Fiber 架构（我们后面会重点讲解）是有关的；\n * Pre-commit阶段：所谓“commit”，这里指的是“更新真正的 DOM 节点”这个动作。所谓 Pre-commit，就是说我在这个阶段其实还并没有去更新真实的 DOM，不过 DOM 信息已经是可以读取的了；\n * Commit 阶段：在这一步，React 会完成真实 DOM 的更新工作。Commit 阶段，我们可以拿到真实 DOM（包括 refs）。\n\n与此同时，新的生命周期在流程方面，仍然遵循“挂载”、“更新”、“卸载”这三个广义的划分方式。它们分别对应到：\n\n * 挂载过程：\n   * constructor\n   * getDerivedStateFromProps\n   * render\n   * componentDidMount\n * 更新过程：\n   * getDerivedStateFromProps\n   * shouldComponentUpdate\n   * render\n   * getSnapshotBeforeUpdate\n   * componentDidUpdate\n * 卸载过程：\n   * componentWillUnmount",
      "normalizedContent": "# 1. react的生命周期有哪些？\n\nreact 通常将组件生命周期分为三个阶段：\n\n * 装载阶段（mount），组件第一次在dom树中被渲染的过程；\n * 更新过程（update），组件状态发生变化，重新更新渲染的过程；\n * 卸载过程（unmount），组件从dom树中被移除的过程；\n\n\n\n# 1）组件挂载阶段\n\n挂载阶段组件被创建，然后组件实例插入到 dom 中，完成组件的第一次渲染，该过程只会发生一次，在此阶段会依次调用以下这些方法：\n\n * constructor\n * getderivedstatefromprops\n * render\n * componentdidmount\n\n# （1）constructor\n\n组件的构造函数，第一个被执行，若没有显式定义它，会有一个默认的构造函数，但是若显式定义了构造函数，我们必须在构造函数中执行 super(props)，否则无法在构造函数中拿到this。\n\n如果不初始化 state 或不进行方法绑定，则不需要为 react 组件实现构造函数constructor。\n\nconstructor中通常只做两件事：\n\n * 初始化组件的 state\n * 给事件处理方法绑定 this\n\nconstructor(props) {\n  super(props);\n  // 不要在构造函数中调用 setstate，可以直接给 state 设置初始值\n  this.state = { counter: 0 }\n  this.handleclick = this.handleclick.bind(this)\n}\n\n\n# （2）getderivedstatefromprops\n\nstatic getderivedstatefromprops(props, state)\n\n\n这是个静态方法，所以不能在这个函数里使用 this，有两个参数 props 和 state，分别指接收到的新参数和当前组件的 state 对象，这个函数会返回一个对象用来更新当前的 state 对象，如果不需要更新可以返回 null。\n\n该函数会在装载时，接收到新的 props 或者调用了 setstate 和 forceupdate 时被调用。如当接收到新的属性想修改 state ，就可以使用。\n\n// 当 props.counter 变化时，赋值给 state \nclass app extends react.component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      counter: 0\n    }\n  }\n  static getderivedstatefromprops(props, state) {\n    if (props.counter !== state.counter) {\n      return {\n        counter: props.counter\n      }\n    }\n    return null\n  }\n  \n  handleclick = () => {\n    this.setstate({\n      counter: this.state.counter + 1\n    })\n  }\n  render() {\n    return (\n      <div>\n        <h1 onclick={this.handleclick}>hello, world!{this.state.counter}</h1>\n      </div>\n    )\n  }\n}\n\n\n现在可以显式传入 counter ，但是这里有个问题，如果想要通过点击实现 state.counter 的增加，但这时会发现值不会发生任何变化，一直保持 props 传进来的值。这是由于在 react 16.4^ 的版本中 setstate 和 forceupdate 也会触发这个生命周期，所以当组件内部 state 变化后，就会重新走这个方法，同时会把 state 值赋值为 props 的值。因此需要多加一个字段来记录之前的 props 值，这样就会解决上述问题。具体如下：\n\n// 这里只列出需要变化的地方\nclass app extends react.component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      // 增加一个 precounter 来记录之前的 props 传来的值\n      precounter: 0,\n      counter: 0\n    }\n  }\n  static getderivedstatefromprops(props, state) {\n    // 跟 state.precounter 进行比较\n    if (props.counter !== state.precounter) {\n      return {\n        counter: props.counter,\n        precounter: props.counter\n      }\n    }\n    return null\n  }\n  handleclick = () => {\n    this.setstate({\n      counter: this.state.counter + 1\n    })\n  }\n  render() {\n    return (\n      <div>\n        <h1 onclick={this.handleclick}>hello, world!{this.state.counter}</h1>\n      </div>\n    )\n  }\n}\n\n\n# （3）render\n\nrender是react 中最核心的方法，一个组件中必须要有这个方法，它会根据状态 state 和属性 props 渲染组件。这个函数只做一件事，就是返回需要渲染的内容，所以不要在这个函数内做其他业务逻辑，通常调用该方法会返回以下类型中一个：\n\n * react 元素：这里包括原生的 dom 以及 react 组件；\n * 数组和 fragment（片段）：可以返回多个元素；\n * portals（插槽）：可以将子元素渲染到不同的 dom 子树种；\n * 字符串和数字：被渲染成 dom 中的 text 节点；\n * 布尔值或 null：不渲染任何内容。\n\n# （4）componentdidmount()\n\ncomponentdidmount()会在组件挂载后（插入 dom 树中）立即调。该阶段通常进行以下操作：\n\n * 执行依赖于dom的操作；\n * 发送网络请求；（官方建议）\n * 添加订阅消息（会在componentwillunmount取消订阅）；\n\n如果在 componentdidmount 中调用 setstate ，就会触发一次额外的渲染，多调用了一次 render 函数，由于它是在浏览器刷新屏幕前执行的，所以用户对此是没有感知的，但是我应当避免这样使用，这样会带来一定的性能问题，尽量是在 constructor 中初始化 state 对象。\n\n在组件装载之后，将计数数字变为1：\n\nclass app extends react.component  {\n  constructor(props) {\n    super(props)\n    this.state = {\n      counter: 0\n    }\n  }\n  componentdidmount () {\n    this.setstate({\n      counter: 1\n    })\n  }\n  render ()  {\n    return (\n      <div classname=\"counter\">\n        counter值: { this.state.counter }\n      </div>\n    )\n  }\n}\n\n\n# 2）组件更新阶段\n\n当组件的 props 改变了，或组件内部调用了 setstate/forceupdate，会触发更新重新渲染，这个过程可能会发生多次。这个阶段会依次调用下面这些方法：\n\n * getderivedstatefromprops\n * shouldcomponentupdate\n * render\n * getsnapshotbeforeupdate\n * componentdidupdate\n\n# （1）shouldcomponentupdate\n\nshouldcomponentupdate(nextprops, nextstate)\n\n\n在说这个生命周期函数之前，来看两个问题：\n\n * setstate 函数在任何情况下都会导致组件重新渲染吗？例如下面这种情况：\n\nthis.setstate({number: this.state.number})\n\n\n * 如果没有调用 setstate，props 值也没有变化，是不是组件就不会重新渲染？\n\n第一个问题答案是 会 ，第二个问题如果是父组件重新渲染时，不管传入的 props 有没有变化，都会引起子组件的重新渲染。\n\n那么有没有什么方法解决在这两个场景下不让组件重新渲染进而提升性能呢？这个时候 shouldcomponentupdate 登场了，这个生命周期函数是用来提升速度的，它是在重新渲染组件开始前触发的，默认返回 true，可以比较 this.props 和 nextprops ，this.state 和 nextstate 值是否变化，来确认返回 true 或者 false。当返回 false 时，组件的更新过程停止，后续的 render、componentdidupdate 也不会被调用。\n\n注意： 添加 shouldcomponentupdate 方法时，不建议使用深度相等检查（如使用 json.stringify()），因为深比较效率很低，可能会比重新渲染组件效率还低。而且该方法维护比较困难，建议使用该方法会产生明显的性能提升时使用。\n\n# （2）getsnapshotbeforeupdate\n\ngetsnapshotbeforeupdate(prevprops, prevstate)\n\n\n这个方法在 render 之后，componentdidupdate 之前调用，有两个参数 prevprops 和 prevstate，表示更新之前的 props 和 state，这个函数必须要和 componentdidupdate 一起使用，并且要有一个返回值，默认是 null，这个返回值作为第三个参数传给 componentdidupdate。\n\n# （3）componentdidupdate\n\ncomponentdidupdate() 会在更新后会被立即调用，首次渲染不会执行此方法。 该阶段通常进行以下操作：\n\n * 当组件更新后，对 dom 进行操作；\n * 如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。\n\ncomponentdidupdate(prevprops, prevstate, snapshot){}\n\n\n该方法有三个参数：\n\n * prevprops: 更新前的props\n * prevstate: 更新前的state\n * snapshot: getsnapshotbeforeupdate()生命周期的返回值\n\n# 3）组件卸载阶段\n\n卸载阶段只有一个生命周期函数，componentwillunmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作：\n\n * 清除 timer，取消网络请求或清除\n * 取消在 componentdidmount() 中创建的订阅等；\n\n这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 setstate，因为组件一旦被卸载，就不会再装载，也就不会重新渲染。\n\n# 4）错误处理阶段\n\ncomponentdidcatch(error, info)，此生命周期在后代组件抛出错误后被调用。 它接收两个参数∶\n\n * error：抛出的错误。\n * info：带有 componentstack key 的对象，其中包含有关组件引发错误的栈信息\n\nreact常见的生命周期如下： react常见生命周期的过程大致如下：\n\n * 挂载阶段，首先执行constructor构造方法，来创建组件\n * 创建完成之后，就会执行render方法，该方法会返回需要渲染的内容\n * 随后，react会将需要渲染的内容挂载到dom树上\n * 挂载完成之后就会执行componentdidmount生命周期函数\n * 如果我们给组件创建一个props（用于组件通信）、调用setstate（更改state中的数据）、调用forceupdate（强制更新组件）时，都会重新调用render函数\n * render函数重新执行之后，就会重新进行dom树的挂载\n * 挂载完成之后就会执行componentdidupdate生命周期函数\n * 当移除组件时，就会执行componentwillunmount生命周期函数\n\nreact主要生命周期总结：\n\n 1. getdefaultprops：这个函数会在组件创建之前被调用一次（有且仅有一次），它被用来初始化组件的 props；\n 2. getinitialstate：用于初始化组件的 state 值；\n 3. componentwillmount：在组件创建后、render 之前，会走到 componentwillmount 阶段。这个阶段我个人一直没用过、非常鸡肋。后来react 官方已经不推荐大家在 componentwillmount 里做任何事情、到现在 react16 直接废弃了这个生命周期，足见其鸡肋程度了；\n 4. render：这是所有生命周期中唯一一个你必须要实现的方法。一般来说需要返回一个 jsx 元素，这时 react 会根据 props 和 state 来把组件渲染到界面上；不过有时，你可能不想渲染任何东西，这种情况下让它返回 null 或者 false 即可；\n 5. componentdidmount：会在组件挂载后（插入 dom 树中后）立即调用，标志着组件挂载完成。一些操作如果依赖获取到 dom 节点信息，我们就会放在这个阶段来做。此外，这还是 react 官方推荐的发起 ajax 请求的时机。该方法和 componentwillmount 一样，有且仅有一次调用。\n\n\n# 2. react 废弃了哪些生命周期？为什么？\n\n被废弃的三个函数都是在render之前，因为fber的出现，很可能因为高优先级任务的出现而打断现有任务导致它们会被执行多次。另外的一个原因则是，react想约束使用者，好的框架能够让人不得已写出容易维护和扩展的代码，这一点又是从何谈起，可以从新增加以及即将废弃的生命周期分析入手\n\n1) componentwillmount\n\n首先这个函数的功能完全可以使用componentdidmount和 constructor来代替，异步获取的数据的情况上面已经说明了，而如果抛去异步获取数据，其余的即是初始化而已，这些功能都可以在constructor中执行，除此之外，如果在 willmount 中订阅事件，但在服务端这并不会执行 willunmount事件，也就是说服务端会导致内存泄漏所以componentwilimount完全可以不使用，但使用者有时候难免因为各 种各样的情况在 componentwilmount中做一些操作，那么react为了约束开发者，干脆就抛掉了这个api\n\n2) componentwillreceiveprops\n\n在老版本的 react 中，如果组件自身的某个 state 跟其 props 密切相关的话，一直都没有一种很优雅的处理方式去更新 state，而是需要在 componentwilreceiveprops 中判断前后两个 props 是否相同，如果不同再将新的 props更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。类似的业务需求也有很多，如一个可以横向滑动的列表，当前高亮的 tab 显然隶属于列表自身的时，根据传入的某个值，直接定位到某个 tab。为了解决这些问题，react引入了第一个新的生命周期：getderivedstatefromprops。它有以下的优点∶\n\n * getdsfp是静态方法，在这里不能使用this，也就是一个纯函数，开发者不能写出副作用的代码\n * 开发者只能通过prevstate而不是prevprops来做对比，保证了state和props之间的简单关系以及不需要处理第一次渲染时prevprops为空的情况\n * 基于第一点，将状态变化（setstate）和昂贵操作（tabchange）区分开，更加便于 render 和 commit 阶段操作或者说优化。\n\n3) componentwillupdate\n\n与 componentwillreceiveprops 类似，许多开发者也会在 componentwillupdate 中根据 props 的变化去触发一些回调 。 但不论是 componentwilreceiveprops 还 是 componentwilupdate，都有可能在一次更新中被调用多次，也就是说写在这里的回调函数也有可能会被调用多次，这显然是不可取的。与 componentdidmount 类 似， componentdidupdate 也不存在这样的问题，一次更新中 componentdidupdate 只会被调用一次，所以将原先写在 componentwillupdate 中 的 回 调 迁 移 至 componentdidupdate 就可以解决这个问题。\n\n另外一种情况则是需要获取dom元素状态，但是由于在fber中，render可打断，可能在wilmount中获取到的元素状态很可能与实际需要的不同，这个通常可以使用第二个新增的生命函数的解决 getsnapshotbeforeupdate(prevprops, prevstate)\n\n4) getsnapshotbeforeupdate(prevprops, prevstate)\n\n返回的值作为componentdidupdate的第三个参数。与willmount不同的是，getsnapshotbeforeupdate会在最终确定的render执行之前执行，也就是能保证其获取到的元素状态与didupdate中获取到的元素状态相同。官方参考代码：\n\nclass scrollinglist extends react.component {\n  constructor(props) {\n    super(props);\n    this.listref = react.createref();\n  }\n\n  getsnapshotbeforeupdate(prevprops, prevstate) {\n    // 我们是否在 list 中添加新的 items ？\n    // 捕获滚动位置以便我们稍后调整滚动位置。\n    if (prevprops.list.length < this.props.list.length) {\n      const list = this.listref.current;\n      return list.scrollheight - list.scrolltop;\n    }\n    return null;\n  }\n\n  componentdidupdate(prevprops, prevstate, snapshot) {\n    // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，\n    // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。\n    //（这里的 snapshot 是 getsnapshotbeforeupdate 的返回值）\n    if (snapshot !== null) {\n      const list = this.listref.current;\n      list.scrolltop = list.scrollheight - snapshot;\n    }\n  }\n\n  render() {\n    return (\n      <div ref={this.listref}>{/* ...contents... */}</div>\n    );\n  }\n}\n\n\n\n# 3. react 16.x 中 props 改变后在哪个生命周期中处理\n\n在getderivedstatefromprops中进行处理。\n\n这个生命周期函数是为了替代componentwillreceiveprops存在的，所以在需要使用componentwillreceiveprops时，就可以考虑使用getderivedstatefromprops来进行替代。\n\n两者的参数是不相同的，而getderivedstatefromprops是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextprops以及prevstate来进行判断，根据新传入的props来映射到state。\n\n需要注意的是，如果props传入的内容不需要影响到你的state，那么就需要返回一个null，这个返回值是必须的，所以尽量将其写到函数的末尾：\n\nstatic getderivedstatefromprops(nextprops, prevstate) {\n    const {type} = nextprops;\n    // 当传入的type发生变化的时候，更新state\n    if (type !== prevstate.type) {\n        return {\n            type,\n        };\n    }\n    // 否则，对于state不进行任何操作\n    return null;\n}\n\n\n\n# 4. react 性能优化在哪个生命周期？它优化的原理是什么？\n\nreact的父级组件的render函数重新渲染会引起子组件的render方法的重新渲染。但是，有的时候子组件的接受父组件的数据没有变动。子组件render的执行会影响性能，这时就可以使用shouldcomponentupdate来解决这个问题。\n\n使用方法如下：\n\nshouldcomponentupdate(nexrprops) {\n    if (this.props.num === nexrprops.num) {\n        return false\n    }\n    return true;\n}\n\n\nshouldcomponentupdate提供了两个参数nextprops和nextstate，表示下一次props和一次state的值，当函数返回false时候，render()方法不执行，组件也就不会渲染，返回true时，组件照常重渲染。此方法就是拿当前props中值和下一次props中的值进行对比，数据相等时，返回false，反之返回true。\n\n需要注意，在进行新旧对比的时候，是**浅对比，**也就是说如果比较的数据时引用数据类型，只要数据的引用的地址没变，即使内容变了，也会被判定为true。\n\n面对这个问题，可以使用如下方法进行解决： （1）使用setstate改变数据之前，先采用es6中assgin进行拷贝，但是assgin只深拷贝的数据的第一层，所以说不是最完美的解决办法：\n\nconst o2 = object.assign({},this.state.obj)\n    o2.student.count = '00000';\n    this.setstate({\n        obj: o2,\n    })\n\n\n（2）使用json.parse(json.stringfy())进行深拷贝，但是遇到数据为undefined和函数时就会错。\n\nconst o2 = json.parse(json.stringify(this.state.obj))\n    o2.student.count = '00000';\n    this.setstate({\n        obj: o2,\n    })\n\n\n\n# 5. state 和 props 触发更新的生命周期分别有什么区别？\n\nstate 更新流程： 这个过程当中涉及的函数：\n\n 1. shouldcomponentupdate: 当组件的 state 或 props 发生改变时，都会首先触发这个生命周期函数。它会接收两个参数：nextprops, nextstate——它们分别代表传入的新 props 和新的 state 值。拿到这两个值之后，我们就可以通过一些对比逻辑来决定是否有 re-render（重渲染）的必要了。如果该函数的返回值为 false，则生命周期终止，反之继续；\n\n> 注意：此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。应该考虑使用内置的 purecomponent 组件，而不是手动编写 shouldcomponentupdate()\n\n 1. componentwillupdate：当组件的 state 或 props 发生改变时，会在渲染之前调用 componentwillupdate。componentwillupdate 是 react16 废弃的三个生命周期之一。过去，我们可能希望能在这个阶段去收集一些必要的信息（比如更新前的 dom 信息等等），现在我们完全可以在 react16 的 getsnapshotbeforeupdate 中去做这些事；\n 2. componentdidupdate：componentdidupdate() 会在ui更新后会被立即调用。它接收 prevprops（上一次的 props 值）作为入参，也就是说在此处我们仍然可以进行 props 值对比（再次说明 componentwillupdate 确实鸡肋哈）。\n\n----------------------------------------\n\nprops 更新流程： 相对于 state 更新，props 更新后唯一的区别是增加了对 componentwillreceiveprops 的调用。关于 componentwillreceiveprops，需要知道这些事情：\n\n * componentwillreceiveprops：它在component接受到新的 props 时被触发。componentwillreceiveprops 会接收一个名为 nextprops 的参数（对应新的 props 值）。该生命周期是 react16 废弃掉的三个生命周期之一。在它被废弃前，可以用它来比较 this.props 和 nextprops 来重新setstate。在 react16 中，用一个类似的新生命周期 getderivedstatefromprops 来代替它。\n\n\n# 6. react中发起网络请求应该在哪个生命周期中进行？为什么？\n\n对于异步请求，最好放在componentdidmount中去操作，对于同步的状态改变，可以放在componentwillmount中，一般用的比较少。\n\n如果认为在componentwillmount里发起请求能提早获得结果，这种想法其实是错误的，通常componentwillmount比componentdidmount早不了多少微秒，网络上任何一点延迟，这一点差异都可忽略不计。\n\nreact的生命周期： constructor() -> componentwillmount() -> render() -> componentdidmount()\n\n上面这些方法的调用是有次序的，由上而下依次调用。\n\n * constructor被调用是在组件准备要挂载的最开始，此时组件尚未挂载到网页上。\n * componentwillmount方法的调用在constructor之后，在render之前，在这方法里的代码调用setstate方法不会触发重新render，所以它一般不会用来作加载数据之用。\n * componentdidmount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setstate方法，会触发重新渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。与组件上的数据无关的加载，也可以在constructor里做，但constructor是做组件state初绐化工作，并不是做加载数据这工作的，constructor里也不能setstate，还有加载的时间太长或者出错，页面就无法加载出来。所以有副作用的代码都会集中在componentdidmount方法里。\n\n总结：\n\n * 跟服务器端渲染（同构）有关系，如果在componentwillmount里面获取数据，fetch data会执行两次，一次在服务器端一次在客户端。在componentdidmount中可以解决这个问题，componentwillmount同样也会render两次。\n * 在componentwillmount中fetch data，数据一定在render后才能到达，如果忘记了设置初始状态，用户体验不好。\n * react16.0以后，componentwillmount可能会被执行多次。\n\n\n# 7. react 16中新生命周期有哪些\n\n关于 react16 开始应用的新生命周期： 可以看出，react16 自上而下地对生命周期做了另一种维度的解读：\n\n * render 阶段：用于计算一些必要的状态信息。这个阶段可能会被 react 暂停，这一点和 react16 引入的 fiber 架构（我们后面会重点讲解）是有关的；\n * pre-commit阶段：所谓“commit”，这里指的是“更新真正的 dom 节点”这个动作。所谓 pre-commit，就是说我在这个阶段其实还并没有去更新真实的 dom，不过 dom 信息已经是可以读取的了；\n * commit 阶段：在这一步，react 会完成真实 dom 的更新工作。commit 阶段，我们可以拿到真实 dom（包括 refs）。\n\n与此同时，新的生命周期在流程方面，仍然遵循“挂载”、“更新”、“卸载”这三个广义的划分方式。它们分别对应到：\n\n * 挂载过程：\n   * constructor\n   * getderivedstatefromprops\n   * render\n   * componentdidmount\n * 更新过程：\n   * getderivedstatefromprops\n   * shouldcomponentupdate\n   * render\n   * getsnapshotbeforeupdate\n   * componentdidupdate\n * 卸载过程：\n   * componentwillunmount",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "组件通信",
      "frontmatter": {
        "title": "组件通信",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/frameReactComponent/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/20.react%E7%AF%87/40.%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html",
      "relativePath": "30.框架篇/20.react篇/40.组件通信.md",
      "key": "v-74abba40",
      "path": "/pages/frameReactComponent/",
      "headers": [
        {
          "level": 3,
          "title": "1. 父子组件的通信方式？",
          "slug": "_1-父子组件的通信方式",
          "normalizedTitle": "1. 父子组件的通信方式？",
          "charIndex": 74
        },
        {
          "level": 3,
          "title": "2. 跨级组件的通信方式？",
          "slug": "_2-跨级组件的通信方式",
          "normalizedTitle": "2. 跨级组件的通信方式？",
          "charIndex": 677
        },
        {
          "level": 3,
          "title": "3. 非嵌套关系组件的通信方式？",
          "slug": "_3-非嵌套关系组件的通信方式",
          "normalizedTitle": "3. 非嵌套关系组件的通信方式？",
          "charIndex": 1656
        },
        {
          "level": 3,
          "title": "4. 如何解决 props 层级过深的问题",
          "slug": "_4-如何解决-props-层级过深的问题",
          "normalizedTitle": "4. 如何解决 props 层级过深的问题",
          "charIndex": 1808
        },
        {
          "level": 3,
          "title": "5. 组件通信的方式有哪些",
          "slug": "_5-组件通信的方式有哪些",
          "normalizedTitle": "5. 组件通信的方式有哪些",
          "charIndex": 1903
        }
      ],
      "headersStr": "1. 父子组件的通信方式？ 2. 跨级组件的通信方式？ 3. 非嵌套关系组件的通信方式？ 4. 如何解决 props 层级过深的问题 5. 组件通信的方式有哪些",
      "content": "React组件间通信常见的几种情况:\n\n * 父组件向子组件通信\n * 子组件向父组件通信\n * 跨级组件通信\n * 非嵌套关系的组件通信\n\n\n# 1. 父子组件的通信方式？\n\n父组件向子组件通信：父组件通过 props 向子组件传递需要的信息。\n\n// 子组件: Child\nconst Child = props =>{\n  return <p>{props.name}</p>\n}\n// 父组件 Parent\nconst Parent = ()=>{\n    return <Child name=\"react\"></Child>\n}\n\n\n子组件向父组件通信：: props+回调的方式。\n\n// 子组件: Child\nconst Child = props =>{\n  const cb = msg =>{\n      return ()=>{\n          props.callback(msg)\n      }\n  }\n  return (\n      <button onClick={cb(\"你好!\")}>你好</button>\n  )\n}\n// 父组件 Parent\nclass Parent extends Component {\n    callback(msg){\n        console.log(msg)\n    }\n    render(){\n        return <Child callback={this.callback.bind(this)}></Child>    \n    }\n}\n\n\n\n# 2. 跨级组件的通信方式？\n\n父组件向子组件的子组件通信，向更深层子组件通信：\n\n * 使用props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。\n * 使用context，context相当于一个大容器，可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。\n\n// context方式实现跨级组件通信 \n// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据\nconst BatteryContext = createContext();\n//  子组件的子组件 \nclass GrandChild extends Component {\n    render(){\n        return (\n            <BatteryContext.Consumer>\n                {\n                    color => <h1 style={{\"color\":color}}>我是红色的:{color}</h1>\n                }\n            </BatteryContext.Consumer>\n        )\n    }\n}\n//  子组件\nconst Child = () =>{\n    return (\n        <GrandChild/>\n    )\n}\n// 父组件\nclass Parent extends Component {\n      state = {\n          color:\"red\"\n      }\n      render(){\n          const {color} = this.state\n          return (\n          <BatteryContext.Provider value={color}>\n              <Child></Child>\n          </BatteryContext.Provider>\n          )\n      }\n}\n\n\n\n# 3. 非嵌套关系组件的通信方式？\n\n即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。\n\n * 可以使用自定义事件通信（发布订阅模式）\n * 可以通过redux等进行全局状态管理\n * 如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。\n\n\n# 4. 如何解决 props 层级过深的问题\n\n * 使用Context API：提供一种组件之间的状态共享，而不必通过显式组件树逐层传递props；\n * 使用Redux等状态库。\n\n\n# 5. 组件通信的方式有哪些\n\n * ⽗组件向⼦组件通讯: ⽗组件可以向⼦组件通过传 props 的⽅式，向⼦组件进⾏通讯\n * ⼦组件向⽗组件通讯: props+回调的⽅式，⽗组件向⼦组件传递props进⾏通讯，此props为作⽤域为⽗组件⾃身的函 数，⼦组件调⽤该函数，将⼦组件想要传递的信息，作为参数，传递到⽗组件的作⽤域中\n * 兄弟组件通信: 找到这两个兄弟节点共同的⽗节点,结合上⾯两种⽅式由⽗节点转发信息进⾏通信\n * 跨层级通信: Context 设计⽬的是为了共享那些对于⼀个组件树⽽⾔是“全局”的数据，例如当前认证的⽤户、主题或⾸选语⾔，对于跨越多层的全局数据通过 Context 通信再适合不过\n * 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引⼊event模块进⾏通信\n * 全局状态管理⼯具: 借助Redux或者Mobx等全局状态管理⼯具进⾏通信,这种⼯具会维护⼀个全局状态中⼼Store,并根据不同的事件产⽣新的状态",
      "normalizedContent": "react组件间通信常见的几种情况:\n\n * 父组件向子组件通信\n * 子组件向父组件通信\n * 跨级组件通信\n * 非嵌套关系的组件通信\n\n\n# 1. 父子组件的通信方式？\n\n父组件向子组件通信：父组件通过 props 向子组件传递需要的信息。\n\n// 子组件: child\nconst child = props =>{\n  return <p>{props.name}</p>\n}\n// 父组件 parent\nconst parent = ()=>{\n    return <child name=\"react\"></child>\n}\n\n\n子组件向父组件通信：: props+回调的方式。\n\n// 子组件: child\nconst child = props =>{\n  const cb = msg =>{\n      return ()=>{\n          props.callback(msg)\n      }\n  }\n  return (\n      <button onclick={cb(\"你好!\")}>你好</button>\n  )\n}\n// 父组件 parent\nclass parent extends component {\n    callback(msg){\n        console.log(msg)\n    }\n    render(){\n        return <child callback={this.callback.bind(this)}></child>    \n    }\n}\n\n\n\n# 2. 跨级组件的通信方式？\n\n父组件向子组件的子组件通信，向更深层子组件通信：\n\n * 使用props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。\n * 使用context，context相当于一个大容器，可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。\n\n// context方式实现跨级组件通信 \n// context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据\nconst batterycontext = createcontext();\n//  子组件的子组件 \nclass grandchild extends component {\n    render(){\n        return (\n            <batterycontext.consumer>\n                {\n                    color => <h1 style={{\"color\":color}}>我是红色的:{color}</h1>\n                }\n            </batterycontext.consumer>\n        )\n    }\n}\n//  子组件\nconst child = () =>{\n    return (\n        <grandchild/>\n    )\n}\n// 父组件\nclass parent extends component {\n      state = {\n          color:\"red\"\n      }\n      render(){\n          const {color} = this.state\n          return (\n          <batterycontext.provider value={color}>\n              <child></child>\n          </batterycontext.provider>\n          )\n      }\n}\n\n\n\n# 3. 非嵌套关系组件的通信方式？\n\n即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。\n\n * 可以使用自定义事件通信（发布订阅模式）\n * 可以通过redux等进行全局状态管理\n * 如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。\n\n\n# 4. 如何解决 props 层级过深的问题\n\n * 使用context api：提供一种组件之间的状态共享，而不必通过显式组件树逐层传递props；\n * 使用redux等状态库。\n\n\n# 5. 组件通信的方式有哪些\n\n * ⽗组件向⼦组件通讯: ⽗组件可以向⼦组件通过传 props 的⽅式，向⼦组件进⾏通讯\n * ⼦组件向⽗组件通讯: props+回调的⽅式，⽗组件向⼦组件传递props进⾏通讯，此props为作⽤域为⽗组件⾃身的函 数，⼦组件调⽤该函数，将⼦组件想要传递的信息，作为参数，传递到⽗组件的作⽤域中\n * 兄弟组件通信: 找到这两个兄弟节点共同的⽗节点,结合上⾯两种⽅式由⽗节点转发信息进⾏通信\n * 跨层级通信: context 设计⽬的是为了共享那些对于⼀个组件树⽽⾔是“全局”的数据，例如当前认证的⽤户、主题或⾸选语⾔，对于跨越多层的全局数据通过 context 通信再适合不过\n * 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引⼊event模块进⾏通信\n * 全局状态管理⼯具: 借助redux或者mobx等全局状态管理⼯具进⾏通信,这种⼯具会维护⼀个全局状态中⼼store,并根据不同的事件产⽣新的状态",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "路由",
      "frontmatter": {
        "title": "路由",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/frameRoute/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/10.vue%E7%AF%87/40.%E8%B7%AF%E7%94%B1.html",
      "relativePath": "30.框架篇/10.vue篇/40.路由.md",
      "key": "v-7ceda8a0",
      "path": "/pages/frameRoute/",
      "headers": [
        {
          "level": 3,
          "title": "1. Vue-Router 的懒加载如何实现",
          "slug": "_1-vue-router-的懒加载如何实现",
          "normalizedTitle": "1. vue-router 的懒加载如何实现",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 路由的hash和history模式的区别",
          "slug": "_2-路由的hash和history模式的区别",
          "normalizedTitle": "2. 路由的hash和history模式的区别",
          "charIndex": 846
        },
        {
          "level": 3,
          "title": "3. 如何获取页面的hash变化",
          "slug": "_3-如何获取页面的hash变化",
          "normalizedTitle": "3. 如何获取页面的hash变化",
          "charIndex": 2606
        },
        {
          "level": 3,
          "title": "4. $route 和$router 的区别",
          "slug": "_4-route-和-router-的区别",
          "normalizedTitle": "4. $route 和$router 的区别",
          "charIndex": 2885
        },
        {
          "level": 3,
          "title": "5. 如何定义动态路由？如何获取传过来的动态参数？",
          "slug": "_5-如何定义动态路由-如何获取传过来的动态参数",
          "normalizedTitle": "5. 如何定义动态路由？如何获取传过来的动态参数？",
          "charIndex": 3027
        },
        {
          "level": 3,
          "title": "6. Vue-router 路由钩子在生命周期的体现",
          "slug": "_6-vue-router-路由钩子在生命周期的体现",
          "normalizedTitle": "6. vue-router 路由钩子在生命周期的体现",
          "charIndex": 4373
        },
        {
          "level": 3,
          "title": "7. Vue-router跳转和location.href有什么区别",
          "slug": "_7-vue-router跳转和location-href有什么区别",
          "normalizedTitle": "7. vue-router跳转和location.href有什么区别",
          "charIndex": 7528
        },
        {
          "level": 3,
          "title": "8. params和query的区别",
          "slug": "_8-params和query的区别",
          "normalizedTitle": "8. params和query的区别",
          "charIndex": 7830
        },
        {
          "level": 3,
          "title": "9. Vue-router 导航守卫有哪些",
          "slug": "_9-vue-router-导航守卫有哪些",
          "normalizedTitle": "9. vue-router 导航守卫有哪些",
          "charIndex": 8079
        },
        {
          "level": 3,
          "title": "10. 对前端路由的理解",
          "slug": "_10-对前端路由的理解",
          "normalizedTitle": "10. 对前端路由的理解",
          "charIndex": 8237
        }
      ],
      "headersStr": "1. Vue-Router 的懒加载如何实现 2. 路由的hash和history模式的区别 3. 如何获取页面的hash变化 4. $route 和$router 的区别 5. 如何定义动态路由？如何获取传过来的动态参数？ 6. Vue-router 路由钩子在生命周期的体现 7. Vue-router跳转和location.href有什么区别 8. params和query的区别 9. Vue-router 导航守卫有哪些 10. 对前端路由的理解",
      "content": "# 1. Vue-Router 的懒加载如何实现\n\n非懒加载：\n\nimport List from '@/components/list.vue'\nconst router = new VueRouter({\n  routes: [\n    { path: '/list', component: List }\n  ]\n})\n\n\n（1）方案一(常用)：使用箭头函数+import动态加载\n\nconst List = () => import('@/components/list.vue')\nconst router = new VueRouter({\n  routes: [\n    { path: '/list', component: List }\n  ]\n})\n\n\n（2）方案二：使用箭头函数+require动态加载\n\nconst router = new Router({\n  routes: [\n   {\n     path: '/list',\n     component: resolve => require(['@/components/list'], resolve)\n   }\n  ]\n})\n\n\n（3）方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。\n\n// r就是resolve\nconst List = r => require.ensure([], () => r(require('@/components/list')), 'list');\n// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 \nconst router = new Router({\n  routes: [\n  {\n    path: '/list',\n    component: List,\n    name: 'list'\n  }\n ]\n}))\n\n\n\n# 2. 路由的hash和history模式的区别\n\nVue-Router有两种模式：hash模式和history模式。默认的路由模式是hash模式。\n\n# 1. hash模式\n\n简介： hash模式是开发中默认的模式，它的URL带着一个#，例如：www.abc.com/#/vue，它的hash值就是#/vue。\n\n特点：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。\n\n原理： hash模式的主要原理就是onhashchange()事件：\n\nwindow.onhashchange = function(event){\n\tconsole.log(event.oldURL, event.newURL);\n\tlet hash = location.hash.slice(1);\n}\n\n\n使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。\n\n# 2. history模式\n\n简介： history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。 特点： 当使用history模式时，URL就像这样：abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。 API： history api可以分为两大部分，切换历史状态和修改历史状态：\n\n * 修改历史状态：包括了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。\n * 切换历史状态： 包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。\n\n虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。\n\n如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：\n\nconst router = new VueRouter({\n  mode: 'history',\n  routes: [...]\n})\n\n\n# 3. 两种模式对比\n\n调用 history.pushState() 相比于直接修改 hash，存在以下优势:\n\n * pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；\n * pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；\n * pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；\n * pushState() 可额外设置 title 属性供后续使用。\n * hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。\n\nhash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。\n\n\n# 3. 如何获取页面的hash变化\n\n（1）监听$route的变化\n\n// 监听,当路由发生变化的时候执行\nwatch: {\n  $route: {\n    handler: function(val, oldVal){\n      console.log(val);\n    },\n    // 深度观察监听\n    deep: true\n  }\n},\n\n\n（2）window.location.hash读取#值 window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。\n\n\n# 4. $route 和$router 的区别\n\n * $route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数\n * $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。\n\n\n# 5. 如何定义动态路由？如何获取传过来的动态参数？\n\n（1）param方式\n\n * 配置路由格式：/router/:id\n * 传递的方式：在path后面跟上对应的值\n * 传递后形成的路径：/router/123\n\n1）路由定义\n\n//在APP.vue中\n<router-link :to=\"'/user/'+userId\" replace>用户</router-link>    \n\n//在index.js\n{\n   path: '/user/:userid',\n   component: User,\n},\n\n\n2）路由跳转\n\n// 方法1：\n<router-link :to=\"{ name: 'users', params: { uname: wade }}\">按钮</router-link\n\n// 方法2：\nthis.$router.push({name:'users',params:{uname:wade}})\n\n// 方法3：\nthis.$router.push('/user/' + wade)\n\n\n3）参数获取 通过 $route.params.userid 获取传递的值\n\n（2）query方式\n\n * 配置路由格式：/router，也就是普通配置\n * 传递的方式：对象中使用query的key作为传递方式\n * 传递后形成的路径：/route?id=123\n\n1）路由定义\n\n//方式1：直接在router-link 标签上以对象的形式\n<router-link :to=\"{path:'/profile',query:{name:'why',age:28,height:188}}\">档案</router-link>\n\n// 方式2：写成按钮以点击事件形式\n<button @click='profileClick'>我的</button>    \n\nprofileClick(){\n  this.$router.push({\n    path: \"/profile\",\n    query: {\n        name: \"kobi\",\n        age: \"28\",\n        height: 198\n    }\n  });\n}\n\n\n2）跳转方法\n\n// 方法1：\n<router-link :to=\"{ name: 'users', query: { uname: james }}\">按钮</router-link>\n\n// 方法2：\nthis.$router.push({ name: 'users', query:{ uname:james }})\n\n// 方法3：\n<router-link :to=\"{ path: '/user', query: { uname:james }}\">按钮</router-link>\n\n// 方法4：\nthis.$router.push({ path: '/user', query:{ uname:james }})\n\n// 方法5：\nthis.$router.push('/user?uname=' + jsmes)\n\n\n3）获取参数\n\n通过$route.query 获取传递的值\n\n\n\n# 6. Vue-router 路由钩子在生命周期的体现\n\n一、Vue-Router导航守卫\n\n有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。 为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的\n\n 1. 全局路由钩子\n\nvue-router全局有三个路由钩子;\n\n * router.beforeEach 全局前置守卫 进入路由之前\n * router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用\n * router.afterEach 全局后置钩子 进入路由之后\n\n具体使用∶\n\n * beforeEach（判断是否登录了，没登录就跳转到登录页）\n\nrouter.beforeEach((to, from, next) => {  \n    let ifInfo = Vue.prototype.$common.getSession('userData');  // 判断是否登录的存储信息\n    if (!ifInfo) { \n        // sessionStorage里没有储存user信息    \n        if (to.path == '/') { \n            //如果是登录页面路径，就直接next()      \n            next();    \n        } else { \n            //不然就跳转到登录      \n            Message.warning(\"请重新登录！\");     \n            window.location.href = Vue.prototype.$loginUrl;    \n        }  \n    } else {    \n        return next();  \n    }\n})\n\n\n * afterEach （跳转之后滚动条回到顶部）\n\nrouter.afterEach((to, from) => {  \n    // 跳转之后滚动条回到顶部  \n    window.scrollTo(0,0);\n});\n\n\n 1. 单个路由独享钩子\n\nbeforeEnter 如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next\n\nexport default [    \n    {        \n        path: '/',        \n        name: 'login',        \n        component: login,        \n        beforeEnter: (to, from, next) => {          \n            console.log('即将进入登录页面')          \n            next()        \n        }    \n    }\n]\n\n\n 1. 组件内钩子\n\nbeforeRouteUpdate、beforeRouteEnter、beforeRouteLeave\n\n这三个钩子都有三个参数∶to、from、next\n\n * beforeRouteEnter∶ 进入组件前触发\n * beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用\n * beforeRouteLeave∶ 离开组件被调用\n\n注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：\n\nbeforeRouteEnter(to, from, next) {      \n    next(target => {        \n        if (from.path == '/classProcess') {          \n            target.isFromProcess = true        \n        }      \n    })    \n}\n\n\n二、Vue路由钩子在生命周期函数的体现\n\n 1. 完整的路由导航解析流程（不包括其他生命周期）\n\n * 触发进入其他路由。\n * 调用要离开路由的组件守卫beforeRouteLeave\n * 调用局前置守卫∶ beforeEach\n * 在重用的组件里调用 beforeRouteUpdate\n * 调用路由独享守卫 beforeEnter。\n * 解析异步路由组件。\n * 在将要进入的路由组件中调用 beforeRouteEnter\n * 调用全局解析守卫 beforeResolve\n * 导航被确认。\n * 调用全局后置钩子的 afterEach 钩子。\n * 触发DOM更新（mounted）。\n * 执行beforeRouteEnter 守卫中传给 next 的回调函数\n\n 1. 触发钩子的完整顺序\n\n路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶\n\n * beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。\n * beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。\n * beforeEnter：路由独享守卫\n * beforeRouteEnter：路由组件的组件进入路由前钩子。\n * beforeResolve：路由全局解析守卫\n * afterEach：路由全局后置钩子\n * beforeCreate：组件生命周期，不能访问tAis。\n * created;组件生命周期，可以访问tAis，不能访问dom。\n * beforeMount：组件生命周期\n * deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。\n * mounted：访问/操作dom。\n * activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。\n * 执行beforeRouteEnter回调函数next。\n\n 1. 导航行为被触发到导航完成的整个过程\n\n * 导航行为被触发，此时导航未被确认。\n * 在失活的组件里调用离开守卫 beforeRouteLeave。\n * 调用全局的 beforeEach守卫。\n * 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。\n * 在路由配置里调用 beforeEnteY。\n * 解析异步路由组件（如果有）。\n * 在被激活的组件里调用 beforeRouteEnter。\n * 调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。\n * 导航被确认。\n * 调用全局的 afterEach 钩子。\n * 非重用组件，开始组件实例的生命周期：beforeCreate&created、beforeMount&mounted\n * 触发 DOM 更新。\n * 用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。\n * 导航完成\n\n\n# 7. Vue-router跳转和location.href有什么区别\n\n * 使用 location.href= /url来跳转，简单方便，但是刷新了页面；\n * 使用 history.pushState( /url ) ，无刷新页面，静态跳转；\n * 引进 router ，然后使用 router.push( /url ) 来跳转，使用了 diff 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 history.pushState() 没什么差别的，因为vue-router就是用了 history.pushState() ，尤其是在history模式下。\n\n\n# 8. params和query的区别\n\n用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 this.$route.query.name 和 this.$route.params.name 。\n\nurl地址显示：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示\n\n注意：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。\n\n\n# 9. Vue-router 导航守卫有哪些\n\n * 全局前置/钩子：beforeEach、beforeResolve、afterEach\n * 路由独享的守卫：beforeEnter\n * 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave\n\n\n# 10. 对前端路由的理解\n\n在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。\n\n后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 SPA（单页面应用）。\n\nSPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：\n\n * SPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。\n * 由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息\n\n为了解决这个问题，前端路由出现了。\n\n前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。\n\n那么如何实现这个目的呢？首先要解决两个问题：\n\n * 当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。\n * 单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？\n\n从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：\n\n * 拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。\n * 感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。",
      "normalizedContent": "# 1. vue-router 的懒加载如何实现\n\n非懒加载：\n\nimport list from '@/components/list.vue'\nconst router = new vuerouter({\n  routes: [\n    { path: '/list', component: list }\n  ]\n})\n\n\n（1）方案一(常用)：使用箭头函数+import动态加载\n\nconst list = () => import('@/components/list.vue')\nconst router = new vuerouter({\n  routes: [\n    { path: '/list', component: list }\n  ]\n})\n\n\n（2）方案二：使用箭头函数+require动态加载\n\nconst router = new router({\n  routes: [\n   {\n     path: '/list',\n     component: resolve => require(['@/components/list'], resolve)\n   }\n  ]\n})\n\n\n（3）方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkname，会合并打包成一个js文件。\n\n// r就是resolve\nconst list = r => require.ensure([], () => r(require('@/components/list')), 'list');\n// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 \nconst router = new router({\n  routes: [\n  {\n    path: '/list',\n    component: list,\n    name: 'list'\n  }\n ]\n}))\n\n\n\n# 2. 路由的hash和history模式的区别\n\nvue-router有两种模式：hash模式和history模式。默认的路由模式是hash模式。\n\n# 1. hash模式\n\n简介： hash模式是开发中默认的模式，它的url带着一个#，例如：www.abc.com/#/vue，它的hash值就是#/vue。\n\n特点：hash值会出现在url里面，但是不会出现在http请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的ie浏览器也支持这种模式。hash路由被称为是前端路由，已经成为spa（单页面应用）的标配。\n\n原理： hash模式的主要原理就是onhashchange()事件：\n\nwindow.onhashchange = function(event){\n\tconsole.log(event.oldurl, event.newurl);\n\tlet hash = location.hash.slice(1);\n}\n\n\n使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的url都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的url关联起来了。\n\n# 2. history模式\n\n简介： history模式的url中没有#，它使用的是传统的路由分发模式，即用户在输入一个url时，服务器会接收这个请求，并解析这个url，然后做出相应的逻辑处理。 特点： 当使用history模式时，url就像这样：abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。 api： history api可以分为两大部分，切换历史状态和修改历史状态：\n\n * 修改历史状态：包括了 html5 history interface 中新增的 pushstate() 和 replacestate() 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个api。\n * 切换历史状态： 包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。\n\n虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。\n\n如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：\n\nconst router = new vuerouter({\n  mode: 'history',\n  routes: [...]\n})\n\n\n# 3. 两种模式对比\n\n调用 history.pushstate() 相比于直接修改 hash，存在以下优势:\n\n * pushstate() 设置的新 url 可以是与当前 url 同源的任意 url；而 hash 只可修改 # 后面的部分，因此只能设置与当前 url 同文档的 url；\n * pushstate() 设置的新 url 可以与当前 url 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；\n * pushstate() 通过 stateobject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；\n * pushstate() 可额外设置 title 属性供后续使用。\n * hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。\n\nhash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。\n\n\n# 3. 如何获取页面的hash变化\n\n（1）监听$route的变化\n\n// 监听,当路由发生变化的时候执行\nwatch: {\n  $route: {\n    handler: function(val, oldval){\n      console.log(val);\n    },\n    // 深度观察监听\n    deep: true\n  }\n},\n\n\n（2）window.location.hash读取#值 window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。\n\n\n# 4. $route 和$router 的区别\n\n * $route 是“路由信息对象”，包括 path，params，hash，query，fullpath，matched，name 等路由信息参数\n * $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。\n\n\n# 5. 如何定义动态路由？如何获取传过来的动态参数？\n\n（1）param方式\n\n * 配置路由格式：/router/:id\n * 传递的方式：在path后面跟上对应的值\n * 传递后形成的路径：/router/123\n\n1）路由定义\n\n//在app.vue中\n<router-link :to=\"'/user/'+userid\" replace>用户</router-link>    \n\n//在index.js\n{\n   path: '/user/:userid',\n   component: user,\n},\n\n\n2）路由跳转\n\n// 方法1：\n<router-link :to=\"{ name: 'users', params: { uname: wade }}\">按钮</router-link\n\n// 方法2：\nthis.$router.push({name:'users',params:{uname:wade}})\n\n// 方法3：\nthis.$router.push('/user/' + wade)\n\n\n3）参数获取 通过 $route.params.userid 获取传递的值\n\n（2）query方式\n\n * 配置路由格式：/router，也就是普通配置\n * 传递的方式：对象中使用query的key作为传递方式\n * 传递后形成的路径：/route?id=123\n\n1）路由定义\n\n//方式1：直接在router-link 标签上以对象的形式\n<router-link :to=\"{path:'/profile',query:{name:'why',age:28,height:188}}\">档案</router-link>\n\n// 方式2：写成按钮以点击事件形式\n<button @click='profileclick'>我的</button>    \n\nprofileclick(){\n  this.$router.push({\n    path: \"/profile\",\n    query: {\n        name: \"kobi\",\n        age: \"28\",\n        height: 198\n    }\n  });\n}\n\n\n2）跳转方法\n\n// 方法1：\n<router-link :to=\"{ name: 'users', query: { uname: james }}\">按钮</router-link>\n\n// 方法2：\nthis.$router.push({ name: 'users', query:{ uname:james }})\n\n// 方法3：\n<router-link :to=\"{ path: '/user', query: { uname:james }}\">按钮</router-link>\n\n// 方法4：\nthis.$router.push({ path: '/user', query:{ uname:james }})\n\n// 方法5：\nthis.$router.push('/user?uname=' + jsmes)\n\n\n3）获取参数\n\n通过$route.query 获取传递的值\n\n\n\n# 6. vue-router 路由钩子在生命周期的体现\n\n一、vue-router导航守卫\n\n有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。 为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的\n\n 1. 全局路由钩子\n\nvue-router全局有三个路由钩子;\n\n * router.beforeeach 全局前置守卫 进入路由之前\n * router.beforeresolve 全局解析守卫（2.5.0+）在 beforerouteenter 调用之后调用\n * router.aftereach 全局后置钩子 进入路由之后\n\n具体使用∶\n\n * beforeeach（判断是否登录了，没登录就跳转到登录页）\n\nrouter.beforeeach((to, from, next) => {  \n    let ifinfo = vue.prototype.$common.getsession('userdata');  // 判断是否登录的存储信息\n    if (!ifinfo) { \n        // sessionstorage里没有储存user信息    \n        if (to.path == '/') { \n            //如果是登录页面路径，就直接next()      \n            next();    \n        } else { \n            //不然就跳转到登录      \n            message.warning(\"请重新登录！\");     \n            window.location.href = vue.prototype.$loginurl;    \n        }  \n    } else {    \n        return next();  \n    }\n})\n\n\n * aftereach （跳转之后滚动条回到顶部）\n\nrouter.aftereach((to, from) => {  \n    // 跳转之后滚动条回到顶部  \n    window.scrollto(0,0);\n});\n\n\n 1. 单个路由独享钩子\n\nbeforeenter 如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next\n\nexport default [    \n    {        \n        path: '/',        \n        name: 'login',        \n        component: login,        \n        beforeenter: (to, from, next) => {          \n            console.log('即将进入登录页面')          \n            next()        \n        }    \n    }\n]\n\n\n 1. 组件内钩子\n\nbeforerouteupdate、beforerouteenter、beforerouteleave\n\n这三个钩子都有三个参数∶to、from、next\n\n * beforerouteenter∶ 进入组件前触发\n * beforerouteupdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用\n * beforerouteleave∶ 离开组件被调用\n\n注意点，beforerouteenter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：\n\nbeforerouteenter(to, from, next) {      \n    next(target => {        \n        if (from.path == '/classprocess') {          \n            target.isfromprocess = true        \n        }      \n    })    \n}\n\n\n二、vue路由钩子在生命周期函数的体现\n\n 1. 完整的路由导航解析流程（不包括其他生命周期）\n\n * 触发进入其他路由。\n * 调用要离开路由的组件守卫beforerouteleave\n * 调用局前置守卫∶ beforeeach\n * 在重用的组件里调用 beforerouteupdate\n * 调用路由独享守卫 beforeenter。\n * 解析异步路由组件。\n * 在将要进入的路由组件中调用 beforerouteenter\n * 调用全局解析守卫 beforeresolve\n * 导航被确认。\n * 调用全局后置钩子的 aftereach 钩子。\n * 触发dom更新（mounted）。\n * 执行beforerouteenter 守卫中传给 next 的回调函数\n\n 1. 触发钩子的完整顺序\n\n路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶\n\n * beforerouteleave：路由组件的组件离开路由前钩子，可取消路由离开。\n * beforeeach：路由全局前置守卫，可用于登录验证、全局路由loading等。\n * beforeenter：路由独享守卫\n * beforerouteenter：路由组件的组件进入路由前钩子。\n * beforeresolve：路由全局解析守卫\n * aftereach：路由全局后置钩子\n * beforecreate：组件生命周期，不能访问tais。\n * created;组件生命周期，可以访问tais，不能访问dom。\n * beforemount：组件生命周期\n * deactivated：离开缓存组件a，或者触发a的beforedestroy和destroyed组件销毁钩子。\n * mounted：访问/操作dom。\n * activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。\n * 执行beforerouteenter回调函数next。\n\n 1. 导航行为被触发到导航完成的整个过程\n\n * 导航行为被触发，此时导航未被确认。\n * 在失活的组件里调用离开守卫 beforerouteleave。\n * 调用全局的 beforeeach守卫。\n * 在重用的组件里调用 beforerouteupdate 守卫(2.2+)。\n * 在路由配置里调用 beforeentey。\n * 解析异步路由组件（如果有）。\n * 在被激活的组件里调用 beforerouteenter。\n * 调用全局的 beforeresolve 守卫（2.5+），标示解析阶段完成。\n * 导航被确认。\n * 调用全局的 aftereach 钩子。\n * 非重用组件，开始组件实例的生命周期：beforecreate&created、beforemount&mounted\n * 触发 dom 更新。\n * 用创建好的实例调用 beforerouteenter守卫中传给 next 的回调函数。\n * 导航完成\n\n\n# 7. vue-router跳转和location.href有什么区别\n\n * 使用 location.href= /url来跳转，简单方便，但是刷新了页面；\n * 使用 history.pushstate( /url ) ，无刷新页面，静态跳转；\n * 引进 router ，然后使用 router.push( /url ) 来跳转，使用了 diff 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 history.pushstate() 没什么差别的，因为vue-router就是用了 history.pushstate() ，尤其是在history模式下。\n\n\n# 8. params和query的区别\n\n用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 this.$route.query.name 和 this.$route.params.name 。\n\nurl地址显示：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示\n\n注意：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。\n\n\n# 9. vue-router 导航守卫有哪些\n\n * 全局前置/钩子：beforeeach、beforeresolve、aftereach\n * 路由独享的守卫：beforeenter\n * 组件内的守卫：beforerouteenter、beforerouteupdate、beforerouteleave\n\n\n# 10. 对前端路由的理解\n\n在前端技术早期，一个 url 对应一个页面，如果要从 a 页面切换到 b 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。\n\n后来，改变发生了——ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 spa（单页面应用）。\n\nspa极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 spa 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 url 都是一样的，这就带来了两个问题：\n\n * spa 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——spa 并不会“记住”你的操作。\n * 由于有且仅有一个 url 给页面做映射，这对 seo 也不够友好，搜索引擎无法收集全面的信息\n\n为了解决这个问题，前端路由出现了。\n\n前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 spa 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 url 上去。此时即便他刷新页面，因为当前的 url 可以标识出他所处的位置，因此内容也不会丢失。\n\n那么如何实现这个目的呢？首先要解决两个问题：\n\n * 当用户刷新页面时，浏览器会默认根据当前 url 对资源进行重新定位（发送请求）。这个动作对 spa 是不必要的，因为我们的 spa 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。\n * 单页面应用对服务端来说，就是一个url、一套资源，那么如何做到用“不同的url”来映射不同的视图内容呢？\n\n从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：\n\n * 拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。\n * 感知 url 的变化。这里不是说要改造 url、凭空制造出 n 个 url 来。而是说 url 还是那个 url，只不过我们可以给它做一些微小的处理——这些处理并不会影响 url 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 js 去给它生成不同的内容。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "路由",
      "frontmatter": {
        "title": "路由",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/frameReactRoute/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/20.react%E7%AF%87/50.%E8%B7%AF%E7%94%B1.html",
      "relativePath": "30.框架篇/20.react篇/50.路由.md",
      "key": "v-08a2d144",
      "path": "/pages/frameReactRoute/",
      "headers": [
        {
          "level": 3,
          "title": "1. React-Router的实现原理是什么？",
          "slug": "_1-react-router的实现原理是什么",
          "normalizedTitle": "1. react-router的实现原理是什么？",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 如何配置 React-Router 实现路由切换",
          "slug": "_2-如何配置-react-router-实现路由切换",
          "normalizedTitle": "2. 如何配置 react-router 实现路由切换",
          "charIndex": 441
        },
        {
          "level": 3,
          "title": "3. React-Router怎么设置重定向？",
          "slug": "_3-react-router怎么设置重定向",
          "normalizedTitle": "3. react-router怎么设置重定向？",
          "charIndex": 1545
        },
        {
          "level": 3,
          "title": "4. react-router 里的 Link 标签和 a 标签的区别",
          "slug": "_4-react-router-里的-link-标签和-a-标签的区别",
          "normalizedTitle": "4. react-router 里的 link 标签和 a 标签的区别",
          "charIndex": 1933
        },
        {
          "level": 3,
          "title": "5. React-Router如何获取URL的参数和历史对象？",
          "slug": "_5-react-router如何获取url的参数和历史对象",
          "normalizedTitle": "5. react-router如何获取url的参数和历史对象？",
          "charIndex": 2518
        },
        {
          "level": 3,
          "title": "6. React-Router 4怎样在路由变化时重新渲染同一个组件？",
          "slug": "_6-react-router-4怎样在路由变化时重新渲染同一个组件",
          "normalizedTitle": "6. react-router 4怎样在路由变化时重新渲染同一个组件？",
          "charIndex": 3272
        },
        {
          "level": 3,
          "title": "7. React-Router的路由有几种模式？",
          "slug": "_7-react-router的路由有几种模式",
          "normalizedTitle": "7. react-router的路由有几种模式？",
          "charIndex": 3894
        },
        {
          "level": 3,
          "title": "8. React-Router 4的Switch有什么用？",
          "slug": "_8-react-router-4的switch有什么用",
          "normalizedTitle": "8. react-router 4的switch有什么用？",
          "charIndex": 5580
        }
      ],
      "headersStr": "1. React-Router的实现原理是什么？ 2. 如何配置 React-Router 实现路由切换 3. React-Router怎么设置重定向？ 4. react-router 里的 Link 标签和 a 标签的区别 5. React-Router如何获取URL的参数和历史对象？ 6. React-Router 4怎样在路由变化时重新渲染同一个组件？ 7. React-Router的路由有几种模式？ 8. React-Router 4的Switch有什么用？",
      "content": "# 1. React-Router的实现原理是什么？\n\n客户端路由实现的思想：\n\n * 基于 hash 的路由：通过监听\n   \n   hashchange\n   \n   \n   事件，感知 hash 的变化\n   \n   * 改变 hash 可以直接通过 location.hash=xxx\n\n * 基于 H5 history 路由：\n   \n   * 改变 url 可以通过 history.pushState 和 resplaceState 等，会将URL压入堆栈，同时能够应用 history.go() 等 API\n   * 监听 url 的变化可以通过自定义事件触发实现\n\nreact-router 实现的思想：\n\n * 基于 history 库来实现上述不同的客户端路由实现思想，并且能够保存历史记录等，磨平浏览器差异，上层无感知\n * 通过维护的列表，在每次 URL 发生变化的回收，通过配置的 路由路径，匹配到对应的 Component，并且 render\n\n\n# 2. 如何配置 React-Router 实现路由切换\n\n（1）使用<Route> 组件\n\n路由匹配是通过比较 <Route> 的 path 属性和当前地址的 pathname 来实现的。当一个 <Route> 匹配成功时，它将渲染其内容，当它不匹配时就会渲染 null。没有路径的 <Route> 将始终被匹配。\n\n// when location = { pathname: '/about' }\n<Route path='/about' component={About}/> // renders <About/>\n<Route path='/contact' component={Contact}/> // renders null\n<Route component={Always}/> // renders <Always/>\n\n\n（2）结合使用 <Switch> 组件和 <Route> 组件\n\n<Switch> 用于将 <Route> 分组。\n\n<Switch>\n    <Route exact path=\"/\" component={Home} />\n    <Route path=\"/about\" component={About} />\n    <Route path=\"/contact\" component={Contact} />\n</Switch>\n\n\n<Switch> 不是分组 <Route> 所必须的，但他通常很有用。 一个 <Switch> 会遍历其所有的子 <Route>元素，并仅渲染与当前地址匹配的第一个元素。\n\n（3）使用 <Link>、 <NavLink>、<Redirect> 组件\n\n<Link> 组件来在你的应用程序中创建链接。无论你在何处渲染一个<Link> ，都会在应用程序的 HTML 中渲染锚（<a>）。\n\n<Link to=\"/\">Home</Link>   \n// <a href='/'>Home</a>\n\n\n是一种特殊类型的 当它的 to属性与当前地址匹配时，可以将其定义为\"活跃的\"。\n\n// location = { pathname: '/react' }\n<NavLink to=\"/react\" activeClassName=\"hurray\">\n    React\n</NavLink>\n// <a href='/react' className='hurray'>React</a>\n\n\n当我们想强制导航时，可以渲染一个<Redirect>，当一个<Redirect>渲染时，它将使用它的to属性进行定向。\n\n\n# 3. React-Router怎么设置重定向？\n\n使用<Redirect>组件实现路由的重定向：\n\n<Switch>\n  <Redirect from='/users/:id' to='/users/profile/:id'/>\n  <Route path='/users/profile/:id' component={Profile}/>\n</Switch>\n\n\n当请求 /users/:id 被重定向去 '/users/profile/:id'：\n\n * 属性 from: string：需要匹配的将要被重定向路径。\n * 属性 to: string：重定向的 URL 字符串\n * 属性 to: object：重定向的 location 对象\n * 属性 push: bool：若为真，重定向操作将会把新地址加入到访问历史记录里面，并且无法回退到前面的页面。\n\n\n# 4. react-router 里的 Link 标签和 a 标签的区别\n\n从最终渲染的 DOM 来看，这两者都是链接，都是 标签，区别是∶ <Link>是react-router 里实现路由跳转的链接，一般配合<Route> 使用，react-router接管了其默认的链接跳转行为，区别于传统的页面跳转，<Link> 的“跳转”行为只会触发相匹配的<Route>对应的页面内容更新，而不会刷新整个页面。\n\n<Link>做了3件事情:\n\n * 有onclick那就执行onclick\n * click的时候阻止a标签默认事件\n * 根据跳转href(即是to)，用history (web前端路由两种方式之一，history & hash)跳转，此时只是链接变了，并没有刷新页面而<a>标签就是普通的超链接了，用于从当前页面跳转到href指向的另一 个页面(非锚点情况)。\n\na标签默认事件禁掉之后做了什么才实现了跳转?\n\nlet domArr = document.getElementsByTagName('a')\n[...domArr].forEach(item=>{\n    item.addEventListener('click',function () {\n        location.href = this.href\n    })\n})\n\n\n\n# 5. React-Router如何获取URL的参数和历史对象？\n\n（1）获取URL的参数\n\n * get传值\n\n路由配置还是普通的配置，如：'admin'，传参方式如：'admin?id='1111''。通过this.props.location.search获取url获取到一个字符串'?id='1111' 可以用url，qs，querystring，浏览器提供的api URLSearchParams对象或者自己封装的方法去解析出id的值。\n\n * 动态路由传值\n\n路由需要配置成动态路由：如path='/admin/:id'，传参方式，如'admin/111'。通过this.props.match.params.id 取得url中的动态路由id部分的值，除此之外还可以通过useParams（Hooks）来获取\n\n * 通过query或state传值\n\n传参方式如：在Link组件的to属性中可以传递对象{pathname:'/admin',query:'111',state:'111'};。通过this.props.location.state或this.props.location.query来获取即可，传递的参数可以是对象、数组等，但是存在缺点就是只要刷新页面，参数就会丢失。\n\n（2）获取历史对象\n\n * 如果React >= 16.8 时可以使用 React Router中提供的Hooks\n\nimport { useHistory } from \"react-router-dom\";\nlet history = useHistory();\n\n\n2.使用this.props.history获取历史对象\n\nlet history = this.props.history;\n\n\n\n# 6. React-Router 4怎样在路由变化时重新渲染同一个组件？\n\n当路由变化时，即组件的props发生了变化，会调用componentWillReceiveProps等生命周期钩子。那需要做的只是： 当路由改变时，根据路由，也去请求数据：\n\nclass NewsList extends Component {\n  componentDidMount () {\n     this.fetchData(this.props.location);\n  }\n  \n  fetchData(location) {\n    const type = location.pathname.replace('/', '') || 'top'\n    this.props.dispatch(fetchListData(type))\n  }\n  componentWillReceiveProps(nextProps) {\n     if (nextProps.location.pathname != this.props.location.pathname) {\n         this.fetchData(nextProps.location);\n     } \n  }\n  render () {\n    ...\n  }\n}\n\n\n利用生命周期componentWillReceiveProps，进行重新render的预处理操作。\n\n\n# 7. React-Router的路由有几种模式？\n\nReact-Router 支持使用 hash（对应 HashRouter）和 browser（对应 BrowserRouter） 两种路由规则， react-router-dom 提供了 BrowserRouter 和 HashRouter 两个组件来实现应用的 UI 和 URL 同步：\n\n * BrowserRouter 创建的 URL 格式：xxx.com/path\n * HashRouter 创建的 URL 格式：xxx.com/#/path\n\n（1）BrowserRouter\n\n它使用 HTML5 提供的 history API（pushState、replaceState 和 popstate 事件）来保持 UI 和 URL 的同步。由此可以看出，BrowserRouter 是使用 HTML 5 的 history API 来控制路由跳转的：\n\n<BrowserRouter\n    basename={string}\n    forceRefresh={bool}\n    getUserConfirmation={func}\n    keyLength={number}\n/>\n\n\n其中的属性如下：\n\n * basename 所有路由的基准 URL。basename 的正确格式是前面有一个前导斜杠，但不能有尾部斜杠；\n\n<BrowserRouter basename=\"/calendar\">\n    <Link to=\"/today\" />\n</BrowserRouter>\n\n\n等同于\n\n<a href=\"/calendar/today\" />\n\n\n * forceRefresh 如果为 true，在导航的过程中整个页面将会刷新。一般情况下，只有在不支持 HTML5 history API 的浏览器中使用此功能；\n * getUserConfirmation 用于确认导航的函数，默认使用 window.confirm。例如，当从 /a 导航至 /b 时，会使用默认的 confirm 函数弹出一个提示，用户点击确定后才进行导航，否则不做任何处理；\n\n// 这是默认的确认函数\nconst getConfirmation = (message, callback) => {\n  const allowTransition = window.confirm(message);\n  callback(allowTransition);\n}\n<BrowserRouter getUserConfirmation={getConfirmation} />\n\n\n> 需要配合<Prompt> 一起使用。\n\n * KeyLength 用来设置 Location.Key 的长度。\n\n（2）HashRouter\n\n使用 URL 的 hash 部分（即 window.location.hash）来保持 UI 和 URL 的同步。由此可以看出，HashRouter 是通过 URL 的 hash 属性来控制路由跳转的：\n\n<HashRouter\n    basename={string}\n    getUserConfirmation={func}\n    hashType={string}  \n/>\n\n\n其参数如下：\n\n * basename, getUserConfirmation 和 BrowserRouter 功能一样；\n * hashType window.location.hash 使用的 hash 类型，有如下几种：\n   * slash - 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops；\n   * noslash - 后面没有斜杠，例如 # 和 #sunshine/lollipops；\n   * hashbang - Google 风格的 ajax crawlable，例如 #!/ 和 #!/sunshine/lollipops。\n\n\n# 8. React-Router 4的Switch有什么用？\n\nSwitch 通常被用来包裹 Route，用于渲染与路径匹配的第一个子 <Route> 或 <Redirect>，它里面不能放其他元素。\n\n假如不加 <Switch> ：\n\nimport { Route } from 'react-router-dom'\n\n<Route path=\"/\" component={Home}></Route>\n<Route path=\"/login\" component={Login}></Route>\n\n\nRoute 组件的 path 属性用于匹配路径，因为需要匹配 / 到 Home，匹配 /login 到 Login，所以需要两个 Route，但是不能这么写。这样写的话，当 URL 的 path 为 “/login” 时，<Route path=\"/\" />和<Route path=\"/login\" /> 都会被匹配，因此页面会展示 Home 和 Login 两个组件。这时就需要借助 <Switch> 来做到只显示一个匹配组件：\n\nimport { Switch, Route} from 'react-router-dom'\n    \n<Switch>\n    <Route path=\"/\" component={Home}></Route>\n    <Route path=\"/login\" component={Login}></Route>\n</Switch>\n\n\n此时，再访问 “/login” 路径时，却只显示了 Home 组件。这是就用到了exact属性，它的作用就是精确匹配路径，经常与<Switch> 联合使用。只有当 URL 和该 <Route> 的 path 属性完全一致的情况下才能匹配上：\n\nimport { Switch, Route} from 'react-router-dom'\n   \n<Switch>\n   <Route exact path=\"/\" component={Home}></Route>\n   <Route exact path=\"/login\" component={Login}></Route>\n</Switch>\n",
      "normalizedContent": "# 1. react-router的实现原理是什么？\n\n客户端路由实现的思想：\n\n * 基于 hash 的路由：通过监听\n   \n   hashchange\n   \n   \n   事件，感知 hash 的变化\n   \n   * 改变 hash 可以直接通过 location.hash=xxx\n\n * 基于 h5 history 路由：\n   \n   * 改变 url 可以通过 history.pushstate 和 resplacestate 等，会将url压入堆栈，同时能够应用 history.go() 等 api\n   * 监听 url 的变化可以通过自定义事件触发实现\n\nreact-router 实现的思想：\n\n * 基于 history 库来实现上述不同的客户端路由实现思想，并且能够保存历史记录等，磨平浏览器差异，上层无感知\n * 通过维护的列表，在每次 url 发生变化的回收，通过配置的 路由路径，匹配到对应的 component，并且 render\n\n\n# 2. 如何配置 react-router 实现路由切换\n\n（1）使用<route> 组件\n\n路由匹配是通过比较 <route> 的 path 属性和当前地址的 pathname 来实现的。当一个 <route> 匹配成功时，它将渲染其内容，当它不匹配时就会渲染 null。没有路径的 <route> 将始终被匹配。\n\n// when location = { pathname: '/about' }\n<route path='/about' component={about}/> // renders <about/>\n<route path='/contact' component={contact}/> // renders null\n<route component={always}/> // renders <always/>\n\n\n（2）结合使用 <switch> 组件和 <route> 组件\n\n<switch> 用于将 <route> 分组。\n\n<switch>\n    <route exact path=\"/\" component={home} />\n    <route path=\"/about\" component={about} />\n    <route path=\"/contact\" component={contact} />\n</switch>\n\n\n<switch> 不是分组 <route> 所必须的，但他通常很有用。 一个 <switch> 会遍历其所有的子 <route>元素，并仅渲染与当前地址匹配的第一个元素。\n\n（3）使用 <link>、 <navlink>、<redirect> 组件\n\n<link> 组件来在你的应用程序中创建链接。无论你在何处渲染一个<link> ，都会在应用程序的 html 中渲染锚（<a>）。\n\n<link to=\"/\">home</link>   \n// <a href='/'>home</a>\n\n\n是一种特殊类型的 当它的 to属性与当前地址匹配时，可以将其定义为\"活跃的\"。\n\n// location = { pathname: '/react' }\n<navlink to=\"/react\" activeclassname=\"hurray\">\n    react\n</navlink>\n// <a href='/react' classname='hurray'>react</a>\n\n\n当我们想强制导航时，可以渲染一个<redirect>，当一个<redirect>渲染时，它将使用它的to属性进行定向。\n\n\n# 3. react-router怎么设置重定向？\n\n使用<redirect>组件实现路由的重定向：\n\n<switch>\n  <redirect from='/users/:id' to='/users/profile/:id'/>\n  <route path='/users/profile/:id' component={profile}/>\n</switch>\n\n\n当请求 /users/:id 被重定向去 '/users/profile/:id'：\n\n * 属性 from: string：需要匹配的将要被重定向路径。\n * 属性 to: string：重定向的 url 字符串\n * 属性 to: object：重定向的 location 对象\n * 属性 push: bool：若为真，重定向操作将会把新地址加入到访问历史记录里面，并且无法回退到前面的页面。\n\n\n# 4. react-router 里的 link 标签和 a 标签的区别\n\n从最终渲染的 dom 来看，这两者都是链接，都是 标签，区别是∶ <link>是react-router 里实现路由跳转的链接，一般配合<route> 使用，react-router接管了其默认的链接跳转行为，区别于传统的页面跳转，<link> 的“跳转”行为只会触发相匹配的<route>对应的页面内容更新，而不会刷新整个页面。\n\n<link>做了3件事情:\n\n * 有onclick那就执行onclick\n * click的时候阻止a标签默认事件\n * 根据跳转href(即是to)，用history (web前端路由两种方式之一，history & hash)跳转，此时只是链接变了，并没有刷新页面而<a>标签就是普通的超链接了，用于从当前页面跳转到href指向的另一 个页面(非锚点情况)。\n\na标签默认事件禁掉之后做了什么才实现了跳转?\n\nlet domarr = document.getelementsbytagname('a')\n[...domarr].foreach(item=>{\n    item.addeventlistener('click',function () {\n        location.href = this.href\n    })\n})\n\n\n\n# 5. react-router如何获取url的参数和历史对象？\n\n（1）获取url的参数\n\n * get传值\n\n路由配置还是普通的配置，如：'admin'，传参方式如：'admin?id='1111''。通过this.props.location.search获取url获取到一个字符串'?id='1111' 可以用url，qs，querystring，浏览器提供的api urlsearchparams对象或者自己封装的方法去解析出id的值。\n\n * 动态路由传值\n\n路由需要配置成动态路由：如path='/admin/:id'，传参方式，如'admin/111'。通过this.props.match.params.id 取得url中的动态路由id部分的值，除此之外还可以通过useparams（hooks）来获取\n\n * 通过query或state传值\n\n传参方式如：在link组件的to属性中可以传递对象{pathname:'/admin',query:'111',state:'111'};。通过this.props.location.state或this.props.location.query来获取即可，传递的参数可以是对象、数组等，但是存在缺点就是只要刷新页面，参数就会丢失。\n\n（2）获取历史对象\n\n * 如果react >= 16.8 时可以使用 react router中提供的hooks\n\nimport { usehistory } from \"react-router-dom\";\nlet history = usehistory();\n\n\n2.使用this.props.history获取历史对象\n\nlet history = this.props.history;\n\n\n\n# 6. react-router 4怎样在路由变化时重新渲染同一个组件？\n\n当路由变化时，即组件的props发生了变化，会调用componentwillreceiveprops等生命周期钩子。那需要做的只是： 当路由改变时，根据路由，也去请求数据：\n\nclass newslist extends component {\n  componentdidmount () {\n     this.fetchdata(this.props.location);\n  }\n  \n  fetchdata(location) {\n    const type = location.pathname.replace('/', '') || 'top'\n    this.props.dispatch(fetchlistdata(type))\n  }\n  componentwillreceiveprops(nextprops) {\n     if (nextprops.location.pathname != this.props.location.pathname) {\n         this.fetchdata(nextprops.location);\n     } \n  }\n  render () {\n    ...\n  }\n}\n\n\n利用生命周期componentwillreceiveprops，进行重新render的预处理操作。\n\n\n# 7. react-router的路由有几种模式？\n\nreact-router 支持使用 hash（对应 hashrouter）和 browser（对应 browserrouter） 两种路由规则， react-router-dom 提供了 browserrouter 和 hashrouter 两个组件来实现应用的 ui 和 url 同步：\n\n * browserrouter 创建的 url 格式：xxx.com/path\n * hashrouter 创建的 url 格式：xxx.com/#/path\n\n（1）browserrouter\n\n它使用 html5 提供的 history api（pushstate、replacestate 和 popstate 事件）来保持 ui 和 url 的同步。由此可以看出，browserrouter 是使用 html 5 的 history api 来控制路由跳转的：\n\n<browserrouter\n    basename={string}\n    forcerefresh={bool}\n    getuserconfirmation={func}\n    keylength={number}\n/>\n\n\n其中的属性如下：\n\n * basename 所有路由的基准 url。basename 的正确格式是前面有一个前导斜杠，但不能有尾部斜杠；\n\n<browserrouter basename=\"/calendar\">\n    <link to=\"/today\" />\n</browserrouter>\n\n\n等同于\n\n<a href=\"/calendar/today\" />\n\n\n * forcerefresh 如果为 true，在导航的过程中整个页面将会刷新。一般情况下，只有在不支持 html5 history api 的浏览器中使用此功能；\n * getuserconfirmation 用于确认导航的函数，默认使用 window.confirm。例如，当从 /a 导航至 /b 时，会使用默认的 confirm 函数弹出一个提示，用户点击确定后才进行导航，否则不做任何处理；\n\n// 这是默认的确认函数\nconst getconfirmation = (message, callback) => {\n  const allowtransition = window.confirm(message);\n  callback(allowtransition);\n}\n<browserrouter getuserconfirmation={getconfirmation} />\n\n\n> 需要配合<prompt> 一起使用。\n\n * keylength 用来设置 location.key 的长度。\n\n（2）hashrouter\n\n使用 url 的 hash 部分（即 window.location.hash）来保持 ui 和 url 的同步。由此可以看出，hashrouter 是通过 url 的 hash 属性来控制路由跳转的：\n\n<hashrouter\n    basename={string}\n    getuserconfirmation={func}\n    hashtype={string}  \n/>\n\n\n其参数如下：\n\n * basename, getuserconfirmation 和 browserrouter 功能一样；\n * hashtype window.location.hash 使用的 hash 类型，有如下几种：\n   * slash - 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops；\n   * noslash - 后面没有斜杠，例如 # 和 #sunshine/lollipops；\n   * hashbang - google 风格的 ajax crawlable，例如 #!/ 和 #!/sunshine/lollipops。\n\n\n# 8. react-router 4的switch有什么用？\n\nswitch 通常被用来包裹 route，用于渲染与路径匹配的第一个子 <route> 或 <redirect>，它里面不能放其他元素。\n\n假如不加 <switch> ：\n\nimport { route } from 'react-router-dom'\n\n<route path=\"/\" component={home}></route>\n<route path=\"/login\" component={login}></route>\n\n\nroute 组件的 path 属性用于匹配路径，因为需要匹配 / 到 home，匹配 /login 到 login，所以需要两个 route，但是不能这么写。这样写的话，当 url 的 path 为 “/login” 时，<route path=\"/\" />和<route path=\"/login\" /> 都会被匹配，因此页面会展示 home 和 login 两个组件。这时就需要借助 <switch> 来做到只显示一个匹配组件：\n\nimport { switch, route} from 'react-router-dom'\n    \n<switch>\n    <route path=\"/\" component={home}></route>\n    <route path=\"/login\" component={login}></route>\n</switch>\n\n\n此时，再访问 “/login” 路径时，却只显示了 home 组件。这是就用到了exact属性，它的作用就是精确匹配路径，经常与<switch> 联合使用。只有当 url 和该 <route> 的 path 属性完全一致的情况下才能匹配上：\n\nimport { switch, route} from 'react-router-dom'\n   \n<switch>\n   <route exact path=\"/\" component={home}></route>\n   <route exact path=\"/login\" component={login}></route>\n</switch>\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "Hooks",
      "frontmatter": {
        "title": "Hooks",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/frameHooks/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/20.react%E7%AF%87/70.Hooks.html",
      "relativePath": "30.框架篇/20.react篇/70.Hooks.md",
      "key": "v-397b3b1e",
      "path": "/pages/frameHooks/",
      "headers": [
        {
          "level": 3,
          "title": "1. 对 React Hook 的理解，它的实现原理是什么",
          "slug": "_1-对-react-hook-的理解-它的实现原理是什么",
          "normalizedTitle": "1. 对 react hook 的理解，它的实现原理是什么",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 为什么 useState 要使用数组而不是对象",
          "slug": "_2-为什么-usestate-要使用数组而不是对象",
          "normalizedTitle": "2. 为什么 usestate 要使用数组而不是对象",
          "charIndex": 2041
        },
        {
          "level": 3,
          "title": "3. React Hooks 解决了哪些问题？",
          "slug": "_3-react-hooks-解决了哪些问题",
          "normalizedTitle": "3. react hooks 解决了哪些问题？",
          "charIndex": 2920
        },
        {
          "level": 3,
          "title": "4. React Hook 的使用限制有哪些？",
          "slug": "_4-react-hook-的使用限制有哪些",
          "normalizedTitle": "4. react hook 的使用限制有哪些？",
          "charIndex": 4161
        },
        {
          "level": 3,
          "title": "5. useEffect 与 useLayoutEffect 的区别",
          "slug": "_5-useeffect-与-uselayouteffect-的区别",
          "normalizedTitle": "5. useeffect 与 uselayouteffect 的区别",
          "charIndex": 4774
        },
        {
          "level": 3,
          "title": "6. React Hooks在平时开发中需要注意的问题和原因",
          "slug": "_6-react-hooks在平时开发中需要注意的问题和原因",
          "normalizedTitle": "6. react hooks在平时开发中需要注意的问题和原因",
          "charIndex": 5496
        },
        {
          "level": 3,
          "title": "7. React Hooks 和生命周期的关系？",
          "slug": "_7-react-hooks-和生命周期的关系",
          "normalizedTitle": "7. react hooks 和生命周期的关系？",
          "charIndex": 7535
        }
      ],
      "headersStr": "1. 对 React Hook 的理解，它的实现原理是什么 2. 为什么 useState 要使用数组而不是对象 3. React Hooks 解决了哪些问题？ 4. React Hook 的使用限制有哪些？ 5. useEffect 与 useLayoutEffect 的区别 6. React Hooks在平时开发中需要注意的问题和原因 7. React Hooks 和生命周期的关系？",
      "content": "# 1. 对 React Hook 的理解，它的实现原理是什么\n\nReact-Hooks 是 React 团队在 React 组件开发实践中，逐渐认知到的一个改进点，这背后其实涉及对类组件和函数组件两种组件形式的思考和侧重。\n\n（1）类组件： 所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件。以下是一个类组件：\n\nclass DemoClass extends React.Component {\n  state = {\n    text: \"\"\n  };\n  componentDidMount() {\n    //...\n  }\n  changeText = (newText) => {\n    this.setState({\n      text: newText\n    });\n  };\n\n  render() {\n    return (\n      <div className=\"demoClass\">\n        <p>{this.state.text}</p>\n        <button onClick={this.changeText}>修改</button>\n      </div>\n    );\n  }\n}\n\n\n\n可以看出，React 类组件内部预置了相当多的“现成的东西”等着我们去调度/定制，state 和生命周期就是这些“现成东西”中的典型。要想得到这些东西，难度也不大，只需要继承一个 React.Component 即可。\n\n当然，这也是类组件的一个不便，它太繁杂了，对于解决许多问题来说，编写一个类组件实在是一个过于复杂的姿势。复杂的姿势必然带来高昂的理解成本，这也是我们所不想看到的。除此之外，由于开发者编写的逻辑在封装后是和组件粘在一起的，这就使得类组件内部的逻辑难以实现拆分和复用。\n\n（2）函数组件：函数组件就是以函数的形态存在的 React 组件。早期并没有 React-Hooks，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件”。以下是一个函数组件：\n\nfunction DemoFunction(props) {\n  const { text } = props\n  return (\n    <div className=\"demoFunction\">\n      <p>{`函数组件接收的内容：[${text}]`}</p>\n    </div>\n  );\n}\n\n\n相比于类组件，函数组件肉眼可见的特质自然包括轻量、灵活、易于组织和维护、较低的学习成本等。\n\n通过对比，从形态上可以对两种组件做区分，它们之间的区别如下：\n\n * 类组件需要继承 class，函数组件不需要；\n * 类组件可以访问生命周期方法，函数组件不能；\n * 类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；\n * 类组件中可以定义并维护 state（状态），而函数组件不可以；\n\n除此之外，还有一些其他的不同。通过上面的区别，我们不能说谁好谁坏，它们各有自己的优势。在 React-Hooks 出现之前，类组件的能力边界明显强于函数组件。\n\n实际上，类组件和函数组件之间，是面向对象和函数式编程这两套不同的设计思想之间的差异。而函数组件更加契合 React 框架的设计理念： React 组件本身的定位就是函数，一个输入数据、输出 UI 的函数。作为开发者，我们编写的是声明式的代码，而 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用户可见的 UI 变化中去。这就意味着从原则上来讲，React 的数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点。函数组件就真正地将数据和渲染绑定到了一起。函数组件是一个更加匹配其设计理念、也更有利于逻辑拆分与重用的组件表达形式。\n\n为了能让开发者更好的的去编写函数式组件。于是，React-Hooks 便应运而生。\n\nReact-Hooks 是一套能够使函数组件更强大、更灵活的“钩子”。\n\n函数组件比起类组件少了很多东西，比如生命周期、对 state 的管理等。这就给函数组件的使用带来了非常多的局限性，导致我们并不能使用函数这种形式，写出一个真正的全功能的组件。而React-Hooks 的出现，就是为了帮助函数组件补齐这些（相对于类组件来说）缺失的能力。\n\n如果说函数组件是一台轻巧的快艇，那么 React-Hooks 就是一个内容丰富的零部件箱。“重装战舰”所预置的那些设备，这个箱子里基本全都有，同时它还不强制你全都要，而是允许你自由地选择和使用你需要的那些能力，然后将这些能力以 Hook（钩子）的形式“钩”进你的组件里，从而定制出一个最适合你的“专属战舰”。\n\n\n# 2. 为什么 useState 要使用数组而不是对象\n\nuseState 的用法：\n\nconst [count, setCount] = useState(0)\n\n\n可以看到 useState 返回的是一个数组，那么为什么是返回数组而不是返回对象呢？\n\n这里用到了解构赋值，所以先来看一下ES6 的解构赋值：\n\n# 数组的解构赋值\n\nconst foo = [1, 2, 3];\nconst [one, two, three] = foo;\nconsole.log(one);\t// 1\nconsole.log(two);\t// 2\nconsole.log(three);\t// 3\n\n\n# 对象的解构赋值\n\nconst user = {\n  id: 888,\n  name: \"xiaoxin\"\n};\nconst { id, name } = user;\nconsole.log(id);\t// 888\nconsole.log(name);\t// \"xiaoxin\"\n\n\n看完这两个例子，答案应该就出来了：\n\n * 如果 useState 返回的是数组，那么使用者可以对数组中的元素命名，代码看起来也比较干净\n * 如果 useState 返回的是对象，在解构对象的时候必须要和 useState 内部实现返回的对象同名，想要使用多次的话，必须得设置别名才能使用返回值\n\n下面来看看如果 useState 返回对象的情况：\n\n// 第一次使用\nconst { state, setState } = useState(false);\n// 第二次使用\nconst { state: counter, setState: setCounter } = useState(0) \n\n\n这里可以看到，返回对象的使用方式还是挺麻烦的，更何况实际项目中会使用的更频繁。 **总结：*useState 返回的是 array 而不是 object 的原因就是为了*降低使用的复杂度，返回数组的话可以直接根据顺序解构，而返回对象的话要想使用多次就需要定义别名了。\n\n\n# 3. React Hooks 解决了哪些问题？\n\nReact Hooks 主要解决了以下问题：\n\n（1）在组件之间复用状态逻辑很难\n\nReact 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）解决此类问题可以使用 render props 和 高阶组件。但是这类方案需要重新组织组件结构，这可能会很麻烦，并且会使代码难以理解。由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。尽管可以在 DevTools 过滤掉它们，但这说明了一个更深层次的问题：React 需要为共享状态逻辑提供更好的原生途径。\n\n可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使我们在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。\n\n（2）复杂组件变得难以理解\n\n在组件中，每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。\n\n在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。\n\n为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。\n\n（3）难以理解的 class\n\n除了代码复用和代码管理会遇到困难外，class 是学习 React 的一大屏障。我们必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。没有稳定的语法提案，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。即便在有经验的 React 开发者之间，对于函数组件与 class 组件的差异也存在分歧，甚至还要区分两种组件的使用场景。\n\n为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术\n\n\n# 4. React Hook 的使用限制有哪些？\n\nReact Hooks 的限制主要有两条：\n\n * 不要在循环、条件或嵌套函数中调用 Hook；\n * 在 React 的函数组件中调用 Hook。\n\n那为什么会有这样的限制呢？Hooks 的设计初衷是为了改进 React 组件的开发模式。在旧有的开发模式下遇到了三个问题。\n\n * 组件之间难以复用状态逻辑。过去常见的解决方案是高阶组件、render props 及状态管理框架。\n * 复杂的组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致关联部分难以拆分。\n * 人和机器都很容易混淆类。常见的有 this 的问题，但在 React 团队中还有类难以优化的问题，希望在编译优化层面做出一些改进。\n\n这三个问题在一定程度上阻碍了 React 的后续发展，所以为了解决这三个问题，Hooks 基于函数组件开始设计。然而第三个问题决定了 Hooks 只支持函数组件。\n\n那为什么不要在循环、条件或嵌套函数中调用 Hook 呢？因为 Hooks 的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。当然，实质上 React 的源码里不是数组，是链表。\n\n这些限制会在编码上造成一定程度的心智负担，新手可能会写错，为了避免这样的情况，可以引入 ESLint 的 Hooks 检查插件进行预防。\n\n\n# 5. useEffect 与 useLayoutEffect 的区别\n\n（1）共同点\n\n * 运用效果： useEffect 与 useLayoutEffect 两者都是用于处理副作用，这些副作用包括改变 DOM、设置订阅、操作定时器等。在函数组件内部操作副作用是不被允许的，所以需要使用这两个函数去处理。\n * 使用方式： useEffect 与 useLayoutEffect 两者底层的函数签名是完全一致的，都是调用的 mountEffectImpl方法，在使用上也没什么差异，基本可以直接替换。\n\n（2）不同点\n\n * 使用场景： useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景；而 useLayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 useLayoutEffect 做计算量较大的耗时任务从而造成阻塞。\n * 使用效果： useEffect是按照顺序执行代码的，改变屏幕像素之后执行（先渲染，后改变DOM），当改变屏幕内容时可能会产生闪烁；useLayoutEffect是改变屏幕像素之前就执行了（会推迟页面显示的事件，先改变DOM后渲染），不会产生闪烁。useLayoutEffect总是比useEffect先执行。\n\n在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可。\n\n\n# 6. React Hooks在平时开发中需要注意的问题和原因\n\n（1）不要在循环，条件或嵌套函数中调用Hook，必须始终在 React函数的顶层使用Hook\n\n这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。\n\n（2）使用useState时候，使用push，pop，splice等直接更改数组对象的坑\n\n使用push直接更改数组无法获取到新值，应该采用析构方式，但是在class里面不会有这个问题。代码示例：\n\nfunction Indicatorfilter() {\n  let [num,setNums] = useState([0,1,2,3])\n  const test = () => {\n    // 这里坑是直接采用push去更新num\n    // setNums(num)是无法更新num的\n    // 必须使用num = [...num ,1]\n    num.push(1)\n    // num = [...num ,1]\n    setNums(num)\n  }\nreturn (\n    <div className='filter'>\n      <div onClick={test}>测试</div>\n        <div>\n          {num.map((item,index) => (\n              <div key={index}>{item}</div>\n          ))}\n      </div>\n    </div>\n  )\n}\n\nclass Indicatorfilter extends React.Component<any,any>{\n  constructor(props:any){\n      super(props)\n      this.state = {\n          nums:[1,2,3]\n      }\n      this.test = this.test.bind(this)\n  }\n\n  test(){\n      // class采用同样的方式是没有问题的\n      this.state.nums.push(1)\n      this.setState({\n          nums: this.state.nums\n      })\n  }\n\n  render(){\n      let {nums} = this.state\n      return(\n          <div>\n              <div onClick={this.test}>测试</div>\n                  <div>\n                      {nums.map((item:any,index:number) => (\n                          <div key={index}>{item}</div>\n                      ))}\n                  </div>\n          </div>\n\n      )\n  }\n}\n\n\n（3）useState设置状态的时候，只有第一次生效，后期需要更新状态，必须通过useEffect\n\nTableDeail是一个公共组件，在调用它的父组件里面，我们通过set改变columns的值，以为传递给TableDeail 的 columns是最新的值，所以tabColumn每次也是最新的值，但是实际tabColumn是最开始的值，不会随着columns的更新而更新：\n\nconst TableDeail = ({\n    columns,\n}:TableData) => {\n    const [tabColumn, setTabColumn] = useState(columns) \n}\n\n// 正确的做法是通过useEffect改变这个值\nconst TableDeail = ({\n    columns,\n}:TableData) => {\n    const [tabColumn, setTabColumn] = useState(columns) \n    useEffect(() =>{setTabColumn(columns)},[columns])\n}\n\n\n\n（4）善用useCallback\n\n父组件传递给子组件事件句柄时，如果我们没有任何参数变动可能会选用useMemo。但是每一次父组件渲染子组件即使没变化也会跟着渲染一次。\n\n（5）不要滥用useContext\n\n可以使用基于 useContext 封装的状态管理工具。\n\n\n# 7. React Hooks 和生命周期的关系？\n\n函数组件 的本质是函数，没有 state 的概念的，因此不存在生命周期一说，仅仅是一个 render 函数而已。 但是引入 Hooks 之后就变得不同了，它能让组件在不使用 class 的情况下拥有 state，所以就有了生命周期的概念，所谓的生命周期其实就是 useState、 useEffect() 和 useLayoutEffect() 。\n\n即：Hooks 组件（使用了Hooks的函数组件）有生命周期，而函数组件（未使用Hooks的函数组件）是没有生命周期的。\n\n下面是具体的 class 与 Hooks 的生命周期对应关系：\n\n * constructor：函数组件不需要构造函数，可以通过调用 **useState 来初始化 state**。如果计算的代价比较昂贵，也可以传一个函数给 useState。\n\nconst [num, UpdateNum] = useState(0)\n\n\n * getDerivedStateFromProps：一般情况下，我们不需要使用它，可以在渲染过程中更新 state，以达到实现 getDerivedStateFromProps 的目的。\n\nfunction ScrollView({row}) {\n  let [isScrollingDown, setIsScrollingDown] = useState(false);\n  let [prevRow, setPrevRow] = useState(null);\n  if (row !== prevRow) {\n    // Row 自上次渲染以来发生过改变。更新 isScrollingDown。\n    setIsScrollingDown(prevRow !== null && row > prevRow);\n    setPrevRow(row);\n  }\n  return `Scrolling down: ${isScrollingDown}`;\n}\n\n\nReact 会立即退出第一次渲染并用更新后的 state 重新运行组件以避免耗费太多性能。\n\n * shouldComponentUpdate：可以用 **React.memo** 包裹一个组件来对它的 props 进行浅比较\n\nconst Button = React.memo((props) => {  // 具体的组件});\n\n\n注意：**React.memo 等效于 **``**PureComponent**，它只浅比较 props。这里也可以使用 useMemo 优化每一个节点。\n\n * render：这是函数组件体本身。\n * componentDidMount, componentDidUpdate： useLayoutEffect 与它们两的调用阶段是一样的。但是，我们推荐你一开始先用 useEffect，只有当它出问题的时候再尝试使用 useLayoutEffect。useEffect 可以表达所有这些的组合。\n\n// componentDidMount\nuseEffect(()=>{\n  // 需要在 componentDidMount 执行的内容\n}, [])\nuseEffect(() => { \n  // 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容\n  document.title = `You clicked ${count} times`; \n  return () => {\n    // 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）\n    // 以及 componentWillUnmount 执行的内容       \n  } // 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关\n}, [count]); // 仅在 count 更改时更新\n\n\n请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 ，因此会使得额外操作很方便\n\n * componentWillUnmount：相当于 useEffect里面返回的 cleanup 函数\n\n// componentDidMount/componentWillUnmount\nuseEffect(()=>{\n  // 需要在 componentDidMount 执行的内容\n  return function cleanup() {\n    // 需要在 componentWillUnmount 执行的内容      \n  }\n}, [])\n\n\n * componentDidCatch and getDerivedStateFromError：目前还没有这些方法的 Hook 等价写法，但很快会加上。\n\nCLASS 组件                   HOOKS 组件\nconstructor                useState\ngetDerivedStateFromProps   useState 里面 update 函数\nshouldComponentUpdate      useMemo\nrender                     函数本身\ncomponentDidMount          useEffect\ncomponentDidUpdate         useEffect\ncomponentWillUnmount       useEffect 里面返回的函数\ncomponentDidCatch          无\ngetDerivedStateFromError   无",
      "normalizedContent": "# 1. 对 react hook 的理解，它的实现原理是什么\n\nreact-hooks 是 react 团队在 react 组件开发实践中，逐渐认知到的一个改进点，这背后其实涉及对类组件和函数组件两种组件形式的思考和侧重。\n\n（1）类组件： 所谓类组件，就是基于 es6 class 这种写法，通过继承 react.component 得来的 react 组件。以下是一个类组件：\n\nclass democlass extends react.component {\n  state = {\n    text: \"\"\n  };\n  componentdidmount() {\n    //...\n  }\n  changetext = (newtext) => {\n    this.setstate({\n      text: newtext\n    });\n  };\n\n  render() {\n    return (\n      <div classname=\"democlass\">\n        <p>{this.state.text}</p>\n        <button onclick={this.changetext}>修改</button>\n      </div>\n    );\n  }\n}\n\n\n\n可以看出，react 类组件内部预置了相当多的“现成的东西”等着我们去调度/定制，state 和生命周期就是这些“现成东西”中的典型。要想得到这些东西，难度也不大，只需要继承一个 react.component 即可。\n\n当然，这也是类组件的一个不便，它太繁杂了，对于解决许多问题来说，编写一个类组件实在是一个过于复杂的姿势。复杂的姿势必然带来高昂的理解成本，这也是我们所不想看到的。除此之外，由于开发者编写的逻辑在封装后是和组件粘在一起的，这就使得类组件内部的逻辑难以实现拆分和复用。\n\n（2）函数组件：函数组件就是以函数的形态存在的 react 组件。早期并没有 react-hooks，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件”。以下是一个函数组件：\n\nfunction demofunction(props) {\n  const { text } = props\n  return (\n    <div classname=\"demofunction\">\n      <p>{`函数组件接收的内容：[${text}]`}</p>\n    </div>\n  );\n}\n\n\n相比于类组件，函数组件肉眼可见的特质自然包括轻量、灵活、易于组织和维护、较低的学习成本等。\n\n通过对比，从形态上可以对两种组件做区分，它们之间的区别如下：\n\n * 类组件需要继承 class，函数组件不需要；\n * 类组件可以访问生命周期方法，函数组件不能；\n * 类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；\n * 类组件中可以定义并维护 state（状态），而函数组件不可以；\n\n除此之外，还有一些其他的不同。通过上面的区别，我们不能说谁好谁坏，它们各有自己的优势。在 react-hooks 出现之前，类组件的能力边界明显强于函数组件。\n\n实际上，类组件和函数组件之间，是面向对象和函数式编程这两套不同的设计思想之间的差异。而函数组件更加契合 react 框架的设计理念： react 组件本身的定位就是函数，一个输入数据、输出 ui 的函数。作为开发者，我们编写的是声明式的代码，而 react 框架的主要工作，就是及时地把声明式的代码转换为命令式的 dom 操作，把数据层面的描述映射到用户可见的 ui 变化中去。这就意味着从原则上来讲，react 的数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点。函数组件就真正地将数据和渲染绑定到了一起。函数组件是一个更加匹配其设计理念、也更有利于逻辑拆分与重用的组件表达形式。\n\n为了能让开发者更好的的去编写函数式组件。于是，react-hooks 便应运而生。\n\nreact-hooks 是一套能够使函数组件更强大、更灵活的“钩子”。\n\n函数组件比起类组件少了很多东西，比如生命周期、对 state 的管理等。这就给函数组件的使用带来了非常多的局限性，导致我们并不能使用函数这种形式，写出一个真正的全功能的组件。而react-hooks 的出现，就是为了帮助函数组件补齐这些（相对于类组件来说）缺失的能力。\n\n如果说函数组件是一台轻巧的快艇，那么 react-hooks 就是一个内容丰富的零部件箱。“重装战舰”所预置的那些设备，这个箱子里基本全都有，同时它还不强制你全都要，而是允许你自由地选择和使用你需要的那些能力，然后将这些能力以 hook（钩子）的形式“钩”进你的组件里，从而定制出一个最适合你的“专属战舰”。\n\n\n# 2. 为什么 usestate 要使用数组而不是对象\n\nusestate 的用法：\n\nconst [count, setcount] = usestate(0)\n\n\n可以看到 usestate 返回的是一个数组，那么为什么是返回数组而不是返回对象呢？\n\n这里用到了解构赋值，所以先来看一下es6 的解构赋值：\n\n# 数组的解构赋值\n\nconst foo = [1, 2, 3];\nconst [one, two, three] = foo;\nconsole.log(one);\t// 1\nconsole.log(two);\t// 2\nconsole.log(three);\t// 3\n\n\n# 对象的解构赋值\n\nconst user = {\n  id: 888,\n  name: \"xiaoxin\"\n};\nconst { id, name } = user;\nconsole.log(id);\t// 888\nconsole.log(name);\t// \"xiaoxin\"\n\n\n看完这两个例子，答案应该就出来了：\n\n * 如果 usestate 返回的是数组，那么使用者可以对数组中的元素命名，代码看起来也比较干净\n * 如果 usestate 返回的是对象，在解构对象的时候必须要和 usestate 内部实现返回的对象同名，想要使用多次的话，必须得设置别名才能使用返回值\n\n下面来看看如果 usestate 返回对象的情况：\n\n// 第一次使用\nconst { state, setstate } = usestate(false);\n// 第二次使用\nconst { state: counter, setstate: setcounter } = usestate(0) \n\n\n这里可以看到，返回对象的使用方式还是挺麻烦的，更何况实际项目中会使用的更频繁。 **总结：*usestate 返回的是 array 而不是 object 的原因就是为了*降低使用的复杂度，返回数组的话可以直接根据顺序解构，而返回对象的话要想使用多次就需要定义别名了。\n\n\n# 3. react hooks 解决了哪些问题？\n\nreact hooks 主要解决了以下问题：\n\n（1）在组件之间复用状态逻辑很难\n\nreact 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）解决此类问题可以使用 render props 和 高阶组件。但是这类方案需要重新组织组件结构，这可能会很麻烦，并且会使代码难以理解。由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。尽管可以在 devtools 过滤掉它们，但这说明了一个更深层次的问题：react 需要为共享状态逻辑提供更好的原生途径。\n\n可以使用 hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。hook 使我们在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 hook 变得更便捷。\n\n（2）复杂组件变得难以理解\n\n在组件中，每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentdidmount 和 componentdidupdate 中获取数据。但是，同一个 componentdidmount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentwillunmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。\n\n在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 react 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。\n\n为了解决这个问题，hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。\n\n（3）难以理解的 class\n\n除了代码复用和代码管理会遇到困难外，class 是学习 react 的一大屏障。我们必须去理解 javascript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。没有稳定的语法提案，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。即便在有经验的 react 开发者之间，对于函数组件与 class 组件的差异也存在分歧，甚至还要区分两种组件的使用场景。\n\n为了解决这些问题，hook 使你在非 class 的情况下可以使用更多的 react 特性。 从概念上讲，react 组件一直更像是函数。而 hook 则拥抱了函数，同时也没有牺牲 react 的精神原则。hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术\n\n\n# 4. react hook 的使用限制有哪些？\n\nreact hooks 的限制主要有两条：\n\n * 不要在循环、条件或嵌套函数中调用 hook；\n * 在 react 的函数组件中调用 hook。\n\n那为什么会有这样的限制呢？hooks 的设计初衷是为了改进 react 组件的开发模式。在旧有的开发模式下遇到了三个问题。\n\n * 组件之间难以复用状态逻辑。过去常见的解决方案是高阶组件、render props 及状态管理框架。\n * 复杂的组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致关联部分难以拆分。\n * 人和机器都很容易混淆类。常见的有 this 的问题，但在 react 团队中还有类难以优化的问题，希望在编译优化层面做出一些改进。\n\n这三个问题在一定程度上阻碍了 react 的后续发展，所以为了解决这三个问题，hooks 基于函数组件开始设计。然而第三个问题决定了 hooks 只支持函数组件。\n\n那为什么不要在循环、条件或嵌套函数中调用 hook 呢？因为 hooks 的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 hook。当然，实质上 react 的源码里不是数组，是链表。\n\n这些限制会在编码上造成一定程度的心智负担，新手可能会写错，为了避免这样的情况，可以引入 eslint 的 hooks 检查插件进行预防。\n\n\n# 5. useeffect 与 uselayouteffect 的区别\n\n（1）共同点\n\n * 运用效果： useeffect 与 uselayouteffect 两者都是用于处理副作用，这些副作用包括改变 dom、设置订阅、操作定时器等。在函数组件内部操作副作用是不被允许的，所以需要使用这两个函数去处理。\n * 使用方式： useeffect 与 uselayouteffect 两者底层的函数签名是完全一致的，都是调用的 mounteffectimpl方法，在使用上也没什么差异，基本可以直接替换。\n\n（2）不同点\n\n * 使用场景： useeffect 在 react 的渲染过程中是被异步调用的，用于绝大多数场景；而 uselayouteffect 会在所有的 dom 变更之后同步调用，主要用于处理 dom 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 uselayouteffect 做计算量较大的耗时任务从而造成阻塞。\n * 使用效果： useeffect是按照顺序执行代码的，改变屏幕像素之后执行（先渲染，后改变dom），当改变屏幕内容时可能会产生闪烁；uselayouteffect是改变屏幕像素之前就执行了（会推迟页面显示的事件，先改变dom后渲染），不会产生闪烁。uselayouteffect总是比useeffect先执行。\n\n在未来的趋势上，两个 api 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。react 团队的建议非常实用，如果实在分不清，先用 useeffect，一般问题不大；如果页面有异常，再直接替换为 uselayouteffect 即可。\n\n\n# 6. react hooks在平时开发中需要注意的问题和原因\n\n（1）不要在循环，条件或嵌套函数中调用hook，必须始终在 react函数的顶层使用hook\n\n这是因为react需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。\n\n（2）使用usestate时候，使用push，pop，splice等直接更改数组对象的坑\n\n使用push直接更改数组无法获取到新值，应该采用析构方式，但是在class里面不会有这个问题。代码示例：\n\nfunction indicatorfilter() {\n  let [num,setnums] = usestate([0,1,2,3])\n  const test = () => {\n    // 这里坑是直接采用push去更新num\n    // setnums(num)是无法更新num的\n    // 必须使用num = [...num ,1]\n    num.push(1)\n    // num = [...num ,1]\n    setnums(num)\n  }\nreturn (\n    <div classname='filter'>\n      <div onclick={test}>测试</div>\n        <div>\n          {num.map((item,index) => (\n              <div key={index}>{item}</div>\n          ))}\n      </div>\n    </div>\n  )\n}\n\nclass indicatorfilter extends react.component<any,any>{\n  constructor(props:any){\n      super(props)\n      this.state = {\n          nums:[1,2,3]\n      }\n      this.test = this.test.bind(this)\n  }\n\n  test(){\n      // class采用同样的方式是没有问题的\n      this.state.nums.push(1)\n      this.setstate({\n          nums: this.state.nums\n      })\n  }\n\n  render(){\n      let {nums} = this.state\n      return(\n          <div>\n              <div onclick={this.test}>测试</div>\n                  <div>\n                      {nums.map((item:any,index:number) => (\n                          <div key={index}>{item}</div>\n                      ))}\n                  </div>\n          </div>\n\n      )\n  }\n}\n\n\n（3）usestate设置状态的时候，只有第一次生效，后期需要更新状态，必须通过useeffect\n\ntabledeail是一个公共组件，在调用它的父组件里面，我们通过set改变columns的值，以为传递给tabledeail 的 columns是最新的值，所以tabcolumn每次也是最新的值，但是实际tabcolumn是最开始的值，不会随着columns的更新而更新：\n\nconst tabledeail = ({\n    columns,\n}:tabledata) => {\n    const [tabcolumn, settabcolumn] = usestate(columns) \n}\n\n// 正确的做法是通过useeffect改变这个值\nconst tabledeail = ({\n    columns,\n}:tabledata) => {\n    const [tabcolumn, settabcolumn] = usestate(columns) \n    useeffect(() =>{settabcolumn(columns)},[columns])\n}\n\n\n\n（4）善用usecallback\n\n父组件传递给子组件事件句柄时，如果我们没有任何参数变动可能会选用usememo。但是每一次父组件渲染子组件即使没变化也会跟着渲染一次。\n\n（5）不要滥用usecontext\n\n可以使用基于 usecontext 封装的状态管理工具。\n\n\n# 7. react hooks 和生命周期的关系？\n\n函数组件 的本质是函数，没有 state 的概念的，因此不存在生命周期一说，仅仅是一个 render 函数而已。 但是引入 hooks 之后就变得不同了，它能让组件在不使用 class 的情况下拥有 state，所以就有了生命周期的概念，所谓的生命周期其实就是 usestate、 useeffect() 和 uselayouteffect() 。\n\n即：hooks 组件（使用了hooks的函数组件）有生命周期，而函数组件（未使用hooks的函数组件）是没有生命周期的。\n\n下面是具体的 class 与 hooks 的生命周期对应关系：\n\n * constructor：函数组件不需要构造函数，可以通过调用 **usestate 来初始化 state**。如果计算的代价比较昂贵，也可以传一个函数给 usestate。\n\nconst [num, updatenum] = usestate(0)\n\n\n * getderivedstatefromprops：一般情况下，我们不需要使用它，可以在渲染过程中更新 state，以达到实现 getderivedstatefromprops 的目的。\n\nfunction scrollview({row}) {\n  let [isscrollingdown, setisscrollingdown] = usestate(false);\n  let [prevrow, setprevrow] = usestate(null);\n  if (row !== prevrow) {\n    // row 自上次渲染以来发生过改变。更新 isscrollingdown。\n    setisscrollingdown(prevrow !== null && row > prevrow);\n    setprevrow(row);\n  }\n  return `scrolling down: ${isscrollingdown}`;\n}\n\n\nreact 会立即退出第一次渲染并用更新后的 state 重新运行组件以避免耗费太多性能。\n\n * shouldcomponentupdate：可以用 **react.memo** 包裹一个组件来对它的 props 进行浅比较\n\nconst button = react.memo((props) => {  // 具体的组件});\n\n\n注意：**react.memo 等效于 **``**purecomponent**，它只浅比较 props。这里也可以使用 usememo 优化每一个节点。\n\n * render：这是函数组件体本身。\n * componentdidmount, componentdidupdate： uselayouteffect 与它们两的调用阶段是一样的。但是，我们推荐你一开始先用 useeffect，只有当它出问题的时候再尝试使用 uselayouteffect。useeffect 可以表达所有这些的组合。\n\n// componentdidmount\nuseeffect(()=>{\n  // 需要在 componentdidmount 执行的内容\n}, [])\nuseeffect(() => { \n  // 在 componentdidmount，以及 count 更改时 componentdidupdate 执行的内容\n  document.title = `you clicked ${count} times`; \n  return () => {\n    // 需要在 count 更改时 componentdidupdate（先于 document.title = ... 执行，遵守先清理后更新）\n    // 以及 componentwillunmount 执行的内容       \n  } // 当函数中 cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关\n}, [count]); // 仅在 count 更改时更新\n\n\n请记得 react 会等待浏览器完成画面渲染之后才会延迟调用 ，因此会使得额外操作很方便\n\n * componentwillunmount：相当于 useeffect里面返回的 cleanup 函数\n\n// componentdidmount/componentwillunmount\nuseeffect(()=>{\n  // 需要在 componentdidmount 执行的内容\n  return function cleanup() {\n    // 需要在 componentwillunmount 执行的内容      \n  }\n}, [])\n\n\n * componentdidcatch and getderivedstatefromerror：目前还没有这些方法的 hook 等价写法，但很快会加上。\n\nclass 组件                   hooks 组件\nconstructor                usestate\ngetderivedstatefromprops   usestate 里面 update 函数\nshouldcomponentupdate      usememo\nrender                     函数本身\ncomponentdidmount          useeffect\ncomponentdidupdate         useeffect\ncomponentwillunmount       useeffect 里面返回的函数\ncomponentdidcatch          无\ngetderivedstatefromerror   无",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "虚拟DOM",
      "frontmatter": {
        "title": "虚拟DOM",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/frameReactDom/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/20.react%E7%AF%87/80.%E8%99%9A%E6%8B%9FDOM.html",
      "relativePath": "30.框架篇/20.react篇/80.虚拟DOM.md",
      "key": "v-232d5685",
      "path": "/pages/frameReactDom/",
      "headers": [
        {
          "level": 3,
          "title": "1. 对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？",
          "slug": "_1-对虚拟-dom-的理解-虚拟-dom-主要做了什么-虚拟-dom-本身是什么",
          "normalizedTitle": "1. 对虚拟 dom 的理解？虚拟 dom 主要做了什么？虚拟 dom 本身是什么？",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. React diff 算法的原理是什么？",
          "slug": "_2-react-diff-算法的原理是什么",
          "normalizedTitle": "2. react diff 算法的原理是什么？",
          "charIndex": 977
        },
        {
          "level": 3,
          "title": "3. React key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的",
          "slug": "_3-react-key-是干嘛用的-为什么要加-key-主要是解决哪一类问题的",
          "normalizedTitle": "3. react key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的",
          "charIndex": 2282
        },
        {
          "level": 3,
          "title": "4. 虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么",
          "slug": "_4-虚拟-dom-的引入与直接操作原生-dom-相比-哪一个效率更高-为什么",
          "normalizedTitle": "4. 虚拟 dom 的引入与直接操作原生 dom 相比，哪一个效率更高，为什么",
          "charIndex": 2632
        },
        {
          "level": 3,
          "title": "5. React 与 Vue 的 diff 算法有何不同？",
          "slug": "_5-react-与-vue-的-diff-算法有何不同",
          "normalizedTitle": "5. react 与 vue 的 diff 算法有何不同？",
          "charIndex": 3070
        }
      ],
      "headersStr": "1. 对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？ 2. React diff 算法的原理是什么？ 3. React key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的 4. 虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么 5. React 与 Vue 的 diff 算法有何不同？",
      "content": "# 1. 对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？\n\n从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。\n\n虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对DOM的描述。它设计的最初目的，就是更好的跨平台，比如node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟dom，因为虚拟dom本身是js对象。 在代码渲染到页面之前，vue或者react会把代码转换成一个对象（虚拟DOM）。以对象的形式来描述真实dom结构，最终渲染到页面。在每次数据发生变化前，虚拟dom都会缓存一份，变化之时，现在的虚拟dom会与缓存的虚拟dom进行比较。在vue或者react内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。\n\n另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。\n\n为什么要用 Virtual DOM：\n\n（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能\n\n下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶\n\n * 真实DOM∶ 生成HTML字符串＋ 重建所有的DOM元素\n * Virtual DOM∶ 生成vNode＋ DOMDiff＋必要的DOM更新\n\nVirtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，我依然可以给你提供过得去的性能。 （2）跨平台 Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。\n\n\n# 2. React diff 算法的原理是什么？\n\n实际上，diff 算法探讨的就是虚拟 DOM 树发生变化后，生成 DOM 树更新补丁的方式。它通过对比新旧两株虚拟 DOM 树的变更差异，将更新补丁作用于真实 DOM，以最小成本完成视图更新。 具体的流程如下：\n\n * 真实的 DOM 首先会映射为虚拟 DOM；\n * 当虚拟 DOM 发生变化后，就会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；\n * 根据 patch 去更新真实的 DOM，反馈到用户的界面上。\n\n一个简单的例子：\n\nimport React from 'react'\nexport default class ExampleComponent extends React.Component {\n  render() {\n    if(this.props.isVisible) {\n       return <div className=\"visible\">visbile</div>;\n    }\n     return <div className=\"hidden\">hidden</div>;\n  }\n}\n\n\n这里，首先假定 ExampleComponent 可见，然后再改变它的状态，让它不可见 。映射为真实的 DOM 操作是这样的，React 会创建一个 div 节点。\n\n<div class=\"visible\">visbile</div>\n\n\n当把 visbile 的值变为 false 时，就会替换 class 属性为 hidden，并重写内部的 innerText 为 hidden。这样一个生成补丁、更新差异的过程统称为 diff 算法。\n\ndiff算法可以总结为三个策略，分别从树、组件及元素三个层面进行复杂度的优化：\n\n策略一：忽略节点跨层级操作场景，提升比对效率。（基于树进行对比）\n\n这一策略需要进行树比对，即对树进行分层比较。树比对的处理手法是非常“暴力”的，即两棵树只对同一层次的节点进行比较，如果发现节点已经不存在了，则该节点及其子节点会被完全删除掉，不会用于进一步的比较，这就提升了比对效率。\n\n策略二：如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构。（基于组件进行对比）\n\n在组件比对的过程中：\n\n * 如果组件是同一类型则进行树比对；\n * 如果不是则直接放入补丁中。\n\n只要父组件类型不同，就会被重新渲染。这也就是为什么 shouldComponentUpdate、PureComponent 及 React.memo 可以提高性能的原因。\n\n策略三：同一层级的子节点，可以通过标记 key 的方式进行列表对比。（基于节点进行对比）\n\n元素比对主要发生在同层级中，通过标记节点操作生成补丁。节点操作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用。通过标记 key 的方式，React 可以直接移动 DOM 节点，降低内耗。\n\n\n# 3. React key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的\n\nKeys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。\n\n在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系。\n\n注意事项：\n\n * key值一定要和具体的元素—一对应；\n * 尽量不要用数组的index去作为key；\n * 不要在render的时候用随机数或者其他操作给元素加上不稳定的key，这样造成的性能开销比不加key的情况下更糟糕。\n\n\n# 4. 虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么\n\n虚拟DOM相对原生的DOM不一定是效率更高，如果只修改一个按钮的文案，那么虚拟 DOM 的操作无论如何都不可能比真实的 DOM 操作更快。在首次渲染大量DOM时，由于多了一层虚拟DOM的计算，虚拟DOM也会比innerHTML插入慢。它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。所以要根据具体的场景进行探讨。\n\n在整个 DOM 操作的演化过程中，其实主要矛盾并不在于性能，而在于开发者写得爽不爽，在于研发体验/研发效率。虚拟 DOM 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物。虚拟 DOM 并不一定会带来更好的性能，React 官方也从来没有把虚拟 DOM 作为性能层面的卖点对外输出过。虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。\n\n\n# 5. React 与 Vue 的 diff 算法有何不同？\n\ndiff 算法是指生成更新补丁的方式，主要应用于虚拟 DOM 树变化后，更新真实 DOM。所以 diff 算法一定存在这样一个过程：触发更新 → 生成补丁 → 应用补丁。\n\nReact 的 diff 算法，触发更新的时机主要在 state 变化与 hooks 调用之后。此时触发虚拟 DOM 树变更遍历，采用了深度优先遍历算法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方式。将单一节点比对转化为了 3 种类型节点的比对，分别是树、组件及元素，以此提升效率。\n\n * 树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。\n * 组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。\n * 元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。\n\n以上是经典的 React diff 算法内容。自 React 16 起，引入了 Fiber 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 FiberNode 与 FiberTree 进行重构。fiberNode 使用了双链表的结构，可以直接找到兄弟节点与子节点。整个更新过程由 current 与 workInProgress 两株树双缓冲完成。workInProgress 更新完成后，再通过修改 current 相关指针指向新节点。\n\nVue 的整体 diff 策略与 React 对齐，虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差，因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。",
      "normalizedContent": "# 1. 对虚拟 dom 的理解？虚拟 dom 主要做了什么？虚拟 dom 本身是什么？\n\n从本质上来说，virtual dom是一个javascript对象，通过对象的方式来表示dom结构。将页面的状态抽象为js对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次dom修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改dom的重绘重排次数，提高渲染性能。\n\n虚拟dom是对dom的抽象，这个对象是更加轻量级的对dom的描述。它设计的最初目的，就是更好的跨平台，比如node.js就没有dom，如果想实现ssr，那么一个方式就是借助虚拟dom，因为虚拟dom本身是js对象。 在代码渲染到页面之前，vue或者react会把代码转换成一个对象（虚拟dom）。以对象的形式来描述真实dom结构，最终渲染到页面。在每次数据发生变化前，虚拟dom都会缓存一份，变化之时，现在的虚拟dom会与缓存的虚拟dom进行比较。在vue或者react内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。\n\n另外现代前端框架的一个基本要求就是无须手动操作dom，一方面是因为手动操作dom无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动dom操作可以大大提高开发效率。\n\n为什么要用 virtual dom：\n\n（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能\n\n下面对比一下修改dom时真实dom操作和virtual dom的过程，来看一下它们重排重绘的性能消耗∶\n\n * 真实dom∶ 生成html字符串＋ 重建所有的dom元素\n * virtual dom∶ 生成vnode＋ domdiff＋必要的dom更新\n\nvirtual dom的更新dom的准备工作耗费更多的时间，也就是js层面，相比于更多的dom操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，我依然可以给你提供过得去的性能。 （2）跨平台 virtual dom本质上是javascript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。\n\n\n# 2. react diff 算法的原理是什么？\n\n实际上，diff 算法探讨的就是虚拟 dom 树发生变化后，生成 dom 树更新补丁的方式。它通过对比新旧两株虚拟 dom 树的变更差异，将更新补丁作用于真实 dom，以最小成本完成视图更新。 具体的流程如下：\n\n * 真实的 dom 首先会映射为虚拟 dom；\n * 当虚拟 dom 发生变化后，就会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；\n * 根据 patch 去更新真实的 dom，反馈到用户的界面上。\n\n一个简单的例子：\n\nimport react from 'react'\nexport default class examplecomponent extends react.component {\n  render() {\n    if(this.props.isvisible) {\n       return <div classname=\"visible\">visbile</div>;\n    }\n     return <div classname=\"hidden\">hidden</div>;\n  }\n}\n\n\n这里，首先假定 examplecomponent 可见，然后再改变它的状态，让它不可见 。映射为真实的 dom 操作是这样的，react 会创建一个 div 节点。\n\n<div class=\"visible\">visbile</div>\n\n\n当把 visbile 的值变为 false 时，就会替换 class 属性为 hidden，并重写内部的 innertext 为 hidden。这样一个生成补丁、更新差异的过程统称为 diff 算法。\n\ndiff算法可以总结为三个策略，分别从树、组件及元素三个层面进行复杂度的优化：\n\n策略一：忽略节点跨层级操作场景，提升比对效率。（基于树进行对比）\n\n这一策略需要进行树比对，即对树进行分层比较。树比对的处理手法是非常“暴力”的，即两棵树只对同一层次的节点进行比较，如果发现节点已经不存在了，则该节点及其子节点会被完全删除掉，不会用于进一步的比较，这就提升了比对效率。\n\n策略二：如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构。（基于组件进行对比）\n\n在组件比对的过程中：\n\n * 如果组件是同一类型则进行树比对；\n * 如果不是则直接放入补丁中。\n\n只要父组件类型不同，就会被重新渲染。这也就是为什么 shouldcomponentupdate、purecomponent 及 react.memo 可以提高性能的原因。\n\n策略三：同一层级的子节点，可以通过标记 key 的方式进行列表对比。（基于节点进行对比）\n\n元素比对主要发生在同层级中，通过标记节点操作生成补丁。节点操作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用。通过标记 key 的方式，react 可以直接移动 dom 节点，降低内耗。\n\n\n# 3. react key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的\n\nkeys 是 react 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。\n\n在 react diff 算法中 react 会借助元素的 key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染此外，react 还需要借助 key 值来判断元素与本地状态的关联关系。\n\n注意事项：\n\n * key值一定要和具体的元素—一对应；\n * 尽量不要用数组的index去作为key；\n * 不要在render的时候用随机数或者其他操作给元素加上不稳定的key，这样造成的性能开销比不加key的情况下更糟糕。\n\n\n# 4. 虚拟 dom 的引入与直接操作原生 dom 相比，哪一个效率更高，为什么\n\n虚拟dom相对原生的dom不一定是效率更高，如果只修改一个按钮的文案，那么虚拟 dom 的操作无论如何都不可能比真实的 dom 操作更快。在首次渲染大量dom时，由于多了一层虚拟dom的计算，虚拟dom也会比innerhtml插入慢。它能保证性能下限，在真实dom操作的时候进行针对性的优化时，还是更快的。所以要根据具体的场景进行探讨。\n\n在整个 dom 操作的演化过程中，其实主要矛盾并不在于性能，而在于开发者写得爽不爽，在于研发体验/研发效率。虚拟 dom 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物。虚拟 dom 并不一定会带来更好的性能，react 官方也从来没有把虚拟 dom 作为性能层面的卖点对外输出过。虚拟 dom 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 ui 编程方式）的同时，仍然保持一个还不错的性能。\n\n\n# 5. react 与 vue 的 diff 算法有何不同？\n\ndiff 算法是指生成更新补丁的方式，主要应用于虚拟 dom 树变化后，更新真实 dom。所以 diff 算法一定存在这样一个过程：触发更新 → 生成补丁 → 应用补丁。\n\nreact 的 diff 算法，触发更新的时机主要在 state 变化与 hooks 调用之后。此时触发虚拟 dom 树变更遍历，采用了深度优先遍历算法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方式。将单一节点比对转化为了 3 种类型节点的比对，分别是树、组件及元素，以此提升效率。\n\n * 树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 dom 树只对同一层次的节点进行比较。\n * 组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。\n * 元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 dom 剪裁操作。\n\n以上是经典的 react diff 算法内容。自 react 16 起，引入了 fiber 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 fibernode 与 fibertree 进行重构。fibernode 使用了双链表的结构，可以直接找到兄弟节点与子节点。整个更新过程由 current 与 workinprogress 两株树双缓冲完成。workinprogress 更新完成后，再通过修改 current 相关指针指向新节点。\n\nvue 的整体 diff 策略与 react 对齐，虽然缺乏时间切片能力，但这并不意味着 vue 的性能更差，因为在 vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "JavaScript 基础",
      "frontmatter": {
        "title": "JavaScript 基础",
        "date": "2022-10-20T10:31:15.000Z",
        "permalink": "/pages/writeCode/javaScript/",
        "article": false
      },
      "regularPath": "/40.%E4%BB%A3%E7%A0%81%E7%AF%87/10.%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%AF%87/10.JavaScript%20%E5%9F%BA%E7%A1%80.html",
      "relativePath": "40.代码篇/10.手写代码篇/10.JavaScript 基础.md",
      "key": "v-4909c5ea",
      "path": "/pages/writeCode/javaScript/",
      "headers": [
        {
          "level": 3,
          "title": "1. 手写 Object.create",
          "slug": "_1-手写-object-create",
          "normalizedTitle": "1. 手写 object.create",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 手写 instanceof 方法",
          "slug": "_2-手写-instanceof-方法",
          "normalizedTitle": "2. 手写 instanceof 方法",
          "charIndex": 123
        },
        {
          "level": 3,
          "title": "3. 手写 new 操作符",
          "slug": "_3-手写-new-操作符",
          "normalizedTitle": "3. 手写 new 操作符",
          "charIndex": 627
        },
        {
          "level": 3,
          "title": "4. 手写 Promise",
          "slug": "_4-手写-promise",
          "normalizedTitle": "4. 手写 promise",
          "charIndex": 1409
        },
        {
          "level": 3,
          "title": "5. 手写 Promise.then",
          "slug": "_5-手写-promise-then",
          "normalizedTitle": "5. 手写 promise.then",
          "charIndex": 3502
        },
        {
          "level": 3,
          "title": "6. 手写 Promise.all",
          "slug": "_6-手写-promise-all",
          "normalizedTitle": "6. 手写 promise.all",
          "charIndex": 5262
        },
        {
          "level": 3,
          "title": "7. 手写 Promise.race",
          "slug": "_7-手写-promise-race",
          "normalizedTitle": "7. 手写 promise.race",
          "charIndex": 6664
        },
        {
          "level": 3,
          "title": "8. 手写防抖函数",
          "slug": "_8-手写防抖函数",
          "normalizedTitle": "8. 手写防抖函数",
          "charIndex": 7055
        },
        {
          "level": 3,
          "title": "9. 手写节流函数",
          "slug": "_9-手写节流函数",
          "normalizedTitle": "9. 手写节流函数",
          "charIndex": 7504
        },
        {
          "level": 3,
          "title": "10. 手写类型判断函数",
          "slug": "_10-手写类型判断函数",
          "normalizedTitle": "10. 手写类型判断函数",
          "charIndex": 7954
        },
        {
          "level": 3,
          "title": "11. 手写 call 函数",
          "slug": "_11-手写-call-函数",
          "normalizedTitle": "11. 手写 call 函数",
          "charIndex": 8358
        },
        {
          "level": 3,
          "title": "12. 手写 apply 函数",
          "slug": "_12-手写-apply-函数",
          "normalizedTitle": "12. 手写 apply 函数",
          "charIndex": 9006
        },
        {
          "level": 3,
          "title": "13. 手写 bind 函数",
          "slug": "_13-手写-bind-函数",
          "normalizedTitle": "13. 手写 bind 函数",
          "charIndex": 9672
        },
        {
          "level": 3,
          "title": "14. 函数柯里化的实现",
          "slug": "_14-函数柯里化的实现",
          "normalizedTitle": "14. 函数柯里化的实现",
          "charIndex": 10266
        },
        {
          "level": 3,
          "title": "15. 实现AJAX请求",
          "slug": "_15-实现ajax请求",
          "normalizedTitle": "15. 实现ajax请求",
          "charIndex": 10937
        },
        {
          "level": 3,
          "title": "16. 使用Promise封装AJAX请求",
          "slug": "_16-使用promise封装ajax请求",
          "normalizedTitle": "16. 使用promise封装ajax请求",
          "charIndex": 12047
        },
        {
          "level": 3,
          "title": "17. 实现浅拷贝",
          "slug": "_17-实现浅拷贝",
          "normalizedTitle": "17. 实现浅拷贝",
          "charIndex": 12833
        },
        {
          "level": 3,
          "title": "18. 实现深拷贝",
          "slug": "_18-实现深拷贝",
          "normalizedTitle": "18. 实现深拷贝",
          "charIndex": 15317
        }
      ],
      "headersStr": "1. 手写 Object.create 2. 手写 instanceof 方法 3. 手写 new 操作符 4. 手写 Promise 5. 手写 Promise.then 6. 手写 Promise.all 7. 手写 Promise.race 8. 手写防抖函数 9. 手写节流函数 10. 手写类型判断函数 11. 手写 call 函数 12. 手写 apply 函数 13. 手写 bind 函数 14. 函数柯里化的实现 15. 实现AJAX请求 16. 使用Promise封装AJAX请求 17. 实现浅拷贝 18. 实现深拷贝",
      "content": "# 1. 手写 Object.create\n\n思路：将传入的对象作为原型\n\nfunction create(obj) {\n  function F() {}\n  F.prototype = obj\n  return new F()\n}\n\n\n\n# 2. 手写 instanceof 方法\n\ninstanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\n\n实现步骤：\n\n 1. 首先获取类型的原型\n 2. 然后获得对象的原型\n 3. 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null\n\n具体实现：\n\nfunction myInstanceof(left, right) {\n  let proto = Object.getPrototypeOf(left), // 获取对象的原型\n      prototype = right.prototype; // 获取构造函数的 prototype 对象\n\n  // 判断构造函数的 prototype 对象是否在对象的原型链上\n  while (true) {\n    if (!proto) return false;\n    if (proto === prototype) return true;\n\n    proto = Object.getPrototypeOf(proto);\n  }\n}\n\n\n\n# 3. 手写 new 操作符\n\n在调用 new 的过程中会发生以上四件事情：\n\n（1）首先创建了一个新的空对象\n\n（2）设置原型，将对象的原型设置为函数的 prototype 对象。\n\n（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\n\n（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。\n\nfunction objectFactory() {\n  let newObject = null;\n  let constructor = Array.prototype.shift.call(arguments);\n  let result = null;\n  // 判断参数是否是一个函数\n  if (typeof constructor !== \"function\") {\n    console.error(\"type error\");\n    return;\n  }\n  // 新建一个空对象，对象的原型为构造函数的 prototype 对象\n  newObject = Object.create(constructor.prototype);\n  // 将 this 指向新建对象，并执行函数\n  result = constructor.apply(newObject, arguments);\n  // 判断返回对象\n  let flag = result && (typeof result === \"object\" || typeof result === \"function\");\n  // 判断返回结果\n  return flag ? result : newObject;\n}\n// 使用方法\nobjectFactory(构造函数, 初始化参数);\n\n\n\n# 4. 手写 Promise\n\nconst PENDING = \"pending\";\nconst RESOLVED = \"resolved\";\nconst REJECTED = \"rejected\";\n\nfunction MyPromise(fn) {\n  // 保存初始化状态\n  var self = this;\n\n  // 初始化状态\n  this.state = PENDING;\n\n  // 用于保存 resolve 或者 rejected 传入的值\n  this.value = null;\n\n  // 用于保存 resolve 的回调函数\n  this.resolvedCallbacks = [];\n\n  // 用于保存 reject 的回调函数\n  this.rejectedCallbacks = [];\n\n  // 状态转变为 resolved 方法\n  function resolve(value) {\n    // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变\n    if (value instanceof MyPromise) {\n      return value.then(resolve, reject);\n    }\n\n    // 保证代码的执行顺序为本轮事件循环的末尾\n    setTimeout(() => {\n      // 只有状态为 pending 时才能转变，\n      if (self.state === PENDING) {\n        // 修改状态\n        self.state = RESOLVED;\n\n        // 设置传入的值\n        self.value = value;\n\n        // 执行回调函数\n        self.resolvedCallbacks.forEach(callback => {\n          callback(value);\n        });\n      }\n    }, 0);\n  }\n\n  // 状态转变为 rejected 方法\n  function reject(value) {\n    // 保证代码的执行顺序为本轮事件循环的末尾\n    setTimeout(() => {\n      // 只有状态为 pending 时才能转变\n      if (self.state === PENDING) {\n        // 修改状态\n        self.state = REJECTED;\n\n        // 设置传入的值\n        self.value = value;\n\n        // 执行回调函数\n        self.rejectedCallbacks.forEach(callback => {\n          callback(value);\n        });\n      }\n    }, 0);\n  }\n\n  // 将两个方法传入函数执行\n  try {\n    fn(resolve, reject);\n  } catch (e) {\n    // 遇到错误时，捕获错误，执行 reject 函数\n    reject(e);\n  }\n}\n\nMyPromise.prototype.then = function(onResolved, onRejected) {\n  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数\n  onResolved =\n    typeof onResolved === \"function\"\n      ? onResolved\n      : function(value) {\n          return value;\n        };\n\n  onRejected =\n    typeof onRejected === \"function\"\n      ? onRejected\n      : function(error) {\n          throw error;\n        };\n\n  // 如果是等待状态，则将函数加入对应列表中\n  if (this.state === PENDING) {\n    this.resolvedCallbacks.push(onResolved);\n    this.rejectedCallbacks.push(onRejected);\n  }\n\n  // 如果状态已经凝固，则直接执行对应状态的函数\n\n  if (this.state === RESOLVED) {\n    onResolved(this.value);\n  }\n\n  if (this.state === REJECTED) {\n    onRejected(this.value);\n  }\n};\n\n\n\n# 5. 手写 Promise.then\n\nthen 方法返回一个新的 promise 实例，为了在 promise 状态发生变化时（resolve / reject 被调用时）再执行 then 里的函数，我们使用一个 callbacks 数组先把传给then的函数暂存起来，等状态改变时再调用。\n\n那么，怎么保证后一个 *\\*\\*then\\*\\** 里的方法在前一个 *\\*\\*then\\*\\**（可能是异步）结束之后再执行呢？ 我们可以将传给 then 的函数和新 promise 的 resolve 一起 push 到前一个 promise 的 callbacks 数组中，达到承前启后的效果：\n\n * 承前：当前一个 promise 完成后，调用其 resolve 变更状态，在这个 resolve 里会依次调用 callbacks 里的回调，这样就执行了 then 里的方法了\n * 启后：上一步中，当 then 里的方法执行完成后，返回一个结果，如果这个结果是个简单的值，就直接调用新 promise 的 resolve，让其状态变更，这又会依次调用新 promise 的 callbacks 数组里的方法，循环往复。。如果返回的结果是个 promise，则需要等它完成之后再触发新 promise 的 resolve，所以可以在其结果的 then 里调用新 promise 的 resolve\n\nthen(onFulfilled, onReject){\n    // 保存前一个promise的this\n    const self = this; \n    return new MyPromise((resolve, reject) => {\n      // 封装前一个promise成功时执行的函数\n      let fulfilled = () => {\n        try{\n          const result = onFulfilled(self.value); // 承前\n          return result instanceof MyPromise? result.then(resolve, reject) : resolve(result); //启后\n        }catch(err){\n          reject(err)\n        }\n      }\n      // 封装前一个promise失败时执行的函数\n      let rejected = () => {\n        try{\n          const result = onReject(self.reason);\n          return result instanceof MyPromise? result.then(resolve, reject) : reject(result);\n        }catch(err){\n          reject(err)\n        }\n      }\n      switch(self.status){\n        case PENDING: \n          self.onFulfilledCallbacks.push(fulfilled);\n          self.onRejectedCallbacks.push(rejected);\n          break;\n        case FULFILLED:\n          fulfilled();\n          break;\n        case REJECT:\n          rejected();\n          break;\n      }\n    })\n   }\n\n\n注意：\n\n * 连续多个 then 里的回调方法是同步注册的，但注册到了不同的 callbacks 数组中，因为每次 then 都返回新的 promise 实例（参考上面的例子和图）\n * 注册完成后开始执行构造函数中的异步事件，异步完成之后依次调用 callbacks 数组中提前注册的回调\n\n\n# 6. 手写 Promise.all\n\n1) 核心思路\n\n 1. 接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数\n 2. 这个方法返回一个新的 promise 对象，\n 3. 遍历传入的参数，用Promise.resolve()将参数\"包一层\"，使其变成一个promise对象\n 4. 参数所有回调成功才是成功，返回值数组与参数顺序一致\n 5. 参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。\n\n2）实现代码\n\n一般来说，Promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了\n\nfunction promiseAll(promises) {\n  return new Promise(function(resolve, reject) {\n    if(!Array.isArray(promises)){\n        throw new TypeError(`argument must be a array`)\n    }\n    var resolvedCounter = 0;\n    var promiseNum = promises.length;\n    var resolvedResult = [];\n    for (let i = 0; i < promiseNum; i++) {\n      Promise.resolve(promises[i]).then(value=>{\n        resolvedCounter++;\n        resolvedResult[i] = value;\n        if (resolvedCounter == promiseNum) {\n            return resolve(resolvedResult)\n          }\n      },error=>{\n        return reject(error)\n      })\n    }\n  })\n}\n// test\nlet p1 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve(1)\n    }, 1000)\n})\nlet p2 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve(2)\n    }, 2000)\n})\nlet p3 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve(3)\n    }, 3000)\n})\npromiseAll([p3, p1, p2]).then(res => {\n    console.log(res) // [3, 1, 2]\n})\n\n\n\n# 7. 手写 Promise.race\n\n该方法的参数是 Promise 实例数组, 然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行. 因为 Promise 的状态只能改变一次, 那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法, 注入到数组中的每一个 Promise 实例中的回调函数中即可.\n\nPromise.race = function (args) {\n  return new Promise((resolve, reject) => {\n    for (let i = 0, len = args.length; i < len; i++) {\n      args[i].then(resolve, reject)\n    }\n  })\n}\n\n\n\n# 8. 手写防抖函数\n\n函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。\n\n// 函数防抖的实现\nfunction debounce(fn, wait) {\n  let timer = null;\n\n  return function() {\n    let context = this,\n        args = arguments;\n\n    // 如果此时存在定时器的话，则取消之前的定时器重新记时\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n\n    // 设置定时器，使事件间隔指定事件后执行\n    timer = setTimeout(() => {\n      fn.apply(context, args);\n    }, wait);\n  };\n}\n\n\n\n# 9. 手写节流函数\n\n函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。\n\n// 函数节流的实现;\nfunction throttle(fn, delay) {\n  let curTime = Date.now();\n\n  return function() {\n    let context = this,\n        args = arguments,\n        nowTime = Date.now();\n\n    // 如果两次时间间隔超过了指定时间，则执行函数。\n    if (nowTime - curTime >= delay) {\n      curTime = Date.now();\n      return fn.apply(context, args);\n    }\n  };\n}\n\n\n\n# 10. 手写类型判断函数\n\nfunction getType(value) {\n  // 判断数据是 null 的情况\n  if (value === null) {\n    return value + \"\";\n  }\n  // 判断数据是引用类型的情况\n  if (typeof value === \"object\") {\n    let valueClass = Object.prototype.toString.call(value),\n      type = valueClass.split(\" \")[1].split(\"\");\n    type.pop();\n    return type.join(\"\").toLowerCase();\n  } else {\n    // 判断数据是基本数据类型的情况和函数的情况\n    return typeof value;\n  }\n}\n\n\n\n# 11. 手写 call 函数\n\ncall 函数的实现步骤：\n\n 1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n 2. 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n 3. 处理传入的参数，截取第一个参数后的所有参数。\n 4. 将函数作为上下文对象的一个属性。\n 5. 使用上下文对象来调用这个方法，并保存返回结果。\n 6. 删除刚才新增的属性。\n 7. 返回结果。\n\n// call函数实现\nFunction.prototype.myCall = function(context) {\n  // 判断调用对象\n  if (typeof this !== \"function\") {\n    console.error(\"type error\");\n  }\n  // 获取参数\n  let args = [...arguments].slice(1),\n      result = null;\n  // 判断 context 是否传入，如果未传入则设置为 window\n  context = context || window;\n  // 将调用函数设为对象的方法\n  context.fn = this;\n  // 调用函数\n  result = context.fn(...args);\n  // 将属性删除\n  delete context.fn;\n  return result;\n};\n\n\n\n# 12. 手写 apply 函数\n\napply 函数的实现步骤：\n\n 1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n 2. 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n 3. 将函数作为上下文对象的一个属性。\n 4. 判断参数值是否传入\n 5. 使用上下文对象来调用这个方法，并保存返回结果。\n 6. 删除刚才新增的属性\n 7. 返回结果\n\n// apply 函数实现\nFunction.prototype.myApply = function(context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== \"function\") {\n    throw new TypeError(\"Error\");\n  }\n  let result = null;\n  // 判断 context 是否存在，如果未传入则为 window\n  context = context || window;\n  // 将函数设为对象的方法\n  context.fn = this;\n  // 调用方法\n  if (arguments[1]) {\n    result = context.fn(...arguments[1]);\n  } else {\n    result = context.fn();\n  }\n  // 将属性删除\n  delete context.fn;\n  return result;\n};\n\n\n\n# 13. 手写 bind 函数\n\nbind 函数的实现步骤：\n\n 1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n 2. 保存当前函数的引用，获取其余传入参数值。\n 3. 创建一个函数返回\n 4. 函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。\n\n// bind 函数实现\nFunction.prototype.myBind = function(context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== \"function\") {\n    throw new TypeError(\"Error\");\n  }\n  // 获取参数\n  var args = [...arguments].slice(1),\n      fn = this;\n  return function Fn() {\n    // 根据调用方式，传入不同绑定值\n    return fn.apply(\n      this instanceof Fn ? this : context,\n      args.concat(...arguments)\n    );\n  };\n};\n\n\n\n# 14. 函数柯里化的实现\n\n函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\n\nfunction curry(fn, args) {\n  // 获取函数需要的参数长度\n  let length = fn.length;\n\n  args = args || [];\n\n  return function() {\n    let subArgs = args.slice(0);\n\n    // 拼接得到现有的所有参数\n    for (let i = 0; i < arguments.length; i++) {\n      subArgs.push(arguments[i]);\n    }\n\n    // 判断参数的长度是否已经满足函数所需参数的长度\n    if (subArgs.length >= length) {\n      // 如果满足，执行函数\n      return fn.apply(this, subArgs);\n    } else {\n      // 如果不满足，递归返回科里化的函数，等待参数的传入\n      return curry.call(this, fn, subArgs);\n    }\n  };\n}\n\n// es6 实现\nfunction curry(fn, ...args) {\n  return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args);\n}\n\n\n\n# 15. 实现AJAX请求\n\nAJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。\n\n创建AJAX请求的步骤：\n\n * 创建一个 XMLHttpRequest 对象。\n * 在这个对象上使用 open 方法创建一个 HTTP 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。\n * 在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。\n * 当对象的属性和监听函数设置完成后，最后调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。\n\nconst SERVER_URL = \"/server\";\nlet xhr = new XMLHttpRequest();\n// 创建 Http 请求\nxhr.open(\"GET\", SERVER_URL, true);\n// 设置状态监听函数\nxhr.onreadystatechange = function() {\n  if (this.readyState !== 4) return;\n  // 当请求成功时\n  if (this.status === 200) {\n    handle(this.response);\n  } else {\n    console.error(this.statusText);\n  }\n};\n// 设置请求失败时的监听函数\nxhr.onerror = function() {\n  console.error(this.statusText);\n};\n// 设置请求头信息\nxhr.responseType = \"json\";\nxhr.setRequestHeader(\"Accept\", \"application/json\");\n// 发送 Http 请求\nxhr.send(null);\n\n\n\n# 16. 使用Promise封装AJAX请求\n\n// promise 封装实现：\nfunction getJSON(url) {\n  // 创建一个 promise 对象\n  let promise = new Promise(function(resolve, reject) {\n    let xhr = new XMLHttpRequest();\n    // 新建一个 http 请求\n    xhr.open(\"GET\", url, true);\n    // 设置状态的监听函数\n    xhr.onreadystatechange = function() {\n      if (this.readyState !== 4) return;\n      // 当请求成功或失败时，改变 promise 的状态\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    // 设置错误监听函数\n    xhr.onerror = function() {\n      reject(new Error(this.statusText));\n    };\n    // 设置响应的数据类型\n    xhr.responseType = \"json\";\n    // 设置请求头信息\n    xhr.setRequestHeader(\"Accept\", \"application/json\");\n    // 发送 http 请求\n    xhr.send(null);\n  });\n  return promise;\n}\n\n\n\n# 17. 实现浅拷贝\n\n浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。\n\n# （1）Object.assign()\n\nObject.assign()是ES6中对象的拷贝方法，接受的第一个参数是目标对象，其余参数是源对象，用法：Object.assign(target, source_1, ···)，该方法可以实现浅拷贝，也可以实现一维对象的深拷贝。\n\n注意：\n\n * 如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。\n * 如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。\n * 因为null 和 undefined 不能转化为对象，所以第一个参数不能为null或 undefined，会报错。\n\nlet target = {a: 1};\nlet object2 = {b: 2};\nlet object3 = {c: 3};\nObject.assign(target,object2,object3);  \nconsole.log(target);  // {a: 1, b: 2, c: 3}\n\n\n# （2）扩展运算符\n\n使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。语法：let cloneObj = { ...obj };\n\nlet obj1 = {a:1,b:{c:1}}\nlet obj2 = {...obj1};\nobj1.a = 2;\nconsole.log(obj1); //{a:2,b:{c:1}}\nconsole.log(obj2); //{a:1,b:{c:1}}\nobj1.b.c = 2;\nconsole.log(obj1); //{a:2,b:{c:2}}\nconsole.log(obj2); //{a:1,b:{c:2}}\n\n\n# （3）数组方法实现数组浅拷贝\n\n# 1）Array.prototype.slice\n\n * slice()方法是JavaScript数组的一个方法，这个方法可以从已有数组中返回选定的元素：用法：array.slice(start, end)，该方法不会改变原始数组。\n * 该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。\n\nlet arr = [1,2,3,4];\nconsole.log(arr.slice()); // [1,2,3,4]\nconsole.log(arr.slice() === arr); //false\n\n\n# 2）Array.prototype.concat\n\n * concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。\n * 该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。\n\nlet arr = [1,2,3,4];\nconsole.log(arr.concat()); // [1,2,3,4]\nconsole.log(arr.concat() === arr); //false\n\n\n# （4）手写实现浅拷贝\n\n// 浅拷贝的实现;\n\nfunction shallowCopy(object) {\n  // 只拷贝对象\n  if (!object || typeof object !== \"object\") return;\n\n  // 根据 object 的类型判断是新建一个数组还是对象\n  let newObject = Array.isArray(object) ? [] : {};\n\n  // 遍历 object，并且判断是 object 的属性才拷贝\n  for (let key in object) {\n    if (object.hasOwnProperty(key)) {\n      newObject[key] = object[key];\n    }\n  }\n\n  return newObject;\n}// 浅拷贝的实现;\n\nfunction shallowCopy(object) {\n  // 只拷贝对象\n  if (!object || typeof object !== \"object\") return;\n\n  // 根据 object 的类型判断是新建一个数组还是对象\n  let newObject = Array.isArray(object) ? [] : {};\n\n  // 遍历 object，并且判断是 object 的属性才拷贝\n  for (let key in object) {\n    if (object.hasOwnProperty(key)) {\n      newObject[key] = object[key];\n    }\n  }\n\n  return newObject;\n}// 浅拷贝的实现;\nfunction shallowCopy(object) {\n  // 只拷贝对象\n  if (!object || typeof object !== \"object\") return;\n  // 根据 object 的类型判断是新建一个数组还是对象\n  let newObject = Array.isArray(object) ? [] : {};\n  // 遍历 object，并且判断是 object 的属性才拷贝\n  for (let key in object) {\n    if (object.hasOwnProperty(key)) {\n      newObject[key] = object[key];\n    }\n  }\n  return newObject;\n}\n\n\n\n# 18. 实现深拷贝\n\n * 浅拷贝： 浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 Object.assign 和展开运算符来实现。\n * 深拷贝： 深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败\n\n# （1）JSON.stringify()\n\n * JSON.parse(JSON.stringify(obj))是目前比较常用的深拷贝方法之一，它的原理就是利用JSON.stringify 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象。\n * 这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过JSON.stringify()进行处理之后，都会消失。\n\nlet obj1 = {  a: 0,\n              b: {\n                 c: 0\n                 }\n            };\nlet obj2 = JSON.parse(JSON.stringify(obj1));\nobj1.a = 1;\nobj1.b.c = 1;\nconsole.log(obj1); // {a: 1, b: {c: 1}}\nconsole.log(obj2); // {a: 0, b: {c: 0}}\n\n\n# （2）函数库lodash的_.cloneDeep方法\n\n该函数库也有提供_.cloneDeep用来做 Deep Copy\n\nvar _ = require('lodash');\nvar obj1 = {\n    a: 1,\n    b: { f: { g: 1 } },\n    c: [1, 2, 3]\n};\nvar obj2 = _.cloneDeep(obj1);\nconsole.log(obj1.b.f === obj2.b.f);// false\n\n\n# （3）手写实现深拷贝函数\n\n// 深拷贝的实现\nfunction deepCopy(object) {\n  if (!object || typeof object !== \"object\") return;\n\n  let newObject = Array.isArray(object) ? [] : {};\n\n  for (let key in object) {\n    if (object.hasOwnProperty(key)) {\n      newObject[key] =\n        typeof object[key] === \"object\" ? deepCopy(object[key]) : object[key];\n    }\n  }\n\n  return newObject;\n}\n",
      "normalizedContent": "# 1. 手写 object.create\n\n思路：将传入的对象作为原型\n\nfunction create(obj) {\n  function f() {}\n  f.prototype = obj\n  return new f()\n}\n\n\n\n# 2. 手写 instanceof 方法\n\ninstanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\n\n实现步骤：\n\n 1. 首先获取类型的原型\n 2. 然后获得对象的原型\n 3. 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null\n\n具体实现：\n\nfunction myinstanceof(left, right) {\n  let proto = object.getprototypeof(left), // 获取对象的原型\n      prototype = right.prototype; // 获取构造函数的 prototype 对象\n\n  // 判断构造函数的 prototype 对象是否在对象的原型链上\n  while (true) {\n    if (!proto) return false;\n    if (proto === prototype) return true;\n\n    proto = object.getprototypeof(proto);\n  }\n}\n\n\n\n# 3. 手写 new 操作符\n\n在调用 new 的过程中会发生以上四件事情：\n\n（1）首先创建了一个新的空对象\n\n（2）设置原型，将对象的原型设置为函数的 prototype 对象。\n\n（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\n\n（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。\n\nfunction objectfactory() {\n  let newobject = null;\n  let constructor = array.prototype.shift.call(arguments);\n  let result = null;\n  // 判断参数是否是一个函数\n  if (typeof constructor !== \"function\") {\n    console.error(\"type error\");\n    return;\n  }\n  // 新建一个空对象，对象的原型为构造函数的 prototype 对象\n  newobject = object.create(constructor.prototype);\n  // 将 this 指向新建对象，并执行函数\n  result = constructor.apply(newobject, arguments);\n  // 判断返回对象\n  let flag = result && (typeof result === \"object\" || typeof result === \"function\");\n  // 判断返回结果\n  return flag ? result : newobject;\n}\n// 使用方法\nobjectfactory(构造函数, 初始化参数);\n\n\n\n# 4. 手写 promise\n\nconst pending = \"pending\";\nconst resolved = \"resolved\";\nconst rejected = \"rejected\";\n\nfunction mypromise(fn) {\n  // 保存初始化状态\n  var self = this;\n\n  // 初始化状态\n  this.state = pending;\n\n  // 用于保存 resolve 或者 rejected 传入的值\n  this.value = null;\n\n  // 用于保存 resolve 的回调函数\n  this.resolvedcallbacks = [];\n\n  // 用于保存 reject 的回调函数\n  this.rejectedcallbacks = [];\n\n  // 状态转变为 resolved 方法\n  function resolve(value) {\n    // 判断传入元素是否为 promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变\n    if (value instanceof mypromise) {\n      return value.then(resolve, reject);\n    }\n\n    // 保证代码的执行顺序为本轮事件循环的末尾\n    settimeout(() => {\n      // 只有状态为 pending 时才能转变，\n      if (self.state === pending) {\n        // 修改状态\n        self.state = resolved;\n\n        // 设置传入的值\n        self.value = value;\n\n        // 执行回调函数\n        self.resolvedcallbacks.foreach(callback => {\n          callback(value);\n        });\n      }\n    }, 0);\n  }\n\n  // 状态转变为 rejected 方法\n  function reject(value) {\n    // 保证代码的执行顺序为本轮事件循环的末尾\n    settimeout(() => {\n      // 只有状态为 pending 时才能转变\n      if (self.state === pending) {\n        // 修改状态\n        self.state = rejected;\n\n        // 设置传入的值\n        self.value = value;\n\n        // 执行回调函数\n        self.rejectedcallbacks.foreach(callback => {\n          callback(value);\n        });\n      }\n    }, 0);\n  }\n\n  // 将两个方法传入函数执行\n  try {\n    fn(resolve, reject);\n  } catch (e) {\n    // 遇到错误时，捕获错误，执行 reject 函数\n    reject(e);\n  }\n}\n\nmypromise.prototype.then = function(onresolved, onrejected) {\n  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数\n  onresolved =\n    typeof onresolved === \"function\"\n      ? onresolved\n      : function(value) {\n          return value;\n        };\n\n  onrejected =\n    typeof onrejected === \"function\"\n      ? onrejected\n      : function(error) {\n          throw error;\n        };\n\n  // 如果是等待状态，则将函数加入对应列表中\n  if (this.state === pending) {\n    this.resolvedcallbacks.push(onresolved);\n    this.rejectedcallbacks.push(onrejected);\n  }\n\n  // 如果状态已经凝固，则直接执行对应状态的函数\n\n  if (this.state === resolved) {\n    onresolved(this.value);\n  }\n\n  if (this.state === rejected) {\n    onrejected(this.value);\n  }\n};\n\n\n\n# 5. 手写 promise.then\n\nthen 方法返回一个新的 promise 实例，为了在 promise 状态发生变化时（resolve / reject 被调用时）再执行 then 里的函数，我们使用一个 callbacks 数组先把传给then的函数暂存起来，等状态改变时再调用。\n\n那么，怎么保证后一个 *\\*\\*then\\*\\** 里的方法在前一个 *\\*\\*then\\*\\**（可能是异步）结束之后再执行呢？ 我们可以将传给 then 的函数和新 promise 的 resolve 一起 push 到前一个 promise 的 callbacks 数组中，达到承前启后的效果：\n\n * 承前：当前一个 promise 完成后，调用其 resolve 变更状态，在这个 resolve 里会依次调用 callbacks 里的回调，这样就执行了 then 里的方法了\n * 启后：上一步中，当 then 里的方法执行完成后，返回一个结果，如果这个结果是个简单的值，就直接调用新 promise 的 resolve，让其状态变更，这又会依次调用新 promise 的 callbacks 数组里的方法，循环往复。。如果返回的结果是个 promise，则需要等它完成之后再触发新 promise 的 resolve，所以可以在其结果的 then 里调用新 promise 的 resolve\n\nthen(onfulfilled, onreject){\n    // 保存前一个promise的this\n    const self = this; \n    return new mypromise((resolve, reject) => {\n      // 封装前一个promise成功时执行的函数\n      let fulfilled = () => {\n        try{\n          const result = onfulfilled(self.value); // 承前\n          return result instanceof mypromise? result.then(resolve, reject) : resolve(result); //启后\n        }catch(err){\n          reject(err)\n        }\n      }\n      // 封装前一个promise失败时执行的函数\n      let rejected = () => {\n        try{\n          const result = onreject(self.reason);\n          return result instanceof mypromise? result.then(resolve, reject) : reject(result);\n        }catch(err){\n          reject(err)\n        }\n      }\n      switch(self.status){\n        case pending: \n          self.onfulfilledcallbacks.push(fulfilled);\n          self.onrejectedcallbacks.push(rejected);\n          break;\n        case fulfilled:\n          fulfilled();\n          break;\n        case reject:\n          rejected();\n          break;\n      }\n    })\n   }\n\n\n注意：\n\n * 连续多个 then 里的回调方法是同步注册的，但注册到了不同的 callbacks 数组中，因为每次 then 都返回新的 promise 实例（参考上面的例子和图）\n * 注册完成后开始执行构造函数中的异步事件，异步完成之后依次调用 callbacks 数组中提前注册的回调\n\n\n# 6. 手写 promise.all\n\n1) 核心思路\n\n 1. 接收一个 promise 实例的数组或具有 iterator 接口的对象作为参数\n 2. 这个方法返回一个新的 promise 对象，\n 3. 遍历传入的参数，用promise.resolve()将参数\"包一层\"，使其变成一个promise对象\n 4. 参数所有回调成功才是成功，返回值数组与参数顺序一致\n 5. 参数数组其中一个失败，则触发失败状态，第一个触发失败的 promise 错误信息作为 promise.all 的错误信息。\n\n2）实现代码\n\n一般来说，promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了\n\nfunction promiseall(promises) {\n  return new promise(function(resolve, reject) {\n    if(!array.isarray(promises)){\n        throw new typeerror(`argument must be a array`)\n    }\n    var resolvedcounter = 0;\n    var promisenum = promises.length;\n    var resolvedresult = [];\n    for (let i = 0; i < promisenum; i++) {\n      promise.resolve(promises[i]).then(value=>{\n        resolvedcounter++;\n        resolvedresult[i] = value;\n        if (resolvedcounter == promisenum) {\n            return resolve(resolvedresult)\n          }\n      },error=>{\n        return reject(error)\n      })\n    }\n  })\n}\n// test\nlet p1 = new promise(function (resolve, reject) {\n    settimeout(function () {\n        resolve(1)\n    }, 1000)\n})\nlet p2 = new promise(function (resolve, reject) {\n    settimeout(function () {\n        resolve(2)\n    }, 2000)\n})\nlet p3 = new promise(function (resolve, reject) {\n    settimeout(function () {\n        resolve(3)\n    }, 3000)\n})\npromiseall([p3, p1, p2]).then(res => {\n    console.log(res) // [3, 1, 2]\n})\n\n\n\n# 7. 手写 promise.race\n\n该方法的参数是 promise 实例数组, 然后其 then 注册的回调方法是数组中的某一个 promise 的状态变为 fulfilled 的时候就执行. 因为 promise 的状态只能改变一次, 那么我们只需要把 promise.race 中产生的 promise 对象的 resolve 方法, 注入到数组中的每一个 promise 实例中的回调函数中即可.\n\npromise.race = function (args) {\n  return new promise((resolve, reject) => {\n    for (let i = 0, len = args.length; i < len; i++) {\n      args[i].then(resolve, reject)\n    }\n  })\n}\n\n\n\n# 8. 手写防抖函数\n\n函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。\n\n// 函数防抖的实现\nfunction debounce(fn, wait) {\n  let timer = null;\n\n  return function() {\n    let context = this,\n        args = arguments;\n\n    // 如果此时存在定时器的话，则取消之前的定时器重新记时\n    if (timer) {\n      cleartimeout(timer);\n      timer = null;\n    }\n\n    // 设置定时器，使事件间隔指定事件后执行\n    timer = settimeout(() => {\n      fn.apply(context, args);\n    }, wait);\n  };\n}\n\n\n\n# 9. 手写节流函数\n\n函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。\n\n// 函数节流的实现;\nfunction throttle(fn, delay) {\n  let curtime = date.now();\n\n  return function() {\n    let context = this,\n        args = arguments,\n        nowtime = date.now();\n\n    // 如果两次时间间隔超过了指定时间，则执行函数。\n    if (nowtime - curtime >= delay) {\n      curtime = date.now();\n      return fn.apply(context, args);\n    }\n  };\n}\n\n\n\n# 10. 手写类型判断函数\n\nfunction gettype(value) {\n  // 判断数据是 null 的情况\n  if (value === null) {\n    return value + \"\";\n  }\n  // 判断数据是引用类型的情况\n  if (typeof value === \"object\") {\n    let valueclass = object.prototype.tostring.call(value),\n      type = valueclass.split(\" \")[1].split(\"\");\n    type.pop();\n    return type.join(\"\").tolowercase();\n  } else {\n    // 判断数据是基本数据类型的情况和函数的情况\n    return typeof value;\n  }\n}\n\n\n\n# 11. 手写 call 函数\n\ncall 函数的实现步骤：\n\n 1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n 2. 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n 3. 处理传入的参数，截取第一个参数后的所有参数。\n 4. 将函数作为上下文对象的一个属性。\n 5. 使用上下文对象来调用这个方法，并保存返回结果。\n 6. 删除刚才新增的属性。\n 7. 返回结果。\n\n// call函数实现\nfunction.prototype.mycall = function(context) {\n  // 判断调用对象\n  if (typeof this !== \"function\") {\n    console.error(\"type error\");\n  }\n  // 获取参数\n  let args = [...arguments].slice(1),\n      result = null;\n  // 判断 context 是否传入，如果未传入则设置为 window\n  context = context || window;\n  // 将调用函数设为对象的方法\n  context.fn = this;\n  // 调用函数\n  result = context.fn(...args);\n  // 将属性删除\n  delete context.fn;\n  return result;\n};\n\n\n\n# 12. 手写 apply 函数\n\napply 函数的实现步骤：\n\n 1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n 2. 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n 3. 将函数作为上下文对象的一个属性。\n 4. 判断参数值是否传入\n 5. 使用上下文对象来调用这个方法，并保存返回结果。\n 6. 删除刚才新增的属性\n 7. 返回结果\n\n// apply 函数实现\nfunction.prototype.myapply = function(context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== \"function\") {\n    throw new typeerror(\"error\");\n  }\n  let result = null;\n  // 判断 context 是否存在，如果未传入则为 window\n  context = context || window;\n  // 将函数设为对象的方法\n  context.fn = this;\n  // 调用方法\n  if (arguments[1]) {\n    result = context.fn(...arguments[1]);\n  } else {\n    result = context.fn();\n  }\n  // 将属性删除\n  delete context.fn;\n  return result;\n};\n\n\n\n# 13. 手写 bind 函数\n\nbind 函数的实现步骤：\n\n 1. 判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n 2. 保存当前函数的引用，获取其余传入参数值。\n 3. 创建一个函数返回\n 4. 函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。\n\n// bind 函数实现\nfunction.prototype.mybind = function(context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== \"function\") {\n    throw new typeerror(\"error\");\n  }\n  // 获取参数\n  var args = [...arguments].slice(1),\n      fn = this;\n  return function fn() {\n    // 根据调用方式，传入不同绑定值\n    return fn.apply(\n      this instanceof fn ? this : context,\n      args.concat(...arguments)\n    );\n  };\n};\n\n\n\n# 14. 函数柯里化的实现\n\n函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\n\nfunction curry(fn, args) {\n  // 获取函数需要的参数长度\n  let length = fn.length;\n\n  args = args || [];\n\n  return function() {\n    let subargs = args.slice(0);\n\n    // 拼接得到现有的所有参数\n    for (let i = 0; i < arguments.length; i++) {\n      subargs.push(arguments[i]);\n    }\n\n    // 判断参数的长度是否已经满足函数所需参数的长度\n    if (subargs.length >= length) {\n      // 如果满足，执行函数\n      return fn.apply(this, subargs);\n    } else {\n      // 如果不满足，递归返回科里化的函数，等待参数的传入\n      return curry.call(this, fn, subargs);\n    }\n  };\n}\n\n// es6 实现\nfunction curry(fn, ...args) {\n  return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args);\n}\n\n\n\n# 15. 实现ajax请求\n\najax是 asynchronous javascript and xml 的缩写，指的是通过 javascript 的 异步通信，从服务器获取 xml 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。\n\n创建ajax请求的步骤：\n\n * 创建一个 xmlhttprequest 对象。\n * 在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。\n * 在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 setrequestheader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 xmlhttprequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readystate 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。\n * 当对象的属性和监听函数设置完成后，最后调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。\n\nconst server_url = \"/server\";\nlet xhr = new xmlhttprequest();\n// 创建 http 请求\nxhr.open(\"get\", server_url, true);\n// 设置状态监听函数\nxhr.onreadystatechange = function() {\n  if (this.readystate !== 4) return;\n  // 当请求成功时\n  if (this.status === 200) {\n    handle(this.response);\n  } else {\n    console.error(this.statustext);\n  }\n};\n// 设置请求失败时的监听函数\nxhr.onerror = function() {\n  console.error(this.statustext);\n};\n// 设置请求头信息\nxhr.responsetype = \"json\";\nxhr.setrequestheader(\"accept\", \"application/json\");\n// 发送 http 请求\nxhr.send(null);\n\n\n\n# 16. 使用promise封装ajax请求\n\n// promise 封装实现：\nfunction getjson(url) {\n  // 创建一个 promise 对象\n  let promise = new promise(function(resolve, reject) {\n    let xhr = new xmlhttprequest();\n    // 新建一个 http 请求\n    xhr.open(\"get\", url, true);\n    // 设置状态的监听函数\n    xhr.onreadystatechange = function() {\n      if (this.readystate !== 4) return;\n      // 当请求成功或失败时，改变 promise 的状态\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new error(this.statustext));\n      }\n    };\n    // 设置错误监听函数\n    xhr.onerror = function() {\n      reject(new error(this.statustext));\n    };\n    // 设置响应的数据类型\n    xhr.responsetype = \"json\";\n    // 设置请求头信息\n    xhr.setrequestheader(\"accept\", \"application/json\");\n    // 发送 http 请求\n    xhr.send(null);\n  });\n  return promise;\n}\n\n\n\n# 17. 实现浅拷贝\n\n浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。\n\n# （1）object.assign()\n\nobject.assign()是es6中对象的拷贝方法，接受的第一个参数是目标对象，其余参数是源对象，用法：object.assign(target, source_1, ···)，该方法可以实现浅拷贝，也可以实现一维对象的深拷贝。\n\n注意：\n\n * 如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。\n * 如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。\n * 因为null 和 undefined 不能转化为对象，所以第一个参数不能为null或 undefined，会报错。\n\nlet target = {a: 1};\nlet object2 = {b: 2};\nlet object3 = {c: 3};\nobject.assign(target,object2,object3);  \nconsole.log(target);  // {a: 1, b: 2, c: 3}\n\n\n# （2）扩展运算符\n\n使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。语法：let cloneobj = { ...obj };\n\nlet obj1 = {a:1,b:{c:1}}\nlet obj2 = {...obj1};\nobj1.a = 2;\nconsole.log(obj1); //{a:2,b:{c:1}}\nconsole.log(obj2); //{a:1,b:{c:1}}\nobj1.b.c = 2;\nconsole.log(obj1); //{a:2,b:{c:2}}\nconsole.log(obj2); //{a:1,b:{c:2}}\n\n\n# （3）数组方法实现数组浅拷贝\n\n# 1）array.prototype.slice\n\n * slice()方法是javascript数组的一个方法，这个方法可以从已有数组中返回选定的元素：用法：array.slice(start, end)，该方法不会改变原始数组。\n * 该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。\n\nlet arr = [1,2,3,4];\nconsole.log(arr.slice()); // [1,2,3,4]\nconsole.log(arr.slice() === arr); //false\n\n\n# 2）array.prototype.concat\n\n * concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。\n * 该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。\n\nlet arr = [1,2,3,4];\nconsole.log(arr.concat()); // [1,2,3,4]\nconsole.log(arr.concat() === arr); //false\n\n\n# （4）手写实现浅拷贝\n\n// 浅拷贝的实现;\n\nfunction shallowcopy(object) {\n  // 只拷贝对象\n  if (!object || typeof object !== \"object\") return;\n\n  // 根据 object 的类型判断是新建一个数组还是对象\n  let newobject = array.isarray(object) ? [] : {};\n\n  // 遍历 object，并且判断是 object 的属性才拷贝\n  for (let key in object) {\n    if (object.hasownproperty(key)) {\n      newobject[key] = object[key];\n    }\n  }\n\n  return newobject;\n}// 浅拷贝的实现;\n\nfunction shallowcopy(object) {\n  // 只拷贝对象\n  if (!object || typeof object !== \"object\") return;\n\n  // 根据 object 的类型判断是新建一个数组还是对象\n  let newobject = array.isarray(object) ? [] : {};\n\n  // 遍历 object，并且判断是 object 的属性才拷贝\n  for (let key in object) {\n    if (object.hasownproperty(key)) {\n      newobject[key] = object[key];\n    }\n  }\n\n  return newobject;\n}// 浅拷贝的实现;\nfunction shallowcopy(object) {\n  // 只拷贝对象\n  if (!object || typeof object !== \"object\") return;\n  // 根据 object 的类型判断是新建一个数组还是对象\n  let newobject = array.isarray(object) ? [] : {};\n  // 遍历 object，并且判断是 object 的属性才拷贝\n  for (let key in object) {\n    if (object.hasownproperty(key)) {\n      newobject[key] = object[key];\n    }\n  }\n  return newobject;\n}\n\n\n\n# 18. 实现深拷贝\n\n * 浅拷贝： 浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 object.assign 和展开运算符来实现。\n * 深拷贝： 深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 json 的两个函数来实现，但是由于 json 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 symbol 类型的值时，会转换失败\n\n# （1）json.stringify()\n\n * json.parse(json.stringify(obj))是目前比较常用的深拷贝方法之一，它的原理就是利用json.stringify 将js对象序列化（json字符串），再使用json.parse来反序列化(还原)js对象。\n * 这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过json.stringify()进行处理之后，都会消失。\n\nlet obj1 = {  a: 0,\n              b: {\n                 c: 0\n                 }\n            };\nlet obj2 = json.parse(json.stringify(obj1));\nobj1.a = 1;\nobj1.b.c = 1;\nconsole.log(obj1); // {a: 1, b: {c: 1}}\nconsole.log(obj2); // {a: 0, b: {c: 0}}\n\n\n# （2）函数库lodash的_.clonedeep方法\n\n该函数库也有提供_.clonedeep用来做 deep copy\n\nvar _ = require('lodash');\nvar obj1 = {\n    a: 1,\n    b: { f: { g: 1 } },\n    c: [1, 2, 3]\n};\nvar obj2 = _.clonedeep(obj1);\nconsole.log(obj1.b.f === obj2.b.f);// false\n\n\n# （3）手写实现深拷贝函数\n\n// 深拷贝的实现\nfunction deepcopy(object) {\n  if (!object || typeof object !== \"object\") return;\n\n  let newobject = array.isarray(object) ? [] : {};\n\n  for (let key in object) {\n    if (object.hasownproperty(key)) {\n      newobject[key] =\n        typeof object[key] === \"object\" ? deepcopy(object[key]) : object[key];\n    }\n  }\n\n  return newobject;\n}\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "数据处理",
      "frontmatter": {
        "title": "数据处理",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/writeCode/dataProcessing/",
        "article": false
      },
      "regularPath": "/40.%E4%BB%A3%E7%A0%81%E7%AF%87/10.%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%AF%87/20.%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html",
      "relativePath": "40.代码篇/10.手写代码篇/20.数据处理.md",
      "key": "v-bbc21a6a",
      "path": "/pages/writeCode/dataProcessing/",
      "headers": [
        {
          "level": 3,
          "title": "1. 实现日期格式化函数",
          "slug": "_1-实现日期格式化函数",
          "normalizedTitle": "1. 实现日期格式化函数",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 交换a,b的值，不能用临时变量",
          "slug": "_2-交换a-b的值-不能用临时变量",
          "normalizedTitle": "2. 交换a,b的值，不能用临时变量",
          "charIndex": 519
        },
        {
          "level": 3,
          "title": "3. 实现数组的乱序输出",
          "slug": "_3-实现数组的乱序输出",
          "normalizedTitle": "3. 实现数组的乱序输出",
          "charIndex": 589
        },
        {
          "level": 3,
          "title": "4. 实现数组元素求和",
          "slug": "_4-实现数组元素求和",
          "normalizedTitle": "4. 实现数组元素求和",
          "charIndex": 1262
        },
        {
          "level": 3,
          "title": "5. 实现数组的扁平化",
          "slug": "_5-实现数组的扁平化",
          "normalizedTitle": "5. 实现数组的扁平化",
          "charIndex": 1750
        },
        {
          "level": 3,
          "title": "6. 实现数组去重",
          "slug": "_6-实现数组去重",
          "normalizedTitle": "6. 实现数组去重",
          "charIndex": 3854
        },
        {
          "level": 3,
          "title": "7. 实现数组的flat方法",
          "slug": "_7-实现数组的flat方法",
          "normalizedTitle": "7. 实现数组的flat方法",
          "charIndex": 4355
        },
        {
          "level": 3,
          "title": "8. 实现数组的push方法",
          "slug": "_8-实现数组的push方法",
          "normalizedTitle": "8. 实现数组的push方法",
          "charIndex": 4644
        },
        {
          "level": 3,
          "title": "9. 实现数组的filter方法",
          "slug": "_9-实现数组的filter方法",
          "normalizedTitle": "9. 实现数组的filter方法",
          "charIndex": 4825
        },
        {
          "level": 3,
          "title": "10. 实现数组的map方法",
          "slug": "_10-实现数组的map方法",
          "normalizedTitle": "10. 实现数组的map方法",
          "charIndex": 5106
        },
        {
          "level": 3,
          "title": "11. 实现字符串的repeat方法",
          "slug": "_11-实现字符串的repeat方法",
          "normalizedTitle": "11. 实现字符串的repeat方法",
          "charIndex": 5370
        },
        {
          "level": 3,
          "title": "12. 实现字符串翻转",
          "slug": "_12-实现字符串翻转",
          "normalizedTitle": "12. 实现字符串翻转",
          "charIndex": 5590
        },
        {
          "level": 3,
          "title": "13. 将数字每千分位用逗号隔开",
          "slug": "_13-将数字每千分位用逗号隔开",
          "normalizedTitle": "13. 将数字每千分位用逗号隔开",
          "charIndex": 5847
        },
        {
          "level": 3,
          "title": "14. 实现非负大整数相加",
          "slug": "_14-实现非负大整数相加",
          "normalizedTitle": "14. 实现非负大整数相加",
          "charIndex": 6977
        },
        {
          "level": 3,
          "title": "13. 实现 add(1)(2)(3)",
          "slug": "_13-实现-add-1-2-3",
          "normalizedTitle": "13. 实现 add(1)(2)(3)",
          "charIndex": 7856
        },
        {
          "level": 3,
          "title": "14. 实现类数组转化为数组",
          "slug": "_14-实现类数组转化为数组",
          "normalizedTitle": "14. 实现类数组转化为数组",
          "charIndex": 9333
        },
        {
          "level": 3,
          "title": "15. 使用 reduce 求和",
          "slug": "_15-使用-reduce-求和",
          "normalizedTitle": "15. 使用 reduce 求和",
          "charIndex": 9654
        },
        {
          "level": 3,
          "title": "16. 将js对象转化为树形结构",
          "slug": "_16-将js对象转化为树形结构",
          "normalizedTitle": "16. 将js对象转化为树形结构",
          "charIndex": 10091
        },
        {
          "level": 3,
          "title": "17. 使用ES5和ES6求函数参数的和",
          "slug": "_17-使用es5和es6求函数参数的和",
          "normalizedTitle": "17. 使用es5和es6求函数参数的和",
          "charIndex": 11112
        },
        {
          "level": 3,
          "title": "18. 解析 URL Params 为对象",
          "slug": "_18-解析-url-params-为对象",
          "normalizedTitle": "18. 解析 url params 为对象",
          "charIndex": 11417
        }
      ],
      "headersStr": "1. 实现日期格式化函数 2. 交换a,b的值，不能用临时变量 3. 实现数组的乱序输出 4. 实现数组元素求和 5. 实现数组的扁平化 6. 实现数组去重 7. 实现数组的flat方法 8. 实现数组的push方法 9. 实现数组的filter方法 10. 实现数组的map方法 11. 实现字符串的repeat方法 12. 实现字符串翻转 13. 将数字每千分位用逗号隔开 14. 实现非负大整数相加 13. 实现 add(1)(2)(3) 14. 实现类数组转化为数组 15. 使用 reduce 求和 16. 将js对象转化为树形结构 17. 使用ES5和ES6求函数参数的和 18. 解析 URL Params 为对象",
      "content": "# 1. 实现日期格式化函数\n\n输入：\n\ndateFormat(new Date('2020-12-01'), 'yyyy/MM/dd') // 2020/12/01\ndateFormat(new Date('2020-04-01'), 'yyyy/MM/dd') // 2020/04/01\ndateFormat(new Date('2020-04-01'), 'yyyy年MM月dd日') // 2020年04月01日\nconst dateFormat = (dateInput, format)=>{\n    var day = dateInput.getDate() \n    var month = dateInput.getMonth() + 1  \n    var year = dateInput.getFullYear()   \n    format = format.replace(/yyyy/, year)\n    format = format.replace(/MM/,month)\n    format = format.replace(/dd/,day)\n    return format\n}\n\n\n\n# 2. 交换a,b的值，不能用临时变量\n\n巧妙的利用两个数的和、差：\n\na = a + b\nb = a - b\na = a - b\n\n\n\n# 3. 实现数组的乱序输出\n\n主要的实现思路就是：\n\n * 取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换。\n * 第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换\n * 按照上面的规律执行，直到遍历完成\n\nvar arr = [1,2,3,4,5,6,7,8,9,10];\nfor (var i = 0; i < arr.length; i++) {\n  const randomIndex = Math.round(Math.random() * (arr.length - 1 - i)) + i;\n  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];\n}\nconsole.log(arr)\n\n\n还有一方法就是倒序遍历：\n\nvar arr = [1,2,3,4,5,6,7,8,9,10];\nlet length = arr.length,\n    randomIndex,\n    temp;\n  while (length) {\n    randomIndex = Math.floor(Math.random() * length--);\n    temp = arr[length];\n    arr[length] = arr[randomIndex];\n    arr[randomIndex] = temp;\n  }\nconsole.log(arr)\n\n\n\n# 4. 实现数组元素求和\n\n * arr=[1,2,3,4,5,6,7,8,9,10]，求和\n\nlet arr=[1,2,3,4,5,6,7,8,9,10]\nlet sum = arr.reduce( (total,i) => total += i,0);\nconsole.log(sum);\n\n\n * arr=[1,2,3,[[4,5],6],7,8,9]，求和\n\nvar = arr=[1,2,3,[[4,5],6],7,8,9]\nlet arr= arr.toString().split(',').reduce( (total,i) => total += Number(i),0);\nconsole.log(arr);\n\n\n递归实现：\n\nlet arr = [1, 2, 3, 4, 5, 6] \n\nfunction add(arr) {\n    if (arr.length == 1) return arr[0] \n    return arr[0] + add(arr.slice(1)) \n}\nconsole.log(add(arr)) // 21\n\n\n\n# 5. 实现数组的扁平化\n\n（1）递归实现\n\n普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接：\n\nlet arr = [1, [2, [3, 4, 5]]];\nfunction flatten(arr) {\n  let result = [];\n\n  for(let i = 0; i < arr.length; i++) {\n    if(Array.isArray(arr[i])) {\n      result = result.concat(flatten(arr[i]));\n    } else {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n}\nflatten(arr);  //  [1, 2, 3, 4，5]\n\n\n（2）reduce 函数迭代\n\n从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么其实也可以用reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示：\n\nlet arr = [1, [2, [3, 4]]];\nfunction flatten(arr) {\n    return arr.reduce(function(prev, next){\n        return prev.concat(Array.isArray(next) ? flatten(next) : next)\n    }, [])\n}\nconsole.log(flatten(arr));//  [1, 2, 3, 4，5]\n\n\n（3）扩展运算符实现\n\n这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的：\n\nlet arr = [1, [2, [3, 4]]];\nfunction flatten(arr) {\n    while (arr.some(item => Array.isArray(item))) {\n        arr = [].concat(...arr);\n    }\n    return arr;\n}\nconsole.log(flatten(arr)); //  [1, 2, 3, 4，5]\n\n\n（4）split 和 toString\n\n可以通过 split 和 toString 两个方法来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示：\n\nlet arr = [1, [2, [3, 4]]];\nfunction flatten(arr) {\n    return arr.toString().split(',');\n}\nconsole.log(flatten(arr)); //  [1, 2, 3, 4，5]\n\n\n通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组。\n\n（5）ES6 中的 flat\n\n我们还可以直接调用 ES6 中的 flat 方法来实现数组扁平化。flat 方法的语法：arr.flat([depth])\n\n其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。如果层数不确定，参数可以传进 Infinity，代表不论多少层都要展开：\n\nlet arr = [1, [2, [3, 4]]];\nfunction flatten(arr) {\n  return arr.flat(Infinity);\n}\nconsole.log(flatten(arr)); //  [1, 2, 3, 4，5]\n\n\n可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。在编程过程中，如果数组的嵌套层数不确定，最好直接使用 Infinity，可以达到扁平化。 （6）正则和 JSON 方法 在第4种方法中已经使用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组：\n\nlet arr = [1, [2, [3, [4, 5]]], 6];\nfunction flatten(arr) {\n  let str = JSON.stringify(arr);\n  str = str.replace(/(\\[|\\])/g, '');\n  str = '[' + str + ']';\n  return JSON.parse(str); \n}\nconsole.log(flatten(arr)); //  [1, 2, 3, 4，5]\n\n\n\n# 6. 实现数组去重\n\n给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。\n\nES6方法（使用数据结构集合）：\n\nconst array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];\n\nArray.from(new Set(array)); // [1, 2, 3, 5, 9, 8]\n\n\nES5方法：使用map存储不重复的数字\n\nconst array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];\n\nuniqueArray(array); // [1, 2, 3, 5, 9, 8]\n\nfunction uniqueArray(array) {\n  let map = {};\n  let res = [];\n  for(var i = 0; i < array.length; i++) {\n    if(!map.hasOwnProperty([array[i]])) {\n      map[array[i]] = 1;\n      res.push(array[i]);\n    }\n  }\n  return res;\n}\n\n\n\n# 7. 实现数组的flat方法\n\nfunction _flat(arr, depth) {\n  if(!Array.isArray(arr) || depth <= 0) {\n    return arr;\n  }\n  return arr.reduce((prev, cur) => {\n    if (Array.isArray(cur)) {\n      return prev.concat(_flat(cur, depth - 1))\n    } else {\n      return prev.concat(cur);\n    }\n  }, []);\n}\n\n\n\n# 8. 实现数组的push方法\n\nlet arr = [];\nArray.prototype.push = function() {\n\tfor( let i = 0 ; i < arguments.length ; i++){\n\t\tthis[this.length] = arguments[i] ;\n\t}\n\treturn this.length;\n}\n\n\n\n# 9. 实现数组的filter方法\n\nArray.prototype._filter = function(fn) {\n    if (typeof fn !== \"function\") {\n        throw Error('参数必须是一个函数');\n    }\n    const res = [];\n    for (let i = 0, len = this.length; i < len; i++) {\n        fn(this[i]) && res.push(this[i]);\n    }\n    return res;\n}\n\n\n\n# 10. 实现数组的map方法\n\nArray.prototype._map = function(fn) {\n   if (typeof fn !== \"function\") {\n        throw Error('参数必须是一个函数');\n    }\n    const res = [];\n    for (let i = 0, len = this.length; i < len; i++) {\n        res.push(fn(this[i]));\n    }\n    return res;\n}\n\n\n\n# 11. 实现字符串的repeat方法\n\n输入字符串s，以及其重复的次数，输出重复的结果，例如输入abc，2，输出abcabc。\n\nfunction repeat(s, n) {\n    return (new Array(n + 1)).join(s);\n}\n\n\n递归：\n\nfunction repeat(s, n) {\n    return (n > 0) ? s.concat(repeat(s, --n)) : \"\";\n}\n\n\n\n# 12. 实现字符串翻转\n\n在字符串的原型链上添加一个方法，实现字符串翻转：\n\nString.prototype._reverse = function(a){\n    return a.split(\"\").reverse().join(\"\");\n}\nvar obj = new String();\nvar res = obj._reverse ('hello');\nconsole.log(res);    // olleh\n\n\n需要注意的是，必须通过实例化对象之后再去调用定义的方法，不然找不到该方法。\n\n\n# 13. 将数字每千分位用逗号隔开\n\n数字有小数版本：\n\nlet format = n => {\n    let num = n.toString() // 转成字符串\n    let decimals = ''\n        // 判断是否有小数\n    num.indexOf('.') > -1 ? decimals = num.split('.')[1] : decimals\n    let len = num.length\n    if (len <= 3) {\n        return num\n    } else {\n        let temp = ''\n        let remainder = len % 3\n        decimals ? temp = '.' + decimals : temp\n        if (remainder > 0) { // 不是3的整数倍\n            return num.slice(0, remainder) + ',' + num.slice(remainder, len).match(/\\d{3}/g).join(',') + temp\n        } else { // 是3的整数倍\n            return num.slice(0, len).match(/\\d{3}/g).join(',') + temp \n        }\n    }\n}\nformat(12323.33)  // '12,323.33'\n\n\n数字无小数版本：\n\nlet format = n => {\n    let num = n.toString() \n    let len = num.length\n    if (len <= 3) {\n        return num\n    } else {\n        let remainder = len % 3\n        if (remainder > 0) { // 不是3的整数倍\n            return num.slice(0, remainder) + ',' + num.slice(remainder, len).match(/\\d{3}/g).join(',') \n        } else { // 是3的整数倍\n            return num.slice(0, len).match(/\\d{3}/g).join(',') \n        }\n    }\n}\nformat(1232323)  // '1,232,323'\n\n\n\n# 14. 实现非负大整数相加\n\nJavaScript对数值有范围的限制，限制如下：\n\nNumber.MAX_VALUE // 1.7976931348623157e+308\nNumber.MAX_SAFE_INTEGER // 9007199254740991\nNumber.MIN_VALUE // 5e-324\nNumber.MIN_SAFE_INTEGER // -9007199254740991\n\n\n如果想要对一个超大的整数(> Number.MAX_SAFE_INTEGER)进行加法运算，但是又想输出一般形式，那么使用 + 是无法达到的，一旦数字超过 Number.MAX_SAFE_INTEGER 数字会被立即转换为科学计数法，并且数字精度相比以前将会有误差。\n\n实现一个算法进行大数的相加：\n\nfunction sumBigNumber(a, b) {\n  let res = '';\n  let temp = 0;\n  \n  a = a.split('');\n  b = b.split('');\n  \n  while (a.length || b.length || temp) {\n    temp += ~~a.pop() + ~~b.pop();\n    res = (temp % 10) + res;\n    temp  = temp > 9\n  }\n  return res.replace(/^0+/, '');\n}\n\n\n其主要的思路如下：\n\n * 首先用字符串的方式来保存大数，这样数字在数学表示上就不会发生变化\n * 初始化res，temp来保存中间的计算结果，并将两个字符串转化为数组，以便进行每一位的加法运算\n * 将两个数组的对应的位进行相加，两个数相加的结果可能大于10，所以可能要仅为，对10进行取余操作，将结果保存在当前位\n * 判断当前位是否大于9，也就是是否会进位，若是则将temp赋值为true，因为在加法运算中，true会自动隐式转化为1，以便于下一次相加\n * 重复上述操作，直至计算结束\n\n\n# 13. 实现 add(1)(2)(3)\n\n函数柯里化概念： 柯里化（Currying）是把接受多个参数的函数转变为接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。\n\n1）粗暴版\n\nfunction add (a) {\nreturn function (b) {\n \treturn function (c) {\n      return a + b + c;\n \t}\n}\n}\nconsole.log(add(1)(2)(3)); // 6\n\n\n2）柯里化解决方案\n\n * 参数长度固定\n\nvar add = function (m) {\n  var temp = function (n) {\n    return add(m + n);\n  }\n  temp.toString = function () {\n    return m;\n  }\n  return temp;\n};\nconsole.log(add(3)(4)(5)); // 12\nconsole.log(add(3)(6)(9)(25)); // 43\n\n\n对于add(3)(4)(5)，其执行过程如下：\n\n 1. 先执行add(3)，此时m=3，并且返回temp函数；\n 2. 执行temp(4)，这个函数内执行add(m+n)，n是此次传进来的数值4，m值还是上一步中的3，所以add(m+n)=add(3+4)=add(7)，此时m=7，并且返回temp函数\n 3. 执行temp(5)，这个函数内执行add(m+n)，n是此次传进来的数值5，m值还是上一步中的7，所以add(m+n)=add(7+5)=add(12)，此时m=12，并且返回temp函数\n 4. 由于后面没有传入参数，等于返回的temp函数不被执行而是打印，了解JS的朋友都知道对象的toString是修改对象转换字符串的方法，因此代码中temp函数的toString函数return m值，而m值是最后一步执行函数时的值m=12，所以返回值是12。\n\n * 参数长度不固定\n\nfunction add (...args) {\n    //求和\n    return args.reduce((a, b) => a + b)\n}\nfunction currying (fn) {\n    let args = []\n    return function temp (...newArgs) {\n        if (newArgs.length) {\n            args = [\n                ...args,\n                ...newArgs\n            ]\n            return temp\n        } else {\n            let val = fn.apply(this, args)\n            args = [] //保证再次调用时清空\n            return val\n        }\n    }\n}\nlet addCurry = currying(add)\nconsole.log(addCurry(1)(2)(3)(4, 5)())  //15\nconsole.log(addCurry(1)(2)(3, 4, 5)())  //15\nconsole.log(addCurry(1)(2, 3, 4, 5)())  //15\n\n\n\n# 14. 实现类数组转化为数组\n\n类数组转换为数组的方法有这样几种：\n\n * 通过 call 调用数组的 slice 方法来实现转换\n\nArray.prototype.slice.call(arrayLike);\n\n\n * 通过 call 调用数组的 splice 方法来实现转换\n\nArray.prototype.splice.call(arrayLike, 0);\n\n\n * 通过 apply 调用数组的 concat 方法来实现转换\n\nArray.prototype.concat.apply([], arrayLike);\n\n\n * 通过 Array.from 方法来实现转换\n\nArray.from(arrayLike);\n\n\n\n# 15. 使用 reduce 求和\n\narr = [1,2,3,4,5,6,7,8,9,10]，求和\n\nlet arr = [1,2,3,4,5,6,7,8,9,10]\narr.reduce((prev, cur) => { return prev + cur }, 0)\n\n\narr = [1,2,3,[[4,5],6],7,8,9]，求和\n\nlet arr = [1,2,3,4,5,6,7,8,9,10]\narr.flat(Infinity).reduce((prev, cur) => { return prev + cur }, 0)\n\n\narr = [{a:1, b:3}, {a:2, b:3, c:4}, {a:3}]，求和\n\nlet arr = [{a:9, b:3, c:4}, {a:1, b:3}, {a:3}] \n\narr.reduce((prev, cur) => {\n    return prev + cur[\"a\"];\n}, 0)\n\n\n\n# 16. 将js对象转化为树形结构\n\n// 转换前：\nsource = [{\n            id: 1,\n            pid: 0,\n            name: 'body'\n          }, {\n            id: 2,\n            pid: 1,\n            name: 'title'\n          }, {\n            id: 3,\n            pid: 2,\n            name: 'div'\n          }]\n// 转换为: \ntree = [{\n          id: 1,\n          pid: 0,\n          name: 'body',\n          children: [{\n            id: 2,\n            pid: 1,\n            name: 'title',\n            children: [{\n              id: 3,\n              pid: 1,\n              name: 'div'\n            }]\n          }\n        }]\n\n\n代码实现：\n\nfunction jsonToTree(data) {\n  // 初始化结果数组，并判断输入数据的格式\n  let result = []\n  if(!Array.isArray(data)) {\n    return result\n  }\n  // 使用map，将当前对象的id与当前对象对应存储起来\n  let map = {};\n  data.forEach(item => {\n    map[item.id] = item;\n  });\n  // \n  data.forEach(item => {\n    let parent = map[item.pid];\n    if(parent) {\n      (parent.children || (parent.children = [])).push(item);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n}\n\n\n\n# 17. 使用ES5和ES6求函数参数的和\n\nES5：\n\nfunction sum() {\n    let sum = 0\n    Array.prototype.forEach.call(arguments, function(item) {\n        sum += item * 1\n    })\n    return sum\n}\n\n\nES6：\n\nfunction sum(...nums) {\n    let sum = 0\n    nums.forEach(function(item) {\n        sum += item * 1\n    })\n    return sum\n}\n\n\n\n# 18. 解析 URL Params 为对象\n\nlet url = 'http://www.domain.com/?user=anonymous&id=123&id=456&city=%E5%8C%97%E4%BA%AC&enabled';\nparseParam(url)\n/* 结果\n{ user: 'anonymous',\n  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型\n  city: '北京', // 中文需解码\n  enabled: true, // 未指定值得 key 约定为 true\n}\n*/\nfunction parseParam(url) {\n  const paramsStr = /.+\\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来\n  const paramsArr = paramsStr.split('&'); // 将字符串以 & 分割后存到数组中\n  let paramsObj = {};\n  // 将 params 存到对象中\n  paramsArr.forEach(param => {\n    if (/=/.test(param)) { // 处理有 value 的参数\n      let [key, val] = param.split('='); // 分割 key 和 value\n      val = decodeURIComponent(val); // 解码\n      val = /^\\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字\n      if (paramsObj.hasOwnProperty(key)) { // 如果对象有 key，则添加一个值\n        paramsObj[key] = [].concat(paramsObj[key], val);\n      } else { // 如果对象没有这个 key，创建 key 并设置值\n        paramsObj[key] = val;\n      }\n    } else { // 处理没有 value 的参数\n      paramsObj[param] = true;\n    }\n  })\n  return paramsObj;\n}\n",
      "normalizedContent": "# 1. 实现日期格式化函数\n\n输入：\n\ndateformat(new date('2020-12-01'), 'yyyy/mm/dd') // 2020/12/01\ndateformat(new date('2020-04-01'), 'yyyy/mm/dd') // 2020/04/01\ndateformat(new date('2020-04-01'), 'yyyy年mm月dd日') // 2020年04月01日\nconst dateformat = (dateinput, format)=>{\n    var day = dateinput.getdate() \n    var month = dateinput.getmonth() + 1  \n    var year = dateinput.getfullyear()   \n    format = format.replace(/yyyy/, year)\n    format = format.replace(/mm/,month)\n    format = format.replace(/dd/,day)\n    return format\n}\n\n\n\n# 2. 交换a,b的值，不能用临时变量\n\n巧妙的利用两个数的和、差：\n\na = a + b\nb = a - b\na = a - b\n\n\n\n# 3. 实现数组的乱序输出\n\n主要的实现思路就是：\n\n * 取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换。\n * 第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换\n * 按照上面的规律执行，直到遍历完成\n\nvar arr = [1,2,3,4,5,6,7,8,9,10];\nfor (var i = 0; i < arr.length; i++) {\n  const randomindex = math.round(math.random() * (arr.length - 1 - i)) + i;\n  [arr[i], arr[randomindex]] = [arr[randomindex], arr[i]];\n}\nconsole.log(arr)\n\n\n还有一方法就是倒序遍历：\n\nvar arr = [1,2,3,4,5,6,7,8,9,10];\nlet length = arr.length,\n    randomindex,\n    temp;\n  while (length) {\n    randomindex = math.floor(math.random() * length--);\n    temp = arr[length];\n    arr[length] = arr[randomindex];\n    arr[randomindex] = temp;\n  }\nconsole.log(arr)\n\n\n\n# 4. 实现数组元素求和\n\n * arr=[1,2,3,4,5,6,7,8,9,10]，求和\n\nlet arr=[1,2,3,4,5,6,7,8,9,10]\nlet sum = arr.reduce( (total,i) => total += i,0);\nconsole.log(sum);\n\n\n * arr=[1,2,3,[[4,5],6],7,8,9]，求和\n\nvar = arr=[1,2,3,[[4,5],6],7,8,9]\nlet arr= arr.tostring().split(',').reduce( (total,i) => total += number(i),0);\nconsole.log(arr);\n\n\n递归实现：\n\nlet arr = [1, 2, 3, 4, 5, 6] \n\nfunction add(arr) {\n    if (arr.length == 1) return arr[0] \n    return arr[0] + add(arr.slice(1)) \n}\nconsole.log(add(arr)) // 21\n\n\n\n# 5. 实现数组的扁平化\n\n（1）递归实现\n\n普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接：\n\nlet arr = [1, [2, [3, 4, 5]]];\nfunction flatten(arr) {\n  let result = [];\n\n  for(let i = 0; i < arr.length; i++) {\n    if(array.isarray(arr[i])) {\n      result = result.concat(flatten(arr[i]));\n    } else {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n}\nflatten(arr);  //  [1, 2, 3, 4，5]\n\n\n（2）reduce 函数迭代\n\n从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么其实也可以用reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示：\n\nlet arr = [1, [2, [3, 4]]];\nfunction flatten(arr) {\n    return arr.reduce(function(prev, next){\n        return prev.concat(array.isarray(next) ? flatten(next) : next)\n    }, [])\n}\nconsole.log(flatten(arr));//  [1, 2, 3, 4，5]\n\n\n（3）扩展运算符实现\n\n这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的：\n\nlet arr = [1, [2, [3, 4]]];\nfunction flatten(arr) {\n    while (arr.some(item => array.isarray(item))) {\n        arr = [].concat(...arr);\n    }\n    return arr;\n}\nconsole.log(flatten(arr)); //  [1, 2, 3, 4，5]\n\n\n（4）split 和 tostring\n\n可以通过 split 和 tostring 两个方法来共同实现数组扁平化，由于数组会默认带一个 tostring 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示：\n\nlet arr = [1, [2, [3, 4]]];\nfunction flatten(arr) {\n    return arr.tostring().split(',');\n}\nconsole.log(flatten(arr)); //  [1, 2, 3, 4，5]\n\n\n通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组。\n\n（5）es6 中的 flat\n\n我们还可以直接调用 es6 中的 flat 方法来实现数组扁平化。flat 方法的语法：arr.flat([depth])\n\n其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。如果层数不确定，参数可以传进 infinity，代表不论多少层都要展开：\n\nlet arr = [1, [2, [3, 4]]];\nfunction flatten(arr) {\n  return arr.flat(infinity);\n}\nconsole.log(flatten(arr)); //  [1, 2, 3, 4，5]\n\n\n可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。在编程过程中，如果数组的嵌套层数不确定，最好直接使用 infinity，可以达到扁平化。 （6）正则和 json 方法 在第4种方法中已经使用 tostring 方法，其中仍然采用了将 json.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 json.parse 把它转换成数组：\n\nlet arr = [1, [2, [3, [4, 5]]], 6];\nfunction flatten(arr) {\n  let str = json.stringify(arr);\n  str = str.replace(/(\\[|\\])/g, '');\n  str = '[' + str + ']';\n  return json.parse(str); \n}\nconsole.log(flatten(arr)); //  [1, 2, 3, 4，5]\n\n\n\n# 6. 实现数组去重\n\n给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。\n\nes6方法（使用数据结构集合）：\n\nconst array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];\n\narray.from(new set(array)); // [1, 2, 3, 5, 9, 8]\n\n\nes5方法：使用map存储不重复的数字\n\nconst array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];\n\nuniquearray(array); // [1, 2, 3, 5, 9, 8]\n\nfunction uniquearray(array) {\n  let map = {};\n  let res = [];\n  for(var i = 0; i < array.length; i++) {\n    if(!map.hasownproperty([array[i]])) {\n      map[array[i]] = 1;\n      res.push(array[i]);\n    }\n  }\n  return res;\n}\n\n\n\n# 7. 实现数组的flat方法\n\nfunction _flat(arr, depth) {\n  if(!array.isarray(arr) || depth <= 0) {\n    return arr;\n  }\n  return arr.reduce((prev, cur) => {\n    if (array.isarray(cur)) {\n      return prev.concat(_flat(cur, depth - 1))\n    } else {\n      return prev.concat(cur);\n    }\n  }, []);\n}\n\n\n\n# 8. 实现数组的push方法\n\nlet arr = [];\narray.prototype.push = function() {\n\tfor( let i = 0 ; i < arguments.length ; i++){\n\t\tthis[this.length] = arguments[i] ;\n\t}\n\treturn this.length;\n}\n\n\n\n# 9. 实现数组的filter方法\n\narray.prototype._filter = function(fn) {\n    if (typeof fn !== \"function\") {\n        throw error('参数必须是一个函数');\n    }\n    const res = [];\n    for (let i = 0, len = this.length; i < len; i++) {\n        fn(this[i]) && res.push(this[i]);\n    }\n    return res;\n}\n\n\n\n# 10. 实现数组的map方法\n\narray.prototype._map = function(fn) {\n   if (typeof fn !== \"function\") {\n        throw error('参数必须是一个函数');\n    }\n    const res = [];\n    for (let i = 0, len = this.length; i < len; i++) {\n        res.push(fn(this[i]));\n    }\n    return res;\n}\n\n\n\n# 11. 实现字符串的repeat方法\n\n输入字符串s，以及其重复的次数，输出重复的结果，例如输入abc，2，输出abcabc。\n\nfunction repeat(s, n) {\n    return (new array(n + 1)).join(s);\n}\n\n\n递归：\n\nfunction repeat(s, n) {\n    return (n > 0) ? s.concat(repeat(s, --n)) : \"\";\n}\n\n\n\n# 12. 实现字符串翻转\n\n在字符串的原型链上添加一个方法，实现字符串翻转：\n\nstring.prototype._reverse = function(a){\n    return a.split(\"\").reverse().join(\"\");\n}\nvar obj = new string();\nvar res = obj._reverse ('hello');\nconsole.log(res);    // olleh\n\n\n需要注意的是，必须通过实例化对象之后再去调用定义的方法，不然找不到该方法。\n\n\n# 13. 将数字每千分位用逗号隔开\n\n数字有小数版本：\n\nlet format = n => {\n    let num = n.tostring() // 转成字符串\n    let decimals = ''\n        // 判断是否有小数\n    num.indexof('.') > -1 ? decimals = num.split('.')[1] : decimals\n    let len = num.length\n    if (len <= 3) {\n        return num\n    } else {\n        let temp = ''\n        let remainder = len % 3\n        decimals ? temp = '.' + decimals : temp\n        if (remainder > 0) { // 不是3的整数倍\n            return num.slice(0, remainder) + ',' + num.slice(remainder, len).match(/\\d{3}/g).join(',') + temp\n        } else { // 是3的整数倍\n            return num.slice(0, len).match(/\\d{3}/g).join(',') + temp \n        }\n    }\n}\nformat(12323.33)  // '12,323.33'\n\n\n数字无小数版本：\n\nlet format = n => {\n    let num = n.tostring() \n    let len = num.length\n    if (len <= 3) {\n        return num\n    } else {\n        let remainder = len % 3\n        if (remainder > 0) { // 不是3的整数倍\n            return num.slice(0, remainder) + ',' + num.slice(remainder, len).match(/\\d{3}/g).join(',') \n        } else { // 是3的整数倍\n            return num.slice(0, len).match(/\\d{3}/g).join(',') \n        }\n    }\n}\nformat(1232323)  // '1,232,323'\n\n\n\n# 14. 实现非负大整数相加\n\njavascript对数值有范围的限制，限制如下：\n\nnumber.max_value // 1.7976931348623157e+308\nnumber.max_safe_integer // 9007199254740991\nnumber.min_value // 5e-324\nnumber.min_safe_integer // -9007199254740991\n\n\n如果想要对一个超大的整数(> number.max_safe_integer)进行加法运算，但是又想输出一般形式，那么使用 + 是无法达到的，一旦数字超过 number.max_safe_integer 数字会被立即转换为科学计数法，并且数字精度相比以前将会有误差。\n\n实现一个算法进行大数的相加：\n\nfunction sumbignumber(a, b) {\n  let res = '';\n  let temp = 0;\n  \n  a = a.split('');\n  b = b.split('');\n  \n  while (a.length || b.length || temp) {\n    temp += ~~a.pop() + ~~b.pop();\n    res = (temp % 10) + res;\n    temp  = temp > 9\n  }\n  return res.replace(/^0+/, '');\n}\n\n\n其主要的思路如下：\n\n * 首先用字符串的方式来保存大数，这样数字在数学表示上就不会发生变化\n * 初始化res，temp来保存中间的计算结果，并将两个字符串转化为数组，以便进行每一位的加法运算\n * 将两个数组的对应的位进行相加，两个数相加的结果可能大于10，所以可能要仅为，对10进行取余操作，将结果保存在当前位\n * 判断当前位是否大于9，也就是是否会进位，若是则将temp赋值为true，因为在加法运算中，true会自动隐式转化为1，以便于下一次相加\n * 重复上述操作，直至计算结束\n\n\n# 13. 实现 add(1)(2)(3)\n\n函数柯里化概念： 柯里化（currying）是把接受多个参数的函数转变为接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。\n\n1）粗暴版\n\nfunction add (a) {\nreturn function (b) {\n \treturn function (c) {\n      return a + b + c;\n \t}\n}\n}\nconsole.log(add(1)(2)(3)); // 6\n\n\n2）柯里化解决方案\n\n * 参数长度固定\n\nvar add = function (m) {\n  var temp = function (n) {\n    return add(m + n);\n  }\n  temp.tostring = function () {\n    return m;\n  }\n  return temp;\n};\nconsole.log(add(3)(4)(5)); // 12\nconsole.log(add(3)(6)(9)(25)); // 43\n\n\n对于add(3)(4)(5)，其执行过程如下：\n\n 1. 先执行add(3)，此时m=3，并且返回temp函数；\n 2. 执行temp(4)，这个函数内执行add(m+n)，n是此次传进来的数值4，m值还是上一步中的3，所以add(m+n)=add(3+4)=add(7)，此时m=7，并且返回temp函数\n 3. 执行temp(5)，这个函数内执行add(m+n)，n是此次传进来的数值5，m值还是上一步中的7，所以add(m+n)=add(7+5)=add(12)，此时m=12，并且返回temp函数\n 4. 由于后面没有传入参数，等于返回的temp函数不被执行而是打印，了解js的朋友都知道对象的tostring是修改对象转换字符串的方法，因此代码中temp函数的tostring函数return m值，而m值是最后一步执行函数时的值m=12，所以返回值是12。\n\n * 参数长度不固定\n\nfunction add (...args) {\n    //求和\n    return args.reduce((a, b) => a + b)\n}\nfunction currying (fn) {\n    let args = []\n    return function temp (...newargs) {\n        if (newargs.length) {\n            args = [\n                ...args,\n                ...newargs\n            ]\n            return temp\n        } else {\n            let val = fn.apply(this, args)\n            args = [] //保证再次调用时清空\n            return val\n        }\n    }\n}\nlet addcurry = currying(add)\nconsole.log(addcurry(1)(2)(3)(4, 5)())  //15\nconsole.log(addcurry(1)(2)(3, 4, 5)())  //15\nconsole.log(addcurry(1)(2, 3, 4, 5)())  //15\n\n\n\n# 14. 实现类数组转化为数组\n\n类数组转换为数组的方法有这样几种：\n\n * 通过 call 调用数组的 slice 方法来实现转换\n\narray.prototype.slice.call(arraylike);\n\n\n * 通过 call 调用数组的 splice 方法来实现转换\n\narray.prototype.splice.call(arraylike, 0);\n\n\n * 通过 apply 调用数组的 concat 方法来实现转换\n\narray.prototype.concat.apply([], arraylike);\n\n\n * 通过 array.from 方法来实现转换\n\narray.from(arraylike);\n\n\n\n# 15. 使用 reduce 求和\n\narr = [1,2,3,4,5,6,7,8,9,10]，求和\n\nlet arr = [1,2,3,4,5,6,7,8,9,10]\narr.reduce((prev, cur) => { return prev + cur }, 0)\n\n\narr = [1,2,3,[[4,5],6],7,8,9]，求和\n\nlet arr = [1,2,3,4,5,6,7,8,9,10]\narr.flat(infinity).reduce((prev, cur) => { return prev + cur }, 0)\n\n\narr = [{a:1, b:3}, {a:2, b:3, c:4}, {a:3}]，求和\n\nlet arr = [{a:9, b:3, c:4}, {a:1, b:3}, {a:3}] \n\narr.reduce((prev, cur) => {\n    return prev + cur[\"a\"];\n}, 0)\n\n\n\n# 16. 将js对象转化为树形结构\n\n// 转换前：\nsource = [{\n            id: 1,\n            pid: 0,\n            name: 'body'\n          }, {\n            id: 2,\n            pid: 1,\n            name: 'title'\n          }, {\n            id: 3,\n            pid: 2,\n            name: 'div'\n          }]\n// 转换为: \ntree = [{\n          id: 1,\n          pid: 0,\n          name: 'body',\n          children: [{\n            id: 2,\n            pid: 1,\n            name: 'title',\n            children: [{\n              id: 3,\n              pid: 1,\n              name: 'div'\n            }]\n          }\n        }]\n\n\n代码实现：\n\nfunction jsontotree(data) {\n  // 初始化结果数组，并判断输入数据的格式\n  let result = []\n  if(!array.isarray(data)) {\n    return result\n  }\n  // 使用map，将当前对象的id与当前对象对应存储起来\n  let map = {};\n  data.foreach(item => {\n    map[item.id] = item;\n  });\n  // \n  data.foreach(item => {\n    let parent = map[item.pid];\n    if(parent) {\n      (parent.children || (parent.children = [])).push(item);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n}\n\n\n\n# 17. 使用es5和es6求函数参数的和\n\nes5：\n\nfunction sum() {\n    let sum = 0\n    array.prototype.foreach.call(arguments, function(item) {\n        sum += item * 1\n    })\n    return sum\n}\n\n\nes6：\n\nfunction sum(...nums) {\n    let sum = 0\n    nums.foreach(function(item) {\n        sum += item * 1\n    })\n    return sum\n}\n\n\n\n# 18. 解析 url params 为对象\n\nlet url = 'http://www.domain.com/?user=anonymous&id=123&id=456&city=%e5%8c%97%e4%ba%ac&enabled';\nparseparam(url)\n/* 结果\n{ user: 'anonymous',\n  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型\n  city: '北京', // 中文需解码\n  enabled: true, // 未指定值得 key 约定为 true\n}\n*/\nfunction parseparam(url) {\n  const paramsstr = /.+\\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来\n  const paramsarr = paramsstr.split('&'); // 将字符串以 & 分割后存到数组中\n  let paramsobj = {};\n  // 将 params 存到对象中\n  paramsarr.foreach(param => {\n    if (/=/.test(param)) { // 处理有 value 的参数\n      let [key, val] = param.split('='); // 分割 key 和 value\n      val = decodeuricomponent(val); // 解码\n      val = /^\\d+$/.test(val) ? parsefloat(val) : val; // 判断是否转为数字\n      if (paramsobj.hasownproperty(key)) { // 如果对象有 key，则添加一个值\n        paramsobj[key] = [].concat(paramsobj[key], val);\n      } else { // 如果对象没有这个 key，创建 key 并设置值\n        paramsobj[key] = val;\n      }\n    } else { // 处理没有 value 的参数\n      paramsobj[param] = true;\n    }\n  })\n  return paramsobj;\n}\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "其它",
      "frontmatter": {
        "title": "其它",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/frameReactOther/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/20.react%E7%AF%87/90.%E5%85%B6%E4%BB%96.html",
      "relativePath": "30.框架篇/20.react篇/90.其他.md",
      "key": "v-3243a014",
      "path": "/pages/frameReactOther/",
      "headers": [
        {
          "level": 3,
          "title": "1. React组件命名推荐的方式是哪个？",
          "slug": "_1-react组件命名推荐的方式是哪个",
          "normalizedTitle": "1. react组件命名推荐的方式是哪个？",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. react 最新版本解决了什么问题，增加了哪些东西",
          "slug": "_2-react-最新版本解决了什么问题-增加了哪些东西",
          "normalizedTitle": "2. react 最新版本解决了什么问题，增加了哪些东西",
          "charIndex": 227
        },
        {
          "level": 3,
          "title": "3. react 实现一个全局的 dialog",
          "slug": "_3-react-实现一个全局的-dialog",
          "normalizedTitle": "3. react 实现一个全局的 dialog",
          "charIndex": 1764
        },
        {
          "level": 3,
          "title": "4. React 数据持久化有什么实践吗？",
          "slug": "_4-react-数据持久化有什么实践吗",
          "normalizedTitle": "4. react 数据持久化有什么实践吗？",
          "charIndex": 4466
        },
        {
          "level": 3,
          "title": "5. 对 React 和 Vue 的理解，它们的异同",
          "slug": "_5-对-react-和-vue-的理解-它们的异同",
          "normalizedTitle": "5. 对 react 和 vue 的理解，它们的异同",
          "charIndex": 6348
        },
        {
          "level": 3,
          "title": "6. 可以使用TypeScript写React应用吗？怎么操作？",
          "slug": "_6-可以使用typescript写react应用吗-怎么操作",
          "normalizedTitle": "6. 可以使用typescript写react应用吗？怎么操作？",
          "charIndex": 7605
        },
        {
          "level": 3,
          "title": "7. React 设计思路，它的理念是什么？",
          "slug": "_7-react-设计思路-它的理念是什么",
          "normalizedTitle": "7. react 设计思路，它的理念是什么？",
          "charIndex": 8036
        },
        {
          "level": 3,
          "title": "8. React中props.children和React.Children的区别",
          "slug": "_8-react中props-children和react-children的区别",
          "normalizedTitle": "8. react中props.children和react.children的区别",
          "charIndex": 9119
        },
        {
          "level": 3,
          "title": "9. React的状态提升是什么？使用场景有哪些？",
          "slug": "_9-react的状态提升是什么-使用场景有哪些",
          "normalizedTitle": "9. react的状态提升是什么？使用场景有哪些？",
          "charIndex": 10381
        },
        {
          "level": 3,
          "title": "10. React中constructor和getInitialState的区别?",
          "slug": "_10-react中constructor和getinitialstate的区别",
          "normalizedTitle": "10. react中constructor和getinitialstate的区别?",
          "charIndex": 11928
        },
        {
          "level": 3,
          "title": "11. React的严格模式如何使用，有什么用处？",
          "slug": "_11-react的严格模式如何使用-有什么用处",
          "normalizedTitle": "11. react的严格模式如何使用，有什么用处？",
          "charIndex": 12436
        },
        {
          "level": 3,
          "title": "12. 在React中遍历的方法有哪些？",
          "slug": "_12-在react中遍历的方法有哪些",
          "normalizedTitle": "12. 在react中遍历的方法有哪些？",
          "charIndex": 13073
        },
        {
          "level": 3,
          "title": "13. 在React中页面重新加载时怎样保留数据？",
          "slug": "_13-在react中页面重新加载时怎样保留数据",
          "normalizedTitle": "13. 在react中页面重新加载时怎样保留数据？",
          "charIndex": 14515
        },
        {
          "level": 3,
          "title": "14. 同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？",
          "slug": "_14-同时引用这三个库react-js、react-dom-js和babel-js它们都有什么作用",
          "normalizedTitle": "14. 同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？",
          "charIndex": 15057
        },
        {
          "level": 3,
          "title": "15. React必须使用JSX吗？",
          "slug": "_15-react必须使用jsx吗",
          "normalizedTitle": "15. react必须使用jsx吗？",
          "charIndex": 15200
        },
        {
          "level": 3,
          "title": "16. 为什么使用jsx的组件中没有看到使用react却需要引入react？",
          "slug": "_16-为什么使用jsx的组件中没有看到使用react却需要引入react",
          "normalizedTitle": "16. 为什么使用jsx的组件中没有看到使用react却需要引入react？",
          "charIndex": 15870
        },
        {
          "level": 3,
          "title": "17. 在React中怎么使用async/await？",
          "slug": "_17-在react中怎么使用async-await",
          "normalizedTitle": "17. 在react中怎么使用async/await？",
          "charIndex": 16093
        },
        {
          "level": 3,
          "title": "18. React.Children.map和js的map有什么区别？",
          "slug": "_18-react-children-map和js的map有什么区别",
          "normalizedTitle": "18. react.children.map和js的map有什么区别？",
          "charIndex": 16374
        },
        {
          "level": 3,
          "title": "19. 对React SSR的理解",
          "slug": "_19-对react-ssr的理解",
          "normalizedTitle": "19. 对react ssr的理解",
          "charIndex": 16520
        },
        {
          "level": 3,
          "title": "20. 为什么 React 要用 JSX？",
          "slug": "_20-为什么-react-要用-jsx",
          "normalizedTitle": "20. 为什么 react 要用 jsx？",
          "charIndex": 17675
        },
        {
          "level": 3,
          "title": "21. React 中的高阶组件运用了什么设计模式？",
          "slug": "_21-react-中的高阶组件运用了什么设计模式",
          "normalizedTitle": "21. react 中的高阶组件运用了什么设计模式？",
          "charIndex": 18824
        }
      ],
      "headersStr": "1. React组件命名推荐的方式是哪个？ 2. react 最新版本解决了什么问题，增加了哪些东西 3. react 实现一个全局的 dialog 4. React 数据持久化有什么实践吗？ 5. 对 React 和 Vue 的理解，它们的异同 6. 可以使用TypeScript写React应用吗？怎么操作？ 7. React 设计思路，它的理念是什么？ 8. React中props.children和React.Children的区别 9. React的状态提升是什么？使用场景有哪些？ 10. React中constructor和getInitialState的区别? 11. React的严格模式如何使用，有什么用处？ 12. 在React中遍历的方法有哪些？ 13. 在React中页面重新加载时怎样保留数据？ 14. 同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？ 15. React必须使用JSX吗？ 16. 为什么使用jsx的组件中没有看到使用react却需要引入react？ 17. 在React中怎么使用async/await？ 18. React.Children.map和js的map有什么区别？ 19. 对React SSR的理解 20. 为什么 React 要用 JSX？ 21. React 中的高阶组件运用了什么设计模式？",
      "content": "# 1. React组件命名推荐的方式是哪个？\n\n通过引用而不是使用来命名组件displayName。\n\n使用displayName命名组件：\n\nexport default React.createClass({  displayName: 'TodoApp',  // ...})\n\n\nReact推荐的方法：\n\nexport default class TodoApp extends React.Component {  // ...}\n\n\n\n# 2. react 最新版本解决了什么问题，增加了哪些东西\n\nReact 16.x的三大新特性 Time Slicing、Suspense、 hooks\n\n * Time Slicing（解决CPU速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得react能在性能极其差的机器跑时，仍然保持有良好的性能\n * Suspense （解决网络IO问题） 和lazy配合，实现异步加载组件。 能暂停当前组件的渲染， 当完成某件事以后再继续渲染，解决从react出生到现在都存在的「异步副作用」的问题，而且解决得非的优雅，使用的是 T异步但是同步的写法，这是最好的解决异步问题的方式\n * 提供了一个内置函数componentDidCatch，当有错误发生时，可以友好地展示 fallback 组件; 可以捕捉到它的子元素（包括嵌套子元素）抛出的异常; 可以复用错误组件。\n\n（1）React16.8 加入hooks，让React函数式组件更加灵活，hooks之前，React存在很多问题：\n\n * 在组件间复用状态逻辑很难\n * 复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。\n * class组件的this指向问题\n * 难以记忆的生命周期\n\nhooks很好的解决了上述问题，hooks提供了很多方法\n\n * useState 返回有状态值，以及更新这个状态值的函数\n * useEffect 接受包含命令式，可能有副作用代码的函数。\n * useContext 接受上下文对象（从 React.createContext返回的值）并返回当前上下文值，\n * useReducer useState 的替代方案。接受类型为 （state，action）=> newState的reducer，并返回与dispatch方法配对的当前状态。\n * useCalLback 返回一个回忆的memoized版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性 o useMemo 纯的一个记忆函数 o useRef 返回一个可变的ref对象，其Current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。\n * useImperativeMethods 自定义使用ref时公开给父组件的实例值\n * useMutationEffect 更新兄弟组件之前，它在React执行其DOM改变的同一阶段同步触发\n * useLayoutEffect DOM改变后同步触发。使用它来从DOM读取布局并同步重新渲染\n\n（2）React16.9\n\n * 重命名 Unsafe 的生命周期方法。新的 UNSAFE_前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出\n * 废弃 javascrip:形式的 URL。以javascript:开头的URL 非常容易遭受攻击，造成安全漏洞。\n * 废弃\"Factory\"组件。 工厂组件会导致 React 变大且变慢。\n * act（）也支持异步函数，并且你可以在调用它时使用 await。\n * 使用 <React.ProfiLer> 进行性能评估。在较大的应用中追踪性能回归可能会很方便\n\n（3）React16.13.0\n\n * 支持在渲染期间调用setState，但仅适用于同一组件\n * 可检测冲突的样式规则并记录警告\n * 废弃 unstable_createPortal，使用CreatePortal\n * 将组件堆栈添加到其开发警告中，使开发人员能够隔离bug并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。\n\n\n# 3. react 实现一个全局的 dialog\n\nimport React, { Component } from 'react';\nimport { is, fromJS } from 'immutable';\nimport ReactDOM from 'react-dom';\nimport ReactCSSTransitionGroup from 'react-addons-css-transition-group';\nimport './dialog.css';\nlet defaultState = {\n  alertStatus:false,\n  alertTip:\"提示\",\n  closeDialog:function(){},\n  childs:''\n}\nclass Dialog extends Component{\n  state = {\n    ...defaultState\n  };\n  // css动画组件设置为目标组件\n  FirstChild = props => {\n    const childrenArray = React.Children.toArray(props.children);\n    return childrenArray[0] || null;\n  }\n  //打开弹窗\n  open =(options)=>{\n    options = options || {};\n    options.alertStatus = true;\n    var props = options.props || {};\n    var childs = this.renderChildren(props,options.childrens) || '';\n    console.log(childs);\n    this.setState({\n      ...defaultState,\n      ...options,\n      childs\n    })\n  }\n  //关闭弹窗\n  close(){\n    this.state.closeDialog();\n    this.setState({\n      ...defaultState\n    })\n  }\n  renderChildren(props,childrens) {\n    //遍历所有子组件\n    var childs = [];\n    childrens = childrens || [];\n    var ps = {\n        ...props,  //给子组件绑定props\n        _close:this.close  //给子组件也绑定一个关闭弹窗的事件    \n       };\n    childrens.forEach((currentItem,index) => {\n        childs.push(React.createElement(\n            currentItem,\n            {\n                ...ps,\n                key:index\n            }\n        ));\n    })\n    return childs;\n  }\n  shouldComponentUpdate(nextProps, nextState){\n    return !is(fromJS(this.props), fromJS(nextProps)) || !is(fromJS(this.state), fromJS(nextState))\n  }\n   \n  render(){\n    return (\n      <ReactCSSTransitionGroup\n        component={this.FirstChild}\n        transitionName='hide'\n        transitionEnterTimeout={300}\n        transitionLeaveTimeout={300}>\n        <div className=\"dialog-con\" style={this.state.alertStatus? {display:'block'}:{display:'none'}}>\n            {this.state.childs}\n        </div>\n      </ReactCSSTransitionGroup>\n    );\n  }\n}\nlet div = document.createElement('div');\nlet props = {\n   \n};\ndocument.body.appendChild(div);\nlet Box = ReactD\n\n\n子类：\n\n//子类jsx\nimport React, { Component } from 'react';\nclass Child extends Component {\n    constructor(props){\n        super(props);\n        this.state = {date: new Date()};\n  }\n  showValue=()=>{\n    this.props.showValue && this.props.showValue()\n  }\n  render() {\n    return (\n      <div className=\"Child\">\n        <div className=\"content\">\n           Child\n           <button onClick={this.showValue}>调用父的方法</button>\n        </div>\n      </div>\n    );\n  }\n}\nexport default Child;\n\n\ncss：\n\n.dialog-con{\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.3);\n}\n\n\n\n# 4. React 数据持久化有什么实践吗？\n\n封装数据持久化组件：\n\n】let storage={\n    // 增加\n    set(key, value){\n        localStorage.setItem(key, JSON.stringify(value));\n    },\n    // 获取\n    get(key){\n        return JSON.parse(localStorage.getItem(key));\n    },\n    // 删除\n    remove(key){\n        localStorage.removeItem(key);\n    }\n};\nexport default Storage;\n\n\n在React项目中，通过redux存储全局数据时，会有一个问题，如果用户刷新了网页，那么通过redux存储的全局数据就会被全部清空，比如登录信息等。这时就会有全局数据持久化存储的需求。首先想到的就是localStorage，localStorage是没有时间限制的数据存储，可以通过它来实现数据的持久化存储。\n\n但是在已经使用redux来管理和存储全局数据的基础上，再去使用localStorage来读写数据，这样不仅是工作量巨大，还容易出错。那么有没有结合redux来达到持久数据存储功能的框架呢？当然，它就是redux-persist。redux-persist会将redux的store中的数据缓存到浏览器的localStorage中。其使用步骤如下：\n\n（1）首先要安装redux-persist：\n\nnpm i redux-persist\n\n\n（2）对于reducer和action的处理不变，只需修改store的生成代码，修改如下：\n\nimport {createStore} from 'redux'\nimport reducers from '../reducers/index'\nimport {persistStore, persistReducer} from 'redux-persist';\nimport storage from 'redux-persist/lib/storage';\nimport autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2';\nconst persistConfig = {\n    key: 'root',\n    storage: storage,\n    stateReconciler: autoMergeLevel2 // 查看 'Merge Process' 部分的具体情况\n};\nconst myPersistReducer = persistReducer(persistConfig, reducers)\nconst store = createStore(myPersistReducer)\nexport const persistor = persistStore(store)\nexport default store\n\n\n（3）在index.js中，将PersistGate标签作为网页内容的父标签：\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport {Provider} from 'react-redux'\nimport store from './redux/store/store'\nimport {persistor} from './redux/store/store'\nimport {PersistGate} from 'redux-persist/lib/integration/react';\nReactDOM.render(<Provider store={store}>\n            <PersistGate loading={null} persistor={persistor}>\n                {/*网页内容*/}\n            </PersistGate>\n        </Provider>, document.getElementById('root'));\n\n\n这就完成了通过redux-persist实现React持久化本地数据存储的简单应用。\n\n\n# 5. 对 React 和 Vue 的理解，它们的异同\n\n相似之处：\n\n * 都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库\n * 都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。\n * 都使用了Virtual DOM（虚拟DOM）提高重绘性能\n * 都有props的概念，允许组件间的数据传递\n * 都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性\n\n不同之处：\n\n1）数据流\n\nVue默认支持数据双向绑定，而React一直提倡单向数据流\n\n2）虚拟DOM\n\nVue2.x开始引入\"Virtual DOM\"，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。\n\n * Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\n * 对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。\n\n3）组件化\n\nReact与Vue最大的不同是模板的编写。\n\n * Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。\n * React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。\n\n具体来讲：React中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 完组件之后，还需要在 components 中再声明下。\n\n4）监听数据变化的实现原理不同\n\n * Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能\n * React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。\n\n5）高阶组件\n\nreact可以通过高阶组件（Higher Order Components-- HOC）来扩展，而vue需要通过mixins来扩展。\n\n原因高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不采用HOC来实现。\n\n6）构建工具\n\n两者都有自己的构建工具\n\n * React ==> Create React APP\n * Vue ==> vue-cli\n\n7）跨平台\n\n * React ==> React Native\n * Vue ==> Weex\n\n\n# 6. 可以使用TypeScript写React应用吗？怎么操作？\n\n（1）如果还未创建 Create React App 项目\n\n * 直接创建一个具有 typescript 的 Create React App 项目：\n\n npx create-react-app demo --typescript\n\n\n（2）如果已经创建了 Create React App 项目，需要将 typescript 引入到已有项目中\n\n * 通过命令将 typescript 引入项目：\n\nnpm install --save typescript @types/node @types/react @types/react-dom @types/jest\n\n\n * 将项目中任何 后缀名为 ‘.js’ 的 JavaScript 文件重命名为 TypeScript 文件即后缀名为 ‘.tsx’（例如 src/index.js 重命名为 src/index.tsx ）\n\n\n# 7. React 设计思路，它的理念是什么？\n\n（1）编写简单直观的代码\n\nReact最大的价值不是高性能的虚拟DOM、封装的事件机制、服务器端渲染，而是声明式的直观的编码方式。react文档第一条就是声明式，React 使创建交互式 UI 变得轻而易举。为应用的每一个状态设计简洁的视图，当数据改变时 React 能有效地更新并正确地渲染组件。 以声明式编写 UI，可以让代码更加可靠，且方便调试。\n\n（2）简化可复用的组件\n\nReact框架里面使用了简化的组件模型，但更彻底地使用了组件化的概念。React将整个UI上的每一个功能模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成更大的组件。React的组件具有如下的特性∶\n\n * 可组合：简单组件可以组合为复杂的组件\n * 可重用：每个组件都是独立的，可以被多个组件使用\n * 可维护：和组件相关的逻辑和UI都封装在了组件的内部，方便维护\n * 可测试：因为组件的独立性，测试组件就变得方便很多。\n\n（3) Virtual DOM\n\n真实页面对应一个 DOM 树。在传统页面的开发模式中，每次需要更新页面时，都要手动操作 DOM 来进行更新。 DOM 操作非常昂贵。在前端开发中，性能消耗最大的就是 DOM 操作，而且这部分代码会让整体项目的代码变得难 以维护。React 把真实 DOM 树转换成 JavaScript 对象树，也就是 Virtual DOM，每次数据更新后，重新计算 Virtual DOM，并和上一次生成的 Virtual DOM 做对比，对发生变化的部分做批量更新。React 也提供了直观的 shouldComponentUpdate 生命周期回调，来减少数据变化后不必要的 Virtual DOM 对比过程，以保证性能。\n\n（4）函数式编程\n\nReact 把过去不断重复构建 UI 的过程抽象成了组件，且在给定参数的情况下约定渲染对应的 UI 界面。React 能充分利用很多函数式方法去减少冗余代码。此外，由于它本身就是简单函数，所以易于测试。\n\n（5）一次学习，随处编写\n\n无论现在正在使用什么技术栈，都可以随时引入 React来开发新特性，而不需要重写现有代码。\n\nReact 还可以使用 Node 进行服务器渲染，或使用 React Native 开发原生移动应用。因为 React 组件可以映射为对应的原生控件。在输出的时候，是输出 Web DOM，还是 Android 控件，还是 iOS 控件，就由平台本身决定了。所以，react很方便和其他平台集成\n\n\n# 8. React中props.children和React.Children的区别\n\n在React中，当涉及组件嵌套，在父组件中使用props.children把所有子组件显示出来。如下：\n\nfunction ParentComponent(props){\n\treturn (\n\t\t<div>\n\t\t\t{props.children}\n\t\t</div>\n\t)\n}\n\n\n如果想把父组件中的属性传给所有的子组件，需要使用React.Children方法。\n\n比如，把几个Radio组合起来，合成一个RadioGroup，这就要求所有的Radio具有同样的name属性值。可以这样：把Radio看做子组件，RadioGroup看做父组件，name的属性值在RadioGroup这个父组件中设置。\n\n首先是子组件：\n\n//子组件\nfunction RadioOption(props) {\n  return (\n    <label>\n      <input type=\"radio\" value={props.value} name={props.name} />\n      {props.label}\n    </label>\n  )\n}\n\n\n然后是父组件，不仅需要把它所有的子组件显示出来，还需要为每个子组件赋上name属性和值：\n\n//父组件用,props是指父组件的props\nfunction renderChildren(props) {\n    \n  //遍历所有子组件\n  return React.Children.map(props.children, child => {\n    if (child.type === RadioOption)\n      return React.cloneElement(child, {\n        //把父组件的props.name赋值给每个子组件\n        name: props.name\n      })\n    else\n      return child\n  })\n}\n//父组件\nfunction RadioGroup(props) {\n  return (\n    <div>\n      {renderChildren(props)}\n    </div>\n  )\n}\nfunction App() {\n  return (\n    <RadioGroup name=\"hello\">\n      <RadioOption label=\"选项一\" value=\"1\" />\n      <RadioOption label=\"选项二\" value=\"2\" />\n      <RadioOption label=\"选项三\" value=\"3\" />\n    </RadioGroup>\n  )\n}\nexport default App;\n\n\n以上，React.Children.map让我们对父组件的所有子组件又更灵活的控制。\n\n\n# 9. React的状态提升是什么？使用场景有哪些？\n\nReact的状态提升就是用户对子组件操作，子组件不改变自己的状态，通过自己的props把这个操作改变的数据传递给父组件，改变父组件的状态，从而改变受父组件控制的所有子组件的状态，这也是React单项数据流的特性决定的。官方的原话是：共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)”。\n\n概括来说就是将多个组件需要共享的状态提升到它们最近的父组件上，在父组件上改变这个状态然后通过props分发给子组件。\n\n一个简单的例子，父组件中有两个input子组件，如果想在第一个输入框输入数据，来改变第二个输入框的值，这就需要用到状态提升。\n\nclass Father extends React.Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            Value1: '',\n            Value2: ''\n        }\n    }\n    value1Change(aa) {\n        this.setState({\n            Value1: aa\n        })\n    }\n    value2Change(bb) {\n        this.setState({\n            Value2: bb\n        })\n    }\n    render() {\n        return (\n            <div style={{ padding: \"100px\" }}>\n                <Child1 value1={this.state.Value1} onvalue1Change={this.value1Change.bind(this)} />\n                \n\n                <Child2 value2={this.state.Value1} />\n            </div>\n        )\n    }\n}\nclass Child1 extends React.Component {\n    constructor(props) {\n        super(props)\n    }\n    changeValue(e) {\n        this.props.onvalue1Change(e.target.value)\n    }\n    render() {\n        return (\n            <input value={this.props.Value1} onChange={this.changeValue.bind(this)} />\n        )\n    }\n}\nclass Child2 extends React.Component {\n    constructor(props) {\n        super(props)\n    }\n    render() {\n        return (\n            <input value={this.props.value2} />\n        )\n    }\n}\n \nReactDOM.render(\n    <Father />,\n    document.getElementById('root')\n)\n\n\n\n# 10. React中constructor和getInitialState的区别?\n\n两者都是用来初始化state的。前者是ES6中的语法，后者是ES5中的语法，新版本的React中已经废弃了该方法。\n\ngetInitialState是ES5中的方法，如果使用createClass方法创建一个Component组件，可以自动调用它的getInitialState方法来获取初始化的State对象，\n\nvar APP = React.creatClass ({\n  getInitialState() {\n    return { \n        userName: 'hi',\n        userId: 0\n     };\n　}\n})\n\n\nReact在ES6的实现中去掉了getInitialState这个hook函数，规定state在constructor中实现，如下：\n\nClass App extends React.Component{\n    constructor(props){\n      super(props);\n      this.state={};\n    }\n  }\n\n\n\n# 11. React的严格模式如何使用，有什么用处？\n\nStrictMode 是一个用来突出显示应用程序中潜在问题的工具。与 Fragment 一样，StrictMode 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。 可以为应用程序的任何部分启用严格模式。例如：\n\nimport React from 'react';\nfunction ExampleApplication() {\n  return (\n    <div>\n      <Header />\n      <React.StrictMode>        \n        <div>\n          <ComponentOne />\n          <ComponentTwo />\n        </div>\n      </React.StrictMode>      \n      <Footer />\n    </div>\n  );\n}\n\n\n在上述的示例中，不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。\n\nStrictMode 目前有助于：\n\n * 识别不安全的生命周期\n * 关于使用过时字符串 ref API 的警告\n * 关于使用废弃的 findDOMNode 方法的警告\n * 检测意外的副作用\n * 检测过时的 context API\n\n\n# 12. 在React中遍历的方法有哪些？\n\n（1）遍历数组：map && forEach\n\nimport React from 'react';\n\nclass App extends React.Component {\n  render() {\n    let arr = ['a', 'b', 'c', 'd'];\n    return (\n      <ul>\n        {\n          arr.map((item, index) => {\n            return <li key={index}>{item}</li>\n          })\n        }\n      </ul>\n    )\n  }\n}\n\nclass App extends React.Component {\n  render() {\n    let arr = ['a', 'b', 'c', 'd'];\n    return (\n      <ul>\n        {\n          arr.forEach((item, index) => {\n            return <li key={index}>{item}</li>\n          })\n        }\n      </ul>\n    )\n  }\n}\n\n\n（2）遍历对象：map && for in\n\nclass App extends React.Component {\n  render() {\n    let obj = {\n      a: 1,\n      b: 2,\n      c: 3\n    }\n    return (\n      <ul>\n        {\n          (() => {\n            let domArr = [];\n            for(const key in obj) {\n              if(obj.hasOwnProperty(key)) {\n                const value = obj[key]\n                domArr.push(<li key={key}>{value}</li>)\n              }\n            }\n            return domArr;\n          })()\n        }\n      </ul>\n    )\n  }\n}\n\n// Object.entries() 把对象转换成数组\nclass App extends React.Component {\n  render() {\n    let obj = {\n      a: 1,\n      b: 2,\n      c: 3\n    }\n    return (\n      <ul>\n        {\n          Object.entries(obj).map(([key, value], index) => {   // item是一个数组，把item解构，写法是[key, value]\n            return <li key={key}>{value}</li>\n          }) \n        }\n      </ul>\n    )\n  }\n}\n\n\n\n# 13. 在React中页面重新加载时怎样保留数据？\n\n这个问题就设计到了数据持久化， 主要的实现方式有以下几种：\n\n * Redux： 将页面的数据存储在redux中，在重新加载页面时，获取Redux中的数据；\n * data.js： 使用webpack构建的项目，可以建一个文件，data.js，将数据保存data.js中，跳转页面后获取；\n * sessionStorge： 在进入选择地址页面之前，componentWillUnMount的时候，将数据存储到sessionStorage中，每次进入页面判断sessionStorage中有没有存储的那个值，有，则读取渲染数据；没有，则说明数据是初始化的状态。返回或进入除了选择地址以外的页面，清掉存储的sessionStorage，保证下次进入是初始化的数据\n * history API： History API 的 pushState 函数可以给历史记录关联一个任意的可序列化 state，所以可以在路由 push 的时候将当前页面的一些信息存到 state 中，下次返回到这个页面的时候就能从 state 里面取出离开前的数据重新渲染。react-router 直接可以支持。这个方法适合一些需要临时存储的场景。\n\n\n# 14. 同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？\n\n * react：包含react所必须的核心代码\n * react-dom：react渲染在不同平台所需要的核心代码\n * babel：将jsx转换成React代码的工具\n\n\n# 15. React必须使用JSX吗？\n\nReact 并不强制要求使用 JSX。当不想在构建环境中配置有关 JSX 编译时，不在 React 中使用 JSX 会更加方便。\n\n每个 JSX 元素只是调用 React.createElement(component, props, ...children) 的语法糖。因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成。\n\n例如，用 JSX 编写的代码：\n\nclass Hello extends React.Component {\n  render() {\n    return <div>Hello {this.props.toWhat}</div>;\n  }\n}\nReactDOM.render(\n  <Hello toWhat=\"World\" />,\n  document.getElementById('root')\n);\n\n\n可以编写为不使用 JSX 的代码：\n\nclass Hello extends React.Component {\n  render() {\n    return React.createElement('div', null, `Hello ${this.props.toWhat}`);\n  }\n}\nReactDOM.render(\n  React.createElement(Hello, {toWhat: 'World'}, null),\n  document.getElementById('root')\n);\n\n\n\n# 16. 为什么使用jsx的组件中没有看到使用react却需要引入react？\n\n本质上来说JSX是React.createElement(component, props, ...children)方法的语法糖。在React 17之前，如果使用了JSX，其实就是在使用React， babel 会把组件转换为 CreateElement 形式。在React 17之后，就不再需要引入，因为 babel 已经可以帮我们自动引入react。\n\n\n# 17. 在React中怎么使用async/await？\n\nasync/await是ES7标准中的新特性。如果是使用React官方的脚手架创建的项目，就可以直接使用。如果是在自己搭建的webpack配置的项目中使用，可能会遇到 regeneratorRuntime is not defined 的异常错误。那么我们就需要引入babel，并在babel中配置使用async/await。可以利用babel的 transform-async-to-module-method 插件来转换其成为浏览器支持的语法，虽然没有性能的提升，但对于代码编写体验要更好。\n\n\n# 18. React.Children.map和js的map有什么区别？\n\nJavaScript中的map不会对为null或者undefined的数据进行处理，而React.Children.map中的map可以处理React.Children为null或者undefined的情况。\n\n\n# 19. 对React SSR的理解\n\n服务端渲染是数据与模版组成的html，即 HTML = 数据 ＋ 模版。将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记\"混合\"为客户端上完全交互的应用程序。页面没使用服务渲染，当请求页面时，返回的body里为空，之后执行js将html结构注入到body里，结合css显示出来;\n\nSSR的优势：\n\n * 对SEO友好\n * 所有的模版、图片等资源都存在服务器端\n * 一个html返回所有数据\n * 减少HTTP请求\n * 响应快、用户体验好、首屏渲染快\n\n1）更利于SEO\n\n不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本使用了React或者其它MVVM框架之后，页面大多数DOM元素都是在客户端根据js动态生成，可供爬虫抓取分析的内容大大减少。另外，浏览器爬虫不会等待我们的数据完成之后再去抓取页面数据。服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML，网络爬中就可以抓取到完整页面的信息。\n\n2）更利于首屏渲染\n\n首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。\n\nSSR的局限：\n\n1）服务端压力较大\n\n本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源;\n\n2）开发条件受限\n\n在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制;\n\n3）学习成本相对较高 除了对webpack、MVVM框架要熟悉，还需要掌握node、 Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。\n\n时间耗时比较：\n\n1）数据请求\n\n由服务端请求首屏数据，而不是客户端请求首屏数据，这是\"快\"的一个主要原因。服务端在内网进行请求，数据响应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大，导致时间差\n\n * 客户端数据请求\n\n\n\n * 服务端数据请求\n\n2）html渲染 服务端渲染是先向后端服务器请求数据，然后生成完整首屏 html返回给浏览器；而客户端渲染是等js代码下载、加载、解析完成后再请求数据渲染，等待的过程页面是什么都没有的，就是用户看到的白屏。就是服务端渲染不需要等待js代码下载完成并请求数据，就可以返回一个已有完整数据的首屏页面。\n\n * 非ssr html渲染\n\n\n\n * ssr html渲染\n\n\n\n\n# 20. 为什么 React 要用 JSX？\n\nJSX 是一个 JavaScript 的语法扩展，或者说是一个类似于 XML 的 ECMAScript 语法扩展。它本身没有太多的语法定义，也不期望引入更多的标准。\n\n其实 React 本身并不强制使用 JSX。在没有 JSX 的时候，React 实现一个组件依赖于使用 React.createElement 函数。代码如下：\n\nclass Hello extends React.Component {\n  render() {\n    return React.createElement(\n        'div',\n        null, \n        `Hello ${this.props.toWhat}`\n      );\n  }\n}\nReactDOM.render(\n  React.createElement(Hello, {toWhat: 'World'}, null),\n  document.getElementById('root')\n);\n\n\n而 JSX 更像是一种语法糖，通过类似 XML 的描述方式，描写函数对象。在采用 JSX 之后，这段代码会这样写：\n\nclass Hello extends React.Component {\n  render() {\n    return <div>Hello {this.props.toWhat}</div>;\n  }\n}\nReactDOM.render(\n  <Hello toWhat=\"World\" />,\n  document.getElementById('root')\n);\n\n\n通过对比，可以清晰地发现，代码变得更为简洁，而且代码结构层次更为清晰。\n\n因为 React 需要将组件转化为虚拟 DOM 树，所以在编写代码时，实际上是在手写一棵结构树。而XML 在树结构的描述上天生具有可读性强的优势。\n\n但这样可读性强的代码仅仅是给写程序的同学看的，实际上在运行的时候，会使用 Babel 插件将 JSX 语法的代码还原为 React.createElement 的代码。\n\n总结： JSX 是一个 JavaScript 的语法扩展，结构类似 XML。JSX 主要用于声明 React 元素，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。\n\nReact 团队并不想引入 JavaScript 本身以外的开发体系。而是希望通过合理的关注点分离保持组件开发的纯粹性。\n\n\n# 21. React 中的高阶组件运用了什么设计模式？\n\n使用了装饰模式，高阶组件的运用：\n\nfunction withWindowWidth(BaseComponent) {\n  class DerivedClass extends React.Component {\n    state = {\n      windowWidth: window.innerWidth,\n    }\n    onResize = () => {\n      this.setState({\n        windowWidth: window.innerWidth,\n      })\n    }\n    componentDidMount() {\n      window.addEventListener('resize', this.onResize)\n    }\n    componentWillUnmount() {\n      window.removeEventListener('resize', this.onResize);\n    }\n    render() {\n      return <BaseComponent {...this.props} {...this.state}/>\n    }\n  }\n  return DerivedClass;\n}\nconst MyComponent = (props) => {\n  return <div>Window width is: {props.windowWidth}</div>\n};\nexport default withWindowWidth(MyComponent);\n\n\n装饰模式的特点是不需要改变 被装饰对象 本身，而只是在外面套一个外壳接口。JavaScript 目前已经有了原生装饰器的提案，其用法如下：\n\n@testable\n   class MyTestableClass {\n}\n",
      "normalizedContent": "# 1. react组件命名推荐的方式是哪个？\n\n通过引用而不是使用来命名组件displayname。\n\n使用displayname命名组件：\n\nexport default react.createclass({  displayname: 'todoapp',  // ...})\n\n\nreact推荐的方法：\n\nexport default class todoapp extends react.component {  // ...}\n\n\n\n# 2. react 最新版本解决了什么问题，增加了哪些东西\n\nreact 16.x的三大新特性 time slicing、suspense、 hooks\n\n * time slicing（解决cpu速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得react能在性能极其差的机器跑时，仍然保持有良好的性能\n * suspense （解决网络io问题） 和lazy配合，实现异步加载组件。 能暂停当前组件的渲染， 当完成某件事以后再继续渲染，解决从react出生到现在都存在的「异步副作用」的问题，而且解决得非的优雅，使用的是 t异步但是同步的写法，这是最好的解决异步问题的方式\n * 提供了一个内置函数componentdidcatch，当有错误发生时，可以友好地展示 fallback 组件; 可以捕捉到它的子元素（包括嵌套子元素）抛出的异常; 可以复用错误组件。\n\n（1）react16.8 加入hooks，让react函数式组件更加灵活，hooks之前，react存在很多问题：\n\n * 在组件间复用状态逻辑很难\n * 复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。\n * class组件的this指向问题\n * 难以记忆的生命周期\n\nhooks很好的解决了上述问题，hooks提供了很多方法\n\n * usestate 返回有状态值，以及更新这个状态值的函数\n * useeffect 接受包含命令式，可能有副作用代码的函数。\n * usecontext 接受上下文对象（从 react.createcontext返回的值）并返回当前上下文值，\n * usereducer usestate 的替代方案。接受类型为 （state，action）=> newstate的reducer，并返回与dispatch方法配对的当前状态。\n * usecallback 返回一个回忆的memoized版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性 o usememo 纯的一个记忆函数 o useref 返回一个可变的ref对象，其current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。\n * useimperativemethods 自定义使用ref时公开给父组件的实例值\n * usemutationeffect 更新兄弟组件之前，它在react执行其dom改变的同一阶段同步触发\n * uselayouteffect dom改变后同步触发。使用它来从dom读取布局并同步重新渲染\n\n（2）react16.9\n\n * 重命名 unsafe 的生命周期方法。新的 unsafe_前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出\n * 废弃 javascrip:形式的 url。以javascript:开头的url 非常容易遭受攻击，造成安全漏洞。\n * 废弃\"factory\"组件。 工厂组件会导致 react 变大且变慢。\n * act（）也支持异步函数，并且你可以在调用它时使用 await。\n * 使用 <react.profiler> 进行性能评估。在较大的应用中追踪性能回归可能会很方便\n\n（3）react16.13.0\n\n * 支持在渲染期间调用setstate，但仅适用于同一组件\n * 可检测冲突的样式规则并记录警告\n * 废弃 unstable_createportal，使用createportal\n * 将组件堆栈添加到其开发警告中，使开发人员能够隔离bug并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。\n\n\n# 3. react 实现一个全局的 dialog\n\nimport react, { component } from 'react';\nimport { is, fromjs } from 'immutable';\nimport reactdom from 'react-dom';\nimport reactcsstransitiongroup from 'react-addons-css-transition-group';\nimport './dialog.css';\nlet defaultstate = {\n  alertstatus:false,\n  alerttip:\"提示\",\n  closedialog:function(){},\n  childs:''\n}\nclass dialog extends component{\n  state = {\n    ...defaultstate\n  };\n  // css动画组件设置为目标组件\n  firstchild = props => {\n    const childrenarray = react.children.toarray(props.children);\n    return childrenarray[0] || null;\n  }\n  //打开弹窗\n  open =(options)=>{\n    options = options || {};\n    options.alertstatus = true;\n    var props = options.props || {};\n    var childs = this.renderchildren(props,options.childrens) || '';\n    console.log(childs);\n    this.setstate({\n      ...defaultstate,\n      ...options,\n      childs\n    })\n  }\n  //关闭弹窗\n  close(){\n    this.state.closedialog();\n    this.setstate({\n      ...defaultstate\n    })\n  }\n  renderchildren(props,childrens) {\n    //遍历所有子组件\n    var childs = [];\n    childrens = childrens || [];\n    var ps = {\n        ...props,  //给子组件绑定props\n        _close:this.close  //给子组件也绑定一个关闭弹窗的事件    \n       };\n    childrens.foreach((currentitem,index) => {\n        childs.push(react.createelement(\n            currentitem,\n            {\n                ...ps,\n                key:index\n            }\n        ));\n    })\n    return childs;\n  }\n  shouldcomponentupdate(nextprops, nextstate){\n    return !is(fromjs(this.props), fromjs(nextprops)) || !is(fromjs(this.state), fromjs(nextstate))\n  }\n   \n  render(){\n    return (\n      <reactcsstransitiongroup\n        component={this.firstchild}\n        transitionname='hide'\n        transitionentertimeout={300}\n        transitionleavetimeout={300}>\n        <div classname=\"dialog-con\" style={this.state.alertstatus? {display:'block'}:{display:'none'}}>\n            {this.state.childs}\n        </div>\n      </reactcsstransitiongroup>\n    );\n  }\n}\nlet div = document.createelement('div');\nlet props = {\n   \n};\ndocument.body.appendchild(div);\nlet box = reactd\n\n\n子类：\n\n//子类jsx\nimport react, { component } from 'react';\nclass child extends component {\n    constructor(props){\n        super(props);\n        this.state = {date: new date()};\n  }\n  showvalue=()=>{\n    this.props.showvalue && this.props.showvalue()\n  }\n  render() {\n    return (\n      <div classname=\"child\">\n        <div classname=\"content\">\n           child\n           <button onclick={this.showvalue}>调用父的方法</button>\n        </div>\n      </div>\n    );\n  }\n}\nexport default child;\n\n\ncss：\n\n.dialog-con{\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.3);\n}\n\n\n\n# 4. react 数据持久化有什么实践吗？\n\n封装数据持久化组件：\n\n】let storage={\n    // 增加\n    set(key, value){\n        localstorage.setitem(key, json.stringify(value));\n    },\n    // 获取\n    get(key){\n        return json.parse(localstorage.getitem(key));\n    },\n    // 删除\n    remove(key){\n        localstorage.removeitem(key);\n    }\n};\nexport default storage;\n\n\n在react项目中，通过redux存储全局数据时，会有一个问题，如果用户刷新了网页，那么通过redux存储的全局数据就会被全部清空，比如登录信息等。这时就会有全局数据持久化存储的需求。首先想到的就是localstorage，localstorage是没有时间限制的数据存储，可以通过它来实现数据的持久化存储。\n\n但是在已经使用redux来管理和存储全局数据的基础上，再去使用localstorage来读写数据，这样不仅是工作量巨大，还容易出错。那么有没有结合redux来达到持久数据存储功能的框架呢？当然，它就是redux-persist。redux-persist会将redux的store中的数据缓存到浏览器的localstorage中。其使用步骤如下：\n\n（1）首先要安装redux-persist：\n\nnpm i redux-persist\n\n\n（2）对于reducer和action的处理不变，只需修改store的生成代码，修改如下：\n\nimport {createstore} from 'redux'\nimport reducers from '../reducers/index'\nimport {persiststore, persistreducer} from 'redux-persist';\nimport storage from 'redux-persist/lib/storage';\nimport automergelevel2 from 'redux-persist/lib/statereconciler/automergelevel2';\nconst persistconfig = {\n    key: 'root',\n    storage: storage,\n    statereconciler: automergelevel2 // 查看 'merge process' 部分的具体情况\n};\nconst mypersistreducer = persistreducer(persistconfig, reducers)\nconst store = createstore(mypersistreducer)\nexport const persistor = persiststore(store)\nexport default store\n\n\n（3）在index.js中，将persistgate标签作为网页内容的父标签：\n\nimport react from 'react';\nimport reactdom from 'react-dom';\nimport {provider} from 'react-redux'\nimport store from './redux/store/store'\nimport {persistor} from './redux/store/store'\nimport {persistgate} from 'redux-persist/lib/integration/react';\nreactdom.render(<provider store={store}>\n            <persistgate loading={null} persistor={persistor}>\n                {/*网页内容*/}\n            </persistgate>\n        </provider>, document.getelementbyid('root'));\n\n\n这就完成了通过redux-persist实现react持久化本地数据存储的简单应用。\n\n\n# 5. 对 react 和 vue 的理解，它们的异同\n\n相似之处：\n\n * 都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库\n * 都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。\n * 都使用了virtual dom（虚拟dom）提高重绘性能\n * 都有props的概念，允许组件间的数据传递\n * 都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性\n\n不同之处：\n\n1）数据流\n\nvue默认支持数据双向绑定，而react一直提倡单向数据流\n\n2）虚拟dom\n\nvue2.x开始引入\"virtual dom\"，消除了和react在这方面的差异，但是在具体的细节还是有各自的特点。\n\n * vue宣称可以更快地计算出virtual dom的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\n * 对于react而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 purecomponent/shouldcomponentupdate这个生命周期方法来进行控制，但vue将此视为默认的优化。\n\n3）组件化\n\nreact与vue最大的不同是模板的编写。\n\n * vue鼓励写近似常规html的模板。写起来很接近标准 html元素，只是多了一些属性。\n * react推荐你所有的模板通用javascript的语法扩展——jsx书写。\n\n具体来讲：react中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 完组件之后，还需要在 components 中再声明下。\n\n4）监听数据变化的实现原理不同\n\n * vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能\n * react 默认是通过比较引用的方式进行的，如果不优化（purecomponent/shouldcomponentupdate）可能导致大量不必要的vdom的重新渲染。这是因为 vue 使用的是可变数据，而react更强调数据的不可变。\n\n5）高阶组件\n\nreact可以通过高阶组件（higher order components-- hoc）来扩展，而vue需要通过mixins来扩展。\n\n原因高阶组件就是高阶函数，而react的组件本身就是纯粹的函数，所以高阶函数对react来说易如反掌。相反vue.js使用html模板创建视图组件，这时模板无法有效的编译，因此vue不采用hoc来实现。\n\n6）构建工具\n\n两者都有自己的构建工具\n\n * react ==> create react app\n * vue ==> vue-cli\n\n7）跨平台\n\n * react ==> react native\n * vue ==> weex\n\n\n# 6. 可以使用typescript写react应用吗？怎么操作？\n\n（1）如果还未创建 create react app 项目\n\n * 直接创建一个具有 typescript 的 create react app 项目：\n\n npx create-react-app demo --typescript\n\n\n（2）如果已经创建了 create react app 项目，需要将 typescript 引入到已有项目中\n\n * 通过命令将 typescript 引入项目：\n\nnpm install --save typescript @types/node @types/react @types/react-dom @types/jest\n\n\n * 将项目中任何 后缀名为 ‘.js’ 的 javascript 文件重命名为 typescript 文件即后缀名为 ‘.tsx’（例如 src/index.js 重命名为 src/index.tsx ）\n\n\n# 7. react 设计思路，它的理念是什么？\n\n（1）编写简单直观的代码\n\nreact最大的价值不是高性能的虚拟dom、封装的事件机制、服务器端渲染，而是声明式的直观的编码方式。react文档第一条就是声明式，react 使创建交互式 ui 变得轻而易举。为应用的每一个状态设计简洁的视图，当数据改变时 react 能有效地更新并正确地渲染组件。 以声明式编写 ui，可以让代码更加可靠，且方便调试。\n\n（2）简化可复用的组件\n\nreact框架里面使用了简化的组件模型，但更彻底地使用了组件化的概念。react将整个ui上的每一个功能模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成更大的组件。react的组件具有如下的特性∶\n\n * 可组合：简单组件可以组合为复杂的组件\n * 可重用：每个组件都是独立的，可以被多个组件使用\n * 可维护：和组件相关的逻辑和ui都封装在了组件的内部，方便维护\n * 可测试：因为组件的独立性，测试组件就变得方便很多。\n\n（3) virtual dom\n\n真实页面对应一个 dom 树。在传统页面的开发模式中，每次需要更新页面时，都要手动操作 dom 来进行更新。 dom 操作非常昂贵。在前端开发中，性能消耗最大的就是 dom 操作，而且这部分代码会让整体项目的代码变得难 以维护。react 把真实 dom 树转换成 javascript 对象树，也就是 virtual dom，每次数据更新后，重新计算 virtual dom，并和上一次生成的 virtual dom 做对比，对发生变化的部分做批量更新。react 也提供了直观的 shouldcomponentupdate 生命周期回调，来减少数据变化后不必要的 virtual dom 对比过程，以保证性能。\n\n（4）函数式编程\n\nreact 把过去不断重复构建 ui 的过程抽象成了组件，且在给定参数的情况下约定渲染对应的 ui 界面。react 能充分利用很多函数式方法去减少冗余代码。此外，由于它本身就是简单函数，所以易于测试。\n\n（5）一次学习，随处编写\n\n无论现在正在使用什么技术栈，都可以随时引入 react来开发新特性，而不需要重写现有代码。\n\nreact 还可以使用 node 进行服务器渲染，或使用 react native 开发原生移动应用。因为 react 组件可以映射为对应的原生控件。在输出的时候，是输出 web dom，还是 android 控件，还是 ios 控件，就由平台本身决定了。所以，react很方便和其他平台集成\n\n\n# 8. react中props.children和react.children的区别\n\n在react中，当涉及组件嵌套，在父组件中使用props.children把所有子组件显示出来。如下：\n\nfunction parentcomponent(props){\n\treturn (\n\t\t<div>\n\t\t\t{props.children}\n\t\t</div>\n\t)\n}\n\n\n如果想把父组件中的属性传给所有的子组件，需要使用react.children方法。\n\n比如，把几个radio组合起来，合成一个radiogroup，这就要求所有的radio具有同样的name属性值。可以这样：把radio看做子组件，radiogroup看做父组件，name的属性值在radiogroup这个父组件中设置。\n\n首先是子组件：\n\n//子组件\nfunction radiooption(props) {\n  return (\n    <label>\n      <input type=\"radio\" value={props.value} name={props.name} />\n      {props.label}\n    </label>\n  )\n}\n\n\n然后是父组件，不仅需要把它所有的子组件显示出来，还需要为每个子组件赋上name属性和值：\n\n//父组件用,props是指父组件的props\nfunction renderchildren(props) {\n    \n  //遍历所有子组件\n  return react.children.map(props.children, child => {\n    if (child.type === radiooption)\n      return react.cloneelement(child, {\n        //把父组件的props.name赋值给每个子组件\n        name: props.name\n      })\n    else\n      return child\n  })\n}\n//父组件\nfunction radiogroup(props) {\n  return (\n    <div>\n      {renderchildren(props)}\n    </div>\n  )\n}\nfunction app() {\n  return (\n    <radiogroup name=\"hello\">\n      <radiooption label=\"选项一\" value=\"1\" />\n      <radiooption label=\"选项二\" value=\"2\" />\n      <radiooption label=\"选项三\" value=\"3\" />\n    </radiogroup>\n  )\n}\nexport default app;\n\n\n以上，react.children.map让我们对父组件的所有子组件又更灵活的控制。\n\n\n# 9. react的状态提升是什么？使用场景有哪些？\n\nreact的状态提升就是用户对子组件操作，子组件不改变自己的状态，通过自己的props把这个操作改变的数据传递给父组件，改变父组件的状态，从而改变受父组件控制的所有子组件的状态，这也是react单项数据流的特性决定的。官方的原话是：共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(lifting state up)”。\n\n概括来说就是将多个组件需要共享的状态提升到它们最近的父组件上，在父组件上改变这个状态然后通过props分发给子组件。\n\n一个简单的例子，父组件中有两个input子组件，如果想在第一个输入框输入数据，来改变第二个输入框的值，这就需要用到状态提升。\n\nclass father extends react.component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            value1: '',\n            value2: ''\n        }\n    }\n    value1change(aa) {\n        this.setstate({\n            value1: aa\n        })\n    }\n    value2change(bb) {\n        this.setstate({\n            value2: bb\n        })\n    }\n    render() {\n        return (\n            <div style={{ padding: \"100px\" }}>\n                <child1 value1={this.state.value1} onvalue1change={this.value1change.bind(this)} />\n                \n\n                <child2 value2={this.state.value1} />\n            </div>\n        )\n    }\n}\nclass child1 extends react.component {\n    constructor(props) {\n        super(props)\n    }\n    changevalue(e) {\n        this.props.onvalue1change(e.target.value)\n    }\n    render() {\n        return (\n            <input value={this.props.value1} onchange={this.changevalue.bind(this)} />\n        )\n    }\n}\nclass child2 extends react.component {\n    constructor(props) {\n        super(props)\n    }\n    render() {\n        return (\n            <input value={this.props.value2} />\n        )\n    }\n}\n \nreactdom.render(\n    <father />,\n    document.getelementbyid('root')\n)\n\n\n\n# 10. react中constructor和getinitialstate的区别?\n\n两者都是用来初始化state的。前者是es6中的语法，后者是es5中的语法，新版本的react中已经废弃了该方法。\n\ngetinitialstate是es5中的方法，如果使用createclass方法创建一个component组件，可以自动调用它的getinitialstate方法来获取初始化的state对象，\n\nvar app = react.creatclass ({\n  getinitialstate() {\n    return { \n        username: 'hi',\n        userid: 0\n     };\n　}\n})\n\n\nreact在es6的实现中去掉了getinitialstate这个hook函数，规定state在constructor中实现，如下：\n\nclass app extends react.component{\n    constructor(props){\n      super(props);\n      this.state={};\n    }\n  }\n\n\n\n# 11. react的严格模式如何使用，有什么用处？\n\nstrictmode 是一个用来突出显示应用程序中潜在问题的工具。与 fragment 一样，strictmode 不会渲染任何可见的 ui。它为其后代元素触发额外的检查和警告。 可以为应用程序的任何部分启用严格模式。例如：\n\nimport react from 'react';\nfunction exampleapplication() {\n  return (\n    <div>\n      <header />\n      <react.strictmode>        \n        <div>\n          <componentone />\n          <componenttwo />\n        </div>\n      </react.strictmode>      \n      <footer />\n    </div>\n  );\n}\n\n\n在上述的示例中，不会对 header 和 footer 组件运行严格模式检查。但是，componentone 和 componenttwo 以及它们的所有后代元素都将进行检查。\n\nstrictmode 目前有助于：\n\n * 识别不安全的生命周期\n * 关于使用过时字符串 ref api 的警告\n * 关于使用废弃的 finddomnode 方法的警告\n * 检测意外的副作用\n * 检测过时的 context api\n\n\n# 12. 在react中遍历的方法有哪些？\n\n（1）遍历数组：map && foreach\n\nimport react from 'react';\n\nclass app extends react.component {\n  render() {\n    let arr = ['a', 'b', 'c', 'd'];\n    return (\n      <ul>\n        {\n          arr.map((item, index) => {\n            return <li key={index}>{item}</li>\n          })\n        }\n      </ul>\n    )\n  }\n}\n\nclass app extends react.component {\n  render() {\n    let arr = ['a', 'b', 'c', 'd'];\n    return (\n      <ul>\n        {\n          arr.foreach((item, index) => {\n            return <li key={index}>{item}</li>\n          })\n        }\n      </ul>\n    )\n  }\n}\n\n\n（2）遍历对象：map && for in\n\nclass app extends react.component {\n  render() {\n    let obj = {\n      a: 1,\n      b: 2,\n      c: 3\n    }\n    return (\n      <ul>\n        {\n          (() => {\n            let domarr = [];\n            for(const key in obj) {\n              if(obj.hasownproperty(key)) {\n                const value = obj[key]\n                domarr.push(<li key={key}>{value}</li>)\n              }\n            }\n            return domarr;\n          })()\n        }\n      </ul>\n    )\n  }\n}\n\n// object.entries() 把对象转换成数组\nclass app extends react.component {\n  render() {\n    let obj = {\n      a: 1,\n      b: 2,\n      c: 3\n    }\n    return (\n      <ul>\n        {\n          object.entries(obj).map(([key, value], index) => {   // item是一个数组，把item解构，写法是[key, value]\n            return <li key={key}>{value}</li>\n          }) \n        }\n      </ul>\n    )\n  }\n}\n\n\n\n# 13. 在react中页面重新加载时怎样保留数据？\n\n这个问题就设计到了数据持久化， 主要的实现方式有以下几种：\n\n * redux： 将页面的数据存储在redux中，在重新加载页面时，获取redux中的数据；\n * data.js： 使用webpack构建的项目，可以建一个文件，data.js，将数据保存data.js中，跳转页面后获取；\n * sessionstorge： 在进入选择地址页面之前，componentwillunmount的时候，将数据存储到sessionstorage中，每次进入页面判断sessionstorage中有没有存储的那个值，有，则读取渲染数据；没有，则说明数据是初始化的状态。返回或进入除了选择地址以外的页面，清掉存储的sessionstorage，保证下次进入是初始化的数据\n * history api： history api 的 pushstate 函数可以给历史记录关联一个任意的可序列化 state，所以可以在路由 push 的时候将当前页面的一些信息存到 state 中，下次返回到这个页面的时候就能从 state 里面取出离开前的数据重新渲染。react-router 直接可以支持。这个方法适合一些需要临时存储的场景。\n\n\n# 14. 同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？\n\n * react：包含react所必须的核心代码\n * react-dom：react渲染在不同平台所需要的核心代码\n * babel：将jsx转换成react代码的工具\n\n\n# 15. react必须使用jsx吗？\n\nreact 并不强制要求使用 jsx。当不想在构建环境中配置有关 jsx 编译时，不在 react 中使用 jsx 会更加方便。\n\n每个 jsx 元素只是调用 react.createelement(component, props, ...children) 的语法糖。因此，使用 jsx 可以完成的任何事情都可以通过纯 javascript 完成。\n\n例如，用 jsx 编写的代码：\n\nclass hello extends react.component {\n  render() {\n    return <div>hello {this.props.towhat}</div>;\n  }\n}\nreactdom.render(\n  <hello towhat=\"world\" />,\n  document.getelementbyid('root')\n);\n\n\n可以编写为不使用 jsx 的代码：\n\nclass hello extends react.component {\n  render() {\n    return react.createelement('div', null, `hello ${this.props.towhat}`);\n  }\n}\nreactdom.render(\n  react.createelement(hello, {towhat: 'world'}, null),\n  document.getelementbyid('root')\n);\n\n\n\n# 16. 为什么使用jsx的组件中没有看到使用react却需要引入react？\n\n本质上来说jsx是react.createelement(component, props, ...children)方法的语法糖。在react 17之前，如果使用了jsx，其实就是在使用react， babel 会把组件转换为 createelement 形式。在react 17之后，就不再需要引入，因为 babel 已经可以帮我们自动引入react。\n\n\n# 17. 在react中怎么使用async/await？\n\nasync/await是es7标准中的新特性。如果是使用react官方的脚手架创建的项目，就可以直接使用。如果是在自己搭建的webpack配置的项目中使用，可能会遇到 regeneratorruntime is not defined 的异常错误。那么我们就需要引入babel，并在babel中配置使用async/await。可以利用babel的 transform-async-to-module-method 插件来转换其成为浏览器支持的语法，虽然没有性能的提升，但对于代码编写体验要更好。\n\n\n# 18. react.children.map和js的map有什么区别？\n\njavascript中的map不会对为null或者undefined的数据进行处理，而react.children.map中的map可以处理react.children为null或者undefined的情况。\n\n\n# 19. 对react ssr的理解\n\n服务端渲染是数据与模版组成的html，即 html = 数据 ＋ 模版。将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记\"混合\"为客户端上完全交互的应用程序。页面没使用服务渲染，当请求页面时，返回的body里为空，之后执行js将html结构注入到body里，结合css显示出来;\n\nssr的优势：\n\n * 对seo友好\n * 所有的模版、图片等资源都存在服务器端\n * 一个html返回所有数据\n * 减少http请求\n * 响应快、用户体验好、首屏渲染快\n\n1）更利于seo\n\n不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本使用了react或者其它mvvm框架之后，页面大多数dom元素都是在客户端根据js动态生成，可供爬虫抓取分析的内容大大减少。另外，浏览器爬虫不会等待我们的数据完成之后再去抓取页面数据。服务端渲染返回给客户端的是已经获取了异步数据并执行javascript脚本的最终html，网络爬中就可以抓取到完整页面的信息。\n\n2）更利于首屏渲染\n\n首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。\n\nssr的局限：\n\n1）服务端压力较大\n\n本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端cpu资源;\n\n2）开发条件受限\n\n在服务端渲染中，只会执行到componentdidmount之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制;\n\n3）学习成本相对较高 除了对webpack、mvvm框架要熟悉，还需要掌握node、 koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。\n\n时间耗时比较：\n\n1）数据请求\n\n由服务端请求首屏数据，而不是客户端请求首屏数据，这是\"快\"的一个主要原因。服务端在内网进行请求，数据响应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大，导致时间差\n\n * 客户端数据请求\n\n\n\n * 服务端数据请求\n\n2）html渲染 服务端渲染是先向后端服务器请求数据，然后生成完整首屏 html返回给浏览器；而客户端渲染是等js代码下载、加载、解析完成后再请求数据渲染，等待的过程页面是什么都没有的，就是用户看到的白屏。就是服务端渲染不需要等待js代码下载完成并请求数据，就可以返回一个已有完整数据的首屏页面。\n\n * 非ssr html渲染\n\n\n\n * ssr html渲染\n\n\n\n\n# 20. 为什么 react 要用 jsx？\n\njsx 是一个 javascript 的语法扩展，或者说是一个类似于 xml 的 ecmascript 语法扩展。它本身没有太多的语法定义，也不期望引入更多的标准。\n\n其实 react 本身并不强制使用 jsx。在没有 jsx 的时候，react 实现一个组件依赖于使用 react.createelement 函数。代码如下：\n\nclass hello extends react.component {\n  render() {\n    return react.createelement(\n        'div',\n        null, \n        `hello ${this.props.towhat}`\n      );\n  }\n}\nreactdom.render(\n  react.createelement(hello, {towhat: 'world'}, null),\n  document.getelementbyid('root')\n);\n\n\n而 jsx 更像是一种语法糖，通过类似 xml 的描述方式，描写函数对象。在采用 jsx 之后，这段代码会这样写：\n\nclass hello extends react.component {\n  render() {\n    return <div>hello {this.props.towhat}</div>;\n  }\n}\nreactdom.render(\n  <hello towhat=\"world\" />,\n  document.getelementbyid('root')\n);\n\n\n通过对比，可以清晰地发现，代码变得更为简洁，而且代码结构层次更为清晰。\n\n因为 react 需要将组件转化为虚拟 dom 树，所以在编写代码时，实际上是在手写一棵结构树。而xml 在树结构的描述上天生具有可读性强的优势。\n\n但这样可读性强的代码仅仅是给写程序的同学看的，实际上在运行的时候，会使用 babel 插件将 jsx 语法的代码还原为 react.createelement 的代码。\n\n总结： jsx 是一个 javascript 的语法扩展，结构类似 xml。jsx 主要用于声明 react 元素，但 react 中并不强制使用 jsx。即使使用了 jsx，也会在构建过程中，通过 babel 插件编译为 react.createelement。所以 jsx 更像是 react.createelement 的一种语法糖。\n\nreact 团队并不想引入 javascript 本身以外的开发体系。而是希望通过合理的关注点分离保持组件开发的纯粹性。\n\n\n# 21. react 中的高阶组件运用了什么设计模式？\n\n使用了装饰模式，高阶组件的运用：\n\nfunction withwindowwidth(basecomponent) {\n  class derivedclass extends react.component {\n    state = {\n      windowwidth: window.innerwidth,\n    }\n    onresize = () => {\n      this.setstate({\n        windowwidth: window.innerwidth,\n      })\n    }\n    componentdidmount() {\n      window.addeventlistener('resize', this.onresize)\n    }\n    componentwillunmount() {\n      window.removeeventlistener('resize', this.onresize);\n    }\n    render() {\n      return <basecomponent {...this.props} {...this.state}/>\n    }\n  }\n  return derivedclass;\n}\nconst mycomponent = (props) => {\n  return <div>window width is: {props.windowwidth}</div>\n};\nexport default withwindowwidth(mycomponent);\n\n\n装饰模式的特点是不需要改变 被装饰对象 本身，而只是在外面套一个外壳接口。javascript 目前已经有了原生装饰器的提案，其用法如下：\n\n@testable\n   class mytestableclass {\n}\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "场景应用",
      "frontmatter": {
        "title": "场景应用",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/writeCode/scenarioApplication/",
        "article": false
      },
      "regularPath": "/40.%E4%BB%A3%E7%A0%81%E7%AF%87/10.%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%AF%87/30.%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8.html",
      "relativePath": "40.代码篇/10.手写代码篇/30.场景应用.md",
      "key": "v-1fbbe367",
      "path": "/pages/writeCode/scenarioApplication/",
      "headers": [
        {
          "level": 3,
          "title": "1. 循环打印红黄绿",
          "slug": "_1-循环打印红黄绿",
          "normalizedTitle": "1. 循环打印红黄绿",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 实现每隔一秒打印 1,2,3,4",
          "slug": "_2-实现每隔一秒打印-1-2-3-4",
          "normalizedTitle": "2. 实现每隔一秒打印 1,2,3,4",
          "charIndex": 1766
        },
        {
          "level": 3,
          "title": "3. 小孩报数问题",
          "slug": "_3-小孩报数问题",
          "normalizedTitle": "3. 小孩报数问题",
          "charIndex": 2038
        },
        {
          "level": 3,
          "title": "4. 用Promise实现图片的异步加载",
          "slug": "_4-用promise实现图片的异步加载",
          "normalizedTitle": "4. 用promise实现图片的异步加载",
          "charIndex": 2876
        },
        {
          "level": 3,
          "title": "5. 实现发布-订阅模式",
          "slug": "_5-实现发布-订阅模式",
          "normalizedTitle": "5. 实现发布-订阅模式",
          "charIndex": 3462
        },
        {
          "level": 3,
          "title": "6. 查找文章中出现频率最高的单词",
          "slug": "_6-查找文章中出现频率最高的单词",
          "normalizedTitle": "6. 查找文章中出现频率最高的单词",
          "charIndex": 4521
        },
        {
          "level": 3,
          "title": "7. 封装异步的fetch，使用async await方式来使用",
          "slug": "_7-封装异步的fetch-使用async-await方式来使用",
          "normalizedTitle": "7. 封装异步的fetch，使用async await方式来使用",
          "charIndex": 5163
        },
        {
          "level": 3,
          "title": "8. 实现prototype继承",
          "slug": "_8-实现prototype继承",
          "normalizedTitle": "8. 实现prototype继承",
          "charIndex": 6595
        },
        {
          "level": 3,
          "title": "9. 实现双向数据绑定",
          "slug": "_9-实现双向数据绑定",
          "normalizedTitle": "9. 实现双向数据绑定",
          "charIndex": 6992
        },
        {
          "level": 3,
          "title": "10. 实现简单路由",
          "slug": "_10-实现简单路由",
          "normalizedTitle": "10. 实现简单路由",
          "charIndex": 7424
        },
        {
          "level": 3,
          "title": "11. 实现斐波那契数列",
          "slug": "_11-实现斐波那契数列",
          "normalizedTitle": "11. 实现斐波那契数列",
          "charIndex": 7977
        },
        {
          "level": 3,
          "title": "12. 字符串出现的不重复最长长度",
          "slug": "_12-字符串出现的不重复最长长度",
          "normalizedTitle": "12. 字符串出现的不重复最长长度",
          "charIndex": 8629
        },
        {
          "level": 3,
          "title": "13. 使用 setTimeout 实现 setInterval",
          "slug": "_13-使用-settimeout-实现-setinterval",
          "normalizedTitle": "13. 使用 settimeout 实现 setinterval",
          "charIndex": 9052
        },
        {
          "level": 3,
          "title": "14. 实现 jsonp",
          "slug": "_14-实现-jsonp",
          "normalizedTitle": "14. 实现 jsonp",
          "charIndex": 9748
        },
        {
          "level": 3,
          "title": "15. 判断对象是否存在循环引用",
          "slug": "_15-判断对象是否存在循环引用",
          "normalizedTitle": "15. 判断对象是否存在循环引用",
          "charIndex": 10124
        }
      ],
      "headersStr": "1. 循环打印红黄绿 2. 实现每隔一秒打印 1,2,3,4 3. 小孩报数问题 4. 用Promise实现图片的异步加载 5. 实现发布-订阅模式 6. 查找文章中出现频率最高的单词 7. 封装异步的fetch，使用async await方式来使用 8. 实现prototype继承 9. 实现双向数据绑定 10. 实现简单路由 11. 实现斐波那契数列 12. 字符串出现的不重复最长长度 13. 使用 setTimeout 实现 setInterval 14. 实现 jsonp 15. 判断对象是否存在循环引用",
      "content": "# 1. 循环打印红黄绿\n\n下面来看一道比较典型的问题，通过这个问题来对比几种异步编程方法：红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？\n\n三个亮灯函数：\n\nfunction red() {\n    console.log('red');\n}\nfunction green() {\n    console.log('green');\n}\nfunction yellow() {\n    console.log('yellow');\n}\n\n\n这道题复杂的地方在于需要“交替重复”亮灯，而不是“亮完一次”就结束了。\n\n# （1）用 callback 实现\n\nconst task = (timer, light, callback) => {\n    setTimeout(() => {\n        if (light === 'red') {\n            red()\n        }\n        else if (light === 'green') {\n            green()\n        }\n        else if (light === 'yellow') {\n            yellow()\n        }\n        callback()\n    }, timer)\n}\ntask(3000, 'red', () => {\n    task(2000, 'green', () => {\n        task(1000, 'yellow', Function.prototype)\n    })\n})\n\n\n这里存在一个 bug：代码只是完成了一次流程，执行后红黄绿灯分别只亮一次。该如何让它交替重复进行呢？\n\n上面提到过递归，可以递归亮灯的一个周期：\n\nconst step = () => {\n    task(3000, 'red', () => {\n        task(2000, 'green', () => {\n            task(1000, 'yellow', step)\n        })\n    })\n}\nstep()\n\n\n注意看黄灯亮的回调里又再次调用了 step 方法 以完成循环亮灯。\n\n# （2）用 promise 实现\n\nconst task = (timer, light) => \n    new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (light === 'red') {\n                red()\n            }\n            else if (light === 'green') {\n                green()\n            }\n            else if (light === 'yellow') {\n                yellow()\n            }\n            resolve()\n        }, timer)\n    })\nconst step = () => {\n    task(3000, 'red')\n        .then(() => task(2000, 'green'))\n        .then(() => task(2100, 'yellow'))\n        .then(step)\n}\nstep()\n\n\n这里将回调移除，在一次亮灯结束后，resolve 当前 promise，并依然使用递归进行。\n\n# （3）用 async/await 实现\n\nconst taskRunner =  async () => {\n    await task(3000, 'red')\n    await task(2000, 'green')\n    await task(2100, 'yellow')\n    taskRunner()\n}\ntaskRunner()\n\n\n\n# 2. 实现每隔一秒打印 1,2,3,4\n\n// 使用闭包实现\nfor (var i = 0; i < 5; i++) {\n  (function(i) {\n    setTimeout(function() {\n      console.log(i);\n    }, i * 1000);\n  })(i);\n}\n// 使用 let 块级作用域\nfor (let i = 0; i < 5; i++) {\n  setTimeout(function() {\n    console.log(i);\n  }, i * 1000);\n}\n\n\n\n# 3. 小孩报数问题\n\n有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3 数到 3 的小孩儿退出这个圈， 然后下一个小孩 重新报数 1、2、3，问最后剩下的那个小孩儿的编号是多少?\n\nfunction childNum(num, count){\n    let allplayer = [];    \n    for(let i = 0; i < num; i++){\n        allplayer[i] = i + 1;\n    }\n    \n    let exitCount = 0;    // 离开人数\n    let counter = 0;      // 记录报数\n    let curIndex = 0;     // 当前下标\n    \n    while(exitCount < num - 1){\n        if(allplayer[curIndex] !== 0) counter++;    \n        \n        if(counter == count){\n            allplayer[curIndex] = 0;                 \n            counter = 0;\n            exitCount++;  \n        }\n        curIndex++;\n        if(curIndex == num){\n            curIndex = 0               \n        };           \n    }    \n    for(i = 0; i < num; i++){\n        if(allplayer[i] !== 0){\n            return allplayer[i]\n        }      \n    }\n}\nchildNum(30, 3)\n\n\n\n# 4. 用Promise实现图片的异步加载\n\nlet imageAsync=(url)=>{\n            return new Promise((resolve,reject)=>{\n                let img = new Image();\n                img.src = url;\n                img.οnlοad=()=>{\n                    console.log(`图片请求成功，此处进行通用操作`);\n                    resolve(image);\n                }\n                img.οnerrοr=(err)=>{\n                    console.log(`失败，此处进行失败的通用操作`);\n                    reject(err);\n                }\n            })\n        }\n        \nimageAsync(\"url\").then(()=>{\n    console.log(\"加载成功\");\n}).catch((error)=>{\n    console.log(\"加载失败\");\n})\n\n\n\n# 5. 实现发布-订阅模式\n\nclass EventCenter{\n  // 1. 定义事件容器，用来装事件数组\n\tlet handlers = {}\n\n  // 2. 添加事件方法，参数：事件名 事件方法\n  addEventListener(type, handler) {\n    // 创建新数组容器\n    if (!this.handlers[type]) {\n      this.handlers[type] = []\n    }\n    // 存入事件\n    this.handlers[type].push(handler)\n  }\n\n  // 3. 触发事件，参数：事件名 事件参数\n  dispatchEvent(type, params) {\n    // 若没有注册该事件则抛出错误\n    if (!this.handlers[type]) {\n      return new Error('该事件未注册')\n    }\n    // 触发事件\n    this.handlers[type].forEach(handler => {\n      handler(...params)\n    })\n  }\n\n  // 4. 事件移除，参数：事件名 要删除事件，若无第二个参数则删除该事件的订阅和发布\n  removeEventListener(type, handler) {\n    if (!this.handlers[type]) {\n      return new Error('事件无效')\n    }\n    if (!handler) {\n      // 移除事件\n      delete this.handlers[type]\n    } else {\n      const index = this.handlers[type].findIndex(el => el === handler)\n      if (index === -1) {\n        return new Error('无该绑定事件')\n      }\n      // 移除事件\n      this.handlers[type].splice(index, 1)\n      if (this.handlers[type].length === 0) {\n        delete this.handlers[type]\n      }\n    }\n  }\n}\n\n\n\n# 6. 查找文章中出现频率最高的单词\n\nfunction findMostWord(article) {\n  // 合法性判断\n  if (!article) return;\n  // 参数处理\n  article = article.trim().toLowerCase();\n  let wordList = article.match(/[a-z]+/g),\n    visited = [],\n    maxNum = 0,\n    maxWord = \"\";\n  article = \" \" + wordList.join(\"  \") + \" \";\n  // 遍历判断单词出现次数\n  wordList.forEach(function(item) {\n    if (visited.indexOf(item) < 0) {\n      // 加入 visited \n      visited.push(item);\n      let word = new RegExp(\" \" + item + \" \", \"g\"),\n        num = article.match(word).length;\n      if (num > maxNum) {\n        maxNum = num;\n        maxWord = item;\n      }\n    }\n  });\n  return maxWord + \"  \" + maxNum;\n}\n\n\n\n# 7. 封装异步的fetch，使用async await方式来使用\n\n(async () => {\n    class HttpRequestUtil {\n        async get(url) {\n            const res = await fetch(url);\n            const data = await res.json();\n            return data;\n        }\n        async post(url, data) {\n            const res = await fetch(url, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(data)\n            });\n            const result = await res.json();\n            return result;\n        }\n        async put(url, data) {\n            const res = await fetch(url, {\n                method: 'PUT',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                data: JSON.stringify(data)\n            });\n            const result = await res.json();\n            return result;\n        }\n        async delete(url, data) {\n            const res = await fetch(url, {\n                method: 'DELETE',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                data: JSON.stringify(data)\n            });\n            const result = await res.json();\n            return result;\n        }\n    }\n    const httpRequestUtil = new HttpRequestUtil();\n    const res = await httpRequestUtil.get('http://golderbrother.cn/');\n    console.log(res);\n})();\n\n\n\n# 8. 实现prototype继承\n\n所谓的原型链继承就是让新实例的原型等于父类的实例：\n\n//父方法\nfunction SupperFunction(flag1){\n    this.flag1 = flag1;\n}\n\n//子方法\nfunction SubFunction(flag2){\n    this.flag2 = flag2;\n}\n\n//父实例\nvar superInstance = new SupperFunction(true);\n\n//子继承父\nSubFunction.prototype = superInstance;\n\n//子实例\nvar subInstance = new SubFunction(false);\n//子调用自己和父的属性\nsubInstance.flag1;   // true\nsubInstance.flag2;   // false\n\n\n\n# 9. 实现双向数据绑定\n\nlet obj = {}\nlet input = document.getElementById('input')\nlet span = document.getElementById('span')\n// 数据劫持\nObject.defineProperty(obj, 'text', {\n  configurable: true,\n  enumerable: true,\n  get() {\n    console.log('获取数据了')\n  },\n  set(newVal) {\n    console.log('数据更新了')\n    input.value = newVal\n    span.innerHTML = newVal\n  }\n})\n// 输入监听\ninput.addEventListener('keyup', function(e) {\n  obj.text = e.target.value\n})\n\n\n\n# 10. 实现简单路由\n\n// hash路由\nclass Route{\n  constructor(){\n    // 路由存储对象\n    this.routes = {}\n    // 当前hash\n    this.currentHash = ''\n    // 绑定this，避免监听时this指向改变\n    this.freshRoute = this.freshRoute.bind(this)\n    // 监听\n    window.addEventListener('load', this.freshRoute, false)\n    window.addEventListener('hashchange', this.freshRoute, false)\n  }\n  // 存储\n  storeRoute (path, cb) {\n    this.routes[path] = cb || function () {}\n  }\n  // 更新\n  freshRoute () {\n    this.currentHash = location.hash.slice(1) || '/'\n    this.routes[this.currentHash]()\n  }\n}\n\n\n\n# 11. 实现斐波那契数列\n\n// 递归\nfunction fn (n){\n    if(n==0) return 0\n    if(n==1) return 1\n    return fn(n-2)+fn(n-1)\n}\n// 优化\nfunction fibonacci2(n) {\n    const arr = [1, 1, 2];\n    const arrLen = arr.length;\n\n    if (n <= arrLen) {\n        return arr[n];\n    }\n\n    for (let i = arrLen; i < n; i++) {\n        arr.push(arr[i - 1] + arr[ i - 2]);\n    }\n\n    return arr[arr.length - 1];\n}\n// 非递归\nfunction fn(n) {\n    let pre1 = 1;\n    let pre2 = 1;\n    let current = 2;\n\n    if (n <= 2) {\n        return current;\n    }\n\n    for (let i = 2; i < n; i++) {\n        pre1 = pre2;\n        pre2 = current;\n        current = pre1 + pre2;\n    }\n\n    return current;\n}\n\n\n\n# 12. 字符串出现的不重复最长长度\n\n用一个滑动窗口装没有重复的字符，枚举字符记录最大值即可。用 map 维护字符的索引，遇到相同的字符，把左边界移动过去即可。挪动的过程中记录最大长度：\n\nvar lengthOfLongestSubstring = function (s) {\n    let map = new Map();\n    let i = -1\n    let res = 0\n    let n = s.length\n    for (let j = 0; j < n; j++) {\n        if (map.has(s[j])) {\n            i = Math.max(i, map.get(s[j]))\n        }\n        res = Math.max(res, j - i)\n        map.set(s[j], j)\n    }\n    return res\n};\n\n\n\n# 13. 使用 setTimeout 实现 setInterval\n\nsetInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。\n\n针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。\n\n实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果\n\nfunction mySetInterval(fn, timeout) {\n  // 控制器，控制定时器是否继续执行\n  var timer = {\n    flag: true\n  };\n  // 设置递归函数，模拟定时器执行。\n  function interval() {\n    if (timer.flag) {\n      fn();\n      setTimeout(interval, timeout);\n    }\n  }\n  // 启动定时器\n  setTimeout(interval, timeout);\n  // 返回控制器\n  return timer;\n}\n\n\n\n# 14. 实现 jsonp\n\n// 动态的加载js文件\nfunction addScript(src) {\n  const script = document.createElement('script');\n  script.src = src;\n  script.type = \"text/javascript\";\n  document.body.appendChild(script);\n}\naddScript(\"http://xxx.xxx.com/xxx.js?callback=handleRes\");\n// 设置一个全局的callback函数来接收回调结果\nfunction handleRes(res) {\n  console.log(res);\n}\n// 接口返回的数据格式\nhandleRes({a: 1, b: 2});\n\n\n\n# 15. 判断对象是否存在循环引用\n\n循环引用对象本来没有什么问题，但是序列化的时候就会发生问题，比如调用JSON.stringify()对该类对象进行序列化，就会报错: Converting circular structure to JSON.\n\n下面方法可以用来判断一个对象中是否已存在循环引用：\n\nconst isCycleObject = (obj,parent) => {\n    const parentArr = parent || [obj];\n    for(let i in obj) {\n        if(typeof obj[i] === 'object') {\n            let flag = false;\n            parentArr.forEach((pObj) => {\n                if(pObj === obj[i]){\n                    flag = true;\n                }\n            })\n            if(flag) return true;\n            flag = isCycleObject(obj[i],[...parentArr,obj[i]]);\n            if(flag) return true;\n        }\n    }\n    return false;\n}\n\n\nconst a = 1;\nconst b = {a};\nconst c = {b};\nconst o = {d:{a:3},c}\no.c.b.aa = a;\n\nconsole.log(isCycleObject(o)\n\n\n查找有序二维数组的目标值：\n\nvar findNumberIn2DArray = function(matrix, target) {\n    if (matrix == null || matrix.length == 0) {\n        return false;\n    }\n    let row = 0;\n    let column = matrix[0].length - 1;\n    while (row < matrix.length && column >= 0) {\n        if (matrix[row][column] == target) {\n            return true;\n        } else if (matrix[row][column] > target) {\n            column--;\n        } else {\n            row++;\n        }\n    }\n    return false;\n};\n\n\n\n二维数组斜向打印：\n\nfunction printMatrix(arr){\n  let m = arr.length, n = arr[0].length\n\tlet res = []\n  \n  // 左上角，从0 到 n - 1 列进行打印\n  for (let k = 0; k < n; k++) {\n    for (let i = 0, j = k; i < m && j >= 0; i++, j--) {\n      res.push(arr[i][j]);\n    }\n  }\n\n  // 右下角，从1 到 n - 1 行进行打印\n  for (let k = 1; k < m; k++) {\n    for (let i = k, j = n - 1; i < m && j >= 0; i++, j--) {\n      res.push(arr[i][j]);\n    }\n  }\n  return res\n}\n",
      "normalizedContent": "# 1. 循环打印红黄绿\n\n下面来看一道比较典型的问题，通过这个问题来对比几种异步编程方法：红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？\n\n三个亮灯函数：\n\nfunction red() {\n    console.log('red');\n}\nfunction green() {\n    console.log('green');\n}\nfunction yellow() {\n    console.log('yellow');\n}\n\n\n这道题复杂的地方在于需要“交替重复”亮灯，而不是“亮完一次”就结束了。\n\n# （1）用 callback 实现\n\nconst task = (timer, light, callback) => {\n    settimeout(() => {\n        if (light === 'red') {\n            red()\n        }\n        else if (light === 'green') {\n            green()\n        }\n        else if (light === 'yellow') {\n            yellow()\n        }\n        callback()\n    }, timer)\n}\ntask(3000, 'red', () => {\n    task(2000, 'green', () => {\n        task(1000, 'yellow', function.prototype)\n    })\n})\n\n\n这里存在一个 bug：代码只是完成了一次流程，执行后红黄绿灯分别只亮一次。该如何让它交替重复进行呢？\n\n上面提到过递归，可以递归亮灯的一个周期：\n\nconst step = () => {\n    task(3000, 'red', () => {\n        task(2000, 'green', () => {\n            task(1000, 'yellow', step)\n        })\n    })\n}\nstep()\n\n\n注意看黄灯亮的回调里又再次调用了 step 方法 以完成循环亮灯。\n\n# （2）用 promise 实现\n\nconst task = (timer, light) => \n    new promise((resolve, reject) => {\n        settimeout(() => {\n            if (light === 'red') {\n                red()\n            }\n            else if (light === 'green') {\n                green()\n            }\n            else if (light === 'yellow') {\n                yellow()\n            }\n            resolve()\n        }, timer)\n    })\nconst step = () => {\n    task(3000, 'red')\n        .then(() => task(2000, 'green'))\n        .then(() => task(2100, 'yellow'))\n        .then(step)\n}\nstep()\n\n\n这里将回调移除，在一次亮灯结束后，resolve 当前 promise，并依然使用递归进行。\n\n# （3）用 async/await 实现\n\nconst taskrunner =  async () => {\n    await task(3000, 'red')\n    await task(2000, 'green')\n    await task(2100, 'yellow')\n    taskrunner()\n}\ntaskrunner()\n\n\n\n# 2. 实现每隔一秒打印 1,2,3,4\n\n// 使用闭包实现\nfor (var i = 0; i < 5; i++) {\n  (function(i) {\n    settimeout(function() {\n      console.log(i);\n    }, i * 1000);\n  })(i);\n}\n// 使用 let 块级作用域\nfor (let i = 0; i < 5; i++) {\n  settimeout(function() {\n    console.log(i);\n  }, i * 1000);\n}\n\n\n\n# 3. 小孩报数问题\n\n有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3 数到 3 的小孩儿退出这个圈， 然后下一个小孩 重新报数 1、2、3，问最后剩下的那个小孩儿的编号是多少?\n\nfunction childnum(num, count){\n    let allplayer = [];    \n    for(let i = 0; i < num; i++){\n        allplayer[i] = i + 1;\n    }\n    \n    let exitcount = 0;    // 离开人数\n    let counter = 0;      // 记录报数\n    let curindex = 0;     // 当前下标\n    \n    while(exitcount < num - 1){\n        if(allplayer[curindex] !== 0) counter++;    \n        \n        if(counter == count){\n            allplayer[curindex] = 0;                 \n            counter = 0;\n            exitcount++;  \n        }\n        curindex++;\n        if(curindex == num){\n            curindex = 0               \n        };           \n    }    \n    for(i = 0; i < num; i++){\n        if(allplayer[i] !== 0){\n            return allplayer[i]\n        }      \n    }\n}\nchildnum(30, 3)\n\n\n\n# 4. 用promise实现图片的异步加载\n\nlet imageasync=(url)=>{\n            return new promise((resolve,reject)=>{\n                let img = new image();\n                img.src = url;\n                img.οnlοad=()=>{\n                    console.log(`图片请求成功，此处进行通用操作`);\n                    resolve(image);\n                }\n                img.οnerrοr=(err)=>{\n                    console.log(`失败，此处进行失败的通用操作`);\n                    reject(err);\n                }\n            })\n        }\n        \nimageasync(\"url\").then(()=>{\n    console.log(\"加载成功\");\n}).catch((error)=>{\n    console.log(\"加载失败\");\n})\n\n\n\n# 5. 实现发布-订阅模式\n\nclass eventcenter{\n  // 1. 定义事件容器，用来装事件数组\n\tlet handlers = {}\n\n  // 2. 添加事件方法，参数：事件名 事件方法\n  addeventlistener(type, handler) {\n    // 创建新数组容器\n    if (!this.handlers[type]) {\n      this.handlers[type] = []\n    }\n    // 存入事件\n    this.handlers[type].push(handler)\n  }\n\n  // 3. 触发事件，参数：事件名 事件参数\n  dispatchevent(type, params) {\n    // 若没有注册该事件则抛出错误\n    if (!this.handlers[type]) {\n      return new error('该事件未注册')\n    }\n    // 触发事件\n    this.handlers[type].foreach(handler => {\n      handler(...params)\n    })\n  }\n\n  // 4. 事件移除，参数：事件名 要删除事件，若无第二个参数则删除该事件的订阅和发布\n  removeeventlistener(type, handler) {\n    if (!this.handlers[type]) {\n      return new error('事件无效')\n    }\n    if (!handler) {\n      // 移除事件\n      delete this.handlers[type]\n    } else {\n      const index = this.handlers[type].findindex(el => el === handler)\n      if (index === -1) {\n        return new error('无该绑定事件')\n      }\n      // 移除事件\n      this.handlers[type].splice(index, 1)\n      if (this.handlers[type].length === 0) {\n        delete this.handlers[type]\n      }\n    }\n  }\n}\n\n\n\n# 6. 查找文章中出现频率最高的单词\n\nfunction findmostword(article) {\n  // 合法性判断\n  if (!article) return;\n  // 参数处理\n  article = article.trim().tolowercase();\n  let wordlist = article.match(/[a-z]+/g),\n    visited = [],\n    maxnum = 0,\n    maxword = \"\";\n  article = \" \" + wordlist.join(\"  \") + \" \";\n  // 遍历判断单词出现次数\n  wordlist.foreach(function(item) {\n    if (visited.indexof(item) < 0) {\n      // 加入 visited \n      visited.push(item);\n      let word = new regexp(\" \" + item + \" \", \"g\"),\n        num = article.match(word).length;\n      if (num > maxnum) {\n        maxnum = num;\n        maxword = item;\n      }\n    }\n  });\n  return maxword + \"  \" + maxnum;\n}\n\n\n\n# 7. 封装异步的fetch，使用async await方式来使用\n\n(async () => {\n    class httprequestutil {\n        async get(url) {\n            const res = await fetch(url);\n            const data = await res.json();\n            return data;\n        }\n        async post(url, data) {\n            const res = await fetch(url, {\n                method: 'post',\n                headers: {\n                    'content-type': 'application/json'\n                },\n                body: json.stringify(data)\n            });\n            const result = await res.json();\n            return result;\n        }\n        async put(url, data) {\n            const res = await fetch(url, {\n                method: 'put',\n                headers: {\n                    'content-type': 'application/json'\n                },\n                data: json.stringify(data)\n            });\n            const result = await res.json();\n            return result;\n        }\n        async delete(url, data) {\n            const res = await fetch(url, {\n                method: 'delete',\n                headers: {\n                    'content-type': 'application/json'\n                },\n                data: json.stringify(data)\n            });\n            const result = await res.json();\n            return result;\n        }\n    }\n    const httprequestutil = new httprequestutil();\n    const res = await httprequestutil.get('http://golderbrother.cn/');\n    console.log(res);\n})();\n\n\n\n# 8. 实现prototype继承\n\n所谓的原型链继承就是让新实例的原型等于父类的实例：\n\n//父方法\nfunction supperfunction(flag1){\n    this.flag1 = flag1;\n}\n\n//子方法\nfunction subfunction(flag2){\n    this.flag2 = flag2;\n}\n\n//父实例\nvar superinstance = new supperfunction(true);\n\n//子继承父\nsubfunction.prototype = superinstance;\n\n//子实例\nvar subinstance = new subfunction(false);\n//子调用自己和父的属性\nsubinstance.flag1;   // true\nsubinstance.flag2;   // false\n\n\n\n# 9. 实现双向数据绑定\n\nlet obj = {}\nlet input = document.getelementbyid('input')\nlet span = document.getelementbyid('span')\n// 数据劫持\nobject.defineproperty(obj, 'text', {\n  configurable: true,\n  enumerable: true,\n  get() {\n    console.log('获取数据了')\n  },\n  set(newval) {\n    console.log('数据更新了')\n    input.value = newval\n    span.innerhtml = newval\n  }\n})\n// 输入监听\ninput.addeventlistener('keyup', function(e) {\n  obj.text = e.target.value\n})\n\n\n\n# 10. 实现简单路由\n\n// hash路由\nclass route{\n  constructor(){\n    // 路由存储对象\n    this.routes = {}\n    // 当前hash\n    this.currenthash = ''\n    // 绑定this，避免监听时this指向改变\n    this.freshroute = this.freshroute.bind(this)\n    // 监听\n    window.addeventlistener('load', this.freshroute, false)\n    window.addeventlistener('hashchange', this.freshroute, false)\n  }\n  // 存储\n  storeroute (path, cb) {\n    this.routes[path] = cb || function () {}\n  }\n  // 更新\n  freshroute () {\n    this.currenthash = location.hash.slice(1) || '/'\n    this.routes[this.currenthash]()\n  }\n}\n\n\n\n# 11. 实现斐波那契数列\n\n// 递归\nfunction fn (n){\n    if(n==0) return 0\n    if(n==1) return 1\n    return fn(n-2)+fn(n-1)\n}\n// 优化\nfunction fibonacci2(n) {\n    const arr = [1, 1, 2];\n    const arrlen = arr.length;\n\n    if (n <= arrlen) {\n        return arr[n];\n    }\n\n    for (let i = arrlen; i < n; i++) {\n        arr.push(arr[i - 1] + arr[ i - 2]);\n    }\n\n    return arr[arr.length - 1];\n}\n// 非递归\nfunction fn(n) {\n    let pre1 = 1;\n    let pre2 = 1;\n    let current = 2;\n\n    if (n <= 2) {\n        return current;\n    }\n\n    for (let i = 2; i < n; i++) {\n        pre1 = pre2;\n        pre2 = current;\n        current = pre1 + pre2;\n    }\n\n    return current;\n}\n\n\n\n# 12. 字符串出现的不重复最长长度\n\n用一个滑动窗口装没有重复的字符，枚举字符记录最大值即可。用 map 维护字符的索引，遇到相同的字符，把左边界移动过去即可。挪动的过程中记录最大长度：\n\nvar lengthoflongestsubstring = function (s) {\n    let map = new map();\n    let i = -1\n    let res = 0\n    let n = s.length\n    for (let j = 0; j < n; j++) {\n        if (map.has(s[j])) {\n            i = math.max(i, map.get(s[j]))\n        }\n        res = math.max(res, j - i)\n        map.set(s[j], j)\n    }\n    return res\n};\n\n\n\n# 13. 使用 settimeout 实现 setinterval\n\nsetinterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。\n\n针对 setinterval 的这个缺点，我们可以使用 settimeout 递归调用来模拟 setinterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setinterval 的问题。\n\n实现思路是使用递归函数，不断地去执行 settimeout 从而达到 setinterval 的效果\n\nfunction mysetinterval(fn, timeout) {\n  // 控制器，控制定时器是否继续执行\n  var timer = {\n    flag: true\n  };\n  // 设置递归函数，模拟定时器执行。\n  function interval() {\n    if (timer.flag) {\n      fn();\n      settimeout(interval, timeout);\n    }\n  }\n  // 启动定时器\n  settimeout(interval, timeout);\n  // 返回控制器\n  return timer;\n}\n\n\n\n# 14. 实现 jsonp\n\n// 动态的加载js文件\nfunction addscript(src) {\n  const script = document.createelement('script');\n  script.src = src;\n  script.type = \"text/javascript\";\n  document.body.appendchild(script);\n}\naddscript(\"http://xxx.xxx.com/xxx.js?callback=handleres\");\n// 设置一个全局的callback函数来接收回调结果\nfunction handleres(res) {\n  console.log(res);\n}\n// 接口返回的数据格式\nhandleres({a: 1, b: 2});\n\n\n\n# 15. 判断对象是否存在循环引用\n\n循环引用对象本来没有什么问题，但是序列化的时候就会发生问题，比如调用json.stringify()对该类对象进行序列化，就会报错: converting circular structure to json.\n\n下面方法可以用来判断一个对象中是否已存在循环引用：\n\nconst iscycleobject = (obj,parent) => {\n    const parentarr = parent || [obj];\n    for(let i in obj) {\n        if(typeof obj[i] === 'object') {\n            let flag = false;\n            parentarr.foreach((pobj) => {\n                if(pobj === obj[i]){\n                    flag = true;\n                }\n            })\n            if(flag) return true;\n            flag = iscycleobject(obj[i],[...parentarr,obj[i]]);\n            if(flag) return true;\n        }\n    }\n    return false;\n}\n\n\nconst a = 1;\nconst b = {a};\nconst c = {b};\nconst o = {d:{a:3},c}\no.c.b.aa = a;\n\nconsole.log(iscycleobject(o)\n\n\n查找有序二维数组的目标值：\n\nvar findnumberin2darray = function(matrix, target) {\n    if (matrix == null || matrix.length == 0) {\n        return false;\n    }\n    let row = 0;\n    let column = matrix[0].length - 1;\n    while (row < matrix.length && column >= 0) {\n        if (matrix[row][column] == target) {\n            return true;\n        } else if (matrix[row][column] > target) {\n            column--;\n        } else {\n            row++;\n        }\n    }\n    return false;\n};\n\n\n\n二维数组斜向打印：\n\nfunction printmatrix(arr){\n  let m = arr.length, n = arr[0].length\n\tlet res = []\n  \n  // 左上角，从0 到 n - 1 列进行打印\n  for (let k = 0; k < n; k++) {\n    for (let i = 0, j = k; i < m && j >= 0; i++, j--) {\n      res.push(arr[i][j]);\n    }\n  }\n\n  // 右下角，从1 到 n - 1 行进行打印\n  for (let k = 1; k < m; k++) {\n    for (let i = k, j = n - 1; i < m && j >= 0; i++, j--) {\n      res.push(arr[i][j]);\n    }\n  }\n  return res\n}\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "this",
      "frontmatter": {
        "title": "this",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/codeOutput/this/",
        "article": false
      },
      "regularPath": "/40.%E4%BB%A3%E7%A0%81%E7%AF%87/20.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E7%AF%87/20.this.html",
      "relativePath": "40.代码篇/20.代码输出结果篇/20.this.md",
      "key": "v-95e283c0",
      "path": "/pages/codeOutput/this/",
      "headers": [
        {
          "level": 3,
          "title": "1. 代码输出结果",
          "slug": "_1-代码输出结果",
          "normalizedTitle": "1. 代码输出结果",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 代码输出结果",
          "slug": "_2-代码输出结果",
          "normalizedTitle": "2. 代码输出结果",
          "charIndex": 260
        },
        {
          "level": 3,
          "title": "3. 代码输出结果",
          "slug": "_3-代码输出结果",
          "normalizedTitle": "3. 代码输出结果",
          "charIndex": 775
        },
        {
          "level": 3,
          "title": "4. 代码输出结果",
          "slug": "_4-代码输出结果",
          "normalizedTitle": "4. 代码输出结果",
          "charIndex": 1177
        },
        {
          "level": 3,
          "title": "6. 代码输出结果",
          "slug": "_6-代码输出结果",
          "normalizedTitle": "6. 代码输出结果",
          "charIndex": 1366
        },
        {
          "level": 3,
          "title": "7. 代码输出结果",
          "slug": "_7-代码输出结果",
          "normalizedTitle": "7. 代码输出结果",
          "charIndex": 1909
        },
        {
          "level": 3,
          "title": "8. 代码输出问题",
          "slug": "_8-代码输出问题",
          "normalizedTitle": "8. 代码输出问题",
          "charIndex": 2450
        },
        {
          "level": 3,
          "title": "9. 代码输出结果",
          "slug": "_9-代码输出结果",
          "normalizedTitle": "9. 代码输出结果",
          "charIndex": 2935
        },
        {
          "level": 3,
          "title": "10. 代码输出结果",
          "slug": "_10-代码输出结果",
          "normalizedTitle": "10. 代码输出结果",
          "charIndex": 3260
        },
        {
          "level": 3,
          "title": "11. 代码输出结果",
          "slug": "_11-代码输出结果",
          "normalizedTitle": "11. 代码输出结果",
          "charIndex": 3638
        },
        {
          "level": 3,
          "title": "12. 代码输出结果",
          "slug": "_12-代码输出结果",
          "normalizedTitle": "12. 代码输出结果",
          "charIndex": 4063
        },
        {
          "level": 3,
          "title": "13. 代码输出结果",
          "slug": "_13-代码输出结果",
          "normalizedTitle": "13. 代码输出结果",
          "charIndex": 4502
        },
        {
          "level": 3,
          "title": "14. 代码输出结果",
          "slug": "_14-代码输出结果",
          "normalizedTitle": "14. 代码输出结果",
          "charIndex": 4948
        },
        {
          "level": 3,
          "title": "15. 代码输出结果",
          "slug": "_15-代码输出结果",
          "normalizedTitle": "15. 代码输出结果",
          "charIndex": 5460
        }
      ],
      "headersStr": "1. 代码输出结果 2. 代码输出结果 3. 代码输出结果 4. 代码输出结果 6. 代码输出结果 7. 代码输出结果 8. 代码输出问题 9. 代码输出结果 10. 代码输出结果 11. 代码输出结果 12. 代码输出结果 13. 代码输出结果 14. 代码输出结果 15. 代码输出结果",
      "content": "# 1. 代码输出结果\n\nfunction foo() {\n  console.log( this.a );\n}\n\nfunction doFoo() {\n  foo();\n}\n\nvar obj = {\n  a: 1,\n  doFoo: doFoo\n};\n\nvar a = 2; \nobj.doFoo()\n\n\n输出结果：2\n\n在Javascript中，this指向函数执行时的当前对象。在执行foo的时候，执行环境就是doFoo函数，执行环境为全局。所以，foo中的this是指向window的，所以会打印出2。\n\n\n# 2. 代码输出结果\n\nvar a = 10\nvar obj = {\n  a: 20,\n  say: () => {\n    console.log(this.a)\n  }\n}\nobj.say() \n\nvar anotherObj = { a: 30 } \nobj.say.apply(anotherObj) \n\n\n输出结果：10 10\n\n我么知道，箭头函数时不绑定this的，它的this来自原其父级所处的上下文，所以首先会打印全局中的 a 的值10。后面虽然让say方法指向了另外一个对象，但是仍不能改变箭头函数的特性，它的this仍然是指向全局的，所以依旧会输出10。\n\n但是，如果是普通函数，那么就会有完全不一样的结果：\n\nvar a = 10  \nvar obj = {  \n  a: 20,  \n  say(){\n    console.log(this.a)  \n  }  \n}  \nobj.say()   \nvar anotherObj={a:30}   \nobj.say.apply(anotherObj)\n\n\n输出结果：20 30\n\n这时，say方法中的this就会指向他所在的对象，输出其中的a的值。\n\n\n# 3. 代码输出结果\n\nfunction a() {\n  console.log(this);\n}\na.call(null);\n\n\n打印结果：window对象\n\n根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管传入null 还是 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。\n\n要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined：\n\n'use strict';\n\nfunction a() {\n    console.log(this);\n}\na.call(null); // null\na.call(undefined); // undefined\n\n\n\n# 4. 代码输出结果\n\nvar obj = { \n  name : 'cuggz', \n  fun : function(){ \n    console.log(this.name); \n  } \n} \nobj.fun()     // cuggz\nnew obj.fun() // undefined\n\n\n使用new构造函数时，其this指向的是全局环境window。\n\n\n# 6. 代码输出结果\n\nvar obj = {\n   say: function() {\n     var f1 = () =>  {\n       console.log(\"1111\", this);\n     }\n     f1();\n   },\n   pro: {\n     getPro:() =>  {\n        console.log(this);\n     }\n   }\n}\nvar o = obj.say;\no();\nobj.say();\nobj.pro.getPro();\n\n\n输出结果：\n\n1111 window对象\n1111 obj对象\nwindow对象\n\n\n解析：\n\n 1. o()，o是在全局执行的，而f1是箭头函数，它是没有绑定this的，它的this指向其父级的this，其父级say方法的this指向的是全局作用域，所以会打印出window；\n 2. obj.say()，谁调用say，say 的this就指向谁，所以此时this指向的是obj对象；\n 3. obj.pro.getPro()，我们知道，箭头函数时不绑定this的，getPro处于pro中，而对象不构成单独的作用域，所以箭头的函数的this就指向了全局作用域window。\n\n\n# 7. 代码输出结果\n\nvar myObject = {\n    foo: \"bar\",\n    func: function() {\n        var self = this;\n        console.log(this.foo);  \n        console.log(self.foo);  \n        (function() {\n            console.log(this.foo);  \n            console.log(self.foo);  \n        }());\n    }\n};\nmyObject.func();\n\n\n输出结果：bar bar undefined bar\n\n解析：\n\n 1. 首先func是由myObject调用的，this指向myObject。又因为var self = this;所以self指向myObject。\n 2. 这个立即执行匿名函数表达式是由window调用的，this指向window 。立即执行匿名函数的作用域处于myObject.func的作用域中，在这个作用域找不到self变量，沿着作用域链向上查找self变量，找到了指向 myObject对象的self。\n\n\n# 8. 代码输出问题\n\nwindow.number = 2;\nvar obj = {\n number: 3,\n db1: (function(){\n   console.log(this);\n   this.number *= 4;\n   return function(){\n     console.log(this);\n     this.number *= 5;\n   }\n })()\n}\nvar db1 = obj.db1;\ndb1();\nobj.db1();\nconsole.log(obj.number);     // 15\nconsole.log(window.number);  // 40\n\n\n这道题目看清起来有点乱，但是实际上是考察this指向的:\n\n 1. 执行db1()时，this指向全局作用域，所以window.number * 4 = 8，然后执行匿名函数， 所以window.number * 5 = 40；\n 2. 执行obj.db1();时，this指向obj对象，执行匿名函数，所以obj.numer * 5 = 15。\n\n\n# 9. 代码输出结果\n\nvar length = 10;\nfunction fn() {\n    console.log(this.length);\n}\n \nvar obj = {\n  length: 5,\n  method: function(fn) {\n    fn();\n    arguments[0]();\n  }\n};\n \nobj.method(fn, 1);\n\n\n输出结果： 10 2\n\n解析：\n\n 1. 第一次执行fn()，this指向window对象，输出10。\n 2. 第二次执行arguments0，相当于arguments调用方法，this指向arguments，而这里传了两个参数，故输出arguments长度为2。\n\n\n# 10. 代码输出结果\n\nvar a = 1;\nfunction printA(){\n  console.log(this.a);\n}\nvar obj={\n  a:2,\n  foo:printA,\n  bar:function(){\n    printA();\n  }\n}\n\nobj.foo(); // 2\nobj.bar(); // 1\nvar foo = obj.foo;\nfoo(); // 1\n\n\n输出结果： 2 1 1\n\n解析：\n\n 1. obj.foo()，foo 的this指向obj对象，所以a会输出2；\n 2. obj.bar()，printA在bar方法中执行，所以此时printA的this指向的是window，所以会输出1；\n 3. foo()，foo是在全局对象中执行的，所以其this指向的是window，所以会输出1；\n\n\n# 11. 代码输出结果\n\nvar x = 3;\nvar y = 4;\nvar obj = {\n    x: 1,\n    y: 6,\n    getX: function() {\n        var x = 5;\n        return function() {\n            return this.x;\n        }();\n    },\n    getY: function() {\n        var y = 7;\n        return this.y;\n    }\n}\nconsole.log(obj.getX()) // 3\nconsole.log(obj.getY()) // 6\n\n\n输出结果：3 6\n\n解析：\n\n 1. 我们知道，匿名函数的this是指向全局对象的，所以this指向window，会打印出3；\n 2. getY是由obj调用的，所以其this指向的是obj对象，会打印出6。\n\n\n# 12. 代码输出结果\n\n var a = 10; \n var obt = { \n   a: 20, \n   fn: function(){ \n     var a = 30; \n     console.log(this.a)\n   } \n }\n obt.fn();  // 20\n obt.fn.call(); // 10\n (obt.fn)(); // 20\n\n\n输出结果： 20 10 20\n\n解析：\n\n 1. obt.fn()，fn是由obt调用的，所以其this指向obt对象，会打印出20；\n 2. obt.fn.call()，这里call的参数啥都没写，就表示null，我们知道如果call的参数为undefined或null，那么this就会指向全局对象this，所以会打印出 10；\n 3. (obt.fn)()， 这里给表达式加了括号，而括号的作用是改变表达式的运算顺序，而在这里加与不加括号并无影响；相当于 obt.fn()，所以会打印出 20；\n\n\n# 13. 代码输出结果\n\nfunction a(xx){\n  this.x = xx;\n  return this\n};\nvar x = a(5);\nvar y = a(6);\n\nconsole.log(x.x)  // undefined\nconsole.log(y.x)  // 6\n\n\n输出结果： undefined 6\n\n解析：\n\n 1. 最关键的就是var x = a(5)，函数a是在全局作用域调用，所以函数内部的this指向window对象。**所以 this.x = 5 就相当于：window.x = 5。**之后 return this，也就是说 var x = a(5) 中的x变量的值是window，这里的x将函数内部的x的值覆盖了。然后执行console.log(x.x)， 也就是console.log(window.x)，而window对象中没有x属性，所以会输出undefined。\n 2. 当指向y.x时，会给全局变量中的x赋值为6，所以会打印出6。\n\n\n# 14. 代码输出结果\n\nfunction foo(something){\n    this.a = something\n}\n\nvar obj1 = {\n    foo: foo\n}\n\nvar obj2 = {}\n\nobj1.foo(2); \nconsole.log(obj1.a); // 2\n\nobj1.foo.call(obj2, 3);\nconsole.log(obj2.a); // 3\n\nvar bar = new obj1.foo(4)\nconsole.log(obj1.a); // 2\nconsole.log(bar.a); // 4\n\n\n输出结果： 2 3 2 4\n\n解析：\n\n 1. 首先执行obj1.foo(2); 会在obj中添加a属性，其值为2。之后执行obj1.a，a是右obj1调用的，所以this指向obj，打印出2；\n 2. 执行 obj1.foo.call(obj2, 3) 时，会将foo的this指向obj2，后面就和上面一样了，所以会打印出3；\n 3. obj1.a会打印出2；\n 4. 最后就是考察this绑定的优先级了，new 绑定是比隐式绑定优先级高，所以会输出4。\n\n\n# 15. 代码输出结果\n\nfunction foo(something){\n    this.a = something\n}\n\nvar obj1 = {}\n\nvar bar = foo.bind(obj1);\nbar(2);\nconsole.log(obj1.a); // 2\n\nvar baz = new bar(3);\nconsole.log(obj1.a); // 2\nconsole.log(baz.a); // 3\n\n\n输出结果： 2 2 3\n\n这道题目和上面题目差不多，主要都是考察this绑定的优先级。记住以下结论即可：\n\nthis绑定的优先级：new绑定 > 显式绑定 > 隐式绑定 > 默认绑定。",
      "normalizedContent": "# 1. 代码输出结果\n\nfunction foo() {\n  console.log( this.a );\n}\n\nfunction dofoo() {\n  foo();\n}\n\nvar obj = {\n  a: 1,\n  dofoo: dofoo\n};\n\nvar a = 2; \nobj.dofoo()\n\n\n输出结果：2\n\n在javascript中，this指向函数执行时的当前对象。在执行foo的时候，执行环境就是dofoo函数，执行环境为全局。所以，foo中的this是指向window的，所以会打印出2。\n\n\n# 2. 代码输出结果\n\nvar a = 10\nvar obj = {\n  a: 20,\n  say: () => {\n    console.log(this.a)\n  }\n}\nobj.say() \n\nvar anotherobj = { a: 30 } \nobj.say.apply(anotherobj) \n\n\n输出结果：10 10\n\n我么知道，箭头函数时不绑定this的，它的this来自原其父级所处的上下文，所以首先会打印全局中的 a 的值10。后面虽然让say方法指向了另外一个对象，但是仍不能改变箭头函数的特性，它的this仍然是指向全局的，所以依旧会输出10。\n\n但是，如果是普通函数，那么就会有完全不一样的结果：\n\nvar a = 10  \nvar obj = {  \n  a: 20,  \n  say(){\n    console.log(this.a)  \n  }  \n}  \nobj.say()   \nvar anotherobj={a:30}   \nobj.say.apply(anotherobj)\n\n\n输出结果：20 30\n\n这时，say方法中的this就会指向他所在的对象，输出其中的a的值。\n\n\n# 3. 代码输出结果\n\nfunction a() {\n  console.log(this);\n}\na.call(null);\n\n\n打印结果：window对象\n\n根据ecmascript262规范规定：如果第一个参数传入的对象调用者是null或者undefined，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管传入null 还是 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。\n\n要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined：\n\n'use strict';\n\nfunction a() {\n    console.log(this);\n}\na.call(null); // null\na.call(undefined); // undefined\n\n\n\n# 4. 代码输出结果\n\nvar obj = { \n  name : 'cuggz', \n  fun : function(){ \n    console.log(this.name); \n  } \n} \nobj.fun()     // cuggz\nnew obj.fun() // undefined\n\n\n使用new构造函数时，其this指向的是全局环境window。\n\n\n# 6. 代码输出结果\n\nvar obj = {\n   say: function() {\n     var f1 = () =>  {\n       console.log(\"1111\", this);\n     }\n     f1();\n   },\n   pro: {\n     getpro:() =>  {\n        console.log(this);\n     }\n   }\n}\nvar o = obj.say;\no();\nobj.say();\nobj.pro.getpro();\n\n\n输出结果：\n\n1111 window对象\n1111 obj对象\nwindow对象\n\n\n解析：\n\n 1. o()，o是在全局执行的，而f1是箭头函数，它是没有绑定this的，它的this指向其父级的this，其父级say方法的this指向的是全局作用域，所以会打印出window；\n 2. obj.say()，谁调用say，say 的this就指向谁，所以此时this指向的是obj对象；\n 3. obj.pro.getpro()，我们知道，箭头函数时不绑定this的，getpro处于pro中，而对象不构成单独的作用域，所以箭头的函数的this就指向了全局作用域window。\n\n\n# 7. 代码输出结果\n\nvar myobject = {\n    foo: \"bar\",\n    func: function() {\n        var self = this;\n        console.log(this.foo);  \n        console.log(self.foo);  \n        (function() {\n            console.log(this.foo);  \n            console.log(self.foo);  \n        }());\n    }\n};\nmyobject.func();\n\n\n输出结果：bar bar undefined bar\n\n解析：\n\n 1. 首先func是由myobject调用的，this指向myobject。又因为var self = this;所以self指向myobject。\n 2. 这个立即执行匿名函数表达式是由window调用的，this指向window 。立即执行匿名函数的作用域处于myobject.func的作用域中，在这个作用域找不到self变量，沿着作用域链向上查找self变量，找到了指向 myobject对象的self。\n\n\n# 8. 代码输出问题\n\nwindow.number = 2;\nvar obj = {\n number: 3,\n db1: (function(){\n   console.log(this);\n   this.number *= 4;\n   return function(){\n     console.log(this);\n     this.number *= 5;\n   }\n })()\n}\nvar db1 = obj.db1;\ndb1();\nobj.db1();\nconsole.log(obj.number);     // 15\nconsole.log(window.number);  // 40\n\n\n这道题目看清起来有点乱，但是实际上是考察this指向的:\n\n 1. 执行db1()时，this指向全局作用域，所以window.number * 4 = 8，然后执行匿名函数， 所以window.number * 5 = 40；\n 2. 执行obj.db1();时，this指向obj对象，执行匿名函数，所以obj.numer * 5 = 15。\n\n\n# 9. 代码输出结果\n\nvar length = 10;\nfunction fn() {\n    console.log(this.length);\n}\n \nvar obj = {\n  length: 5,\n  method: function(fn) {\n    fn();\n    arguments[0]();\n  }\n};\n \nobj.method(fn, 1);\n\n\n输出结果： 10 2\n\n解析：\n\n 1. 第一次执行fn()，this指向window对象，输出10。\n 2. 第二次执行arguments0，相当于arguments调用方法，this指向arguments，而这里传了两个参数，故输出arguments长度为2。\n\n\n# 10. 代码输出结果\n\nvar a = 1;\nfunction printa(){\n  console.log(this.a);\n}\nvar obj={\n  a:2,\n  foo:printa,\n  bar:function(){\n    printa();\n  }\n}\n\nobj.foo(); // 2\nobj.bar(); // 1\nvar foo = obj.foo;\nfoo(); // 1\n\n\n输出结果： 2 1 1\n\n解析：\n\n 1. obj.foo()，foo 的this指向obj对象，所以a会输出2；\n 2. obj.bar()，printa在bar方法中执行，所以此时printa的this指向的是window，所以会输出1；\n 3. foo()，foo是在全局对象中执行的，所以其this指向的是window，所以会输出1；\n\n\n# 11. 代码输出结果\n\nvar x = 3;\nvar y = 4;\nvar obj = {\n    x: 1,\n    y: 6,\n    getx: function() {\n        var x = 5;\n        return function() {\n            return this.x;\n        }();\n    },\n    gety: function() {\n        var y = 7;\n        return this.y;\n    }\n}\nconsole.log(obj.getx()) // 3\nconsole.log(obj.gety()) // 6\n\n\n输出结果：3 6\n\n解析：\n\n 1. 我们知道，匿名函数的this是指向全局对象的，所以this指向window，会打印出3；\n 2. gety是由obj调用的，所以其this指向的是obj对象，会打印出6。\n\n\n# 12. 代码输出结果\n\n var a = 10; \n var obt = { \n   a: 20, \n   fn: function(){ \n     var a = 30; \n     console.log(this.a)\n   } \n }\n obt.fn();  // 20\n obt.fn.call(); // 10\n (obt.fn)(); // 20\n\n\n输出结果： 20 10 20\n\n解析：\n\n 1. obt.fn()，fn是由obt调用的，所以其this指向obt对象，会打印出20；\n 2. obt.fn.call()，这里call的参数啥都没写，就表示null，我们知道如果call的参数为undefined或null，那么this就会指向全局对象this，所以会打印出 10；\n 3. (obt.fn)()， 这里给表达式加了括号，而括号的作用是改变表达式的运算顺序，而在这里加与不加括号并无影响；相当于 obt.fn()，所以会打印出 20；\n\n\n# 13. 代码输出结果\n\nfunction a(xx){\n  this.x = xx;\n  return this\n};\nvar x = a(5);\nvar y = a(6);\n\nconsole.log(x.x)  // undefined\nconsole.log(y.x)  // 6\n\n\n输出结果： undefined 6\n\n解析：\n\n 1. 最关键的就是var x = a(5)，函数a是在全局作用域调用，所以函数内部的this指向window对象。**所以 this.x = 5 就相当于：window.x = 5。**之后 return this，也就是说 var x = a(5) 中的x变量的值是window，这里的x将函数内部的x的值覆盖了。然后执行console.log(x.x)， 也就是console.log(window.x)，而window对象中没有x属性，所以会输出undefined。\n 2. 当指向y.x时，会给全局变量中的x赋值为6，所以会打印出6。\n\n\n# 14. 代码输出结果\n\nfunction foo(something){\n    this.a = something\n}\n\nvar obj1 = {\n    foo: foo\n}\n\nvar obj2 = {}\n\nobj1.foo(2); \nconsole.log(obj1.a); // 2\n\nobj1.foo.call(obj2, 3);\nconsole.log(obj2.a); // 3\n\nvar bar = new obj1.foo(4)\nconsole.log(obj1.a); // 2\nconsole.log(bar.a); // 4\n\n\n输出结果： 2 3 2 4\n\n解析：\n\n 1. 首先执行obj1.foo(2); 会在obj中添加a属性，其值为2。之后执行obj1.a，a是右obj1调用的，所以this指向obj，打印出2；\n 2. 执行 obj1.foo.call(obj2, 3) 时，会将foo的this指向obj2，后面就和上面一样了，所以会打印出3；\n 3. obj1.a会打印出2；\n 4. 最后就是考察this绑定的优先级了，new 绑定是比隐式绑定优先级高，所以会输出4。\n\n\n# 15. 代码输出结果\n\nfunction foo(something){\n    this.a = something\n}\n\nvar obj1 = {}\n\nvar bar = foo.bind(obj1);\nbar(2);\nconsole.log(obj1.a); // 2\n\nvar baz = new bar(3);\nconsole.log(obj1.a); // 2\nconsole.log(baz.a); // 3\n\n\n输出结果： 2 2 3\n\n这道题目和上面题目差不多，主要都是考察this绑定的优先级。记住以下结论即可：\n\nthis绑定的优先级：new绑定 > 显式绑定 > 隐式绑定 > 默认绑定。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "异步&事件循环",
      "frontmatter": {
        "title": "异步&事件循环",
        "date": "2022-10-20T10:31:15.000Z",
        "permalink": "/pages/codeOutput/react/",
        "article": false
      },
      "regularPath": "/40.%E4%BB%A3%E7%A0%81%E7%AF%87/20.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E7%AF%87/10.%E5%BC%82%E6%AD%A5&%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html",
      "relativePath": "40.代码篇/20.代码输出结果篇/10.异步&事件循环.md",
      "key": "v-0d7ff816",
      "path": "/pages/codeOutput/react/",
      "headers": [
        {
          "level": 3,
          "title": "1. 代码输出结果",
          "slug": "_1-代码输出结果",
          "normalizedTitle": "1. 代码输出结果",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 代码输出结果",
          "slug": "_2-代码输出结果",
          "normalizedTitle": "2. 代码输出结果",
          "charIndex": 281
        },
        {
          "level": 3,
          "title": "3. 代码输出结果",
          "slug": "_3-代码输出结果",
          "normalizedTitle": "3. 代码输出结果",
          "charIndex": 977
        },
        {
          "level": 3,
          "title": "4. 代码输出结果",
          "slug": "_4-代码输出结果",
          "normalizedTitle": "4. 代码输出结果",
          "charIndex": 1655
        },
        {
          "level": 3,
          "title": "5. 代码输出结果",
          "slug": "_5-代码输出结果",
          "normalizedTitle": "5. 代码输出结果",
          "charIndex": 2396
        },
        {
          "level": 3,
          "title": "6. 代码输出结果",
          "slug": "_6-代码输出结果",
          "normalizedTitle": "6. 代码输出结果",
          "charIndex": 2779
        },
        {
          "level": 3,
          "title": "7. 代码输出结果",
          "slug": "_7-代码输出结果",
          "normalizedTitle": "7. 代码输出结果",
          "charIndex": 3122
        },
        {
          "level": 3,
          "title": "8. 代码输出结果",
          "slug": "_8-代码输出结果",
          "normalizedTitle": "8. 代码输出结果",
          "charIndex": 3684
        },
        {
          "level": 3,
          "title": "9. 代码输出结果",
          "slug": "_9-代码输出结果",
          "normalizedTitle": "9. 代码输出结果",
          "charIndex": 4106
        },
        {
          "level": 3,
          "title": "10. 代码输出结果",
          "slug": "_10-代码输出结果",
          "normalizedTitle": "10. 代码输出结果",
          "charIndex": 4462
        },
        {
          "level": 3,
          "title": "11. 代码输出结果",
          "slug": "_11-代码输出结果",
          "normalizedTitle": "11. 代码输出结果",
          "charIndex": 4719
        },
        {
          "level": 3,
          "title": "12. 代码输出结果",
          "slug": "_12-代码输出结果",
          "normalizedTitle": "12. 代码输出结果",
          "charIndex": 4976
        },
        {
          "level": 3,
          "title": "13. 代码输出结果",
          "slug": "_13-代码输出结果",
          "normalizedTitle": "13. 代码输出结果",
          "charIndex": 5662
        },
        {
          "level": 3,
          "title": "14. 代码输出结果",
          "slug": "_14-代码输出结果",
          "normalizedTitle": "14. 代码输出结果",
          "charIndex": 6546
        },
        {
          "level": 3,
          "title": "15. 代码输出结果",
          "slug": "_15-代码输出结果",
          "normalizedTitle": "15. 代码输出结果",
          "charIndex": 6959
        },
        {
          "level": 3,
          "title": "16. 代码输出结果",
          "slug": "_16-代码输出结果",
          "normalizedTitle": "16. 代码输出结果",
          "charIndex": 7537
        },
        {
          "level": 3,
          "title": "17. 代码输出结果",
          "slug": "_17-代码输出结果",
          "normalizedTitle": "17. 代码输出结果",
          "charIndex": 7875
        },
        {
          "level": 3,
          "title": "18. 代码输出结果",
          "slug": "_18-代码输出结果",
          "normalizedTitle": "18. 代码输出结果",
          "charIndex": 8475
        },
        {
          "level": 3,
          "title": "19. 代码输出结果",
          "slug": "_19-代码输出结果",
          "normalizedTitle": "19. 代码输出结果",
          "charIndex": 8978
        },
        {
          "level": 3,
          "title": "20. 代码输出结果",
          "slug": "_20-代码输出结果",
          "normalizedTitle": "20. 代码输出结果",
          "charIndex": 9705
        },
        {
          "level": 3,
          "title": "21. 代码输出结果",
          "slug": "_21-代码输出结果",
          "normalizedTitle": "21. 代码输出结果",
          "charIndex": 10152
        },
        {
          "level": 3,
          "title": "22. 代码输出结果",
          "slug": "_22-代码输出结果",
          "normalizedTitle": "22. 代码输出结果",
          "charIndex": 10632
        },
        {
          "level": 3,
          "title": "23. 代码输出结果",
          "slug": "_23-代码输出结果",
          "normalizedTitle": "23. 代码输出结果",
          "charIndex": 11555
        },
        {
          "level": 3,
          "title": "24. 代码输出结果",
          "slug": "_24-代码输出结果",
          "normalizedTitle": "24. 代码输出结果",
          "charIndex": 12240
        },
        {
          "level": 3,
          "title": "25. 代码输出结果",
          "slug": "_25-代码输出结果",
          "normalizedTitle": "25. 代码输出结果",
          "charIndex": 13154
        },
        {
          "level": 3,
          "title": "26. 代码输出结果",
          "slug": "_26-代码输出结果",
          "normalizedTitle": "26. 代码输出结果",
          "charIndex": 14061
        },
        {
          "level": 3,
          "title": "27. 代码输出结果",
          "slug": "_27-代码输出结果",
          "normalizedTitle": "27. 代码输出结果",
          "charIndex": 14669
        },
        {
          "level": 3,
          "title": "28. 代码输出结果",
          "slug": "_28-代码输出结果",
          "normalizedTitle": "28. 代码输出结果",
          "charIndex": 16652
        },
        {
          "level": 3,
          "title": "29. 代码输出结果",
          "slug": "_29-代码输出结果",
          "normalizedTitle": "29. 代码输出结果",
          "charIndex": 17386
        },
        {
          "level": 3,
          "title": "30. 代码输出结果",
          "slug": "_30-代码输出结果",
          "normalizedTitle": "30. 代码输出结果",
          "charIndex": 18072
        },
        {
          "level": 3,
          "title": "31. 代码输出结果",
          "slug": "_31-代码输出结果",
          "normalizedTitle": "31. 代码输出结果",
          "charIndex": 18482
        }
      ],
      "headersStr": "1. 代码输出结果 2. 代码输出结果 3. 代码输出结果 4. 代码输出结果 5. 代码输出结果 6. 代码输出结果 7. 代码输出结果 8. 代码输出结果 9. 代码输出结果 10. 代码输出结果 11. 代码输出结果 12. 代码输出结果 13. 代码输出结果 14. 代码输出结果 15. 代码输出结果 16. 代码输出结果 17. 代码输出结果 18. 代码输出结果 19. 代码输出结果 20. 代码输出结果 21. 代码输出结果 22. 代码输出结果 23. 代码输出结果 24. 代码输出结果 25. 代码输出结果 26. 代码输出结果 27. 代码输出结果 28. 代码输出结果 29. 代码输出结果 30. 代码输出结果 31. 代码输出结果",
      "content": "# 1. 代码输出结果\n\nconst promise = new Promise((resolve, reject) => {\n  console.log(1);\n  console.log(2);\n});\npromise.then(() => {\n  console.log(3);\n});\nconsole.log(4);\n\n\n输出结果如下：\n\n1 \n2 \n4\n\n\npromise.then 是微任务，它会在所有的宏任务执行完之后才会执行，同时需要promise内部的状态发生变化，因为这里内部没有发生变化，一直处于pending状态，所以不输出3。\n\n\n# 2. 代码输出结果\n\nconst promise1 = new Promise((resolve, reject) => {\n  console.log('promise1')\n  resolve('resolve1')\n})\nconst promise2 = promise1.then(res => {\n  console.log(res)\n})\nconsole.log('1', promise1);\nconsole.log('2', promise2);\n\n\n输出结果如下：\n\npromise1\n1 Promise{<resolved>: resolve1}\n2 Promise{<pending>}\nresolve1\n\n\n需要注意的是，直接打印promise1，会打印出它的状态值和参数。\n\n代码执行过程如下：\n\n 1. script是一个宏任务，按照顺序执行这些代码；\n 2. 首先进入Promise，执行该构造函数中的代码，打印promise1；\n 3. 碰到resolve函数, 将promise1的状态改变为resolved, 并将结果保存下来；\n 4. 碰到promise1.then这个微任务，将它放入微任务队列；\n 5. promise2是一个新的状态为pending的Promise；\n 6. 执行同步代码1， 同时打印出promise1的状态是resolved；\n 7. 执行同步代码2，同时打印出promise2的状态是pending；\n 8. 宏任务执行完毕，查找微任务队列，发现promise1.then这个微任务且状态为resolved，执行它。\n\n\n# 3. 代码输出结果\n\nconst promise = new Promise((resolve, reject) => {\n  console.log(1);\n  setTimeout(() => {\n    console.log(\"timerStart\");\n    resolve(\"success\");\n    console.log(\"timerEnd\");\n  }, 0);\n  console.log(2);\n});\npromise.then((res) => {\n  console.log(res);\n});\nconsole.log(4);\n\n\n输出结果如下：\n\n1\n2\n4\ntimerStart\ntimerEnd\nsuccess\n\n\n代码执行过程如下：\n\n * 首先遇到Promise构造函数，会先执行里面的内容，打印1；\n * 遇到定时器steTimeout，它是一个宏任务，放入宏任务队列；\n * 继续向下执行，打印出2；\n * 由于Promise的状态此时还是pending，所以promise.then先不执行；\n * 继续执行下面的同步任务，打印出4；\n * 此时微任务队列没有任务，继续执行下一轮宏任务，执行steTimeout；\n * 首先执行timerStart，然后遇到了resolve，将promise的状态改为resolved且保存结果并将之前的promise.then推入微任务队列，再执行timerEnd；\n * 执行完这个宏任务，就去执行微任务promise.then，打印出resolve的结果。\n\n\n# 4. 代码输出结果\n\nPromise.resolve().then(() => {\n  console.log('promise1');\n  const timer2 = setTimeout(() => {\n    console.log('timer2')\n  }, 0)\n});\nconst timer1 = setTimeout(() => {\n  console.log('timer1')\n  Promise.resolve().then(() => {\n    console.log('promise2')\n  })\n}, 0)\nconsole.log('start');\n\n\n输出结果如下：\n\nstart\npromise1\ntimer1\npromise2\ntimer2\n\n\n代码执行过程如下：\n\n 1. 首先，Promise.resolve().then是一个微任务，加入微任务队列\n 2. 执行timer1，它是一个宏任务，加入宏任务队列\n 3. 继续执行下面的同步代码，打印出start\n 4. 这样第一轮宏任务就执行完了，开始执行微任务Promise.resolve().then，打印出promise1\n 5. 遇到timer2，它是一个宏任务，将其加入宏任务队列，此时宏任务队列有两个任务，分别是timer1、timer2；\n 6. 这样第一轮微任务就执行完了，开始执行第二轮宏任务，首先执行定时器timer1，打印timer1；\n 7. 遇到Promise.resolve().then，它是一个微任务，加入微任务队列\n 8. 开始执行微任务队列中的任务，打印promise2；\n 9. 最后执行宏任务timer2定时器，打印出timer2；\n\n\n# 5. 代码输出结果\n\nconst promise = new Promise((resolve, reject) => {\n    resolve('success1');\n    reject('error');\n    resolve('success2');\n});\npromise.then((res) => {\n    console.log('then:', res);\n}).catch((err) => {\n    console.log('catch:', err);\n})\n\n\n输出结果如下：\n\nthen：success1\n\n\n这个题目考察的就是Promise的状态在发生变化之后，就不会再发生变化。开始状态由pending变为resolve，说明已经变为已完成状态，下面的两个状态的就不会再执行，同时下面的catch也不会捕获到错误。\n\n\n# 6. 代码输出结果\n\nPromise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n\n\n输出结果如下：\n\n1\nPromise {<fulfilled>: undefined}\n\n\nPromise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved，Promise.resolve方法的参数，会同时传给回调函数。\n\nthen方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null)，这就会导致前一个Promise的结果会传递下面。\n\n\n# 7. 代码输出结果\n\nconst promise1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('success')\n  }, 1000)\n})\nconst promise2 = promise1.then(() => {\n  throw new Error('error!!!')\n})\nconsole.log('promise1', promise1)\nconsole.log('promise2', promise2)\nsetTimeout(() => {\n  console.log('promise1', promise1)\n  console.log('promise2', promise2)\n}, 2000)\n\n\n输出结果如下：\n\npromise1 Promise {<pending>}\npromise2 Promise {<pending>}\n\nUncaught (in promise) Error: error!!!\npromise1 Promise {<fulfilled>: \"success\"}\npromise2 Promise {<rejected>: Error: error!!}\n\n\n\n# 8. 代码输出结果\n\nPromise.resolve(1)\n  .then(res => {\n    console.log(res);\n    return 2;\n  })\n  .catch(err => {\n    return 3;\n  })\n  .then(res => {\n    console.log(res);\n  });\n\n\n输出结果如下：\n\n1   \n2\n\n\nPromise是可以链式调用的，由于每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般任务的链式调用一样return this。\n\n上面的输出结果之所以依次打印出1和2，是因为resolve(1)之后走的是第一个then方法，并没有进catch里，所以第二个then中的res得到的实际上是第一个then的返回值。并且return 2会被包装成resolve(2)，被最后的then打印输出2。\n\n\n# 9. 代码输出结果\n\nPromise.resolve().then(() => {\n  return new Error('error!!!')\n}).then(res => {\n  console.log(\"then: \", res)\n}).catch(err => {\n  console.log(\"catch: \", err)\n})\n\n\n输出结果如下：\n\n\"then: \" \"Error: error!!!\"\n\n\n返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的return new Error('error!!!')也被包裹成了return Promise.resolve(new Error('error!!!'))，因此它会被then捕获而不是catch。\n\n\n# 10. 代码输出结果\n\nconst promise = Promise.resolve().then(() => {\n  return promise;\n})\npromise.catch(console.err)\n\n\n输出结果如下：\n\nUncaught (in promise) TypeError: Chaining cycle detected for promise #<Promise>\n\n\n这里其实是一个坑，.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。\n\n\n# 11. 代码输出结果\n\nPromise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n\n\n输出结果如下：\n\n1\n\n\n看到这个题目，好多的then，实际上只需要记住一个原则：.then 或.catch 的参数期望是函数，传入非函数则会发生值透传。\n\n第一个then和第二个then中传入的都不是函数，一个是数字，一个是对象，因此发生了透传，将resolve(1) 的值直接传到最后一个then里，直接打印出1。\n\n\n# 12. 代码输出结果\n\nPromise.reject('err!!!')\n  .then((res) => {\n    console.log('success', res)\n  }, (err) => {\n    console.log('error', err)\n  }).catch(err => {\n    console.log('catch', err)\n  })\n\n\n输出结果如下：\n\nerror err!!!\n\n\n我们知道，.then函数中的两个参数：\n\n * 第一个参数是用来处理Promise成功的函数\n * 第二个则是处理失败的函数\n\n也就是说Promise.resolve('1')的值会进入成功的函数，Promise.reject('2')的值会进入失败的函数。\n\n在这道题中，错误直接被then的第二个参数捕获了，所以就不会被catch捕获了，输出结果为：error err!!!'\n\n但是，如果是像下面这样：\n\nPromise.resolve()\n  .then(function success (res) {\n    throw new Error('error!!!')\n  }, function fail1 (err) {\n    console.log('fail1', err)\n  }).catch(function fail2 (err) {\n    console.log('fail2', err)\n  })\n\n\n在then的第一参数中抛出了错误，那么他就不会被第二个参数不活了，而是被后面的catch捕获到。\n\n\n# 13. 代码输出结果\n\nPromise.resolve('1')\n  .then(res => {\n    console.log(res)\n  })\n  .finally(() => {\n    console.log('finally')\n  })\nPromise.resolve('2')\n  .finally(() => {\n    console.log('finally2')\n  \treturn '我是finally2返回的值'\n  })\n  .then(res => {\n    console.log('finally2后面的then函数', res)\n  })\n\n\n输出结果如下：\n\n1\nfinally2\nfinally\nfinally2后面的then函数 2\n\n\n.finally()一般用的很少，只要记住以下几点就可以了：\n\n * .finally()方法不管Promise对象最后的状态如何都会执行\n * .finally()方法的回调函数不接受任何的参数，也就是说你在.finally()函数中是无法知道Promise最终的状态是resolved还是rejected的\n * 它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。\n * finally本质上是then方法的特例\n\n.finally()的错误捕获：\n\nPromise.resolve('1')\n  .finally(() => {\n    console.log('finally1')\n    throw new Error('我是finally中抛出的异常')\n  })\n  .then(res => {\n    console.log('finally后面的then函数', res)\n  })\n  .catch(err => {\n    console.log('捕获错误', err)\n  })\n\n\n输出结果为：\n\n'finally1'\n'捕获错误' Error: 我是finally中抛出的异常\n\n\n\n# 14. 代码输出结果\n\nfunction runAsync (x) {\n    const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))\n    return p\n}\n\nPromise.all([runAsync(1), runAsync(2), runAsync(3)]).then(res => console.log(res))\n\n\n输出结果如下：\n\n1\n2\n3\n[1, 2, 3]\n\n\n首先，定义了一个Promise，来异步执行函数runAsync，该函数传入一个值x，然后间隔一秒后打印出这个x。\n\n之后再使用Promise.all来执行这个函数，执行的时候，看到一秒之后输出了1，2，3，同时输出了数组[1, 2, 3]，三个函数是同步执行的，并且在一个回调函数中返回了所有的结果。并且结果和函数的执行顺序是一致的。\n\n\n# 15. 代码输出结果\n\nfunction runAsync (x) {\n  const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))\n  return p\n}\nfunction runReject (x) {\n  const p = new Promise((res, rej) => setTimeout(() => rej(`Error: ${x}`, console.log(x)), 1000 * x))\n  return p\n}\nPromise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])\n       .then(res => console.log(res))\n       .catch(err => console.log(err))\n\n\n输出结果如下：\n\n// 1s后输出\n1\n3\n// 2s后输出\n2\nError: 2\n// 4s后输出\n4\n\n\n可以看到。catch捕获到了第一个错误，在这道题目中最先的错误就是runReject(2)的结果。如果一组异步操作中有一个异常都不会进入.then()的第一个回调函数参数中。会被.then()的第二个回调函数捕获。\n\n\n# 16. 代码输出结果\n\nfunction runAsync (x) {\n  const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))\n  return p\n}\nPromise.race([runAsync(1), runAsync(2), runAsync(3)])\n  .then(res => console.log('result: ', res))\n  .catch(err => console.log(err))\n\n\n输出结果如下：\n\n1\n'result: ' 1\n2\n3\n\n\nthen只会捕获第一个成功的方法，其他的函数虽然还会继续执行，但是不是被then捕获了。\n\n\n# 17. 代码输出结果\n\nfunction runAsync(x) {\n  const p = new Promise(r =>\n    setTimeout(() => r(x, console.log(x)), 1000)\n  );\n  return p;\n}\nfunction runReject(x) {\n  const p = new Promise((res, rej) =>\n    setTimeout(() => rej(`Error: ${x}`, console.log(x)), 1000 * x)\n  );\n  return p;\n}\nPromise.race([runReject(0), runAsync(1), runAsync(2), runAsync(3)])\n  .then(res => console.log(\"result: \", res))\n  .catch(err => console.log(err));\n\n\n输出结果如下：\n\n0\nError: 0\n1\n2\n3\n\n\n可以看到在catch捕获到第一个错误之后，后面的代码还不执行，不过不会再被捕获了。\n\n注意：all和race传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。\n\n\n# 18. 代码输出结果\n\nasync function async1() {\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n}\nasync function async2() {\n  console.log(\"async2\");\n}\nasync1();\nconsole.log('start')\n\n\n输出结果如下：\n\nasync1 start\nasync2\nstart\nasync1 end\n\n\n代码的执行过程如下：\n\n 1. 首先执行函数中的同步代码async1 start，之后遇到了await，它会阻塞async1后面代码的执行，因此会先去执行async2中的同步代码async2，然后跳出async1；\n 2. 跳出async1函数后，执行同步代码start；\n 3. 在一轮宏任务全部执行完之后，再来执行await后面的内容async1 end。\n\n这里可以理解为await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中。\n\n\n# 19. 代码输出结果\n\nasync function async1() {\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n  setTimeout(() => {\n    console.log('timer1')\n  }, 0)\n}\nasync function async2() {\n  setTimeout(() => {\n    console.log('timer2')\n  }, 0)\n  console.log(\"async2\");\n}\nasync1();\nsetTimeout(() => {\n  console.log('timer3')\n}, 0)\nconsole.log(\"start\")\n\n\n输出结果如下：\n\nasync1 start\nasync2\nstart\nasync1 end\ntimer2\ntimer3\ntimer1\n\n\n代码的执行过程如下：\n\n 1. 首先进入async1，打印出async1 start；\n 2. 之后遇到async2，进入async2，遇到定时器timer2，加入宏任务队列，之后打印async2；\n 3. 由于async2阻塞了后面代码的执行，所以执行后面的定时器timer3，将其加入宏任务队列，之后打印start；\n 4. 然后执行async2后面的代码，打印出async1 end，遇到定时器timer1，将其加入宏任务队列；\n 5. 最后，宏任务队列有三个任务，先后顺序为timer2，timer3，timer1，没有微任务，所以直接所有的宏任务按照先进先出的原则执行。\n\n\n# 20. 代码输出结果\n\nasync function async1 () {\n  console.log('async1 start');\n  await new Promise(resolve => {\n    console.log('promise1')\n  })\n  console.log('async1 success');\n  return 'async1 end'\n}\nconsole.log('srcipt start')\nasync1().then(res => console.log(res))\nconsole.log('srcipt end')\n\n\n输出结果如下：\n\nscript start\nasync1 start\npromise1\nscript end\n\n\n这里需要注意的是在async1中await后面的Promise是没有返回值的，也就是它的状态始终是pending状态，所以在await之后的内容是不会执行的，包括async1后面的 .then。\n\n\n# 21. 代码输出结果\n\nasync function async1 () {\n  console.log('async1 start');\n  await new Promise(resolve => {\n    console.log('promise1')\n    resolve('promise1 resolve')\n  }).then(res => console.log(res))\n  console.log('async1 success');\n  return 'async1 end'\n}\nconsole.log('srcipt start')\nasync1().then(res => console.log(res))\nconsole.log('srcipt end')\n\n\n这里是对上面一题进行了改造，加上了resolve。\n\n输出结果如下：\n\nscript start\nasync1 start\npromise1\nscript end\npromise1 resolve\nasync1 success\nasync1 end\n\n\n\n# 22. 代码输出结果\n\nasync function async1() {\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n}\n\nasync function async2() {\n  console.log(\"async2\");\n}\n\nconsole.log(\"script start\");\n\nsetTimeout(function() {\n  console.log(\"setTimeout\");\n}, 0);\n\nasync1();\n\nnew Promise(resolve => {\n  console.log(\"promise1\");\n  resolve();\n}).then(function() {\n  console.log(\"promise2\");\n});\nconsole.log('script end')\n\n\n输出结果如下：\n\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n\n\n代码执行过程如下：\n\n 1. 开头定义了async1和async2两个函数，但是并未执行，执行script中的代码，所以打印出script start；\n 2. 遇到定时器Settimeout，它是一个宏任务，将其加入到宏任务队列；\n 3. 之后执行函数async1，首先打印出async1 start；\n 4. 遇到await，执行async2，打印出async2，并阻断后面代码的执行，将后面的代码加入到微任务队列；\n 5. 然后跳出async1和async2，遇到Promise，打印出promise1；\n 6. 遇到resolve，将其加入到微任务队列，然后执行后面的script代码，打印出script end；\n 7. 之后就该执行微任务队列了，首先打印出async1 end，然后打印出promise2；\n 8. 执行完微任务队列，就开始执行宏任务队列中的定时器，打印出setTimeout。\n\n\n# 23. 代码输出结果\n\nasync function async1 () {\n  await async2();\n  console.log('async1');\n  return 'async1 success'\n}\nasync function async2 () {\n  return new Promise((resolve, reject) => {\n    console.log('async2')\n    reject('error')\n  })\n}\nasync1().then(res => console.log(res))\n\n\n输出结果如下：\n\nasync2\nUncaught (in promise) error\n\n\n可以看到，如果async函数中抛出了错误，就会终止错误结果，不会继续向下执行。\n\n如果想要让错误不足之处后面的代码执行，可以使用catch来捕获：\n\nasync function async1 () {\n  await Promise.reject('error!!!').catch(e => console.log(e))\n  console.log('async1');\n  return Promise.resolve('async1 success')\n}\nasync1().then(res => console.log(res))\nconsole.log('script start')\n\n\n这样的输出结果就是：\n\nscript start\nerror!!!\nasync1\nasync1 success\n\n\n\n# 24. 代码输出结果\n\nconst first = () => (new Promise((resolve, reject) => {\n    console.log(3);\n    let p = new Promise((resolve, reject) => {\n        console.log(7);\n        setTimeout(() => {\n            console.log(5);\n            resolve(6);\n            console.log(p)\n        }, 0)\n        resolve(1);\n    });\n    resolve(2);\n    p.then((arg) => {\n        console.log(arg);\n    });\n}));\nfirst().then((arg) => {\n    console.log(arg);\n});\nconsole.log(4);\n\n\n输出结果如下：\n\n3\n7\n4\n1\n2\n5\nPromise{<resolved>: 1}\n\n\n代码的执行过程如下：\n\n 1. 首先会进入Promise，打印出3，之后进入下面的Promise，打印出7；\n 2. 遇到了定时器，将其加入宏任务队列；\n 3. 执行Promise p中的resolve，状态变为resolved，返回值为1；\n 4. 执行Promise first中的resolve，状态变为resolved，返回值为2；\n 5. 遇到p.then，将其加入微任务队列，遇到first().then，将其加入任务队列；\n 6. 执行外面的代码，打印出4；\n 7. 这样第一轮宏任务就执行完了，开始执行微任务队列中的任务，先后打印出1和2；\n 8. 这样微任务就执行完了，开始执行下一轮宏任务，宏任务队列中有一个定时器，执行它，打印出5，由于执行已经变为resolved状态，所以resolve(6)不会再执行；\n 9. 最后console.log(p)打印出Promise{<resolved>: 1}；\n\n\n# 25. 代码输出结果\n\nconst async1 = async () => {\n  console.log('async1');\n  setTimeout(() => {\n    console.log('timer1')\n  }, 2000)\n  await new Promise(resolve => {\n    console.log('promise1')\n  })\n  console.log('async1 end')\n  return 'async1 success'\n} \nconsole.log('script start');\nasync1().then(res => console.log(res));\nconsole.log('script end');\nPromise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .catch(4)\n  .then(res => console.log(res))\nsetTimeout(() => {\n  console.log('timer2')\n}, 1000)\n\n\n输出结果如下：\n\nscript start\nasync1\npromise1\nscript end\n1\ntimer2\ntimer1\n\n\n代码的执行过程如下：\n\n 1. 首先执行同步带吗，打印出script start；\n 2. 遇到定时器timer1将其加入宏任务队列；\n 3. 之后是执行Promise，打印出promise1，由于Promise没有返回值，所以后面的代码不会执行；\n 4. 然后执行同步代码，打印出script end；\n 5. 继续执行下面的Promise，.then和.catch期望参数是一个函数，这里传入的是一个数字，因此就会发生值渗透，将resolve(1)的值传到最后一个then，直接打印出1；\n 6. 遇到第二个定时器，将其加入到微任务队列，执行微任务队列，按顺序依次执行两个定时器，但是由于定时器时间的原因，会在两秒后先打印出timer2，在四秒后打印出timer1。\n\n\n# 26. 代码输出结果\n\nconst p1 = new Promise((resolve) => {\n  setTimeout(() => {\n    resolve('resolve3');\n    console.log('timer1')\n  }, 0)\n  resolve('resovle1');\n  resolve('resolve2');\n}).then(res => {\n  console.log(res)  // resolve1\n  setTimeout(() => {\n    console.log(p1)\n  }, 1000)\n}).finally(res => {\n  console.log('finally', res)\n})\n\n\n执行结果为如下：\n\nresolve1\nfinally  undefined\ntimer1\nPromise{<resolved>: undefined}\n\n\n需要注意的是最后一个定时器打印出的p1其实是.finally的返回值，我们知道.finally的返回值如果在没有抛出错误的情况下默认会是上一个Promise的返回值，而这道题中.finally上一个Promise是.then()，但是这个.then()并没有返回值，所以p1打印出来的Promise的值会是undefined，如果在定时器的下面加上一个return 1，则值就会变成1。\n\n\n# 27. 代码输出结果\n\nconsole.log('1');\n\nsetTimeout(function() {\n    console.log('2');\n    process.nextTick(function() {\n        console.log('3');\n    })\n    new Promise(function(resolve) {\n        console.log('4');\n        resolve();\n    }).then(function() {\n        console.log('5')\n    })\n})\nprocess.nextTick(function() {\n    console.log('6');\n})\nnew Promise(function(resolve) {\n    console.log('7');\n    resolve();\n}).then(function() {\n    console.log('8')\n})\n\nsetTimeout(function() {\n    console.log('9');\n    process.nextTick(function() {\n        console.log('10');\n    })\n    new Promise(function(resolve) {\n        console.log('11');\n        resolve();\n    }).then(function() {\n        console.log('12')\n    })\n})\n\n\n输出结果如下：\n\n1\n7\n6\n8\n2\n4\n3\n5\n9\n11\n10\n12\n\n\n（1）第一轮事件循环流程分析如下：\n\n * 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。\n * 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。暂且记为setTimeout1。\n * 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。记为process1。\n * 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。记为then1。\n * 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，记为setTimeout2。\n\n宏任务EVENT QUEUE   微任务EVENT QUEUE\nsetTimeout1      process1\nsetTimeout2      then1\n\n上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。发现了process1和then1两个微任务：\n\n * 执行process1，输出6。\n * 执行then1，输出8。\n\n第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。\n\n（2）第二轮时间循环从**setTimeout1**宏任务开始：\n\n * 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。\n * new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。\n\n宏任务EVENT QUEUE   微任务EVENT QUEUE\nsetTimeout2      process2\n                 then2\n\n第二轮事件循环宏任务结束，发现有process2和then2两个微任务可以执行：\n\n * 输出3。\n * 输出5。\n\n第二轮事件循环结束，第二轮输出2，4，3，5。\n\n（3）第三轮事件循环开始，此时只剩setTimeout2了，执行。\n\n * 直接输出9。\n * 将process.nextTick()分发到微任务Event Queue中。记为process3。\n * 直接执行new Promise，输出11。\n * 将then分发到微任务Event Queue中，记为then3。\n\n宏任务EVENT QUEUE   微任务EVENT QUEUE\n                 process3\n                 then3\n\n第三轮事件循环宏任务执行结束，执行两个微任务process3和then3：\n\n * 输出10。\n * 输出12。\n\n第三轮事件循环结束，第三轮输出9，11，10，12。\n\n整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。\n\n\n# 28. 代码输出结果\n\nconsole.log(1)\n\nsetTimeout(() => {\n  console.log(2)\n})\n\nnew Promise(resolve =>  {\n  console.log(3)\n  resolve(4)\n}).then(d => console.log(d))\n\nsetTimeout(() => {\n  console.log(5)\n  new Promise(resolve =>  {\n    resolve(6)\n  }).then(d => console.log(d))\n})\n\nsetTimeout(() => {\n  console.log(7)\n})\n\nconsole.log(8)\n\n\n输出结果如下：\n\n1\n3\n8\n4\n2\n5\n6\n7\n\n\n代码执行过程如下：\n\n 1.  首先执行script代码，打印出1；\n 2.  遇到第一个定时器，加入到宏任务队列；\n 3.  遇到Promise，执行代码，打印出3，遇到resolve，将其加入到微任务队列；\n 4.  遇到第二个定时器，加入到宏任务队列；\n 5.  遇到第三个定时器，加入到宏任务队列；\n 6.  继续执行script代码，打印出8，第一轮执行结束；\n 7.  执行微任务队列，打印出第一个Promise的resolve结果：4；\n 8.  开始执行宏任务队列，执行第一个定时器，打印出2；\n 9.  此时没有微任务，继续执行宏任务中的第二个定时器，首先打印出5，遇到Promise，首选打印出6，遇到resolve，将其加入到微任务队列；\n 10. 执行微任务队列，打印出6；\n 11. 执行宏任务队列中的最后一个定时器，打印出7。\n\n\n# 29. 代码输出结果\n\nconsole.log(1);\n    \nsetTimeout(() => {\n  console.log(2);\n  Promise.resolve().then(() => {\n    console.log(3)\n  });\n});\n\nnew Promise((resolve, reject) => {\n  console.log(4)\n  resolve(5)\n}).then((data) => {\n  console.log(data);\n})\n\nsetTimeout(() => {\n  console.log(6);\n})\n\nconsole.log(7);\n\n\n代码输出结果如下：\n\n1\n4\n7\n5\n2\n3\n6\n\n\n代码执行过程如下：\n\n 1. 首先执行scrip代码，打印出1；\n 2. 遇到第一个定时器setTimeout，将其加入到宏任务队列；\n 3. 遇到Promise，执行里面的同步代码，打印出4，遇到resolve，将其加入到微任务队列；\n 4. 遇到第二个定时器setTimeout，将其加入到红任务队列；\n 5. 执行script代码，打印出7，至此第一轮执行完成；\n 6. 指定微任务队列中的代码，打印出resolve的结果：5；\n 7. 执行宏任务中的第一个定时器setTimeout，首先打印出2，然后遇到 Promise.resolve().then()，将其加入到微任务队列；\n 8. 执行完这个宏任务，就开始执行微任务队列，打印出3；\n 9. 继续执行宏任务队列中的第二个定时器，打印出6。\n\n\n# 30. 代码输出结果\n\nPromise.resolve().then(() => {\n    console.log('1');\n    throw 'Error';\n}).then(() => {\n    console.log('2');\n}).catch(() => {\n    console.log('3');\n    throw 'Error';\n}).then(() => {\n    console.log('4');\n}).catch(() => {\n    console.log('5');\n}).then(() => {\n    console.log('6');\n});\n\n\n执行结果如下：\n\n1 \n3 \n5 \n6\n\n\n在这道题目中，我们需要知道，无论是thne还是catch中，只要throw 抛出了错误，就会被catch捕获，如果没有throw出错误，就被继续执行后面的then。\n\n\n# 31. 代码输出结果\n\nsetTimeout(function () {\n  console.log(1);\n}, 100);\n\nnew Promise(function (resolve) {\n  console.log(2);\n  resolve();\n  console.log(3);\n}).then(function () {\n  console.log(4);\n  new Promise((resove, reject) => {\n    console.log(5);\n    setTimeout(() =>  {\n      console.log(6);\n    }, 10);\n  })\n});\nconsole.log(7);\nconsole.log(8);\n\n\n输出结果为：\n\n2\n3\n7\n8\n4\n5\n6\n1\n\n\n代码执行过程如下：\n\n 1. 首先遇到定时器，将其加入到宏任务队列；\n 2. 遇到Promise，首先执行里面的同步代码，打印出2，遇到resolve，将其加入到微任务队列，执行后面同步代码，打印出3；\n 3. 继续执行script中的代码，打印出7和8，至此第一轮代码执行完成；\n 4. 执行微任务队列中的代码，首先打印出4，如遇到Promise，执行其中的同步代码，打印出5，遇到定时器，将其加入到宏任务队列中，此时宏任务队列中有两个定时器；\n 5. 执行宏任务队列中的代码，这里我们需要注意是的第一个定时器的时间为100ms，第二个定时器的时间为10ms，所以先执行第二个定时器，打印出6；\n 6. 此时微任务队列为空，继续执行宏任务队列，打印出1。\n\n做完这道题目，我们就需要格外注意，每个定时器的时间，并不是所有定时器的时间都为0哦。",
      "normalizedContent": "# 1. 代码输出结果\n\nconst promise = new promise((resolve, reject) => {\n  console.log(1);\n  console.log(2);\n});\npromise.then(() => {\n  console.log(3);\n});\nconsole.log(4);\n\n\n输出结果如下：\n\n1 \n2 \n4\n\n\npromise.then 是微任务，它会在所有的宏任务执行完之后才会执行，同时需要promise内部的状态发生变化，因为这里内部没有发生变化，一直处于pending状态，所以不输出3。\n\n\n# 2. 代码输出结果\n\nconst promise1 = new promise((resolve, reject) => {\n  console.log('promise1')\n  resolve('resolve1')\n})\nconst promise2 = promise1.then(res => {\n  console.log(res)\n})\nconsole.log('1', promise1);\nconsole.log('2', promise2);\n\n\n输出结果如下：\n\npromise1\n1 promise{<resolved>: resolve1}\n2 promise{<pending>}\nresolve1\n\n\n需要注意的是，直接打印promise1，会打印出它的状态值和参数。\n\n代码执行过程如下：\n\n 1. script是一个宏任务，按照顺序执行这些代码；\n 2. 首先进入promise，执行该构造函数中的代码，打印promise1；\n 3. 碰到resolve函数, 将promise1的状态改变为resolved, 并将结果保存下来；\n 4. 碰到promise1.then这个微任务，将它放入微任务队列；\n 5. promise2是一个新的状态为pending的promise；\n 6. 执行同步代码1， 同时打印出promise1的状态是resolved；\n 7. 执行同步代码2，同时打印出promise2的状态是pending；\n 8. 宏任务执行完毕，查找微任务队列，发现promise1.then这个微任务且状态为resolved，执行它。\n\n\n# 3. 代码输出结果\n\nconst promise = new promise((resolve, reject) => {\n  console.log(1);\n  settimeout(() => {\n    console.log(\"timerstart\");\n    resolve(\"success\");\n    console.log(\"timerend\");\n  }, 0);\n  console.log(2);\n});\npromise.then((res) => {\n  console.log(res);\n});\nconsole.log(4);\n\n\n输出结果如下：\n\n1\n2\n4\ntimerstart\ntimerend\nsuccess\n\n\n代码执行过程如下：\n\n * 首先遇到promise构造函数，会先执行里面的内容，打印1；\n * 遇到定时器stetimeout，它是一个宏任务，放入宏任务队列；\n * 继续向下执行，打印出2；\n * 由于promise的状态此时还是pending，所以promise.then先不执行；\n * 继续执行下面的同步任务，打印出4；\n * 此时微任务队列没有任务，继续执行下一轮宏任务，执行stetimeout；\n * 首先执行timerstart，然后遇到了resolve，将promise的状态改为resolved且保存结果并将之前的promise.then推入微任务队列，再执行timerend；\n * 执行完这个宏任务，就去执行微任务promise.then，打印出resolve的结果。\n\n\n# 4. 代码输出结果\n\npromise.resolve().then(() => {\n  console.log('promise1');\n  const timer2 = settimeout(() => {\n    console.log('timer2')\n  }, 0)\n});\nconst timer1 = settimeout(() => {\n  console.log('timer1')\n  promise.resolve().then(() => {\n    console.log('promise2')\n  })\n}, 0)\nconsole.log('start');\n\n\n输出结果如下：\n\nstart\npromise1\ntimer1\npromise2\ntimer2\n\n\n代码执行过程如下：\n\n 1. 首先，promise.resolve().then是一个微任务，加入微任务队列\n 2. 执行timer1，它是一个宏任务，加入宏任务队列\n 3. 继续执行下面的同步代码，打印出start\n 4. 这样第一轮宏任务就执行完了，开始执行微任务promise.resolve().then，打印出promise1\n 5. 遇到timer2，它是一个宏任务，将其加入宏任务队列，此时宏任务队列有两个任务，分别是timer1、timer2；\n 6. 这样第一轮微任务就执行完了，开始执行第二轮宏任务，首先执行定时器timer1，打印timer1；\n 7. 遇到promise.resolve().then，它是一个微任务，加入微任务队列\n 8. 开始执行微任务队列中的任务，打印promise2；\n 9. 最后执行宏任务timer2定时器，打印出timer2；\n\n\n# 5. 代码输出结果\n\nconst promise = new promise((resolve, reject) => {\n    resolve('success1');\n    reject('error');\n    resolve('success2');\n});\npromise.then((res) => {\n    console.log('then:', res);\n}).catch((err) => {\n    console.log('catch:', err);\n})\n\n\n输出结果如下：\n\nthen：success1\n\n\n这个题目考察的就是promise的状态在发生变化之后，就不会再发生变化。开始状态由pending变为resolve，说明已经变为已完成状态，下面的两个状态的就不会再执行，同时下面的catch也不会捕获到错误。\n\n\n# 6. 代码输出结果\n\npromise.resolve(1)\n  .then(2)\n  .then(promise.resolve(3))\n  .then(console.log)\n\n\n输出结果如下：\n\n1\npromise {<fulfilled>: undefined}\n\n\npromise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，则promise.resolve方法返回一个新的promise对象，状态为resolved，promise.resolve方法的参数，会同时传给回调函数。\n\nthen方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null)，这就会导致前一个promise的结果会传递下面。\n\n\n# 7. 代码输出结果\n\nconst promise1 = new promise((resolve, reject) => {\n  settimeout(() => {\n    resolve('success')\n  }, 1000)\n})\nconst promise2 = promise1.then(() => {\n  throw new error('error!!!')\n})\nconsole.log('promise1', promise1)\nconsole.log('promise2', promise2)\nsettimeout(() => {\n  console.log('promise1', promise1)\n  console.log('promise2', promise2)\n}, 2000)\n\n\n输出结果如下：\n\npromise1 promise {<pending>}\npromise2 promise {<pending>}\n\nuncaught (in promise) error: error!!!\npromise1 promise {<fulfilled>: \"success\"}\npromise2 promise {<rejected>: error: error!!}\n\n\n\n# 8. 代码输出结果\n\npromise.resolve(1)\n  .then(res => {\n    console.log(res);\n    return 2;\n  })\n  .catch(err => {\n    return 3;\n  })\n  .then(res => {\n    console.log(res);\n  });\n\n\n输出结果如下：\n\n1   \n2\n\n\npromise是可以链式调用的，由于每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般任务的链式调用一样return this。\n\n上面的输出结果之所以依次打印出1和2，是因为resolve(1)之后走的是第一个then方法，并没有进catch里，所以第二个then中的res得到的实际上是第一个then的返回值。并且return 2会被包装成resolve(2)，被最后的then打印输出2。\n\n\n# 9. 代码输出结果\n\npromise.resolve().then(() => {\n  return new error('error!!!')\n}).then(res => {\n  console.log(\"then: \", res)\n}).catch(err => {\n  console.log(\"catch: \", err)\n})\n\n\n输出结果如下：\n\n\"then: \" \"error: error!!!\"\n\n\n返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的return new error('error!!!')也被包裹成了return promise.resolve(new error('error!!!'))，因此它会被then捕获而不是catch。\n\n\n# 10. 代码输出结果\n\nconst promise = promise.resolve().then(() => {\n  return promise;\n})\npromise.catch(console.err)\n\n\n输出结果如下：\n\nuncaught (in promise) typeerror: chaining cycle detected for promise #<promise>\n\n\n这里其实是一个坑，.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。\n\n\n# 11. 代码输出结果\n\npromise.resolve(1)\n  .then(2)\n  .then(promise.resolve(3))\n  .then(console.log)\n\n\n输出结果如下：\n\n1\n\n\n看到这个题目，好多的then，实际上只需要记住一个原则：.then 或.catch 的参数期望是函数，传入非函数则会发生值透传。\n\n第一个then和第二个then中传入的都不是函数，一个是数字，一个是对象，因此发生了透传，将resolve(1) 的值直接传到最后一个then里，直接打印出1。\n\n\n# 12. 代码输出结果\n\npromise.reject('err!!!')\n  .then((res) => {\n    console.log('success', res)\n  }, (err) => {\n    console.log('error', err)\n  }).catch(err => {\n    console.log('catch', err)\n  })\n\n\n输出结果如下：\n\nerror err!!!\n\n\n我们知道，.then函数中的两个参数：\n\n * 第一个参数是用来处理promise成功的函数\n * 第二个则是处理失败的函数\n\n也就是说promise.resolve('1')的值会进入成功的函数，promise.reject('2')的值会进入失败的函数。\n\n在这道题中，错误直接被then的第二个参数捕获了，所以就不会被catch捕获了，输出结果为：error err!!!'\n\n但是，如果是像下面这样：\n\npromise.resolve()\n  .then(function success (res) {\n    throw new error('error!!!')\n  }, function fail1 (err) {\n    console.log('fail1', err)\n  }).catch(function fail2 (err) {\n    console.log('fail2', err)\n  })\n\n\n在then的第一参数中抛出了错误，那么他就不会被第二个参数不活了，而是被后面的catch捕获到。\n\n\n# 13. 代码输出结果\n\npromise.resolve('1')\n  .then(res => {\n    console.log(res)\n  })\n  .finally(() => {\n    console.log('finally')\n  })\npromise.resolve('2')\n  .finally(() => {\n    console.log('finally2')\n  \treturn '我是finally2返回的值'\n  })\n  .then(res => {\n    console.log('finally2后面的then函数', res)\n  })\n\n\n输出结果如下：\n\n1\nfinally2\nfinally\nfinally2后面的then函数 2\n\n\n.finally()一般用的很少，只要记住以下几点就可以了：\n\n * .finally()方法不管promise对象最后的状态如何都会执行\n * .finally()方法的回调函数不接受任何的参数，也就是说你在.finally()函数中是无法知道promise最终的状态是resolved还是rejected的\n * 它最终返回的默认会是一个上一次的promise对象值，不过如果抛出的是一个异常则返回异常的promise对象。\n * finally本质上是then方法的特例\n\n.finally()的错误捕获：\n\npromise.resolve('1')\n  .finally(() => {\n    console.log('finally1')\n    throw new error('我是finally中抛出的异常')\n  })\n  .then(res => {\n    console.log('finally后面的then函数', res)\n  })\n  .catch(err => {\n    console.log('捕获错误', err)\n  })\n\n\n输出结果为：\n\n'finally1'\n'捕获错误' error: 我是finally中抛出的异常\n\n\n\n# 14. 代码输出结果\n\nfunction runasync (x) {\n    const p = new promise(r => settimeout(() => r(x, console.log(x)), 1000))\n    return p\n}\n\npromise.all([runasync(1), runasync(2), runasync(3)]).then(res => console.log(res))\n\n\n输出结果如下：\n\n1\n2\n3\n[1, 2, 3]\n\n\n首先，定义了一个promise，来异步执行函数runasync，该函数传入一个值x，然后间隔一秒后打印出这个x。\n\n之后再使用promise.all来执行这个函数，执行的时候，看到一秒之后输出了1，2，3，同时输出了数组[1, 2, 3]，三个函数是同步执行的，并且在一个回调函数中返回了所有的结果。并且结果和函数的执行顺序是一致的。\n\n\n# 15. 代码输出结果\n\nfunction runasync (x) {\n  const p = new promise(r => settimeout(() => r(x, console.log(x)), 1000))\n  return p\n}\nfunction runreject (x) {\n  const p = new promise((res, rej) => settimeout(() => rej(`error: ${x}`, console.log(x)), 1000 * x))\n  return p\n}\npromise.all([runasync(1), runreject(4), runasync(3), runreject(2)])\n       .then(res => console.log(res))\n       .catch(err => console.log(err))\n\n\n输出结果如下：\n\n// 1s后输出\n1\n3\n// 2s后输出\n2\nerror: 2\n// 4s后输出\n4\n\n\n可以看到。catch捕获到了第一个错误，在这道题目中最先的错误就是runreject(2)的结果。如果一组异步操作中有一个异常都不会进入.then()的第一个回调函数参数中。会被.then()的第二个回调函数捕获。\n\n\n# 16. 代码输出结果\n\nfunction runasync (x) {\n  const p = new promise(r => settimeout(() => r(x, console.log(x)), 1000))\n  return p\n}\npromise.race([runasync(1), runasync(2), runasync(3)])\n  .then(res => console.log('result: ', res))\n  .catch(err => console.log(err))\n\n\n输出结果如下：\n\n1\n'result: ' 1\n2\n3\n\n\nthen只会捕获第一个成功的方法，其他的函数虽然还会继续执行，但是不是被then捕获了。\n\n\n# 17. 代码输出结果\n\nfunction runasync(x) {\n  const p = new promise(r =>\n    settimeout(() => r(x, console.log(x)), 1000)\n  );\n  return p;\n}\nfunction runreject(x) {\n  const p = new promise((res, rej) =>\n    settimeout(() => rej(`error: ${x}`, console.log(x)), 1000 * x)\n  );\n  return p;\n}\npromise.race([runreject(0), runasync(1), runasync(2), runasync(3)])\n  .then(res => console.log(\"result: \", res))\n  .catch(err => console.log(err));\n\n\n输出结果如下：\n\n0\nerror: 0\n1\n2\n3\n\n\n可以看到在catch捕获到第一个错误之后，后面的代码还不执行，不过不会再被捕获了。\n\n注意：all和race传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。\n\n\n# 18. 代码输出结果\n\nasync function async1() {\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n}\nasync function async2() {\n  console.log(\"async2\");\n}\nasync1();\nconsole.log('start')\n\n\n输出结果如下：\n\nasync1 start\nasync2\nstart\nasync1 end\n\n\n代码的执行过程如下：\n\n 1. 首先执行函数中的同步代码async1 start，之后遇到了await，它会阻塞async1后面代码的执行，因此会先去执行async2中的同步代码async2，然后跳出async1；\n 2. 跳出async1函数后，执行同步代码start；\n 3. 在一轮宏任务全部执行完之后，再来执行await后面的内容async1 end。\n\n这里可以理解为await后面的语句相当于放到了new promise中，下一行及之后的语句相当于放在promise.then中。\n\n\n# 19. 代码输出结果\n\nasync function async1() {\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n  settimeout(() => {\n    console.log('timer1')\n  }, 0)\n}\nasync function async2() {\n  settimeout(() => {\n    console.log('timer2')\n  }, 0)\n  console.log(\"async2\");\n}\nasync1();\nsettimeout(() => {\n  console.log('timer3')\n}, 0)\nconsole.log(\"start\")\n\n\n输出结果如下：\n\nasync1 start\nasync2\nstart\nasync1 end\ntimer2\ntimer3\ntimer1\n\n\n代码的执行过程如下：\n\n 1. 首先进入async1，打印出async1 start；\n 2. 之后遇到async2，进入async2，遇到定时器timer2，加入宏任务队列，之后打印async2；\n 3. 由于async2阻塞了后面代码的执行，所以执行后面的定时器timer3，将其加入宏任务队列，之后打印start；\n 4. 然后执行async2后面的代码，打印出async1 end，遇到定时器timer1，将其加入宏任务队列；\n 5. 最后，宏任务队列有三个任务，先后顺序为timer2，timer3，timer1，没有微任务，所以直接所有的宏任务按照先进先出的原则执行。\n\n\n# 20. 代码输出结果\n\nasync function async1 () {\n  console.log('async1 start');\n  await new promise(resolve => {\n    console.log('promise1')\n  })\n  console.log('async1 success');\n  return 'async1 end'\n}\nconsole.log('srcipt start')\nasync1().then(res => console.log(res))\nconsole.log('srcipt end')\n\n\n输出结果如下：\n\nscript start\nasync1 start\npromise1\nscript end\n\n\n这里需要注意的是在async1中await后面的promise是没有返回值的，也就是它的状态始终是pending状态，所以在await之后的内容是不会执行的，包括async1后面的 .then。\n\n\n# 21. 代码输出结果\n\nasync function async1 () {\n  console.log('async1 start');\n  await new promise(resolve => {\n    console.log('promise1')\n    resolve('promise1 resolve')\n  }).then(res => console.log(res))\n  console.log('async1 success');\n  return 'async1 end'\n}\nconsole.log('srcipt start')\nasync1().then(res => console.log(res))\nconsole.log('srcipt end')\n\n\n这里是对上面一题进行了改造，加上了resolve。\n\n输出结果如下：\n\nscript start\nasync1 start\npromise1\nscript end\npromise1 resolve\nasync1 success\nasync1 end\n\n\n\n# 22. 代码输出结果\n\nasync function async1() {\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n}\n\nasync function async2() {\n  console.log(\"async2\");\n}\n\nconsole.log(\"script start\");\n\nsettimeout(function() {\n  console.log(\"settimeout\");\n}, 0);\n\nasync1();\n\nnew promise(resolve => {\n  console.log(\"promise1\");\n  resolve();\n}).then(function() {\n  console.log(\"promise2\");\n});\nconsole.log('script end')\n\n\n输出结果如下：\n\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsettimeout\n\n\n代码执行过程如下：\n\n 1. 开头定义了async1和async2两个函数，但是并未执行，执行script中的代码，所以打印出script start；\n 2. 遇到定时器settimeout，它是一个宏任务，将其加入到宏任务队列；\n 3. 之后执行函数async1，首先打印出async1 start；\n 4. 遇到await，执行async2，打印出async2，并阻断后面代码的执行，将后面的代码加入到微任务队列；\n 5. 然后跳出async1和async2，遇到promise，打印出promise1；\n 6. 遇到resolve，将其加入到微任务队列，然后执行后面的script代码，打印出script end；\n 7. 之后就该执行微任务队列了，首先打印出async1 end，然后打印出promise2；\n 8. 执行完微任务队列，就开始执行宏任务队列中的定时器，打印出settimeout。\n\n\n# 23. 代码输出结果\n\nasync function async1 () {\n  await async2();\n  console.log('async1');\n  return 'async1 success'\n}\nasync function async2 () {\n  return new promise((resolve, reject) => {\n    console.log('async2')\n    reject('error')\n  })\n}\nasync1().then(res => console.log(res))\n\n\n输出结果如下：\n\nasync2\nuncaught (in promise) error\n\n\n可以看到，如果async函数中抛出了错误，就会终止错误结果，不会继续向下执行。\n\n如果想要让错误不足之处后面的代码执行，可以使用catch来捕获：\n\nasync function async1 () {\n  await promise.reject('error!!!').catch(e => console.log(e))\n  console.log('async1');\n  return promise.resolve('async1 success')\n}\nasync1().then(res => console.log(res))\nconsole.log('script start')\n\n\n这样的输出结果就是：\n\nscript start\nerror!!!\nasync1\nasync1 success\n\n\n\n# 24. 代码输出结果\n\nconst first = () => (new promise((resolve, reject) => {\n    console.log(3);\n    let p = new promise((resolve, reject) => {\n        console.log(7);\n        settimeout(() => {\n            console.log(5);\n            resolve(6);\n            console.log(p)\n        }, 0)\n        resolve(1);\n    });\n    resolve(2);\n    p.then((arg) => {\n        console.log(arg);\n    });\n}));\nfirst().then((arg) => {\n    console.log(arg);\n});\nconsole.log(4);\n\n\n输出结果如下：\n\n3\n7\n4\n1\n2\n5\npromise{<resolved>: 1}\n\n\n代码的执行过程如下：\n\n 1. 首先会进入promise，打印出3，之后进入下面的promise，打印出7；\n 2. 遇到了定时器，将其加入宏任务队列；\n 3. 执行promise p中的resolve，状态变为resolved，返回值为1；\n 4. 执行promise first中的resolve，状态变为resolved，返回值为2；\n 5. 遇到p.then，将其加入微任务队列，遇到first().then，将其加入任务队列；\n 6. 执行外面的代码，打印出4；\n 7. 这样第一轮宏任务就执行完了，开始执行微任务队列中的任务，先后打印出1和2；\n 8. 这样微任务就执行完了，开始执行下一轮宏任务，宏任务队列中有一个定时器，执行它，打印出5，由于执行已经变为resolved状态，所以resolve(6)不会再执行；\n 9. 最后console.log(p)打印出promise{<resolved>: 1}；\n\n\n# 25. 代码输出结果\n\nconst async1 = async () => {\n  console.log('async1');\n  settimeout(() => {\n    console.log('timer1')\n  }, 2000)\n  await new promise(resolve => {\n    console.log('promise1')\n  })\n  console.log('async1 end')\n  return 'async1 success'\n} \nconsole.log('script start');\nasync1().then(res => console.log(res));\nconsole.log('script end');\npromise.resolve(1)\n  .then(2)\n  .then(promise.resolve(3))\n  .catch(4)\n  .then(res => console.log(res))\nsettimeout(() => {\n  console.log('timer2')\n}, 1000)\n\n\n输出结果如下：\n\nscript start\nasync1\npromise1\nscript end\n1\ntimer2\ntimer1\n\n\n代码的执行过程如下：\n\n 1. 首先执行同步带吗，打印出script start；\n 2. 遇到定时器timer1将其加入宏任务队列；\n 3. 之后是执行promise，打印出promise1，由于promise没有返回值，所以后面的代码不会执行；\n 4. 然后执行同步代码，打印出script end；\n 5. 继续执行下面的promise，.then和.catch期望参数是一个函数，这里传入的是一个数字，因此就会发生值渗透，将resolve(1)的值传到最后一个then，直接打印出1；\n 6. 遇到第二个定时器，将其加入到微任务队列，执行微任务队列，按顺序依次执行两个定时器，但是由于定时器时间的原因，会在两秒后先打印出timer2，在四秒后打印出timer1。\n\n\n# 26. 代码输出结果\n\nconst p1 = new promise((resolve) => {\n  settimeout(() => {\n    resolve('resolve3');\n    console.log('timer1')\n  }, 0)\n  resolve('resovle1');\n  resolve('resolve2');\n}).then(res => {\n  console.log(res)  // resolve1\n  settimeout(() => {\n    console.log(p1)\n  }, 1000)\n}).finally(res => {\n  console.log('finally', res)\n})\n\n\n执行结果为如下：\n\nresolve1\nfinally  undefined\ntimer1\npromise{<resolved>: undefined}\n\n\n需要注意的是最后一个定时器打印出的p1其实是.finally的返回值，我们知道.finally的返回值如果在没有抛出错误的情况下默认会是上一个promise的返回值，而这道题中.finally上一个promise是.then()，但是这个.then()并没有返回值，所以p1打印出来的promise的值会是undefined，如果在定时器的下面加上一个return 1，则值就会变成1。\n\n\n# 27. 代码输出结果\n\nconsole.log('1');\n\nsettimeout(function() {\n    console.log('2');\n    process.nexttick(function() {\n        console.log('3');\n    })\n    new promise(function(resolve) {\n        console.log('4');\n        resolve();\n    }).then(function() {\n        console.log('5')\n    })\n})\nprocess.nexttick(function() {\n    console.log('6');\n})\nnew promise(function(resolve) {\n    console.log('7');\n    resolve();\n}).then(function() {\n    console.log('8')\n})\n\nsettimeout(function() {\n    console.log('9');\n    process.nexttick(function() {\n        console.log('10');\n    })\n    new promise(function(resolve) {\n        console.log('11');\n        resolve();\n    }).then(function() {\n        console.log('12')\n    })\n})\n\n\n输出结果如下：\n\n1\n7\n6\n8\n2\n4\n3\n5\n9\n11\n10\n12\n\n\n（1）第一轮事件循环流程分析如下：\n\n * 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。\n * 遇到settimeout，其回调函数被分发到宏任务event queue中。暂且记为settimeout1。\n * 遇到process.nexttick()，其回调函数被分发到微任务event queue中。记为process1。\n * 遇到promise，new promise直接执行，输出7。then被分发到微任务event queue中。记为then1。\n * 又遇到了settimeout，其回调函数被分发到宏任务event queue中，记为settimeout2。\n\n宏任务event queue   微任务event queue\nsettimeout1      process1\nsettimeout2      then1\n\n上表是第一轮事件循环宏任务结束时各event queue的情况，此时已经输出了1和7。发现了process1和then1两个微任务：\n\n * 执行process1，输出6。\n * 执行then1，输出8。\n\n第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。\n\n（2）第二轮时间循环从**settimeout1**宏任务开始：\n\n * 首先输出2。接下来遇到了process.nexttick()，同样将其分发到微任务event queue中，记为process2。\n * new promise立即执行输出4，then也分发到微任务event queue中，记为then2。\n\n宏任务event queue   微任务event queue\nsettimeout2      process2\n                 then2\n\n第二轮事件循环宏任务结束，发现有process2和then2两个微任务可以执行：\n\n * 输出3。\n * 输出5。\n\n第二轮事件循环结束，第二轮输出2，4，3，5。\n\n（3）第三轮事件循环开始，此时只剩settimeout2了，执行。\n\n * 直接输出9。\n * 将process.nexttick()分发到微任务event queue中。记为process3。\n * 直接执行new promise，输出11。\n * 将then分发到微任务event queue中，记为then3。\n\n宏任务event queue   微任务event queue\n                 process3\n                 then3\n\n第三轮事件循环宏任务执行结束，执行两个微任务process3和then3：\n\n * 输出10。\n * 输出12。\n\n第三轮事件循环结束，第三轮输出9，11，10，12。\n\n整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。\n\n\n# 28. 代码输出结果\n\nconsole.log(1)\n\nsettimeout(() => {\n  console.log(2)\n})\n\nnew promise(resolve =>  {\n  console.log(3)\n  resolve(4)\n}).then(d => console.log(d))\n\nsettimeout(() => {\n  console.log(5)\n  new promise(resolve =>  {\n    resolve(6)\n  }).then(d => console.log(d))\n})\n\nsettimeout(() => {\n  console.log(7)\n})\n\nconsole.log(8)\n\n\n输出结果如下：\n\n1\n3\n8\n4\n2\n5\n6\n7\n\n\n代码执行过程如下：\n\n 1.  首先执行script代码，打印出1；\n 2.  遇到第一个定时器，加入到宏任务队列；\n 3.  遇到promise，执行代码，打印出3，遇到resolve，将其加入到微任务队列；\n 4.  遇到第二个定时器，加入到宏任务队列；\n 5.  遇到第三个定时器，加入到宏任务队列；\n 6.  继续执行script代码，打印出8，第一轮执行结束；\n 7.  执行微任务队列，打印出第一个promise的resolve结果：4；\n 8.  开始执行宏任务队列，执行第一个定时器，打印出2；\n 9.  此时没有微任务，继续执行宏任务中的第二个定时器，首先打印出5，遇到promise，首选打印出6，遇到resolve，将其加入到微任务队列；\n 10. 执行微任务队列，打印出6；\n 11. 执行宏任务队列中的最后一个定时器，打印出7。\n\n\n# 29. 代码输出结果\n\nconsole.log(1);\n    \nsettimeout(() => {\n  console.log(2);\n  promise.resolve().then(() => {\n    console.log(3)\n  });\n});\n\nnew promise((resolve, reject) => {\n  console.log(4)\n  resolve(5)\n}).then((data) => {\n  console.log(data);\n})\n\nsettimeout(() => {\n  console.log(6);\n})\n\nconsole.log(7);\n\n\n代码输出结果如下：\n\n1\n4\n7\n5\n2\n3\n6\n\n\n代码执行过程如下：\n\n 1. 首先执行scrip代码，打印出1；\n 2. 遇到第一个定时器settimeout，将其加入到宏任务队列；\n 3. 遇到promise，执行里面的同步代码，打印出4，遇到resolve，将其加入到微任务队列；\n 4. 遇到第二个定时器settimeout，将其加入到红任务队列；\n 5. 执行script代码，打印出7，至此第一轮执行完成；\n 6. 指定微任务队列中的代码，打印出resolve的结果：5；\n 7. 执行宏任务中的第一个定时器settimeout，首先打印出2，然后遇到 promise.resolve().then()，将其加入到微任务队列；\n 8. 执行完这个宏任务，就开始执行微任务队列，打印出3；\n 9. 继续执行宏任务队列中的第二个定时器，打印出6。\n\n\n# 30. 代码输出结果\n\npromise.resolve().then(() => {\n    console.log('1');\n    throw 'error';\n}).then(() => {\n    console.log('2');\n}).catch(() => {\n    console.log('3');\n    throw 'error';\n}).then(() => {\n    console.log('4');\n}).catch(() => {\n    console.log('5');\n}).then(() => {\n    console.log('6');\n});\n\n\n执行结果如下：\n\n1 \n3 \n5 \n6\n\n\n在这道题目中，我们需要知道，无论是thne还是catch中，只要throw 抛出了错误，就会被catch捕获，如果没有throw出错误，就被继续执行后面的then。\n\n\n# 31. 代码输出结果\n\nsettimeout(function () {\n  console.log(1);\n}, 100);\n\nnew promise(function (resolve) {\n  console.log(2);\n  resolve();\n  console.log(3);\n}).then(function () {\n  console.log(4);\n  new promise((resove, reject) => {\n    console.log(5);\n    settimeout(() =>  {\n      console.log(6);\n    }, 10);\n  })\n});\nconsole.log(7);\nconsole.log(8);\n\n\n输出结果为：\n\n2\n3\n7\n8\n4\n5\n6\n1\n\n\n代码执行过程如下：\n\n 1. 首先遇到定时器，将其加入到宏任务队列；\n 2. 遇到promise，首先执行里面的同步代码，打印出2，遇到resolve，将其加入到微任务队列，执行后面同步代码，打印出3；\n 3. 继续执行script中的代码，打印出7和8，至此第一轮代码执行完成；\n 4. 执行微任务队列中的代码，首先打印出4，如遇到promise，执行其中的同步代码，打印出5，遇到定时器，将其加入到宏任务队列中，此时宏任务队列中有两个定时器；\n 5. 执行宏任务队列中的代码，这里我们需要注意是的第一个定时器的时间为100ms，第二个定时器的时间为10ms，所以先执行第二个定时器，打印出6；\n 6. 此时微任务队列为空，继续执行宏任务队列，打印出1。\n\n做完这道题目，我们就需要格外注意，每个定时器的时间，并不是所有定时器的时间都为0哦。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "作用域&变量提升&闭包",
      "frontmatter": {
        "title": "作用域&变量提升&闭包",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/codeOutput/scope/",
        "article": false
      },
      "regularPath": "/40.%E4%BB%A3%E7%A0%81%E7%AF%87/20.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E7%AF%87/30.%E4%BD%9C%E7%94%A8%E5%9F%9F&%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87&%E9%97%AD%E5%8C%85.html",
      "relativePath": "40.代码篇/20.代码输出结果篇/30.作用域&变量提升&闭包.md",
      "key": "v-33d65927",
      "path": "/pages/codeOutput/scope/",
      "headers": [
        {
          "level": 3,
          "title": "1. 代码输出结果",
          "slug": "_1-代码输出结果",
          "normalizedTitle": "1. 代码输出结果",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 代码输出结果",
          "slug": "_2-代码输出结果",
          "normalizedTitle": "2. 代码输出结果",
          "charIndex": 311
        },
        {
          "level": 3,
          "title": "3. 代码输出结果",
          "slug": "_3-代码输出结果",
          "normalizedTitle": "3. 代码输出结果",
          "charIndex": 615
        },
        {
          "level": 3,
          "title": "4. 代码输出结果",
          "slug": "_4-代码输出结果",
          "normalizedTitle": "4. 代码输出结果",
          "charIndex": 1157
        },
        {
          "level": 3,
          "title": "5. 代码输出结果",
          "slug": "_5-代码输出结果",
          "normalizedTitle": "5. 代码输出结果",
          "charIndex": 1409
        },
        {
          "level": 3,
          "title": "6. 代码输出结果",
          "slug": "_6-代码输出结果",
          "normalizedTitle": "6. 代码输出结果",
          "charIndex": 1796
        },
        {
          "level": 3,
          "title": "7.  代码输出问题",
          "slug": "_7-代码输出问题",
          "normalizedTitle": "7.  代码输出问题",
          "charIndex": null
        },
        {
          "level": 3,
          "title": "8. 代码输出结果",
          "slug": "_8-代码输出结果",
          "normalizedTitle": "8. 代码输出结果",
          "charIndex": 2525
        }
      ],
      "headersStr": "1. 代码输出结果 2. 代码输出结果 3. 代码输出结果 4. 代码输出结果 5. 代码输出结果 6. 代码输出结果 7.  代码输出问题 8. 代码输出结果",
      "content": "# 1. 代码输出结果\n\n(function(){\n   var x = y = 1;\n})();\nvar z;\n\nconsole.log(y); // 1\nconsole.log(z); // undefined\nconsole.log(x); // Uncaught ReferenceError: x is not defined\n\n\n这段代码的关键在于：var x = y = 1; 实际上这里是从右往左执行的，首先执行y = 1, 因为y没有使用var声明，所以它是一个全局变量，然后第二步是将y赋值给x，讲一个全局变量赋值给了一个局部变量，最终，x是一个局部变量，y是一个全局变量，所以打印x是报错。\n\n\n# 2. 代码输出结果\n\nvar a, b\n(function () {\n   console.log(a);\n   console.log(b);\n   var a = (b = 3);\n   console.log(a);\n   console.log(b);   \n})()\nconsole.log(a);\nconsole.log(b);\n\n\n输出结果：\n\nundefined \nundefined \n3 \n3 \nundefined \n3\n\n\n这个题目和上面题目考察的知识点类似，b赋值为3，b此时是一个全局变量，而将3赋值给a，a是一个局部变量，所以最后打印的时候，a仍旧是undefined。\n\n\n# 3. 代码输出结果\n\nvar friendName = 'World';\n(function() {\n  if (typeof friendName === 'undefined') {\n    var friendName = 'Jack';\n    console.log('Goodbye ' + friendName);\n  } else {\n    console.log('Hello ' + friendName);\n  }\n})();\n\n\n输出结果：Goodbye Jack\n\n我们知道，在 JavaScript中， Function 和 var 都会被提升（变量提升），所以上面的代码就相当于：\n\nvar name = 'World!';\n(function () {\n    var name;\n    if (typeof name === 'undefined') {\n        name = 'Jack';\n        console.log('Goodbye ' + name);\n    } else {\n        console.log('Hello ' + name);\n    }\n})();\n\n\n这样，答案就一目了然了。\n\n\n# 4. 代码输出结果\n\nfunction fn1(){\n  console.log('fn1')\n}\nvar fn2\n \nfn1()\nfn2()\n \nfn2 = function() {\n  console.log('fn2')\n}\n \nfn2()\n\n\n输出结果：\n\nfn1\nUncaught TypeError: fn2 is not a function\nfn2\n\n\n这里也是在考察变量提升，关键在于第一个fn2()，这时fn2仍是一个undefined的变量，所以会报错fn2不是一个函数。\n\n\n# 5. 代码输出结果\n\nfunction a() {\n    var temp = 10;\n    function b() {\n        console.log(temp); // 10\n    }\n    b();\n}\na();\n\nfunction a() {\n    var temp = 10;\n    b();\n}\nfunction b() {\n    console.log(temp); // 报错 Uncaught ReferenceError: temp is not defined\n}\na();\n\n\n在上面的两段代码中，第一段是可以正常输出，这个应该没啥问题，关键在于第二段代码，它会报错Uncaught ReferenceError: temp is not defined。这时因为在b方法执行时，temp 的值为undefined。\n\n\n# 6. 代码输出结果\n\n var a=3;\n function c(){\n    alert(a);\n }\n (function(){\n  var a=4;\n  c();\n })();\n\n\njs中变量的作用域链与定义时的环境有关，与执行时无关。执行环境只会改变this、传递的参数、全局变量等\n\n\n# 7. 代码输出问题\n\nfunction fun(n, o) {\n  console.log(o)\n  return {\n    fun: function(m){\n      return fun(m, n);\n    }\n  };\n}\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);\nvar b = fun(0).fun(1).fun(2).fun(3);\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);\n\n\n输出结果：\n\nundefined  0  0  0\nundefined  0  1  2\nundefined  0  1  1\n\n\n这是一道关于闭包的题目，对于fun方法，调用之后返回的是一个对象。我们知道，当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。所以 console.log(o); 会输出undefined。而a就是是fun(0)返回的那个对象。也就是说，函数fun中参数 n 的值是0，而返回的那个对象中，需要一个参数n，而这个对象的作用域中没有n，它就继续沿着作用域向上一级的作用域中寻找n，最后在函数fun中找到了n，n的值是0。了解了这一点，其他运算就很简单了，以此类推。\n\n\n# 8. 代码输出结果\n\nf = function() {return true;};   \ng = function() {return false;};   \n(function() {   \n   if (g() && [] == ![]) {   \n      f = function f() {return false;};   \n      function g() {return true;}   \n   }   \n})();   \nconsole.log(f());\n\n\n输出结果： false\n\n这里首先定义了两个变量f和g，我们知道变量是可以重新赋值的。后面是一个匿名自执行函数，在 if 条件中调用了函数 g()，由于在匿名函数中，又重新定义了函数g，就覆盖了外部定义的变量g，所以，这里调用的是内部函数 g 方法，返回为 true。第一个条件通过，进入第二个条件。\n\n第二个条件是[] == ![]，先看 ![] ，在 JavaScript 中，当用于布尔运算时，比如在这里，对象的非空引用被视为 true，空引用 null 则被视为 false。由于这里不是一个 null, 而是一个没有元素的数组，所以 [] 被视为 true, 而 ![] 的结果就是 false 了。当一个布尔值参与到条件运算的时候，true 会被看作 1, 而 false 会被看作 0。现在条件变成了 [] == 0 的问题了，当一个对象参与条件比较的时候，它会被求值，求值的结果是数组成为一个字符串，[] 的结果就是 '' ，而 '' 会被当作 0 ，所以，条件成立。\n\n两个条件都成立，所以会执行条件中的代码， f 在定义是没有使用var，所以他是一个全局变量。因此，这里会通过闭包访问到外部的变量 f, 重新赋值，现在执行 f 函数返回值已经成为 false 了。而 g 则不会有这个问题，这里是一个函数内定义的 g，不会影响到外部的 g 函数。所以最后的结果就是 false。",
      "normalizedContent": "# 1. 代码输出结果\n\n(function(){\n   var x = y = 1;\n})();\nvar z;\n\nconsole.log(y); // 1\nconsole.log(z); // undefined\nconsole.log(x); // uncaught referenceerror: x is not defined\n\n\n这段代码的关键在于：var x = y = 1; 实际上这里是从右往左执行的，首先执行y = 1, 因为y没有使用var声明，所以它是一个全局变量，然后第二步是将y赋值给x，讲一个全局变量赋值给了一个局部变量，最终，x是一个局部变量，y是一个全局变量，所以打印x是报错。\n\n\n# 2. 代码输出结果\n\nvar a, b\n(function () {\n   console.log(a);\n   console.log(b);\n   var a = (b = 3);\n   console.log(a);\n   console.log(b);   \n})()\nconsole.log(a);\nconsole.log(b);\n\n\n输出结果：\n\nundefined \nundefined \n3 \n3 \nundefined \n3\n\n\n这个题目和上面题目考察的知识点类似，b赋值为3，b此时是一个全局变量，而将3赋值给a，a是一个局部变量，所以最后打印的时候，a仍旧是undefined。\n\n\n# 3. 代码输出结果\n\nvar friendname = 'world';\n(function() {\n  if (typeof friendname === 'undefined') {\n    var friendname = 'jack';\n    console.log('goodbye ' + friendname);\n  } else {\n    console.log('hello ' + friendname);\n  }\n})();\n\n\n输出结果：goodbye jack\n\n我们知道，在 javascript中， function 和 var 都会被提升（变量提升），所以上面的代码就相当于：\n\nvar name = 'world!';\n(function () {\n    var name;\n    if (typeof name === 'undefined') {\n        name = 'jack';\n        console.log('goodbye ' + name);\n    } else {\n        console.log('hello ' + name);\n    }\n})();\n\n\n这样，答案就一目了然了。\n\n\n# 4. 代码输出结果\n\nfunction fn1(){\n  console.log('fn1')\n}\nvar fn2\n \nfn1()\nfn2()\n \nfn2 = function() {\n  console.log('fn2')\n}\n \nfn2()\n\n\n输出结果：\n\nfn1\nuncaught typeerror: fn2 is not a function\nfn2\n\n\n这里也是在考察变量提升，关键在于第一个fn2()，这时fn2仍是一个undefined的变量，所以会报错fn2不是一个函数。\n\n\n# 5. 代码输出结果\n\nfunction a() {\n    var temp = 10;\n    function b() {\n        console.log(temp); // 10\n    }\n    b();\n}\na();\n\nfunction a() {\n    var temp = 10;\n    b();\n}\nfunction b() {\n    console.log(temp); // 报错 uncaught referenceerror: temp is not defined\n}\na();\n\n\n在上面的两段代码中，第一段是可以正常输出，这个应该没啥问题，关键在于第二段代码，它会报错uncaught referenceerror: temp is not defined。这时因为在b方法执行时，temp 的值为undefined。\n\n\n# 6. 代码输出结果\n\n var a=3;\n function c(){\n    alert(a);\n }\n (function(){\n  var a=4;\n  c();\n })();\n\n\njs中变量的作用域链与定义时的环境有关，与执行时无关。执行环境只会改变this、传递的参数、全局变量等\n\n\n# 7. 代码输出问题\n\nfunction fun(n, o) {\n  console.log(o)\n  return {\n    fun: function(m){\n      return fun(m, n);\n    }\n  };\n}\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);\nvar b = fun(0).fun(1).fun(2).fun(3);\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);\n\n\n输出结果：\n\nundefined  0  0  0\nundefined  0  1  2\nundefined  0  1  1\n\n\n这是一道关于闭包的题目，对于fun方法，调用之后返回的是一个对象。我们知道，当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。所以 console.log(o); 会输出undefined。而a就是是fun(0)返回的那个对象。也就是说，函数fun中参数 n 的值是0，而返回的那个对象中，需要一个参数n，而这个对象的作用域中没有n，它就继续沿着作用域向上一级的作用域中寻找n，最后在函数fun中找到了n，n的值是0。了解了这一点，其他运算就很简单了，以此类推。\n\n\n# 8. 代码输出结果\n\nf = function() {return true;};   \ng = function() {return false;};   \n(function() {   \n   if (g() && [] == ![]) {   \n      f = function f() {return false;};   \n      function g() {return true;}   \n   }   \n})();   \nconsole.log(f());\n\n\n输出结果： false\n\n这里首先定义了两个变量f和g，我们知道变量是可以重新赋值的。后面是一个匿名自执行函数，在 if 条件中调用了函数 g()，由于在匿名函数中，又重新定义了函数g，就覆盖了外部定义的变量g，所以，这里调用的是内部函数 g 方法，返回为 true。第一个条件通过，进入第二个条件。\n\n第二个条件是[] == ![]，先看 ![] ，在 javascript 中，当用于布尔运算时，比如在这里，对象的非空引用被视为 true，空引用 null 则被视为 false。由于这里不是一个 null, 而是一个没有元素的数组，所以 [] 被视为 true, 而 ![] 的结果就是 false 了。当一个布尔值参与到条件运算的时候，true 会被看作 1, 而 false 会被看作 0。现在条件变成了 [] == 0 的问题了，当一个对象参与条件比较的时候，它会被求值，求值的结果是数组成为一个字符串，[] 的结果就是 '' ，而 '' 会被当作 0 ，所以，条件成立。\n\n两个条件都成立，所以会执行条件中的代码， f 在定义是没有使用var，所以他是一个全局变量。因此，这里会通过闭包访问到外部的变量 f, 重新赋值，现在执行 f 函数返回值已经成为 false 了。而 g 则不会有这个问题，这里是一个函数内定义的 g，不会影响到外部的 g 函数。所以最后的结果就是 false。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "Redux",
      "frontmatter": {
        "title": "Redux",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/frameRedux/",
        "article": false
      },
      "regularPath": "/30.%E6%A1%86%E6%9E%B6%E7%AF%87/20.react%E7%AF%87/60.Redux.html",
      "relativePath": "30.框架篇/20.react篇/60.Redux.md",
      "key": "v-2645275e",
      "path": "/pages/frameRedux/",
      "headers": [
        {
          "level": 3,
          "title": "1. 对 Redux 的理解，主要解决什么问题",
          "slug": "_1-对-redux-的理解-主要解决什么问题",
          "normalizedTitle": "1. 对 redux 的理解，主要解决什么问题",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. Redux 原理及工作流程",
          "slug": "_2-redux-原理及工作流程",
          "normalizedTitle": "2. redux 原理及工作流程",
          "charIndex": 954
        },
        {
          "level": 3,
          "title": "3. Redux 中异步的请求怎么处理",
          "slug": "_3-redux-中异步的请求怎么处理",
          "normalizedTitle": "3. redux 中异步的请求怎么处理",
          "charIndex": 3057
        },
        {
          "level": 3,
          "title": "4. Redux 怎么实现属性传递，介绍下原理",
          "slug": "_4-redux-怎么实现属性传递-介绍下原理",
          "normalizedTitle": "4. redux 怎么实现属性传递，介绍下原理",
          "charIndex": 6498
        },
        {
          "level": 3,
          "title": "5. Redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？",
          "slug": "_5-redux-中间件是什么-接受几个参数-柯里化函数两端的参数具体是什么",
          "normalizedTitle": "5. redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？",
          "charIndex": 8076
        },
        {
          "level": 3,
          "title": "6. Redux 请求中间件如何处理并发",
          "slug": "_6-redux-请求中间件如何处理并发",
          "normalizedTitle": "6. redux 请求中间件如何处理并发",
          "charIndex": 9199
        },
        {
          "level": 3,
          "title": "7. Redux 状态管理器和变量挂载到 window 中有什么区别",
          "slug": "_7-redux-状态管理器和变量挂载到-window-中有什么区别",
          "normalizedTitle": "7. redux 状态管理器和变量挂载到 window 中有什么区别",
          "charIndex": 10194
        },
        {
          "level": 3,
          "title": "8. mobox 和 redux 有什么区别？",
          "slug": "_8-mobox-和-redux-有什么区别",
          "normalizedTitle": "8. mobox 和 redux 有什么区别？",
          "charIndex": 10915
        },
        {
          "level": 3,
          "title": "9. Redux 和 Vuex 有什么区别，它们的共同思想",
          "slug": "_9-redux-和-vuex-有什么区别-它们的共同思想",
          "normalizedTitle": "9. redux 和 vuex 有什么区别，它们的共同思想",
          "charIndex": 12179
        },
        {
          "level": 3,
          "title": "10. Redux 中间件是怎么拿到store 和 action? 然后怎么处理?",
          "slug": "_10-redux-中间件是怎么拿到store-和-action-然后怎么处理",
          "normalizedTitle": "10. redux 中间件是怎么拿到store 和 action? 然后怎么处理?",
          "charIndex": 12661
        },
        {
          "level": 3,
          "title": "11. Redux中的connect有什么作用",
          "slug": "_11-redux中的connect有什么作用",
          "normalizedTitle": "11. redux中的connect有什么作用",
          "charIndex": 13072
        }
      ],
      "headersStr": "1. 对 Redux 的理解，主要解决什么问题 2. Redux 原理及工作流程 3. Redux 中异步的请求怎么处理 4. Redux 怎么实现属性传递，介绍下原理 5. Redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？ 6. Redux 请求中间件如何处理并发 7. Redux 状态管理器和变量挂载到 window 中有什么区别 8. mobox 和 redux 有什么区别？ 9. Redux 和 Vuex 有什么区别，它们的共同思想 10. Redux 中间件是怎么拿到store 和 action? 然后怎么处理? 11. Redux中的connect有什么作用",
      "content": "# 1. 对 Redux 的理解，主要解决什么问题\n\nReact是视图层框架。Redux是一个用来管理数据状态和UI状态的JavaScript应用工具。随着JavaScript单页应用（SPA）开发日趋复杂， JavaScript需要管理比任何时候都要多的state（状态）， Redux就是降低管理难度的。（Redux支持React、Angular、jQuery甚至纯JavaScript）。\n\n在 React 中，UI 以组件的形式来搭建，组件之间可以嵌套组合。但 React 中组件间通信的数据流是单向的，顶层组件可以通过 props 属性向下层组件传递数据，而下层组件不能向上层组件传递数据，兄弟组件之间同样不能。这样简单的单向数据流支撑起了 React 中的数据可控性。\n\n当项目越来越大的时候，管理数据的事件或回调函数将越来越多，也将越来越不好管理。管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等。state 的管理在大项目中相当复杂。\n\nRedux 提供了一个叫 store 的统一仓储库，组件通过 dispatch 将 state 直接传入store，不用通过其他的组件。并且组件通过 subscribe 从 store获取到 state 的改变。使用了 Redux，所有的组件都可以从 store 中获取到所需的 state，他们也能从store 获取到 state 的改变。这比组件之间互相传递数据清晰明朗的多。\n\n主要解决的问题： 单纯的Redux只是一个状态机，是没有UI呈现的，react- redux作用是将Redux的状态机和React的UI呈现绑定在一起，当你dispatch action改变state的时候，会自动更新页面。\n\n\n# 2. Redux 原理及工作流程\n\n（1）原理 Redux源码主要分为以下几个模块文件\n\n * compose.js 提供从右到左进行函数式编程\n * createStore.js 提供作为生成唯一store的函数\n * combineReducers.js 提供合并多个reducer的函数，保证store的唯一性\n * bindActionCreators.js 可以让开发者在不直接接触dispacth的前提下进行更改state的操作\n * applyMiddleware.js 这个方法通过中间件来增强dispatch的功能\n\nconst actionTypes = {\n    ADD: 'ADD',\n    CHANGEINFO: 'CHANGEINFO',\n}\n\nconst initState = {\n    info: '初始化',\n}\n\nexport default function initReducer(state=initState, action) {\n    switch(action.type) {\n        case actionTypes.CHANGEINFO:\n            return {\n                ...state,\n                info: action.preload.info || '',\n            }\n        default:\n            return { ...state };\n    }\n}\n\nexport default function createStore(reducer, initialState, middleFunc) {\n\n    if (initialState && typeof initialState === 'function') {\n        middleFunc = initialState;\n        initialState = undefined;\n    }\n\n    let currentState = initialState;\n\n    const listeners = [];\n\n    if (middleFunc && typeof middleFunc === 'function') {\n        // 封装dispatch \n        return middleFunc(createStore)(reducer, initialState);\n    }\n\n    const getState = () => {\n        return currentState;\n    }\n\n    const dispatch = (action) => {\n        currentState = reducer(currentState, action);\n\n        listeners.forEach(listener => {\n            listener();\n        })\n    }\n\n    const subscribe = (listener) => {\n        listeners.push(listener);\n    }\n\n    return {\n        getState,\n        dispatch,\n        subscribe\n    }\n}\n\n\n（2）工作流程\n\n * const store= createStore（fn）生成数据;\n * action: {type: Symble('action01), payload:'payload' }定义行为;\n * dispatch发起action：store.dispatch(doSomething('action001'));\n * reducer：处理action，返回新的state;\n\n通俗点解释：\n\n * 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法\n * 然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State\n * State—旦有变化，Store就会调用监听函数，来更新View\n\n以 store 为核心，可以把它看成数据存储中心，但是他要更改数据的时候不能直接修改，数据修改更新的角色由Reducers来担任，store只做存储，中间人，当Reducers的更新完成以后会通过store的订阅来通知react component，组件把新的状态重新获取渲染，组件中也能主动发送action，创建action后这个动作是不会执行的，所以要dispatch这个action，让store通过reducers去做更新React Component 就是react的每个组件。\n\n\n# 3. Redux 中异步的请求怎么处理\n\n可以在 componentDidmount 中直接进⾏请求⽆须借助redux。但是在⼀定规模的项⽬中,上述⽅法很难进⾏异步流的管理,通常情况下我们会借助redux的异步中间件进⾏异步处理。redux异步流中间件其实有很多，当下主流的异步中间件有两种redux-thunk、redux-saga。\n\n（1）使用react-thunk中间件\n\nredux-thunk优点:\n\n * 体积⼩: redux-thunk的实现⽅式很简单,只有不到20⾏代码\n * 使⽤简单: redux-thunk没有引⼊像redux-saga或者redux-observable额外的范式,上⼿简单\n\nredux-thunk缺陷:\n\n * 样板代码过多: 与redux本身⼀样,通常⼀个请求需要⼤量的代码,⽽且很多都是重复性质的\n * 耦合严重: 异步操作与redux的action偶合在⼀起,不⽅便管理\n * 功能孱弱: 有⼀些实际开发中常⽤的功能需要⾃⼰进⾏封装\n\n使用步骤：\n\n * 配置中间件，在store的创建中配置\n\nimport {createStore, applyMiddleware, compose} from 'redux';\nimport reducer from './reducer';\nimport thunk from 'redux-thunk'\n\n// 设置调试工具\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose;\n// 设置中间件\nconst enhancer = composeEnhancers(\n  applyMiddleware(thunk)\n);\n\nconst store = createStore(reducer, enhancer);\n\nexport default store;\n\n\n * 添加一个返回函数的actionCreator，将异步请求逻辑放在里面\n\n/**\n  发送get请求，并生成相应action，更新store的函数\n  @param url {string} 请求地址\n  @param func {function} 真正需要生成的action对应的actionCreator\n  @return {function} \n*/\n// dispatch为自动接收的store.dispatch函数 \nexport const getHttpAction = (url, func) => (dispatch) => {\n    axios.get(url).then(function(res){\n        const action = func(res.data)\n        dispatch(action)\n    })\n}\n\n\n * 生成action，并发送action\n\ncomponentDidMount(){\n    var action = getHttpAction('/getData', getInitTodoItemAction)\n    // 发送函数类型的action时，该action的函数体会自动执行\n    store.dispatch(action)\n}\n\n\n（2）使用redux-saga中间件\n\nredux-saga优点:\n\n * 异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中\n * action摆脱thunk function: dispatch 的参数依然是⼀个纯粹的 action (FSA)，⽽不是充满 “⿊魔法” thunk function\n * 异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理\n * 功能强⼤: redux-saga提供了⼤量的Saga 辅助函数和Effect 创建器供开发者使⽤,开发者⽆须封装或者简单封装即可使⽤\n * 灵活: redux-saga可以将多个Saga可以串⾏/并⾏组合起来,形成⼀个⾮常实⽤的异步flow\n * 易测试，提供了各种case的测试⽅案，包括mock task，分⽀覆盖等等\n\nredux-saga缺陷:\n\n * 额外的学习成本: redux-saga不仅在使⽤难以理解的 generator function,⽽且有数⼗个API,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和⼀整套思想\n * 体积庞⼤: 体积略⼤,代码近2000⾏，min版25KB左右\n * 功能过剩: 实际上并发控制等功能很难⽤到,但是我们依然需要引⼊这些代码\n * ts⽀持不友好: yield⽆法返回TS类型\n\nredux-saga可以捕获action，然后执行一个函数，那么可以把异步代码放在这个函数中，使用步骤如下：\n\n * 配置中间件\n\nimport {createStore, applyMiddleware, compose} from 'redux';\nimport reducer from './reducer';\nimport createSagaMiddleware from 'redux-saga'\nimport TodoListSaga from './sagas'\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose;\nconst sagaMiddleware = createSagaMiddleware()\n\nconst enhancer = composeEnhancers(\n  applyMiddleware(sagaMiddleware)\n);\n\nconst store = createStore(reducer, enhancer);\nsagaMiddleware.run(TodoListSaga)\n\nexport default store;\n\n\n * 将异步请求放在sagas.js中\n\nimport {takeEvery, put} from 'redux-saga/effects'\nimport {initTodoList} from './actionCreator'\nimport {GET_INIT_ITEM} from './actionTypes'\nimport axios from 'axios'\n\nfunction* func(){\n    try{\n        // 可以获取异步返回数据\n        const res = yield axios.get('/getData')\n        const action = initTodoList(res.data)\n        // 将action发送到reducer\n        yield put(action)\n    }catch(e){\n        console.log('网络请求失败')\n    }\n}\n\nfunction* mySaga(){\n    // 自动捕获GET_INIT_ITEM类型的action，并执行func\n    yield takeEvery(GET_INIT_ITEM, func)\n}\n\nexport default mySaga\n\n\n * 发送action\n\ncomponentDidMount(){\n  const action = getInitTodoItemAction()\n  store.dispatch(action)\n}\n\n\n\n# 4. Redux 怎么实现属性传递，介绍下原理\n\nreact-redux 数据传输∶ view-->action-->reducer-->store-->view。看下点击事件的数据是如何通过redux传到view上：\n\n * view 上的AddClick 事件通过mapDispatchToProps 把数据传到action ---> click:()=>dispatch(ADD)\n * action 的ADD 传到reducer上\n * reducer传到store上 const store = createStore(reducer);\n * store再通过 mapStateToProps 映射穿到view上text:State.text\n\n代码示例∶\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore } from 'redux';\nimport { Provider, connect } from 'react-redux';\nclass App extends React.Component{\n    render(){\n        let { text, click, clickR } = this.props;\n        return(\n            <div>\n                <div>数据:已有人{text}</div>\n                <div onClick={click}>加人</div>\n                <div onClick={clickR}>减人</div>\n            </div>\n        )\n    }\n}\nconst initialState = {\n    text:5\n}\nconst reducer = function(state,action){\n    switch(action.type){\n        case 'ADD':\n            return {text:state.text+1}\n        case 'REMOVE':\n            return {text:state.text-1}\n        default:\n            return initialState;\n    }\n}\n\nlet ADD = {\n    type:'ADD'\n}\nlet Remove = {\n    type:'REMOVE'\n}\n\nconst store = createStore(reducer);\n\nlet mapStateToProps = function (state){\n    return{\n        text:state.text\n    }\n}\n\nlet mapDispatchToProps = function(dispatch){\n    return{\n        click:()=>dispatch(ADD),\n        clickR:()=>dispatch(Remove)\n    }\n}\n\nconst App1 = connect(mapStateToProps,mapDispatchToProps)(App);\n\nReactDOM.render(\n    <Provider store = {store}>\n        <App1></App1>\n    </Provider>,document.getElementById('root')\n)\n\n\n\n# 5. Redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？\n\nRedux 的中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点，换而言之，原本 view -→> action -> reducer -> store 的数据流加上中间件后变成了 view -> action -> middleware -> reducer -> store ，在这一环节可以做一些\"副作用\"的操作，如异步请求、打印日志等。\n\napplyMiddleware源码：\n\nexport default function applyMiddleware(...middlewares) {\n    return createStore => (...args) => {\n        // 利用传入的createStore和reducer和创建一个store\n        const store = createStore(...args)\n        let dispatch = () => {\n            throw new Error()\n        }\n        const middlewareAPI = {\n            getState: store.getState,\n            dispatch: (...args) => dispatch(...args)\n        }\n        // 让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍\n        const chain = middlewares.map(middleware => middleware(middlewareAPI))\n        // 接着 compose 将 chain 中的所有匿名函数，组装成一个新的函数，即新的 dispatch\n        dispatch = compose(...chain)(store.dispatch)\n        return {\n            ...store,\n            dispatch\n        }\n    }\n}\n\n\n从applyMiddleware中可以看出∶\n\n * redux中间件接受一个对象作为参数，对象的参数上有两个字段 dispatch 和 getState，分别代表着 Redux Store 上的两个同名函数。\n * 柯里化函数两端一个是 middewares，一个是store.dispatch\n\n\n# 6. Redux 请求中间件如何处理并发\n\n使用redux-Saga redux-saga是一个管理redux应用异步操作的中间件，用于代替 redux-thunk 的。它通过创建 Sagas 将所有异步操作逻辑存放在一个地方进行集中处理，以此将react中的同步操作与异步操作区分开来，以便于后期的管理与维护。 redux-saga如何处理并发：\n\n * takeEvery\n\n可以让多个 saga 任务并行被 fork 执行。\n\nimport {\n    fork,\n    take\n} from \"redux-saga/effects\"\n\nconst takeEvery = (pattern, saga, ...args) => fork(function*() {\n    while (true) {\n        const action = yield take(pattern)\n        yield fork(saga, ...args.concat(action))\n    }\n})\n\n\n * takeLatest\n\ntakeLatest 不允许多个 saga 任务并行地执行。一旦接收到新的发起的 action，它就会取消前面所有 fork 过的任务（如果这些任务还在执行的话）。 在处理 AJAX 请求的时候，如果只希望获取最后那个请求的响应， takeLatest 就会非常有用。\n\nimport {\n    cancel,\n    fork,\n    take\n} from \"redux-saga/effects\"\n\nconst takeLatest = (pattern, saga, ...args) => fork(function*() {\n    let lastTask\n    while (true) {\n        const action = yield take(pattern)\n        if (lastTask) {\n            yield cancel(lastTask) // 如果任务已经结束，则 cancel 为空操作\n        }\n        lastTask = yield fork(saga, ...args.concat(action))\n    }\n})\n\n\n\n# 7. Redux 状态管理器和变量挂载到 window 中有什么区别\n\n两者都是存储数据以供后期使用。但是Redux状态更改可回溯——Time travel，数据多了的时候可以很清晰的知道改动在哪里发生，完整的提供了一套状态管理模式。\n\n随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。\n\n管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。 如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等等。前端开发者正在经受前所未有的复杂性，难道就这么放弃了吗?当然不是。\n\n这里的复杂性很大程度上来自于：我们总是将两个难以理清的概念混淆在一起：变化和异步。 可以称它们为曼妥思和可乐。如果把二者分开，能做的很好，但混到一起，就变得一团糟。一些库如 React 视图在视图层禁止异步和直接操作 DOM来解决这个问题。美中不足的是，React 依旧把处理 state 中数据的问题留给了你。Redux就是为了帮你解决这个问题。\n\n\n# 8. mobox 和 redux 有什么区别？\n\n（1）共同点\n\n * 为了解决状态管理混乱，无法有效同步的问题统一维护管理应用状态;\n * 某一状态只有一个可信数据来源（通常命名为store，指状态容器）;\n * 操作更新状态方式统一，并且可控（通常以action方式提供更新状态的途径）;\n * 支持将store与React组件连接，如react-redux，mobx- react;\n\n（2）区别 Redux更多的是遵循Flux模式的一种实现，是一个 JavaScript库，它关注点主要是以下几方面∶\n\n * Action∶ 一个JavaScript对象，描述动作相关信息，主要包含type属性和payload属性∶\n   \n   o type∶ action 类型; o payload∶ 负载数据;\n   \n\n * Reducer∶ 定义应用状态如何响应不同动作（action），如何更新状态;\n\n * Store∶ 管理action和reducer及其关系的对象，主要提供以下功能∶\n   \n   o 维护应用状态并支持访问状态(getState());\n   o 支持监听action的分发，更新状态(dispatch(action)); \n   o 支持订阅store的变更(subscribe(listener));\n   \n\n * 异步流∶ 由于Redux所有对store状态的变更，都应该通过action触发，异步任务（通常都是业务或获取数据任务）也不例外，而为了不将业务或数据相关的任务混入React组件中，就需要使用其他框架配合管理异步任务流程，如redux-thunk，redux-saga等;\n\nMobx是一个透明函数响应式编程的状态管理库，它使得状态管理简单可伸缩∶\n\n * Action∶定义改变状态的动作函数，包括如何变更状态;\n * Store∶ 集中管理模块状态（State）和动作(action)\n * Derivation（衍生）∶ 从应用状态中派生而出，且没有任何其他影响的数据\n\n对比总结：\n\n * redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中\n * redux使用plain object保存数据，需要手动处理变化后的操作;mobx适用observable保存数据，数据变化后自动处理响应的操作\n * redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数;mobx中的状态是可变的，可以直接对其进行修改\n * mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维;redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用\n * mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测;而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易\n\n\n# 9. Redux 和 Vuex 有什么区别，它们的共同思想\n\n（1）Redux 和 Vuex区别\n\n * Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可\n * Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可\n * Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）\n\n通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变；取消了action概念，不必传入特定的 action形式进行指定变更；弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;\n\n（2）共同思想\n\n * 单—的数据源\n * 变化可以预测\n\n本质上∶ redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案。\n\n\n# 10. Redux 中间件是怎么拿到store 和 action? 然后怎么处理?\n\nredux中间件本质就是一个函数柯里化。redux applyMiddleware Api 源码中每个middleware 接受2个参数， Store 的getState 函数和dispatch 函数，分别获得store和action，最终返回一个函数。该函数会被传入 next 的下一个 middleware 的 dispatch 方法，并返回一个接收 action 的新函数，这个函数可以直接调用 next（action），或者在其他需要的时刻调用，甚至根本不去调用它。调用链中最后一个 middleware 会接受真实的 store的 dispatch 方法作为 next 参数，并借此结束调用链。所以，middleware 的函数签名是（{ getState，dispatch })=> next => action。\n\n\n# 11. Redux中的connect有什么作用\n\nconnect负责连接React和Redux\n\n（1）获取state\n\nconnect 通过 context获取 Provider 中的 store，通过store.getState() 获取整个store tree 上所有state\n\n（2）包装原组件\n\n将state和action通过props的方式传入到原组件内部 wrapWithConnect 返回—个 ReactComponent 对 象 Connect，Connect 重 新 render 外部传入的原组件 WrappedComponent ，并把 connect 中传入的 mapStateToProps，mapDispatchToProps与组件上原有的 props合并后，通过属性的方式传给WrappedComponent\n\n（3）监听store tree变化\n\nconnect缓存了store tree中state的状态，通过当前state状态 和变更前 state 状态进行比较，从而确定是否调用 this.setState()方法触发Connect及其子组件的重新渲染",
      "normalizedContent": "# 1. 对 redux 的理解，主要解决什么问题\n\nreact是视图层框架。redux是一个用来管理数据状态和ui状态的javascript应用工具。随着javascript单页应用（spa）开发日趋复杂， javascript需要管理比任何时候都要多的state（状态）， redux就是降低管理难度的。（redux支持react、angular、jquery甚至纯javascript）。\n\n在 react 中，ui 以组件的形式来搭建，组件之间可以嵌套组合。但 react 中组件间通信的数据流是单向的，顶层组件可以通过 props 属性向下层组件传递数据，而下层组件不能向上层组件传递数据，兄弟组件之间同样不能。这样简单的单向数据流支撑起了 react 中的数据可控性。\n\n当项目越来越大的时候，管理数据的事件或回调函数将越来越多，也将越来越不好管理。管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等。state 的管理在大项目中相当复杂。\n\nredux 提供了一个叫 store 的统一仓储库，组件通过 dispatch 将 state 直接传入store，不用通过其他的组件。并且组件通过 subscribe 从 store获取到 state 的改变。使用了 redux，所有的组件都可以从 store 中获取到所需的 state，他们也能从store 获取到 state 的改变。这比组件之间互相传递数据清晰明朗的多。\n\n主要解决的问题： 单纯的redux只是一个状态机，是没有ui呈现的，react- redux作用是将redux的状态机和react的ui呈现绑定在一起，当你dispatch action改变state的时候，会自动更新页面。\n\n\n# 2. redux 原理及工作流程\n\n（1）原理 redux源码主要分为以下几个模块文件\n\n * compose.js 提供从右到左进行函数式编程\n * createstore.js 提供作为生成唯一store的函数\n * combinereducers.js 提供合并多个reducer的函数，保证store的唯一性\n * bindactioncreators.js 可以让开发者在不直接接触dispacth的前提下进行更改state的操作\n * applymiddleware.js 这个方法通过中间件来增强dispatch的功能\n\nconst actiontypes = {\n    add: 'add',\n    changeinfo: 'changeinfo',\n}\n\nconst initstate = {\n    info: '初始化',\n}\n\nexport default function initreducer(state=initstate, action) {\n    switch(action.type) {\n        case actiontypes.changeinfo:\n            return {\n                ...state,\n                info: action.preload.info || '',\n            }\n        default:\n            return { ...state };\n    }\n}\n\nexport default function createstore(reducer, initialstate, middlefunc) {\n\n    if (initialstate && typeof initialstate === 'function') {\n        middlefunc = initialstate;\n        initialstate = undefined;\n    }\n\n    let currentstate = initialstate;\n\n    const listeners = [];\n\n    if (middlefunc && typeof middlefunc === 'function') {\n        // 封装dispatch \n        return middlefunc(createstore)(reducer, initialstate);\n    }\n\n    const getstate = () => {\n        return currentstate;\n    }\n\n    const dispatch = (action) => {\n        currentstate = reducer(currentstate, action);\n\n        listeners.foreach(listener => {\n            listener();\n        })\n    }\n\n    const subscribe = (listener) => {\n        listeners.push(listener);\n    }\n\n    return {\n        getstate,\n        dispatch,\n        subscribe\n    }\n}\n\n\n（2）工作流程\n\n * const store= createstore（fn）生成数据;\n * action: {type: symble('action01), payload:'payload' }定义行为;\n * dispatch发起action：store.dispatch(dosomething('action001'));\n * reducer：处理action，返回新的state;\n\n通俗点解释：\n\n * 首先，用户（通过view）发出action，发出方式就用到了dispatch方法\n * 然后，store自动调用reducer，并且传入两个参数：当前state和收到的action，reducer会返回新的state\n * state—旦有变化，store就会调用监听函数，来更新view\n\n以 store 为核心，可以把它看成数据存储中心，但是他要更改数据的时候不能直接修改，数据修改更新的角色由reducers来担任，store只做存储，中间人，当reducers的更新完成以后会通过store的订阅来通知react component，组件把新的状态重新获取渲染，组件中也能主动发送action，创建action后这个动作是不会执行的，所以要dispatch这个action，让store通过reducers去做更新react component 就是react的每个组件。\n\n\n# 3. redux 中异步的请求怎么处理\n\n可以在 componentdidmount 中直接进⾏请求⽆须借助redux。但是在⼀定规模的项⽬中,上述⽅法很难进⾏异步流的管理,通常情况下我们会借助redux的异步中间件进⾏异步处理。redux异步流中间件其实有很多，当下主流的异步中间件有两种redux-thunk、redux-saga。\n\n（1）使用react-thunk中间件\n\nredux-thunk优点:\n\n * 体积⼩: redux-thunk的实现⽅式很简单,只有不到20⾏代码\n * 使⽤简单: redux-thunk没有引⼊像redux-saga或者redux-observable额外的范式,上⼿简单\n\nredux-thunk缺陷:\n\n * 样板代码过多: 与redux本身⼀样,通常⼀个请求需要⼤量的代码,⽽且很多都是重复性质的\n * 耦合严重: 异步操作与redux的action偶合在⼀起,不⽅便管理\n * 功能孱弱: 有⼀些实际开发中常⽤的功能需要⾃⼰进⾏封装\n\n使用步骤：\n\n * 配置中间件，在store的创建中配置\n\nimport {createstore, applymiddleware, compose} from 'redux';\nimport reducer from './reducer';\nimport thunk from 'redux-thunk'\n\n// 设置调试工具\nconst composeenhancers = window.__redux_devtools_extension_compose__ ? window.__redux_devtools_extension_compose__({}) : compose;\n// 设置中间件\nconst enhancer = composeenhancers(\n  applymiddleware(thunk)\n);\n\nconst store = createstore(reducer, enhancer);\n\nexport default store;\n\n\n * 添加一个返回函数的actioncreator，将异步请求逻辑放在里面\n\n/**\n  发送get请求，并生成相应action，更新store的函数\n  @param url {string} 请求地址\n  @param func {function} 真正需要生成的action对应的actioncreator\n  @return {function} \n*/\n// dispatch为自动接收的store.dispatch函数 \nexport const gethttpaction = (url, func) => (dispatch) => {\n    axios.get(url).then(function(res){\n        const action = func(res.data)\n        dispatch(action)\n    })\n}\n\n\n * 生成action，并发送action\n\ncomponentdidmount(){\n    var action = gethttpaction('/getdata', getinittodoitemaction)\n    // 发送函数类型的action时，该action的函数体会自动执行\n    store.dispatch(action)\n}\n\n\n（2）使用redux-saga中间件\n\nredux-saga优点:\n\n * 异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中\n * action摆脱thunk function: dispatch 的参数依然是⼀个纯粹的 action (fsa)，⽽不是充满 “⿊魔法” thunk function\n * 异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理\n * 功能强⼤: redux-saga提供了⼤量的saga 辅助函数和effect 创建器供开发者使⽤,开发者⽆须封装或者简单封装即可使⽤\n * 灵活: redux-saga可以将多个saga可以串⾏/并⾏组合起来,形成⼀个⾮常实⽤的异步flow\n * 易测试，提供了各种case的测试⽅案，包括mock task，分⽀覆盖等等\n\nredux-saga缺陷:\n\n * 额外的学习成本: redux-saga不仅在使⽤难以理解的 generator function,⽽且有数⼗个api,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和⼀整套思想\n * 体积庞⼤: 体积略⼤,代码近2000⾏，min版25kb左右\n * 功能过剩: 实际上并发控制等功能很难⽤到,但是我们依然需要引⼊这些代码\n * ts⽀持不友好: yield⽆法返回ts类型\n\nredux-saga可以捕获action，然后执行一个函数，那么可以把异步代码放在这个函数中，使用步骤如下：\n\n * 配置中间件\n\nimport {createstore, applymiddleware, compose} from 'redux';\nimport reducer from './reducer';\nimport createsagamiddleware from 'redux-saga'\nimport todolistsaga from './sagas'\n\nconst composeenhancers = window.__redux_devtools_extension_compose__ ? window.__redux_devtools_extension_compose__({}) : compose;\nconst sagamiddleware = createsagamiddleware()\n\nconst enhancer = composeenhancers(\n  applymiddleware(sagamiddleware)\n);\n\nconst store = createstore(reducer, enhancer);\nsagamiddleware.run(todolistsaga)\n\nexport default store;\n\n\n * 将异步请求放在sagas.js中\n\nimport {takeevery, put} from 'redux-saga/effects'\nimport {inittodolist} from './actioncreator'\nimport {get_init_item} from './actiontypes'\nimport axios from 'axios'\n\nfunction* func(){\n    try{\n        // 可以获取异步返回数据\n        const res = yield axios.get('/getdata')\n        const action = inittodolist(res.data)\n        // 将action发送到reducer\n        yield put(action)\n    }catch(e){\n        console.log('网络请求失败')\n    }\n}\n\nfunction* mysaga(){\n    // 自动捕获get_init_item类型的action，并执行func\n    yield takeevery(get_init_item, func)\n}\n\nexport default mysaga\n\n\n * 发送action\n\ncomponentdidmount(){\n  const action = getinittodoitemaction()\n  store.dispatch(action)\n}\n\n\n\n# 4. redux 怎么实现属性传递，介绍下原理\n\nreact-redux 数据传输∶ view-->action-->reducer-->store-->view。看下点击事件的数据是如何通过redux传到view上：\n\n * view 上的addclick 事件通过mapdispatchtoprops 把数据传到action ---> click:()=>dispatch(add)\n * action 的add 传到reducer上\n * reducer传到store上 const store = createstore(reducer);\n * store再通过 mapstatetoprops 映射穿到view上text:state.text\n\n代码示例∶\n\nimport react from 'react';\nimport reactdom from 'react-dom';\nimport { createstore } from 'redux';\nimport { provider, connect } from 'react-redux';\nclass app extends react.component{\n    render(){\n        let { text, click, clickr } = this.props;\n        return(\n            <div>\n                <div>数据:已有人{text}</div>\n                <div onclick={click}>加人</div>\n                <div onclick={clickr}>减人</div>\n            </div>\n        )\n    }\n}\nconst initialstate = {\n    text:5\n}\nconst reducer = function(state,action){\n    switch(action.type){\n        case 'add':\n            return {text:state.text+1}\n        case 'remove':\n            return {text:state.text-1}\n        default:\n            return initialstate;\n    }\n}\n\nlet add = {\n    type:'add'\n}\nlet remove = {\n    type:'remove'\n}\n\nconst store = createstore(reducer);\n\nlet mapstatetoprops = function (state){\n    return{\n        text:state.text\n    }\n}\n\nlet mapdispatchtoprops = function(dispatch){\n    return{\n        click:()=>dispatch(add),\n        clickr:()=>dispatch(remove)\n    }\n}\n\nconst app1 = connect(mapstatetoprops,mapdispatchtoprops)(app);\n\nreactdom.render(\n    <provider store = {store}>\n        <app1></app1>\n    </provider>,document.getelementbyid('root')\n)\n\n\n\n# 5. redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？\n\nredux 的中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点，换而言之，原本 view -→> action -> reducer -> store 的数据流加上中间件后变成了 view -> action -> middleware -> reducer -> store ，在这一环节可以做一些\"副作用\"的操作，如异步请求、打印日志等。\n\napplymiddleware源码：\n\nexport default function applymiddleware(...middlewares) {\n    return createstore => (...args) => {\n        // 利用传入的createstore和reducer和创建一个store\n        const store = createstore(...args)\n        let dispatch = () => {\n            throw new error()\n        }\n        const middlewareapi = {\n            getstate: store.getstate,\n            dispatch: (...args) => dispatch(...args)\n        }\n        // 让每个 middleware 带着 middlewareapi 这个参数分别执行一遍\n        const chain = middlewares.map(middleware => middleware(middlewareapi))\n        // 接着 compose 将 chain 中的所有匿名函数，组装成一个新的函数，即新的 dispatch\n        dispatch = compose(...chain)(store.dispatch)\n        return {\n            ...store,\n            dispatch\n        }\n    }\n}\n\n\n从applymiddleware中可以看出∶\n\n * redux中间件接受一个对象作为参数，对象的参数上有两个字段 dispatch 和 getstate，分别代表着 redux store 上的两个同名函数。\n * 柯里化函数两端一个是 middewares，一个是store.dispatch\n\n\n# 6. redux 请求中间件如何处理并发\n\n使用redux-saga redux-saga是一个管理redux应用异步操作的中间件，用于代替 redux-thunk 的。它通过创建 sagas 将所有异步操作逻辑存放在一个地方进行集中处理，以此将react中的同步操作与异步操作区分开来，以便于后期的管理与维护。 redux-saga如何处理并发：\n\n * takeevery\n\n可以让多个 saga 任务并行被 fork 执行。\n\nimport {\n    fork,\n    take\n} from \"redux-saga/effects\"\n\nconst takeevery = (pattern, saga, ...args) => fork(function*() {\n    while (true) {\n        const action = yield take(pattern)\n        yield fork(saga, ...args.concat(action))\n    }\n})\n\n\n * takelatest\n\ntakelatest 不允许多个 saga 任务并行地执行。一旦接收到新的发起的 action，它就会取消前面所有 fork 过的任务（如果这些任务还在执行的话）。 在处理 ajax 请求的时候，如果只希望获取最后那个请求的响应， takelatest 就会非常有用。\n\nimport {\n    cancel,\n    fork,\n    take\n} from \"redux-saga/effects\"\n\nconst takelatest = (pattern, saga, ...args) => fork(function*() {\n    let lasttask\n    while (true) {\n        const action = yield take(pattern)\n        if (lasttask) {\n            yield cancel(lasttask) // 如果任务已经结束，则 cancel 为空操作\n        }\n        lasttask = yield fork(saga, ...args.concat(action))\n    }\n})\n\n\n\n# 7. redux 状态管理器和变量挂载到 window 中有什么区别\n\n两者都是存储数据以供后期使用。但是redux状态更改可回溯——time travel，数据多了的时候可以很清晰的知道改动在哪里发生，完整的提供了一套状态管理模式。\n\n随着 javascript 单页应用开发日趋复杂，javascript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 ui状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。\n\n管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。 如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等等。前端开发者正在经受前所未有的复杂性，难道就这么放弃了吗?当然不是。\n\n这里的复杂性很大程度上来自于：我们总是将两个难以理清的概念混淆在一起：变化和异步。 可以称它们为曼妥思和可乐。如果把二者分开，能做的很好，但混到一起，就变得一团糟。一些库如 react 视图在视图层禁止异步和直接操作 dom来解决这个问题。美中不足的是，react 依旧把处理 state 中数据的问题留给了你。redux就是为了帮你解决这个问题。\n\n\n# 8. mobox 和 redux 有什么区别？\n\n（1）共同点\n\n * 为了解决状态管理混乱，无法有效同步的问题统一维护管理应用状态;\n * 某一状态只有一个可信数据来源（通常命名为store，指状态容器）;\n * 操作更新状态方式统一，并且可控（通常以action方式提供更新状态的途径）;\n * 支持将store与react组件连接，如react-redux，mobx- react;\n\n（2）区别 redux更多的是遵循flux模式的一种实现，是一个 javascript库，它关注点主要是以下几方面∶\n\n * action∶ 一个javascript对象，描述动作相关信息，主要包含type属性和payload属性∶\n   \n   o type∶ action 类型; o payload∶ 负载数据;\n   \n\n * reducer∶ 定义应用状态如何响应不同动作（action），如何更新状态;\n\n * store∶ 管理action和reducer及其关系的对象，主要提供以下功能∶\n   \n   o 维护应用状态并支持访问状态(getstate());\n   o 支持监听action的分发，更新状态(dispatch(action)); \n   o 支持订阅store的变更(subscribe(listener));\n   \n\n * 异步流∶ 由于redux所有对store状态的变更，都应该通过action触发，异步任务（通常都是业务或获取数据任务）也不例外，而为了不将业务或数据相关的任务混入react组件中，就需要使用其他框架配合管理异步任务流程，如redux-thunk，redux-saga等;\n\nmobx是一个透明函数响应式编程的状态管理库，它使得状态管理简单可伸缩∶\n\n * action∶定义改变状态的动作函数，包括如何变更状态;\n * store∶ 集中管理模块状态（state）和动作(action)\n * derivation（衍生）∶ 从应用状态中派生而出，且没有任何其他影响的数据\n\n对比总结：\n\n * redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中\n * redux使用plain object保存数据，需要手动处理变化后的操作;mobx适用observable保存数据，数据变化后自动处理响应的操作\n * redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数;mobx中的状态是可变的，可以直接对其进行修改\n * mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维;redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用\n * mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测;而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易\n\n\n# 9. redux 和 vuex 有什么区别，它们的共同思想\n\n（1）redux 和 vuex区别\n\n * vuex改进了redux中的action和reducer函数，以mutations变化函数取代reducer，无需switch，只需在对应的mutation函数里改变state值即可\n * vuex由于vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的state即可\n * vuex数据流的顺序是∶view调用store.commit提交对应的请求到store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）\n\n通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变；取消了action概念，不必传入特定的 action形式进行指定变更；弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;\n\n（2）共同思想\n\n * 单—的数据源\n * 变化可以预测\n\n本质上∶ redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案。\n\n\n# 10. redux 中间件是怎么拿到store 和 action? 然后怎么处理?\n\nredux中间件本质就是一个函数柯里化。redux applymiddleware api 源码中每个middleware 接受2个参数， store 的getstate 函数和dispatch 函数，分别获得store和action，最终返回一个函数。该函数会被传入 next 的下一个 middleware 的 dispatch 方法，并返回一个接收 action 的新函数，这个函数可以直接调用 next（action），或者在其他需要的时刻调用，甚至根本不去调用它。调用链中最后一个 middleware 会接受真实的 store的 dispatch 方法作为 next 参数，并借此结束调用链。所以，middleware 的函数签名是（{ getstate，dispatch })=> next => action。\n\n\n# 11. redux中的connect有什么作用\n\nconnect负责连接react和redux\n\n（1）获取state\n\nconnect 通过 context获取 provider 中的 store，通过store.getstate() 获取整个store tree 上所有state\n\n（2）包装原组件\n\n将state和action通过props的方式传入到原组件内部 wrapwithconnect 返回—个 reactcomponent 对 象 connect，connect 重 新 render 外部传入的原组件 wrappedcomponent ，并把 connect 中传入的 mapstatetoprops，mapdispatchtoprops与组件上原有的 props合并后，通过属性的方式传给wrappedcomponent\n\n（3）监听store tree变化\n\nconnect缓存了store tree中state的状态，通过当前state状态 和变更前 state 状态进行比较，从而确定是否调用 this.setstate()方法触发connect及其子组件的重新渲染",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "原型&继承",
      "frontmatter": {
        "title": "原型&继承",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/codeOutput/prototype/",
        "article": false
      },
      "regularPath": "/40.%E4%BB%A3%E7%A0%81%E7%AF%87/20.%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E7%AF%87/40.%E5%8E%9F%E5%9E%8B&%E7%BB%A7%E6%89%BF.html",
      "relativePath": "40.代码篇/20.代码输出结果篇/40.原型&继承.md",
      "key": "v-56d46bdc",
      "path": "/pages/codeOutput/prototype/",
      "headers": [
        {
          "level": 3,
          "title": "1. 代码输出结果",
          "slug": "_1-代码输出结果",
          "normalizedTitle": "1. 代码输出结果",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 代码输出结果",
          "slug": "_2-代码输出结果",
          "normalizedTitle": "2. 代码输出结果",
          "charIndex": 997
        },
        {
          "level": 3,
          "title": "3. 代码输出结果",
          "slug": "_3-代码输出结果",
          "normalizedTitle": "3. 代码输出结果",
          "charIndex": 2230
        },
        {
          "level": 3,
          "title": "4. 代码输出结果",
          "slug": "_4-代码输出结果",
          "normalizedTitle": "4. 代码输出结果",
          "charIndex": 2785
        },
        {
          "level": 3,
          "title": "5. 代码输出结果",
          "slug": "_5-代码输出结果",
          "normalizedTitle": "5. 代码输出结果",
          "charIndex": 3440
        },
        {
          "level": 3,
          "title": "6. 代码输出结果",
          "slug": "_6-代码输出结果",
          "normalizedTitle": "6. 代码输出结果",
          "charIndex": 3974
        },
        {
          "level": 3,
          "title": "7. 代码输出问题",
          "slug": "_7-代码输出问题",
          "normalizedTitle": "7. 代码输出问题",
          "charIndex": 4479
        },
        {
          "level": 3,
          "title": "8 代码输出问题",
          "slug": "_8-代码输出问题",
          "normalizedTitle": "8 代码输出问题",
          "charIndex": 5010
        },
        {
          "level": 3,
          "title": "9. 代码输出结果",
          "slug": "_9-代码输出结果",
          "normalizedTitle": "9. 代码输出结果",
          "charIndex": 7140
        }
      ],
      "headersStr": "1. 代码输出结果 2. 代码输出结果 3. 代码输出结果 4. 代码输出结果 5. 代码输出结果 6. 代码输出结果 7. 代码输出问题 8 代码输出问题 9. 代码输出结果",
      "content": "# 1. 代码输出结果\n\nfunction Person(name) {\n    this.name = name\n}\nvar p2 = new Person('king');\nconsole.log(p2.__proto__) //Person.prototype\nconsole.log(p2.__proto__.__proto__) //Object.prototype\nconsole.log(p2.__proto__.__proto__.__proto__) // null\nconsole.log(p2.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错\nconsole.log(p2.__proto__.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错\nconsole.log(p2.constructor)//Person\nconsole.log(p2.prototype)//undefined p2是实例，没有prototype属性\nconsole.log(Person.constructor)//Function 一个空函数\nconsole.log(Person.prototype)//打印出Person.prototype这个对象里所有的方法和属性\nconsole.log(Person.prototype.constructor)//Person\nconsole.log(Person.prototype.__proto__)// Object.prototype\nconsole.log(Person.__proto__) //Function.prototype\nconsole.log(Function.prototype.__proto__)//Object.prototype\nconsole.log(Function.__proto__)//Function.prototype\nconsole.log(Object.__proto__)//Function.prototype\nconsole.log(Object.prototype.__proto__)//null\n\n\n这道义题目考察原型、原型链的基础，记住就可以了。\n\n\n# 2. 代码输出结果\n\n// a\nfunction Foo () {\n getName = function () {\n   console.log(1);\n }\n return this;\n}\n// b\nFoo.getName = function () {\n console.log(2);\n}\n// c\nFoo.prototype.getName = function () {\n console.log(3);\n}\n// d\nvar getName = function () {\n console.log(4);\n}\n// e\nfunction getName () {\n console.log(5);\n}\n\nFoo.getName();           // 2\ngetName();               // 4\nFoo().getName();         // 1\ngetName();               // 1 \nnew Foo.getName();       // 2\nnew Foo().getName();     // 3\nnew new Foo().getName(); // 3\n\n\n输出结果：2 4 1 1 2 3 3\n\n解析：\n\n 1. Foo.getName()， Foo为一个函数对象，对象都可以有属性，b 处定义Foo的getName属性为函数，输出2；\n 2. getName()， 这里看d、e处，d为函数表达式，e为函数声明，两者区别在于变量提升，函数声明的 5 会被后边函数表达式的 4 覆盖；\n 3. ** Foo().getName()，** 这里要看a处，在Foo内部将全局的getName重新赋值为 console.log(1) 的函数，执行Foo()返回 this，这个this指向window，Foo().getName() 即为window.getName()，输出 1；\n 4. getName()， 上面3中，全局的getName已经被重新赋值，所以这里依然输出 1；\n 5. new Foo.getName()， 这里等价于 new (Foo.getName())，先执行 Foo.getName()，输出 2，然后new一个实例；\n 6. new Foo().getName()， 这 里等价于 (new Foo()).getName(), 先new一个Foo的实例，再执行这个实例的getName方法，但是这个实例本身没有这个方法，所以去原型链__protot__上边找，实例.protot === Foo.prototype，所以输出 3；\n 7. new new Foo().getName()， 这里等价于new (new Foo().getName())，如上述6，先输出 3，然后new 一个 new Foo().getName() 的实例。\n\n\n# 3. 代码输出结果\n\nvar F = function() {};\nObject.prototype.a = function() {\n  console.log('a');\n};\nFunction.prototype.b = function() {\n  console.log('b');\n}\nvar f = new F();\nf.a();\nf.b();\nF.a();\nF.b()\n\n\n输出结果：\n\na\nUncaught TypeError: f.b is not a function\na\nb\n\n\n解析：\n\n 1. f 并不是 Function 的实例，因为它本来就不是构造函数，调用的是 Function 原型链上的相关属性和方法，只能访问到 Object 原型链。所以 f.a() 输出 a ，而 f.b() 就报错了。\n 2. F 是个构造函数，而 F 是构造函数 Function 的一个实例。因为 F instanceof Object === true，F instanceof Function === true，由此可以得出结论：F 是 Object 和 Function 两个的实例，即 F 能访问到 a， 也能访问到 b。所以 F.a() 输出 a ，F.b() 输出 b。\n\n\n# 4. 代码输出结果\n\nfunction Foo(){\n    Foo.a = function(){\n        console.log(1);\n    }\n    this.a = function(){\n        console.log(2)\n    }\n}\n\nFoo.prototype.a = function(){\n    console.log(3);\n}\n\nFoo.a = function(){\n    console.log(4);\n}\n\nFoo.a();\nlet obj = new Foo();\nobj.a();\nFoo.a();\n\n\n输出结果：4 2 1\n\n解析：\n\n 1. Foo.a() 这个是调用 Foo 函数的静态方法 a，虽然 Foo 中有优先级更高的属性方法 a，但 Foo 此时没有被调用，所以此时输出 Foo 的静态方法 a 的结果：4\n 2. let obj = new Foo(); 使用了 new 方法调用了函数，返回了函数实例对象，此时 Foo 函数内部的属性方法初始化，原型链建立。\n 3. obj.a() ; 调用 obj 实例上的方法 a，该实例上目前有两个 a 方法：一个是内部属性方法，另一个是原型上的方法。当这两者都存在时，首先查找 ownProperty ，如果没有才去原型链上找，所以调用实例上的 a 输出：2\n 4. Foo.a() ; 根据第2步可知 Foo 函数内部的属性方法已初始化，覆盖了同名的静态方法，所以输出：1\n\n\n# 5. 代码输出结果\n\nfunction Dog() {\n  this.name = 'puppy'\n}\nDog.prototype.bark = () => {\n  console.log('woof!woof!')\n}\nconst dog = new Dog()\nconsole.log(Dog.prototype.constructor === Dog && dog.constructor === Dog && dog instanceof Dog)\n\n\n输出结果：true\n\n解析： 因为constructor是prototype上的属性，所以dog.constructor实际上就是指向Dog.prototype.constructor；constructor属性指向构造函数。instanceof而实际检测的是类型是否在实例的原型链上。\n\nconstructor是prototype上的属性，这一点很容易被忽略掉。constructor和instanceof 的作用是不同的，感性地来说，constructor的限制比较严格，它只能严格对比对象的构造函数是不是指定的值；而instanceof比较松散，只要检测的类型在原型链上，就会返回true。\n\n\n# 6. 代码输出结果\n\nvar A = {n: 4399};\nvar B =  function(){this.n = 9999};\nvar C =  function(){var n = 8888};\nB.prototype = A;\nC.prototype = A;\nvar b = new B();\nvar c = new C();\nA.n++\nconsole.log(b.n);\nconsole.log(c.n);\n\n\n输出结果：9999 4400\n\n解析：\n\n 1. console.log(b.n)，在查找b.n是首先查找 b 对象自身有没有 n 属性，如果没有会去原型（prototype）上查找，当执行var b = new B()时，函数内部this.n=9999(此时this指向 b) 返回b对象，b对象有自身的n属性，所以返回 9999。\n 2. console.log(c.n)，同理，当执行var c = new C()时，c对象没有自身的n属性，向上查找，找到原型 （prototype）上的 n 属性，因为 A.n++(此时对象A中的n为4400)， 所以返回4400。\n\n\n# 7. 代码输出问题\n\nfunction A(){\n}\nfunction B(a){\n　　this.a = a;\n}\nfunction C(a){\n　　if(a){\nthis.a = a;\n　　}\n}\nA.prototype.a = 1;\nB.prototype.a = 1;\nC.prototype.a = 1;\n \nconsole.log(new A().a);\nconsole.log(new B().a);\nconsole.log(new C(2).a);\n\n\n输出结果：1 undefined 2\n\n解析：\n\n 1. console.log(new A().a)，new A()为构造函数创建的对象，本身没有a属性，所以向它的原型去找，发现原型的a属性的属性值为1，故该输出值为1；\n 2. console.log(new B().a)，ew B()为构造函数创建的对象，该构造函数有参数a，但该对象没有传参，故该输出值为undefined;\n 3. console.log(new C(2).a)，new C()为构造函数创建的对象，该构造函数有参数a，且传的实参为2，执行函数内部，发现if为真，执行this.a = 2,故属性a的值为2。\n\n\n# 8 代码输出问题\n\nfunction Parent() {\n    this.a = 1;\n    this.b = [1, 2, this.a];\n    this.c = { demo: 5 };\n    this.show = function () {\n        console.log(this.a , this.b , this.c.demo );\n    }\n}\n\nfunction Child() {\n    this.a = 2;\n    this.change = function () {\n        this.b.push(this.a);\n        this.a = this.b.length;\n        this.c.demo = this.a++;\n    }\n}\n\nChild.prototype = new Parent();\nvar parent = new Parent();\nvar child1 = new Child();\nvar child2 = new Child();\nchild1.a = 11;\nchild2.a = 12;\nparent.show();\nchild1.show();\nchild2.show();\nchild1.change();\nchild2.change();\nparent.show();\nchild1.show();\nchild2.show();\n\n\n输出结果：\n\nparent.show(); // 1  [1,2,1] 5\n\nchild1.show(); // 11 [1,2,1] 5\nchild2.show(); // 12 [1,2,1] 5\n\nparent.show(); // 1 [1,2,1] 5\n\nchild1.show(); // 5 [1,2,1,11,12] 5\n\nchild2.show(); // 6 [1,2,1,11,12] 5\n\n\n这道题目值得神帝，他涉及到的知识点很多，例如this的指向、原型、原型链、类的继承、数据类型等。\n\n解析：\n\n 1. parent.show()，可以直接获得所需的值，没啥好说的；\n 2. child1.show()，Child的构造函数原本是指向Child的，题目显式将Child类的原型对象指向了Parent类的一个实例，需要注意Child.prototype指向的是Parent的实例parent，而不是指向Parent这个类。\n 3. child2.show()，这个也没啥好说的；\n 4. parent.show()，parent是一个Parent类的实例，Child.prorotype指向的是Parent类的另一个实例，两者在堆内存中互不影响，所以上述操作不影响parent实例，所以输出结果不变；\n 5. child1.show()，child1执行了change()方法后，发生了怎样的变化呢?\n\n * this.b.push(this.a)，**由于this的动态指向特性，this.b会指向Child.prototype上的**b数组,this.a会指向child1的a属性,所以Child.prototype.b变成了**[1,2,1,11]**;\n * **this.a = this.b.length，*这条语句中this.a和this.b的指向与上一句一致，故结果为child1.a变为*4;\n * this.c.demo = this.a++，**由于child1自身属性并没有**c这个属性，所以此处的this.c会指向Child.prototype.c，this.a值为4，为原始类型，故赋值操作时会直接赋值，Child.prototype.c.demo的结果为4，而this.a随后自增为5(4 + 1 = 5)。\n\n 1. child2执行了change()方法, 而child2和child1均是Child类的实例，所以他们的原型链指向同一个原型对象Child.prototype,也就是同一个parent实例，所以child2.change()中所有影响到原型对象的语句都会影响child1的最终输出结果。\n\n * this.b.push(this.a)，**由于this的动态指向特性，this.b会指向Child.prototype上的**b数组,this.a会指向child2的a属性,所以Child.prototype.b变成了**[1,2,1,11,12]**;\n * **this.a = this.b.length，*这条语句中this.a和this.b的指向与上一句一致，故结果为child2.a变为*5;\n * this.c.demo = this.a++，**由于child2自身属性并没有**c这个属性，所以此处的this.c会指向Child.prototype.c，故执行结果为Child.prototype.c.demo的值变为child2.a的值5，而child2.a最终自增为6(5 + 1 = 6)。\n\n\n# 9. 代码输出结果\n\nfunction SuperType(){\n    this.property = true;\n}\n\nSuperType.prototype.getSuperValue = function(){\n    return this.property;\n};\n\nfunction SubType(){\n    this.subproperty = false;\n}\n\nSubType.prototype = new SuperType();\nSubType.prototype.getSubValue = function (){\n    return this.subproperty;\n};\n\nvar instance = new SubType();\nconsole.log(instance.getSuperValue());\n\n\n输出结果：true\n\n实际上，这段代码就是在实现原型链继承，SubType继承了SuperType，本质是重写了SubType的原型对象，代之以一个新类型的实例。SubType的原型被重写了，所以instance.constructor指向的是SuperType。具体如下：",
      "normalizedContent": "# 1. 代码输出结果\n\nfunction person(name) {\n    this.name = name\n}\nvar p2 = new person('king');\nconsole.log(p2.__proto__) //person.prototype\nconsole.log(p2.__proto__.__proto__) //object.prototype\nconsole.log(p2.__proto__.__proto__.__proto__) // null\nconsole.log(p2.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错\nconsole.log(p2.__proto__.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错\nconsole.log(p2.constructor)//person\nconsole.log(p2.prototype)//undefined p2是实例，没有prototype属性\nconsole.log(person.constructor)//function 一个空函数\nconsole.log(person.prototype)//打印出person.prototype这个对象里所有的方法和属性\nconsole.log(person.prototype.constructor)//person\nconsole.log(person.prototype.__proto__)// object.prototype\nconsole.log(person.__proto__) //function.prototype\nconsole.log(function.prototype.__proto__)//object.prototype\nconsole.log(function.__proto__)//function.prototype\nconsole.log(object.__proto__)//function.prototype\nconsole.log(object.prototype.__proto__)//null\n\n\n这道义题目考察原型、原型链的基础，记住就可以了。\n\n\n# 2. 代码输出结果\n\n// a\nfunction foo () {\n getname = function () {\n   console.log(1);\n }\n return this;\n}\n// b\nfoo.getname = function () {\n console.log(2);\n}\n// c\nfoo.prototype.getname = function () {\n console.log(3);\n}\n// d\nvar getname = function () {\n console.log(4);\n}\n// e\nfunction getname () {\n console.log(5);\n}\n\nfoo.getname();           // 2\ngetname();               // 4\nfoo().getname();         // 1\ngetname();               // 1 \nnew foo.getname();       // 2\nnew foo().getname();     // 3\nnew new foo().getname(); // 3\n\n\n输出结果：2 4 1 1 2 3 3\n\n解析：\n\n 1. foo.getname()， foo为一个函数对象，对象都可以有属性，b 处定义foo的getname属性为函数，输出2；\n 2. getname()， 这里看d、e处，d为函数表达式，e为函数声明，两者区别在于变量提升，函数声明的 5 会被后边函数表达式的 4 覆盖；\n 3. ** foo().getname()，** 这里要看a处，在foo内部将全局的getname重新赋值为 console.log(1) 的函数，执行foo()返回 this，这个this指向window，foo().getname() 即为window.getname()，输出 1；\n 4. getname()， 上面3中，全局的getname已经被重新赋值，所以这里依然输出 1；\n 5. new foo.getname()， 这里等价于 new (foo.getname())，先执行 foo.getname()，输出 2，然后new一个实例；\n 6. new foo().getname()， 这 里等价于 (new foo()).getname(), 先new一个foo的实例，再执行这个实例的getname方法，但是这个实例本身没有这个方法，所以去原型链__protot__上边找，实例.protot === foo.prototype，所以输出 3；\n 7. new new foo().getname()， 这里等价于new (new foo().getname())，如上述6，先输出 3，然后new 一个 new foo().getname() 的实例。\n\n\n# 3. 代码输出结果\n\nvar f = function() {};\nobject.prototype.a = function() {\n  console.log('a');\n};\nfunction.prototype.b = function() {\n  console.log('b');\n}\nvar f = new f();\nf.a();\nf.b();\nf.a();\nf.b()\n\n\n输出结果：\n\na\nuncaught typeerror: f.b is not a function\na\nb\n\n\n解析：\n\n 1. f 并不是 function 的实例，因为它本来就不是构造函数，调用的是 function 原型链上的相关属性和方法，只能访问到 object 原型链。所以 f.a() 输出 a ，而 f.b() 就报错了。\n 2. f 是个构造函数，而 f 是构造函数 function 的一个实例。因为 f instanceof object === true，f instanceof function === true，由此可以得出结论：f 是 object 和 function 两个的实例，即 f 能访问到 a， 也能访问到 b。所以 f.a() 输出 a ，f.b() 输出 b。\n\n\n# 4. 代码输出结果\n\nfunction foo(){\n    foo.a = function(){\n        console.log(1);\n    }\n    this.a = function(){\n        console.log(2)\n    }\n}\n\nfoo.prototype.a = function(){\n    console.log(3);\n}\n\nfoo.a = function(){\n    console.log(4);\n}\n\nfoo.a();\nlet obj = new foo();\nobj.a();\nfoo.a();\n\n\n输出结果：4 2 1\n\n解析：\n\n 1. foo.a() 这个是调用 foo 函数的静态方法 a，虽然 foo 中有优先级更高的属性方法 a，但 foo 此时没有被调用，所以此时输出 foo 的静态方法 a 的结果：4\n 2. let obj = new foo(); 使用了 new 方法调用了函数，返回了函数实例对象，此时 foo 函数内部的属性方法初始化，原型链建立。\n 3. obj.a() ; 调用 obj 实例上的方法 a，该实例上目前有两个 a 方法：一个是内部属性方法，另一个是原型上的方法。当这两者都存在时，首先查找 ownproperty ，如果没有才去原型链上找，所以调用实例上的 a 输出：2\n 4. foo.a() ; 根据第2步可知 foo 函数内部的属性方法已初始化，覆盖了同名的静态方法，所以输出：1\n\n\n# 5. 代码输出结果\n\nfunction dog() {\n  this.name = 'puppy'\n}\ndog.prototype.bark = () => {\n  console.log('woof!woof!')\n}\nconst dog = new dog()\nconsole.log(dog.prototype.constructor === dog && dog.constructor === dog && dog instanceof dog)\n\n\n输出结果：true\n\n解析： 因为constructor是prototype上的属性，所以dog.constructor实际上就是指向dog.prototype.constructor；constructor属性指向构造函数。instanceof而实际检测的是类型是否在实例的原型链上。\n\nconstructor是prototype上的属性，这一点很容易被忽略掉。constructor和instanceof 的作用是不同的，感性地来说，constructor的限制比较严格，它只能严格对比对象的构造函数是不是指定的值；而instanceof比较松散，只要检测的类型在原型链上，就会返回true。\n\n\n# 6. 代码输出结果\n\nvar a = {n: 4399};\nvar b =  function(){this.n = 9999};\nvar c =  function(){var n = 8888};\nb.prototype = a;\nc.prototype = a;\nvar b = new b();\nvar c = new c();\na.n++\nconsole.log(b.n);\nconsole.log(c.n);\n\n\n输出结果：9999 4400\n\n解析：\n\n 1. console.log(b.n)，在查找b.n是首先查找 b 对象自身有没有 n 属性，如果没有会去原型（prototype）上查找，当执行var b = new b()时，函数内部this.n=9999(此时this指向 b) 返回b对象，b对象有自身的n属性，所以返回 9999。\n 2. console.log(c.n)，同理，当执行var c = new c()时，c对象没有自身的n属性，向上查找，找到原型 （prototype）上的 n 属性，因为 a.n++(此时对象a中的n为4400)， 所以返回4400。\n\n\n# 7. 代码输出问题\n\nfunction a(){\n}\nfunction b(a){\n　　this.a = a;\n}\nfunction c(a){\n　　if(a){\nthis.a = a;\n　　}\n}\na.prototype.a = 1;\nb.prototype.a = 1;\nc.prototype.a = 1;\n \nconsole.log(new a().a);\nconsole.log(new b().a);\nconsole.log(new c(2).a);\n\n\n输出结果：1 undefined 2\n\n解析：\n\n 1. console.log(new a().a)，new a()为构造函数创建的对象，本身没有a属性，所以向它的原型去找，发现原型的a属性的属性值为1，故该输出值为1；\n 2. console.log(new b().a)，ew b()为构造函数创建的对象，该构造函数有参数a，但该对象没有传参，故该输出值为undefined;\n 3. console.log(new c(2).a)，new c()为构造函数创建的对象，该构造函数有参数a，且传的实参为2，执行函数内部，发现if为真，执行this.a = 2,故属性a的值为2。\n\n\n# 8 代码输出问题\n\nfunction parent() {\n    this.a = 1;\n    this.b = [1, 2, this.a];\n    this.c = { demo: 5 };\n    this.show = function () {\n        console.log(this.a , this.b , this.c.demo );\n    }\n}\n\nfunction child() {\n    this.a = 2;\n    this.change = function () {\n        this.b.push(this.a);\n        this.a = this.b.length;\n        this.c.demo = this.a++;\n    }\n}\n\nchild.prototype = new parent();\nvar parent = new parent();\nvar child1 = new child();\nvar child2 = new child();\nchild1.a = 11;\nchild2.a = 12;\nparent.show();\nchild1.show();\nchild2.show();\nchild1.change();\nchild2.change();\nparent.show();\nchild1.show();\nchild2.show();\n\n\n输出结果：\n\nparent.show(); // 1  [1,2,1] 5\n\nchild1.show(); // 11 [1,2,1] 5\nchild2.show(); // 12 [1,2,1] 5\n\nparent.show(); // 1 [1,2,1] 5\n\nchild1.show(); // 5 [1,2,1,11,12] 5\n\nchild2.show(); // 6 [1,2,1,11,12] 5\n\n\n这道题目值得神帝，他涉及到的知识点很多，例如this的指向、原型、原型链、类的继承、数据类型等。\n\n解析：\n\n 1. parent.show()，可以直接获得所需的值，没啥好说的；\n 2. child1.show()，child的构造函数原本是指向child的，题目显式将child类的原型对象指向了parent类的一个实例，需要注意child.prototype指向的是parent的实例parent，而不是指向parent这个类。\n 3. child2.show()，这个也没啥好说的；\n 4. parent.show()，parent是一个parent类的实例，child.prorotype指向的是parent类的另一个实例，两者在堆内存中互不影响，所以上述操作不影响parent实例，所以输出结果不变；\n 5. child1.show()，child1执行了change()方法后，发生了怎样的变化呢?\n\n * this.b.push(this.a)，**由于this的动态指向特性，this.b会指向child.prototype上的**b数组,this.a会指向child1的a属性,所以child.prototype.b变成了**[1,2,1,11]**;\n * **this.a = this.b.length，*这条语句中this.a和this.b的指向与上一句一致，故结果为child1.a变为*4;\n * this.c.demo = this.a++，**由于child1自身属性并没有**c这个属性，所以此处的this.c会指向child.prototype.c，this.a值为4，为原始类型，故赋值操作时会直接赋值，child.prototype.c.demo的结果为4，而this.a随后自增为5(4 + 1 = 5)。\n\n 1. child2执行了change()方法, 而child2和child1均是child类的实例，所以他们的原型链指向同一个原型对象child.prototype,也就是同一个parent实例，所以child2.change()中所有影响到原型对象的语句都会影响child1的最终输出结果。\n\n * this.b.push(this.a)，**由于this的动态指向特性，this.b会指向child.prototype上的**b数组,this.a会指向child2的a属性,所以child.prototype.b变成了**[1,2,1,11,12]**;\n * **this.a = this.b.length，*这条语句中this.a和this.b的指向与上一句一致，故结果为child2.a变为*5;\n * this.c.demo = this.a++，**由于child2自身属性并没有**c这个属性，所以此处的this.c会指向child.prototype.c，故执行结果为child.prototype.c.demo的值变为child2.a的值5，而child2.a最终自增为6(5 + 1 = 6)。\n\n\n# 9. 代码输出结果\n\nfunction supertype(){\n    this.property = true;\n}\n\nsupertype.prototype.getsupervalue = function(){\n    return this.property;\n};\n\nfunction subtype(){\n    this.subproperty = false;\n}\n\nsubtype.prototype = new supertype();\nsubtype.prototype.getsubvalue = function (){\n    return this.subproperty;\n};\n\nvar instance = new subtype();\nconsole.log(instance.getsupervalue());\n\n\n输出结果：true\n\n实际上，这段代码就是在实现原型链继承，subtype继承了supertype，本质是重写了subtype的原型对象，代之以一个新类型的实例。subtype的原型被重写了，所以instance.constructor指向的是supertype。具体如下：",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "HTTP协议",
      "frontmatter": {
        "title": "HTTP协议",
        "date": "2022-08-03T21:31:15.000Z",
        "permalink": "/pages/network/http/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/10.HTTP%E5%8D%8F%E8%AE%AE.html",
      "relativePath": "50.性能&网络篇/10.计算机网络篇/10.HTTP协议.md",
      "key": "v-0cbeb6e8",
      "path": "/pages/network/http/",
      "headers": [
        {
          "level": 3,
          "title": "1. GET和POST的请求的区别",
          "slug": "_1-get和post的请求的区别",
          "normalizedTitle": "1. get和post的请求的区别",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. POST和PUT请求的区别",
          "slug": "_2-post和put请求的区别",
          "normalizedTitle": "2. post和put请求的区别",
          "charIndex": 470
        },
        {
          "level": 3,
          "title": "3. 常见的HTTP请求头和响应头",
          "slug": "_3-常见的http请求头和响应头",
          "normalizedTitle": "3. 常见的http请求头和响应头",
          "charIndex": 630
        },
        {
          "level": 3,
          "title": "4. HTTP状态码304是多好还是少好",
          "slug": "_4-http状态码304是多好还是少好",
          "normalizedTitle": "4. http状态码304是多好还是少好",
          "charIndex": 1458
        },
        {
          "level": 3,
          "title": "5. 常见的HTTP请求方法",
          "slug": "_5-常见的http请求方法",
          "normalizedTitle": "5. 常见的http请求方法",
          "charIndex": 1866
        },
        {
          "level": 3,
          "title": "6. OPTIONS请求方法及使用场景",
          "slug": "_6-options请求方法及使用场景",
          "normalizedTitle": "6. options请求方法及使用场景",
          "charIndex": 2113
        },
        {
          "level": 3,
          "title": "7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？",
          "slug": "_7-http-1-0-和-http-1-1-之间有哪些区别",
          "normalizedTitle": "7. http 1.0 和 http 1.1 之间有哪些区别？",
          "charIndex": 2419
        },
        {
          "level": 3,
          "title": "8. HTTP 1.1 和 HTTP 2.0 的区别",
          "slug": "_8-http-1-1-和-http-2-0-的区别",
          "normalizedTitle": "8. http 1.1 和 http 2.0 的区别",
          "charIndex": 3172
        },
        {
          "level": 3,
          "title": "9. HTTP和HTTPS协议的区别",
          "slug": "_9-http和https协议的区别",
          "normalizedTitle": "9. http和https协议的区别",
          "charIndex": 4259
        },
        {
          "level": 3,
          "title": "10. GET方法URL长度限制的原因",
          "slug": "_10-get方法url长度限制的原因",
          "normalizedTitle": "10. get方法url长度限制的原因",
          "charIndex": 4508
        },
        {
          "level": 3,
          "title": "11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？",
          "slug": "_11-当在浏览器中输入-google-com-并且按下回车之后发生了什么",
          "normalizedTitle": "11. 当在浏览器中输入 google.com 并且按下回车之后发生了什么？",
          "charIndex": 5229
        },
        {
          "level": 3,
          "title": "12. 对keep-alive的理解",
          "slug": "_12-对keep-alive的理解",
          "normalizedTitle": "12. 对keep-alive的理解",
          "charIndex": 7389
        },
        {
          "level": 3,
          "title": "13. 页面有多张图片，HTTP是怎样的加载表现？",
          "slug": "_13-页面有多张图片-http是怎样的加载表现",
          "normalizedTitle": "13. 页面有多张图片，http是怎样的加载表现？",
          "charIndex": 8388
        },
        {
          "level": 3,
          "title": "14. HTTP2的头部压缩算法是怎样的？",
          "slug": "_14-http2的头部压缩算法是怎样的",
          "normalizedTitle": "14. http2的头部压缩算法是怎样的？",
          "charIndex": 8561
        },
        {
          "level": 3,
          "title": "15. HTTP请求报文的是什么样的？",
          "slug": "_15-http请求报文的是什么样的",
          "normalizedTitle": "15. http请求报文的是什么样的？",
          "charIndex": 8876
        },
        {
          "level": 3,
          "title": "16. HTTP响应报文的是什么样的？",
          "slug": "_16-http响应报文的是什么样的",
          "normalizedTitle": "16. http响应报文的是什么样的？",
          "charIndex": 9175
        },
        {
          "level": 3,
          "title": "17. HTTP协议的优点和缺点",
          "slug": "_17-http协议的优点和缺点",
          "normalizedTitle": "17. http协议的优点和缺点",
          "charIndex": 9324
        },
        {
          "level": 3,
          "title": "18. 说一下HTTP 3.0",
          "slug": "_18-说一下http-3-0",
          "normalizedTitle": "18. 说一下http 3.0",
          "charIndex": 9948
        },
        {
          "level": 3,
          "title": "19. HTTP协议的性能怎么样",
          "slug": "_19-http协议的性能怎么样",
          "normalizedTitle": "19. http协议的性能怎么样",
          "charIndex": 10243
        },
        {
          "level": 3,
          "title": "20. URL有哪些组成部分",
          "slug": "_20-url有哪些组成部分",
          "normalizedTitle": "20. url有哪些组成部分",
          "charIndex": 11172
        },
        {
          "level": 3,
          "title": "21. 与缓存相关的HTTP请求头有哪些",
          "slug": "_21-与缓存相关的http请求头有哪些",
          "normalizedTitle": "21. 与缓存相关的http请求头有哪些",
          "charIndex": 11952
        }
      ],
      "headersStr": "1. GET和POST的请求的区别 2. POST和PUT请求的区别 3. 常见的HTTP请求头和响应头 4. HTTP状态码304是多好还是少好 5. 常见的HTTP请求方法 6. OPTIONS请求方法及使用场景 7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？ 8. HTTP 1.1 和 HTTP 2.0 的区别 9. HTTP和HTTPS协议的区别 10. GET方法URL长度限制的原因 11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？ 12. 对keep-alive的理解 13. 页面有多张图片，HTTP是怎样的加载表现？ 14. HTTP2的头部压缩算法是怎样的？ 15. HTTP请求报文的是什么样的？ 16. HTTP响应报文的是什么样的？ 17. HTTP协议的优点和缺点 18. 说一下HTTP 3.0 19. HTTP协议的性能怎么样 20. URL有哪些组成部分 21. 与缓存相关的HTTP请求头有哪些",
      "content": "# 1. GET和POST的请求的区别\n\nPost 和 Get 是 HTTP 请求的两种方法，其区别如下：\n\n * 应用场景： GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。\n * 是否缓存： 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。\n * 发送的报文格式： Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。\n * 安全性： Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。\n * 请求长度： 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。\n * 参数类型： post 的参数传递支持更多的数据类型。\n\n\n# 2. POST和PUT请求的区别\n\n * PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时更新数据）\n * POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是创建数据）\n\n\n# 3. 常见的HTTP请求头和响应头\n\nHTTP Request Header 常见的请求头：\n\n * Accept:浏览器能够处理的内容类型\n * Accept-Charset:浏览器能够显示的字符集\n * Accept-Encoding：浏览器能够处理的压缩编码\n * Accept-Language：浏览器当前设置的语言\n * Connection：浏览器与服务器之间连接的类型\n * Cookie：当前页面设置的任何Cookie\n * Host：发出请求的页面所在的域\n * Referer：发出请求的页面的URL\n * User-Agent：浏览器的用户代理字符串\n\nHTTP Responses Header 常见的响应头：\n\n * Date：表示消息发送的时间，时间的描述格式由rfc822定义\n * server:服务器名称\n * Connection：浏览器与服务器之间连接的类型\n * Cache-Control：控制HTTP缓存\n * content-type:表示后面的文档属于什么MIME类型\n\n常见的 Content-Type 属性值有以下四种：\n\n（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。\n\n（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。\n\n（3）application/json：服务器消息主体是序列化后的 JSON 字符串。\n\n（4）text/xml：该种方式主要用来提交 XML 格式的数据。\n\n\n# 4. HTTP状态码304是多好还是少好\n\n服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。\n\n状态码304不应该认为是一种错误，而是对客户端有缓存情况下服务端的一种响应。\n\n搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。\n\n产生较多304状态码的原因：\n\n * 页面更新周期长或不更新\n * 纯静态页面或强制生成静态html\n\n304状态码出现过多会造成以下问题：\n\n * 网站快照停止；\n * 收录减少；\n * 权重下降。\n\n\n# 5. 常见的HTTP请求方法\n\n * GET: 向服务器获取数据；\n * POST：将实体提交到指定的资源，通常会造成服务器资源的修改；\n * PUT：上传文件，更新数据；\n * DELETE：删除服务器上的对象；\n * HEAD：获取报文首部，与GET相比，不返回报文主体部分；\n * OPTIONS：询问支持的请求方法，用来跨域请求；\n * CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；\n * TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。\n\n\n# 6. OPTIONS请求方法及使用场景\n\nOPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。\n\nOPTIONS方法是用于请求获得由Request-URI标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。\n\nOPTIONS请求方法的主要用途有两个：\n\n * 获取服务器支持的所有HTTP请求方法；\n * 用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。\n\n\n# 7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？\n\nHTTP 1.0和 HTTP 1.1 有以下区别：\n\n * 连接方面，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。\n * 资源请求方面，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\n * 缓存方面，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。\n * http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。\n * http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。\n\n\n# 8. HTTP 1.1 和 HTTP 2.0 的区别\n\n * 二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为\"帧\"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。\n * 多路复用： HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了\"队头堵塞\"【1】的问题。\n * 数据流： HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。\n * 头信息压缩： HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。\n * 服务器推送： HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。\n\n【1】队头堵塞：\n\n> 队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。\n\n\n# 9. HTTP和HTTPS协议的区别\n\nHTTP和HTTPS协议的主要区别如下：\n\n * HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；\n * HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；\n * 使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；\n * HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。\n\n\n# 10. GET方法URL长度限制的原因\n\n实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。 IE对URL长度的限制是2083字节(2K+35)。由于IE浏览器对URL长度的允许值是最小的，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。\n\nGET的长度值 = URL（2083）- （你的Domain+Path）-2（2是get请求中?=两个字符的长度）\n\n\n下面看一下主流浏览器对get方法中url的长度限制范围：\n\n * Microsoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。\n * Firefox (Browser)：对于Firefox浏览器URL的长度限制为 65,536 个字符。\n * Safari (Browser)：URL最大长度限制为 80,000 个字符。\n * Opera (Browser)：URL最大长度限制为 190,000 个字符。\n * Google (chrome)：URL最大长度限制为 8182 个字符。\n\n主流的服务器对get方法中url的长度限制范围：\n\n * Apache (Server)：能接受最大url长度为8192个字符。\n * Microsoft Internet Information Server(IIS)：能接受最大url的长度为16384个字符。\n\n根据上面的数据，可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。\n\n\n# 11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？\n\n（1）解析URL： 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。\n\n（2）缓存判断： 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。\n\n（3）DNS解析： 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。\n\n（4）获取MAC地址： 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。\n\n（5）TCP三次握手： 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。\n\n（6）HTTPS握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。\n\n（7）返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。\n\n（8）页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。\n\n（9）TCP四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。\n\n\n# 12. 对keep-alive的理解\n\nHTTP1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是短连接。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是长连接。其使用方法如下：\n\n * HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送Connection: keep-alive字段。若想断开keep-alive连接，需发送Connection:close字段；\n * HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送Connection：close首部字段。\n\nKeep-Alive的建立过程：\n\n * 客户端向服务器在发送请求报文同时在首部添加发送Connection字段\n * 服务器收到请求并处理 Connection字段\n * 服务器回送Connection:Keep-Alive字段给客户端\n * 客户端接收到Connection字段\n * Keep-Alive连接建立成功\n\n服务端自动断开过程（也就是没有keep-alive）：\n\n * 客户端向服务器只是发送内容报文（不包含Connection字段）\n * 服务器收到请求并处理\n * 服务器返回客户端请求的资源并关闭连接\n * 客户端接收资源，发现没有Connection字段，断开连接\n\n客户端请求断开连接过程：\n\n * 客户端向服务器发送Connection:close字段\n * 服务器收到请求并处理connection字段\n * 服务器回送响应资源并断开连接\n * 客户端接收资源并断开连接\n\n开启Keep-Alive的优点：\n\n * 较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；\n * 允许请求和应答的HTTP管线化；\n * 降低拥塞控制 （TCP连接减少了）；\n * 减少了后续请求的延迟（⽆需再进⾏握⼿）；\n * 报告错误⽆需关闭TCP连；\n\n开启Keep-Alive的缺点：\n\n * 长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。\n\n\n# 13. 页面有多张图片，HTTP是怎样的加载表现？\n\n * 在HTTP 1下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。\n * 在HTTP 2下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。\n\n\n# 14. HTTP2的头部压缩算法是怎样的？\n\nHTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。\n\n具体来说:\n\n * 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；\n * 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；\n * 每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。\n\n例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。\n\n\n# 15. HTTP请求报文的是什么样的？\n\n请求报⽂有4部分组成:\n\n * 请求⾏\n * 请求头部\n * 空⾏\n * 请求体\n\n其中： （1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 （2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔\n\n * User-Agent：产⽣请求的浏览器类型。\n * Accept：客户端可识别的内容类型列表。\n * Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。\n\n（3）请求体: post put等请求携带的数据\n\n\n# 16. HTTP响应报文的是什么样的？\n\n请求报⽂有4部分组成:\n\n * 响应⾏\n * 响应头\n * 空⾏\n * 响应体\n\n\n\n * 响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。\n * 响应头：响应部⾸组成\n * 响应体：服务器响应的数据\n\n\n# 17. HTTP协议的优点和缺点\n\nHTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。\n\nHTTP协议具有以下优点：\n\n * 支持客户端/服务器模式\n * 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。\n * 无连接：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。\n * 无状态：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。\n * 灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。\n\nHTTP协议具有以下缺点：\n\n * 无状态： HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。\n * 明文传输： 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。\n * 不安全\n\n（1）通信使用明文（不加密），内容可能会被窃听； （2）不验证通信方的身份，因此有可能遭遇伪装； （3）无法证明报文的完整性，所以有可能已遭篡改；\n\n\n# 18. 说一下HTTP 3.0\n\nHTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。\n\n 1. 流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。\n 2. 集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。\n 3. 多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。\n\n\n\n 1. 快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。\n\n\n# 19. HTTP协议的性能怎么样\n\nHTTP 协议是基于 TCP/IP，并且使用了请求-应答的通信模式，所以性能的关键就在这两点里。\n\n * 长连接\n\nHTTP协议有两种连接模式，一种是持续连接，一种非持续连接。 （1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。 （2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。\n\n对于不同版本的采用不同的连接方式：\n\n * 在HTTP/1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。\n * 在HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。\n\n\n\n * 管道网络传输\n\nHTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。\n\n管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。\n\n * 队头堵塞\n\nHTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。\n\n队头阻塞的解决方案： （1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。 （2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。\n\n\n# 20. URL有哪些组成部分\n\n以下面的URL为例：www.aspxfans.com:8080/news/index.…\n\n从上面的URL可以看出，一个完整的URL包括以下几部分：\n\n * 协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在\"HTTP\"后面的“//”为分隔符；\n * 域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用\n * 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；\n * 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；\n * 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；\n * 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；\n * 参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。\n\n\n# 21. 与缓存相关的HTTP请求头有哪些\n\n强缓存：\n\n * Expires\n * Cache-Control\n\n协商缓存：\n\n * Etag、If-None-Match\n * Last-Modified、If-Modified-Since",
      "normalizedContent": "# 1. get和post的请求的区别\n\npost 和 get 是 http 请求的两种方法，其区别如下：\n\n * 应用场景： get 请求是一个幂等的请求，一般 get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。\n * 是否缓存： 因为两者应用场景不同，浏览器一般会对 get 请求缓存，但很少对 post 请求缓存。\n * 发送的报文格式： get 请求的报文中实体部分为空，post 请求的报文中实体部分一般为向服务器发送的数据。\n * 安全性： get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。\n * 请求长度： 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 rfc 规定的。\n * 参数类型： post 的参数传递支持更多的数据类型。\n\n\n# 2. post和put请求的区别\n\n * put请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次put操作，其结果并没有不同。（可以理解为时更新数据）\n * post请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是创建数据）\n\n\n# 3. 常见的http请求头和响应头\n\nhttp request header 常见的请求头：\n\n * accept:浏览器能够处理的内容类型\n * accept-charset:浏览器能够显示的字符集\n * accept-encoding：浏览器能够处理的压缩编码\n * accept-language：浏览器当前设置的语言\n * connection：浏览器与服务器之间连接的类型\n * cookie：当前页面设置的任何cookie\n * host：发出请求的页面所在的域\n * referer：发出请求的页面的url\n * user-agent：浏览器的用户代理字符串\n\nhttp responses header 常见的响应头：\n\n * date：表示消息发送的时间，时间的描述格式由rfc822定义\n * server:服务器名称\n * connection：浏览器与服务器之间连接的类型\n * cache-control：控制http缓存\n * content-type:表示后面的文档属于什么mime类型\n\n常见的 content-type 属性值有以下四种：\n\n（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 url转码。\n\n（2）multipart/form-data：该种方式也是一个常见的 post 提交方式，通常表单上传文件时使用该种方式。\n\n（3）application/json：服务器消息主体是序列化后的 json 字符串。\n\n（4）text/xml：该种方式主要用来提交 xml 格式的数据。\n\n\n# 4. http状态码304是多好还是少好\n\n服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。\n\n状态码304不应该认为是一种错误，而是对客户端有缓存情况下服务端的一种响应。\n\n搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。\n\n产生较多304状态码的原因：\n\n * 页面更新周期长或不更新\n * 纯静态页面或强制生成静态html\n\n304状态码出现过多会造成以下问题：\n\n * 网站快照停止；\n * 收录减少；\n * 权重下降。\n\n\n# 5. 常见的http请求方法\n\n * get: 向服务器获取数据；\n * post：将实体提交到指定的资源，通常会造成服务器资源的修改；\n * put：上传文件，更新数据；\n * delete：删除服务器上的对象；\n * head：获取报文首部，与get相比，不返回报文主体部分；\n * options：询问支持的请求方法，用来跨域请求；\n * connect：要求在与代理服务器通信时建立隧道，使用隧道进行tcp通信；\n * trace: 回显服务器收到的请求，主要⽤于测试或诊断。\n\n\n# 6. options请求方法及使用场景\n\noptions是除了get和post之外的其中一种 http请求方法。\n\noptions方法是用于请求获得由request-uri标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。\n\noptions请求方法的主要用途有两个：\n\n * 获取服务器支持的所有http请求方法；\n * 用来检查访问权限。例如：在进行 cors 跨域资源共享时，对于复杂请求，就是使用 options 方法发送嗅探请求，以判断是否有对指定资源的访问权限。\n\n\n# 7. http 1.0 和 http 1.1 之间有哪些区别？\n\nhttp 1.0和 http 1.1 有以下区别：\n\n * 连接方面，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 tcp 连接，以此来避免使用非持久连接时每次需要建立连接的时延。\n * 资源请求方面，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（partial content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\n * 缓存方面，在 http1.0 中主要使用 header 里的 if-modified-since、expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 etag、if-unmodified-since、if-match、if-none-match 等更多可供选择的缓存头来控制缓存策略。\n * http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 ip 地址，因此，请求消息中的 url 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个ip地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。\n * http1.1 相对于 http1.0 还新增了很多请求方法，如 put、head、options 等。\n\n\n# 8. http 1.1 和 http 2.0 的区别\n\n * 二进制协议：http/2 是一个二进制协议。在 http/1.1 版中，报文的头信息必须是文本（ascii 编码），数据体可以是文本，也可以是二进制。http/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为\"帧\"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。\n * 多路复用： http/2 实现了多路复用，http/2 仍然复用 tcp 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了\"队头堵塞\"【1】的问题。\n * 数据流： http/2 使用了数据流的概念，因为 http/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。http/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 id ，用来区分它属于哪个数据流。\n * 头信息压缩： http/2 实现了头信息压缩，由于 http 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 cookie 和 user agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。http/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。\n * 服务器推送： http/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 websocket 以及使用 sse 等方式向客户端发送即时数据的推送是不同的。\n\n【1】队头堵塞：\n\n> 队头阻塞是由 http 基本的“请求 - 应答”模型所导致的。http 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。\n\n\n# 9. http和https协议的区别\n\nhttp和https协议的主要区别如下：\n\n * https协议需要ca证书，费用较高；而http协议不需要；\n * http协议是超文本传输协议，信息是明文传输的，https则是具有安全性的ssl加密传输协议；\n * 使用不同的连接方式，端口也不同，http协议端口是80，https协议端口是443；\n * http协议连接很简单，是无状态的；https协议是有ssl和http协议构建的可进行加密传输、身份认证的网络协议，比http更加安全。\n\n\n# 10. get方法url长度限制的原因\n\n实际上http协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。 ie对url长度的限制是2083字节(2k+35)。由于ie浏览器对url长度的允许值是最小的，所以开发过程中，只要url不超过2083字节，那么在所有浏览器中工作都不会有问题。\n\nget的长度值 = url（2083）- （你的domain+path）-2（2是get请求中?=两个字符的长度）\n\n\n下面看一下主流浏览器对get方法中url的长度限制范围：\n\n * microsoft internet explorer (browser)：ie浏览器对url的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。\n * firefox (browser)：对于firefox浏览器url的长度限制为 65,536 个字符。\n * safari (browser)：url最大长度限制为 80,000 个字符。\n * opera (browser)：url最大长度限制为 190,000 个字符。\n * google (chrome)：url最大长度限制为 8182 个字符。\n\n主流的服务器对get方法中url的长度限制范围：\n\n * apache (server)：能接受最大url长度为8192个字符。\n * microsoft internet information server(iis)：能接受最大url的长度为16384个字符。\n\n根据上面的数据，可以知道，get方法中的url长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。\n\n\n# 11. 当在浏览器中输入 google.com 并且按下回车之后发生了什么？\n\n（1）解析url： 首先会对 url 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 url 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 url 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。\n\n（2）缓存判断： 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。\n\n（3）dns解析： 下一步首先需要获取的是输入的 url 中的域名的 ip 地址，首先会判断本地是否有该域名的 ip 地址的缓存，如果有则使用，如果没有则向本地 dns 服务器发起请求。本地 dns 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 ip 地址后，本地 dns 服务器再将这个 ip 地址返回给请求的用户。用户向本地 dns 服务器发起请求属于递归请求，本地 dns 服务器向各级域名服务器发起请求属于迭代请求。\n\n（4）获取mac地址： 当浏览器得到 ip 地址后，数据传输还需要知道目的主机 mac 地址，因为应用层下发数据给传输层，tcp 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 ip 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 mac 地址，本机的 mac 地址作为源 mac 地址，目的 mac 地址需要分情况处理。通过将 ip 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 apr 协议获取到目的主机的 mac 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 arp 协议来获取网关的 mac 地址，此时目的主机的 mac 地址应该为网关的地址。\n\n（5）tcp三次握手： 下面是 tcp 建立连接的三次握手的过程，首先客户端向服务器发送一个 syn 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 syn ack报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ack 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。\n\n（6）https握手： 如果使用的是 https 协议，在通信前还存在 tls 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。\n\n（7）返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。\n\n（8）页面渲染： 浏览器首先会根据 html 文件构建 dom 树，根据解析到的 css 文件构建 cssom 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 dom 树和 cssom 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 ui 接口对页面进行绘制。这个时候整个页面就显示出来了。\n\n（9）tcp四次挥手： 最后一步是 tcp 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 tcp 链接。然后会发送 ack 包，并进入 close_wait 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 tcp 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 last-ack 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 time-wait 状态。该状态会持续 2msl（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 closed 状态。当服务端收到确认应答后，也便进入 closed 状态。\n\n\n# 12. 对keep-alive的理解\n\nhttp1.0 中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是短连接。当使用keep-alive模式时，keep-alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，keep-alive功能避免了建立或者重新建立连接，这就是长连接。其使用方法如下：\n\n * http1.0版本是默认没有keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送connection: keep-alive字段。若想断开keep-alive连接，需发送connection:close字段；\n * http1.1规定了默认保持长连接，数据传输完成了保持tcp连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送connection：close首部字段。\n\nkeep-alive的建立过程：\n\n * 客户端向服务器在发送请求报文同时在首部添加发送connection字段\n * 服务器收到请求并处理 connection字段\n * 服务器回送connection:keep-alive字段给客户端\n * 客户端接收到connection字段\n * keep-alive连接建立成功\n\n服务端自动断开过程（也就是没有keep-alive）：\n\n * 客户端向服务器只是发送内容报文（不包含connection字段）\n * 服务器收到请求并处理\n * 服务器返回客户端请求的资源并关闭连接\n * 客户端接收资源，发现没有connection字段，断开连接\n\n客户端请求断开连接过程：\n\n * 客户端向服务器发送connection:close字段\n * 服务器收到请求并处理connection字段\n * 服务器回送响应资源并断开连接\n * 客户端接收资源并断开连接\n\n开启keep-alive的优点：\n\n * 较少的cpu和内存的使⽤（由于同时打开的连接的减少了）；\n * 允许请求和应答的http管线化；\n * 降低拥塞控制 （tcp连接减少了）；\n * 减少了后续请求的延迟（⽆需再进⾏握⼿）；\n * 报告错误⽆需关闭tcp连；\n\n开启keep-alive的缺点：\n\n * 长时间的tcp连接容易导致系统资源无效占用，浪费系统资源。\n\n\n# 13. 页面有多张图片，http是怎样的加载表现？\n\n * 在http 1下，浏览器对一个域名下最大tcp连接数为6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。\n * 在http 2下，可以一瞬间加载出来很多资源，因为，http2支持多路复用，可以在一个tcp连接中发送多个http请求。\n\n\n# 14. http2的头部压缩算法是怎样的？\n\nhttp2的头部压缩是hpack算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。\n\n具体来说:\n\n * 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；\n * 首部表在http/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；\n * 每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。\n\n例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。\n\n\n# 15. http请求报文的是什么样的？\n\n请求报⽂有4部分组成:\n\n * 请求⾏\n * 请求头部\n * 空⾏\n * 请求体\n\n其中： （1）请求⾏包括：请求⽅法字段、url字段、http协议版本字段。它们⽤空格分隔。例如，get /index.html http/1.1。 （2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔\n\n * user-agent：产⽣请求的浏览器类型。\n * accept：客户端可识别的内容类型列表。\n * host：请求的主机名，允许多个域名同处⼀个ip地址，即虚拟主机。\n\n（3）请求体: post put等请求携带的数据\n\n\n# 16. http响应报文的是什么样的？\n\n请求报⽂有4部分组成:\n\n * 响应⾏\n * 响应头\n * 空⾏\n * 响应体\n\n\n\n * 响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 http/1.1 200 ok 。\n * 响应头：响应部⾸组成\n * 响应体：服务器响应的数据\n\n\n# 17. http协议的优点和缺点\n\nhttp 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 tcp 作为传输层协议，保证了数据传输的可靠性。\n\nhttp协议具有以下优点：\n\n * 支持客户端/服务器模式\n * 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 http 协议简单，使得 http 服务器的程序规模小，因而通信速度很快。\n * 无连接：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。\n * 无状态：http 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。\n * 灵活：http 允许传输任意类型的数据对象。正在传输的类型由 content-type 加以标记。\n\nhttp协议具有以下缺点：\n\n * 无状态： http 是一个无状态的协议，http 服务器不会保存关于客户的任何信息。\n * 明文传输： 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。\n * 不安全\n\n（1）通信使用明文（不加密），内容可能会被窃听； （2）不验证通信方的身份，因此有可能遭遇伪装； （3）无法证明报文的完整性，所以有可能已遭篡改；\n\n\n# 18. 说一下http 3.0\n\nhttp/3基于udp协议实现了类似于tcp的多路复用数据流、传输可靠性等功能，这套功能被称为quic协议。\n\n 1. 流量控制、传输可靠性功能：quic在udp的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些tcp中的特性。\n 2. 集成tls加密功能：目前quic使用tls1.3，减少了握手所花费的rtt数。\n 3. 多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了tcp的队头阻塞问题。\n\n\n\n 1. 快速握手：由于基于udp，可以实现使用0 ~ 1个rtt来建立连接。\n\n\n# 19. http协议的性能怎么样\n\nhttp 协议是基于 tcp/ip，并且使用了请求-应答的通信模式，所以性能的关键就在这两点里。\n\n * 长连接\n\nhttp协议有两种连接模式，一种是持续连接，一种非持续连接。 （1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。 （2）持续连接下，tcp 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 tcp 连接三次握手时所花费的时间。\n\n对于不同版本的采用不同的连接方式：\n\n * 在http/1.0 每发起一个请求，都要新建一次 tcp 连接（三次握手），而且是串行请求，做了无畏的 tcp 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 connection: keep-a live 来要求服务器不要关闭 tcp 连接。\n * 在http/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 tcp 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。\n\n\n\n * 管道网络传输\n\nhttp/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。\n\n管道（pipeline）网络传输是指：可以在同一个 tcp 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。\n\n * 队头堵塞\n\nhttp 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是http队头阻塞问题。\n\n队头阻塞的解决方案： （1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。 （2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。\n\n\n# 20. url有哪些组成部分\n\n以下面的url为例：www.aspxfans.com:8080/news/index.…\n\n从上面的url可以看出，一个完整的url包括以下几部分：\n\n * 协议部分：该url的协议部分为“http：”，这代表网页使用的是http协议。在internet中可以使用多种协议，如http，ftp等等本例中使用的是http协议。在\"http\"后面的“//”为分隔符；\n * 域名部分：该url的域名部分为“www.aspxfans.com”。一个url中，也可以使用ip地址作为域名使用\n * 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个url必须的部分，如果省略端口部分，将采用默认端口（http协议默认端口是80，https协议默认端口是443）；\n * 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个url必须的部分。本例中的虚拟目录是“/news/”；\n * 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个url必须的部分，如果省略该部分，则使用默认的文件名；\n * 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个url必须的部分；\n * 参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardid=5&id=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。\n\n\n# 21. 与缓存相关的http请求头有哪些\n\n强缓存：\n\n * expires\n * cache-control\n\n协商缓存：\n\n * etag、if-none-match\n * last-modified、if-modified-since",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "HTTPS协议",
      "frontmatter": {
        "title": "HTTPS协议",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/network/https/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/20.HTTPS%E5%8D%8F%E8%AE%AE.html",
      "relativePath": "50.性能&网络篇/10.计算机网络篇/20.HTTPS协议.md",
      "key": "v-6649af8a",
      "path": "/pages/network/https/",
      "headers": [
        {
          "level": 3,
          "title": "1. 什么是HTTPS协议？",
          "slug": "_1-什么是https协议",
          "normalizedTitle": "1. 什么是https协议？",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. TLS/SSL的工作原理",
          "slug": "_2-tls-ssl的工作原理",
          "normalizedTitle": "2. tls/ssl的工作原理",
          "charIndex": 301
        },
        {
          "level": 3,
          "title": "3. 数字证书是什么？",
          "slug": "_3-数字证书是什么",
          "normalizedTitle": "3. 数字证书是什么？",
          "charIndex": 1655
        },
        {
          "level": 3,
          "title": "4. HTTPS通信（握手）过程",
          "slug": "_4-https通信-握手-过程",
          "normalizedTitle": "4. https通信（握手）过程",
          "charIndex": 2112
        },
        {
          "level": 3,
          "title": "5. HTTPS的特点",
          "slug": "_5-https的特点",
          "normalizedTitle": "5. https的特点",
          "charIndex": 2461
        },
        {
          "level": 3,
          "title": "6. HTTPS是如何保证安全的？",
          "slug": "_6-https是如何保证安全的",
          "normalizedTitle": "6. https是如何保证安全的？",
          "charIndex": 2832
        }
      ],
      "headersStr": "1. 什么是HTTPS协议？ 2. TLS/SSL的工作原理 3. 数字证书是什么？ 4. HTTPS通信（握手）过程 5. HTTPS的特点 6. HTTPS是如何保证安全的？",
      "content": "# 1. 什么是HTTPS协议？\n\n超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。\n\n安全层的主要职责就是对发起的HTTP请求的数据进行加密操作 和 对接收到的HTTP的内容进行解密操作。\n\n\n# 2. TLS/SSL的工作原理\n\nTLS/SSL全称安全传输层协议（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。\n\nTLS/SSL的功能实现主要依赖三类基本算法：散列函数hash、对称加密、非对称加密。这三类算法的作用如下：\n\n * 基于散列函数验证信息的完整性\n * 对称加密算法采用协商的秘钥对数据加密\n * 非对称加密实现身份认证和秘钥协商\n\n\n\n# （1）散列函数hash\n\n常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。\n\n特点： 在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。\n\n# （2）对称加密\n\n对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。\n\n常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。\n\n特点： 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。\n\n# （3）非对称加密\n\n非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。\n\n常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。\n\n特点： 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。\n\n综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。\n\n\n# 3. 数字证书是什么？\n\n现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。\n\n首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。\n\n这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。\n\n\n# 4. HTTPS通信（握手）过程\n\nHTTPS的通信过程如下：\n\n 1. 客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。\n 2. 服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。\n 3. 客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。\n 4. 服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。\n 5. 客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。\n\n\n# 5. HTTPS的特点\n\nHTTPS的优点如下：\n\n * 使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；\n * 使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；\n * HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；\n\nHTTPS的缺点如下：\n\n * HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；\n * HTTPS协议握手阶段比较费时，增加页面的加载时间；\n * SSL证书是收费的，功能越强大的证书费用越高；\n * HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；\n * SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。\n\n\n# 6. HTTPS是如何保证安全的？\n\n先理解两个概念：\n\n * 对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。\n * ⾮对称加密：\n\n 1. 私钥 + 公钥= 密钥对\n 2. 即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密\n 3. 因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅\n 4. 然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密\n\n⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。\n\n解决⽅案：\n\n结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。\n\n此时⼜带来⼀个问题，中间⼈问题： 如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。\n\n所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。\n\n但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。\n\n数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。",
      "normalizedContent": "# 1. 什么是https协议？\n\n超文本传输安全协议（hypertext transfer protocol secure，简称：https）是一种通过计算机网络进行安全通信的传输协议。https经由http进行通信，利用ssl/tls来加密数据包。https的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 http协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议tls/ssl具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。\n\n安全层的主要职责就是对发起的http请求的数据进行加密操作 和 对接收到的http的内容进行解密操作。\n\n\n# 2. tls/ssl的工作原理\n\ntls/ssl全称安全传输层协议（transport layer security）, 是介于tcp和http之间的一层安全协议，不影响原有的tcp协议和http协议，所以使用https基本上不需要对http页面进行太多的改造。\n\ntls/ssl的功能实现主要依赖三类基本算法：散列函数hash、对称加密、非对称加密。这三类算法的作用如下：\n\n * 基于散列函数验证信息的完整性\n * 对称加密算法采用协商的秘钥对数据加密\n * 非对称加密实现身份认证和秘钥协商\n\n\n\n# （1）散列函数hash\n\n常见的散列函数有md5、sha1、sha256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。\n\n特点： 在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。\n\n# （2）对称加密\n\n对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。\n\n常见的对称加密算法有aes-cbc、des、3des、aes-gcm等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。\n\n特点： 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和n个客户端通信，需要维持n个密码记录且不能修改密码。\n\n# （3）非对称加密\n\n非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。\n\n常见的非对称加密算法有rsa、ecc、dh等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。\n\n特点： 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。\n\n综合上述算法特点，tls/ssl的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。\n\n\n# 3. 数字证书是什么？\n\n现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。\n\n首先使用一种 hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 ca ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。\n\n这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。\n\n\n# 4. https通信（握手）过程\n\nhttps的通信过程如下：\n\n 1. 客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。\n 2. 服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。\n 3. 客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。\n 4. 服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。\n 5. 客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。\n\n\n# 5. https的特点\n\nhttps的优点如下：\n\n * 使用https协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；\n * 使用https协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；\n * https是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；\n\nhttps的缺点如下：\n\n * https需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；\n * https协议握手阶段比较费时，增加页面的加载时间；\n * ssl证书是收费的，功能越强大的证书费用越高；\n * https连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；\n * ssl证书需要绑定ip，不能再同一个ip上绑定多个域名。\n\n\n# 6. https是如何保证安全的？\n\n先理解两个概念：\n\n * 对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。\n * ⾮对称加密：\n\n 1. 私钥 + 公钥= 密钥对\n 2. 即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密\n 3. 因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅\n 4. 然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密\n\n⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。\n\n解决⽅案：\n\n结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。\n\n此时⼜带来⼀个问题，中间⼈问题： 如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。\n\n所以这个时候需要⼀个安全的第三⽅颁发证书（ca），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的hash算法、证书到期时间等。\n\n但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。\n\n数字签名就是⽤ca⾃带的hash算法对证书的内容进⾏hash得到⼀个摘要，再⽤ca的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的hash算法,再次⽣成消息摘要，然后⽤ca的公钥对数字签名解密,得到ca创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "HTTPS状态码",
      "frontmatter": {
        "title": "HTTPS状态码",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/network/httpCode/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/30.HTTP%E7%8A%B6%E6%80%81%E7%A0%81.html",
      "relativePath": "50.性能&网络篇/10.计算机网络篇/30.HTTP状态码.md",
      "key": "v-2a404630",
      "path": "/pages/network/httpCode/",
      "headers": [
        {
          "level": 3,
          "title": "1. 2XX (Success 成功状态码)",
          "slug": "_1-2xx-success-成功状态码",
          "normalizedTitle": "1. 2xx (success 成功状态码)",
          "charIndex": 261
        },
        {
          "level": 3,
          "title": "2. 3XX (Redirection 重定向状态码)",
          "slug": "_2-3xx-redirection-重定向状态码",
          "normalizedTitle": "2. 3xx (redirection 重定向状态码)",
          "charIndex": 563
        },
        {
          "level": 3,
          "title": "3. 4XX (Client Error 客户端错误状态码)",
          "slug": "_3-4xx-client-error-客户端错误状态码",
          "normalizedTitle": "3. 4xx (client error 客户端错误状态码)",
          "charIndex": 2243
        },
        {
          "level": 3,
          "title": "4. 5XX (Server Error 服务器错误状态码)",
          "slug": "_4-5xx-server-error-服务器错误状态码",
          "normalizedTitle": "4. 5xx (server error 服务器错误状态码)",
          "charIndex": 3849
        },
        {
          "level": 3,
          "title": "5. 总结",
          "slug": "_5-总结",
          "normalizedTitle": "5. 总结",
          "charIndex": 4454
        },
        {
          "level": 3,
          "title": "6. 同样是重定向，307，303，302的区别？",
          "slug": "_6-同样是重定向-307-303-302的区别",
          "normalizedTitle": "6. 同样是重定向，307，303，302的区别？",
          "charIndex": 5221
        }
      ],
      "headersStr": "1. 2XX (Success 成功状态码) 2. 3XX (Redirection 重定向状态码) 3. 4XX (Client Error 客户端错误状态码) 4. 5XX (Server Error 服务器错误状态码) 5. 总结 6. 同样是重定向，307，303，302的区别？",
      "content": "状态码的类别：\n\n类别    原因                        描述\n1xx   Informational(信息性状态码)     接受的请求正在处理\n2xx   Success(成功状态码)            请求正常处理完毕\n3xx   Redirection(重定向状态码)       需要进行附加操作一完成请求\n4xx   Client Error (客户端错误状态码)   服务器无法处理请求\n5xx   Server Error(服务器错误状态码)    服务器处理请求出错\n\n\n# 1. 2XX (Success 成功状态码)\n\n状态码2XX表示请求被正常处理了。\n\n# （1）200 OK\n\n200 OK表示客户端发来的请求被服务器端正常处理了。\n\n# （2）204 No Content\n\n该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。\n\n# （3）206 Partial Content\n\n该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。\n\n\n# 2. 3XX (Redirection 重定向状态码)\n\n3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。\n\n# （1）301 Moved Permanently\n\n永久重定向。 该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。\n\n使用场景：\n\n * 当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。\n * 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。\n\n# （2）302 Found\n\n临时重定向。 该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。\n\n使用场景：\n\n * 当我们在做活动时，登录到首页自动重定向，进入活动页面。\n * 未登陆的用户访问用户中心重定向到登录页面。\n * 访问404页面重新定向到首页。\n\n# （3）303 See Other\n\n该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。\n\n303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。\n\n注意：\n\n * 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。\n * 301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。\n\n# （4）304 Not Modified\n\n浏览器缓存相关。 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。\n\n带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（if-match、if-none-match、if-modified-since、if-unmodified-since、if-range）中任意首部。\n\n状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。\n\n# （5）307 Temporary Redirect\n\n307表示临时重定向。 该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。\n\n307 会遵守浏览器标准，不会从 POST 变成 GET。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。\n\n\n# 3. 4XX (Client Error 客户端错误状态码)\n\n4XX 的响应结果表明客户端是发生错误的原因所在。\n\n# （1）400 Bad Request\n\n该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。\n\n# （2）401 Unauthorized\n\n该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败\n\n返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。\n\n以下情况会出现401：\n\n * 401.1 - 登录失败。\n * 401.2 - 服务器配置导致登录失败。\n * 401.3 - 由于 ACL 对资源的限制而未获得授权。\n * 401.4 - 筛选器授权失败。\n * 401.5 - ISAPI/CGI 应用程序授权失败。\n * 401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。\n\n# （3）403 Forbidden\n\n该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。\n\nIIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因：\n\n * 403.1 - 执行访问被禁止。\n * 403.2 - 读访问被禁止。\n * 403.3 - 写访问被禁止。\n * 403.4 - 要求 SSL。\n * 403.5 - 要求 SSL 128。\n * 403.6 - IP 地址被拒绝。\n * 403.7 - 要求客户端证书。\n * 403.8 - 站点访问被拒绝。\n * 403.9 - 用户数过多。\n * 403.10 - 配置无效。\n * 403.11 - 密码更改。\n * 403.12 - 拒绝访问映射表。\n * 403.13 - 客户端证书被吊销。\n * 403.14 - 拒绝目录列表。\n * 403.15 - 超出客户端访问许可。\n * 403.16 - 客户端证书不受信任或无效。\n * 403.17 - 客户端证书已过期或尚未生效\n * 403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。\n * 403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。\n * 403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。\n\n# （4）404 Not Found\n\n该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 以下情况会出现404：\n\n * 404.0 -（无） – 没有找到文件或目录。\n * 404.1 - 无法在所请求的端口上访问 Web 站点。\n * 404.2 - Web 服务扩展锁定策略阻止本请求。\n * 404.3 - MIME 映射策略阻止本请求。\n\n# （5）405 Method Not Allowed\n\n该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下\n\nAccess-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE\n\n\n\n# 4. 5XX (Server Error 服务器错误状态码)\n\n5XX 的响应结果表明服务器本身发生错误.\n\n# （1）500 Internal Server Error\n\n该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。\n\n# （2）502 Bad Gateway\n\n该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。以下情况会出现502：\n\n * 502.1 - CGI （通用网关接口）应用程序超时。\n * 502.2 - CGI （通用网关接口）应用程序出错。\n\n# （3）503 Service Unavailable\n\n该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。\n\n使用场景：\n\n * 服务器停机维护时，主动用503响应请求；\n * nginx 设置限速，超过限速，会返回503。\n\n# （4）504 Gateway Timeout\n\n该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP 1.1中新加入的。\n\n使用场景：代码执行时间超时，或者发生了死循环。\n\n\n# 5. 总结\n\n（1）2XX 成功\n\n * 200 OK，表示从客户端发来的请求在服务器端被正确处理\n * 204 No content，表示请求成功，但响应报文不含实体的主体部分\n * 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容\n * 206 Partial Content，进行范围请求\n\n（2）3XX 重定向\n\n * 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL\n * 302 found，临时性重定向，表示资源临时被分配了新的 URL\n * 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源\n * 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况\n * 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求\n\n（3）4XX 客户端错误\n\n * 400 bad request，请求报文存在语法错误\n * 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息\n * 403 forbidden，表示对请求资源的访问被服务器拒绝\n * 404 not found，表示在服务器上没有找到请求的资源\n\n（4）5XX 服务器错误\n\n * 500 internal sever error，表示服务器端在执行请求时发生了错误\n * 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能\n * 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求\n\n\n# 6. 同样是重定向，307，303，302的区别？\n\n302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get。",
      "normalizedContent": "状态码的类别：\n\n类别    原因                        描述\n1xx   informational(信息性状态码)     接受的请求正在处理\n2xx   success(成功状态码)            请求正常处理完毕\n3xx   redirection(重定向状态码)       需要进行附加操作一完成请求\n4xx   client error (客户端错误状态码)   服务器无法处理请求\n5xx   server error(服务器错误状态码)    服务器处理请求出错\n\n\n# 1. 2xx (success 成功状态码)\n\n状态码2xx表示请求被正常处理了。\n\n# （1）200 ok\n\n200 ok表示客户端发来的请求被服务器端正常处理了。\n\n# （2）204 no content\n\n该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。\n\n# （3）206 partial content\n\n该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 get 请求。响应报文中包含由 content-range 指定范围的实体内容。\n\n\n# 2. 3xx (redirection 重定向状态码)\n\n3xx 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。\n\n# （1）301 moved permanently\n\n永久重定向。 该状态码表示请求的资源已经被分配了新的 uri，以后应使用资源指定的 uri。新的 uri 会在 http 响应头中的 location 首部字段指定。若用户已经把原来的uri保存为书签，此时会按照 location 中新的uri重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。\n\n使用场景：\n\n * 当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。\n * 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。\n\n# （2）302 found\n\n临时重定向。 该状态码表示请求的资源被分配到了新的 uri，希望用户（本次）能使用新的 uri 访问资源。和 301 moved permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 uri 将来还有可能发生改变。若用户把 uri 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 uri。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。\n\n使用场景：\n\n * 当我们在做活动时，登录到首页自动重定向，进入活动页面。\n * 未登陆的用户访问用户中心重定向到登录页面。\n * 访问404页面重新定向到首页。\n\n# （3）303 see other\n\n该状态码表示由于请求对应的资源存在着另一个 uri，应使用 get 方法定向获取请求的资源。 303 状态码和 302 found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 get 方法获取资源。\n\n303 状态码通常作为 put 或 post 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 get。\n\n注意：\n\n * 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 post 改成get，并删除请求报文内的主体，之后请求会再次自动发送。\n * 301、302 标准是禁止将 post 方法变成 get方法的，但实际大家都会这么做。\n\n# （4）304 not modified\n\n浏览器缓存相关。 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3xx 类别中，但是和重定向没有关系。\n\n带条件的请求（http 条件请求）：使用 get方法 请求，请求报文中包含（if-match、if-none-match、if-modified-since、if-unmodified-since、if-range）中任意首部。\n\n状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。\n\n# （5）307 temporary redirect\n\n307表示临时重定向。 该状态码与 302 found 有着相同含义，尽管 302 标准禁止 post 变成 get，但是实际使用时还是这样做了。\n\n307 会遵守浏览器标准，不会从 post 变成 get。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 location 的地址 post 内容。规范要求浏览器继续向 location 的地址 post 内容。\n\n\n# 3. 4xx (client error 客户端错误状态码)\n\n4xx 的响应结果表明客户端是发生错误的原因所在。\n\n# （1）400 bad request\n\n该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 ok 一样对待该状态码。\n\n# （2）401 unauthorized\n\n该状态码表示发送的请求需要有通过 http 认证(basic 认证、digest 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败\n\n返回含有 401 的响应必须包含一个适用于被请求资源的 www-authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。\n\n以下情况会出现401：\n\n * 401.1 - 登录失败。\n * 401.2 - 服务器配置导致登录失败。\n * 401.3 - 由于 acl 对资源的限制而未获得授权。\n * 401.4 - 筛选器授权失败。\n * 401.5 - isapi/cgi 应用程序授权失败。\n * 401.7 - 访问被 web 服务器上的 url 授权策略拒绝。这个错误代码为 iis 6.0 所专用。\n\n# （3）403 forbidden\n\n该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。\n\niis 定义了许多不同的 403 错误，它们指明更为具体的错误原因：\n\n * 403.1 - 执行访问被禁止。\n * 403.2 - 读访问被禁止。\n * 403.3 - 写访问被禁止。\n * 403.4 - 要求 ssl。\n * 403.5 - 要求 ssl 128。\n * 403.6 - ip 地址被拒绝。\n * 403.7 - 要求客户端证书。\n * 403.8 - 站点访问被拒绝。\n * 403.9 - 用户数过多。\n * 403.10 - 配置无效。\n * 403.11 - 密码更改。\n * 403.12 - 拒绝访问映射表。\n * 403.13 - 客户端证书被吊销。\n * 403.14 - 拒绝目录列表。\n * 403.15 - 超出客户端访问许可。\n * 403.16 - 客户端证书不受信任或无效。\n * 403.17 - 客户端证书已过期或尚未生效\n * 403.18 - 在当前的应用程序池中不能执行所请求的 url。这个错误代码为 iis 6.0 所专用。\n * 403.19 - 不能为这个应用程序池中的客户端执行 cgi。这个错误代码为 iis 6.0 所专用。\n * 403.20 - passport 登录失败。这个错误代码为 iis 6.0 所专用。\n\n# （4）404 not found\n\n该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 以下情况会出现404：\n\n * 404.0 -（无） – 没有找到文件或目录。\n * 404.1 - 无法在所请求的端口上访问 web 站点。\n * 404.2 - web 服务扩展锁定策略阻止本请求。\n * 404.3 - mime 映射策略阻止本请求。\n\n# （5）405 method not allowed\n\n该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。get 和 head 方法，服务器应该总是允许客户端进行访问。客户端可以通过 options 方法（预检）来查看服务器允许的访问方法, 如下\n\naccess-control-allow-methods: get,head,put,patch,post,delete\n\n\n\n# 4. 5xx (server error 服务器错误状态码)\n\n5xx 的响应结果表明服务器本身发生错误.\n\n# （1）500 internal server error\n\n该状态码表明服务器端在执行请求时发生了错误。也有可能是 web 应用存在的 bug 或某些临时的故障。\n\n# （2）502 bad gateway\n\n该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 web 服务器或者代理服务器对其进行修复。以下情况会出现502：\n\n * 502.1 - cgi （通用网关接口）应用程序超时。\n * 502.2 - cgi （通用网关接口）应用程序出错。\n\n# （3）503 service unavailable\n\n该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 retryafter 首部字段再返回给客户端。\n\n使用场景：\n\n * 服务器停机维护时，主动用503响应请求；\n * nginx 设置限速，超过限速，会返回503。\n\n# （4）504 gateway timeout\n\n该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是http 1.1中新加入的。\n\n使用场景：代码执行时间超时，或者发生了死循环。\n\n\n# 5. 总结\n\n（1）2xx 成功\n\n * 200 ok，表示从客户端发来的请求在服务器端被正确处理\n * 204 no content，表示请求成功，但响应报文不含实体的主体部分\n * 205 reset content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容\n * 206 partial content，进行范围请求\n\n（2）3xx 重定向\n\n * 301 moved permanently，永久性重定向，表示资源已被分配了新的 url\n * 302 found，临时性重定向，表示资源临时被分配了新的 url\n * 303 see other，表示资源存在着另一个 url，应使用 get 方法获取资源\n * 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况\n * 307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求\n\n（3）4xx 客户端错误\n\n * 400 bad request，请求报文存在语法错误\n * 401 unauthorized，表示发送的请求需要有通过 http 认证的认证信息\n * 403 forbidden，表示对请求资源的访问被服务器拒绝\n * 404 not found，表示在服务器上没有找到请求的资源\n\n（4）5xx 服务器错误\n\n * 500 internal sever error，表示服务器端在执行请求时发生了错误\n * 501 not implemented，表示服务器不支持当前请求所需要的某个功能\n * 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求\n\n\n# 6. 同样是重定向，307，303，302的区别？\n\n302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。 303明确表示客户端应当采⽤get⽅法获取资源，他会把post请求变为get请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "DNS协议介绍",
      "frontmatter": {
        "title": "DNS协议介绍",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/network/dns/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/40.DNS%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D.html",
      "relativePath": "50.性能&网络篇/10.计算机网络篇/40.DNS协议介绍.md",
      "key": "v-2ff787ea",
      "path": "/pages/network/dns/",
      "headers": [
        {
          "level": 3,
          "title": "1. DNS 协议是什么",
          "slug": "_1-dns-协议是什么",
          "normalizedTitle": "1. dns 协议是什么",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. DNS同时使用TCP和UDP协议？",
          "slug": "_2-dns同时使用tcp和udp协议",
          "normalizedTitle": "2. dns同时使用tcp和udp协议？",
          "charIndex": 260
        },
        {
          "level": 3,
          "title": "3. DNS完整的查询过程",
          "slug": "_3-dns完整的查询过程",
          "normalizedTitle": "3. dns完整的查询过程",
          "charIndex": 618
        },
        {
          "level": 3,
          "title": "4. 迭代查询与递归查询",
          "slug": "_4-迭代查询与递归查询",
          "normalizedTitle": "4. 迭代查询与递归查询",
          "charIndex": 1278
        },
        {
          "level": 3,
          "title": "5. DNS 记录和报文",
          "slug": "_5-dns-记录和报文",
          "normalizedTitle": "5. dns 记录和报文",
          "charIndex": 1618
        }
      ],
      "headersStr": "1. DNS 协议是什么 2. DNS同时使用TCP和UDP协议？ 3. DNS完整的查询过程 4. 迭代查询与递归查询 5. DNS 记录和报文",
      "content": "# 1. DNS 协议是什么\n\n概念： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。\n\n作用： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。\n\n\n# 2. DNS同时使用TCP和UDP协议？\n\nDNS占用53号端口，同时使用TCP和UDP协议。 （1）在区域传输的时候使用TCP协议\n\n * 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。\n * TCP是一种可靠连接，保证了数据的准确性。\n\n（2）在域名解析的时候使用UDP协议\n\n * 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。\n\n\n# 3. DNS完整的查询过程\n\nDNS服务器解析域名的过程：\n\n * 首先会在浏览器的缓存中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步\n * 将请求发送给本地DNS服务器，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步\n * 本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址\n * 本地DNS服务器向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址\n * 本地DNS服务器向权威域名服务器发送请求，域名服务器返回对应的结果\n * 本地DNS服务器将返回结果保存在缓存中，便于下次使用\n * 本地DNS服务器将返回结果返回给浏览器\n\n比如要查询 www.baidu.com 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。\n\n\n# 4. 迭代查询与递归查询\n\n实际上，DNS解析是一个包含迭代查询和递归查询的过程。\n\n * 递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。\n * 迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。\n\n一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。\n\n\n# 5. DNS 记录和报文\n\nDNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为\n\n（Name，Value，Type，TTL）\n\n\n其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。\n\n常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：\n\n * 如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。\n * 如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。\n * 如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。\n * 如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。",
      "normalizedContent": "# 1. dns 协议是什么\n\n概念： dns 是域名系统 (domain name system) 的缩写，提供的是一种主机名到 ip 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 dns 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的ip数串。\n\n作用： 将域名解析为ip地址，客户端向dns服务器（dns服务器有自己的ip地址）发送域名查询请求，dns服务器告知客户机web服务器的 ip 地址。\n\n\n# 2. dns同时使用tcp和udp协议？\n\ndns占用53号端口，同时使用tcp和udp协议。 （1）在区域传输的时候使用tcp协议\n\n * 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用tcp而不是udp，因为数据同步传送的数据量比一个请求应答的数据量要多得多。\n * tcp是一种可靠连接，保证了数据的准确性。\n\n（2）在域名解析的时候使用udp协议\n\n * 客户端向dns服务器查询域名，一般返回的内容都不超过512字节，用udp传输即可。不用经过三次握手，这样dns服务器负载更低，响应更快。理论上说，客户端也可以指定向dns服务器查询时用tcp，但事实上，很多dns服务器进行配置的时候，仅支持udp查询包。\n\n\n# 3. dns完整的查询过程\n\ndns服务器解析域名的过程：\n\n * 首先会在浏览器的缓存中查找对应的ip地址，如果查找到直接返回，若找不到继续下一步\n * 将请求发送给本地dns服务器，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步\n * 本地dns服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址\n * 本地dns服务器向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址\n * 本地dns服务器向权威域名服务器发送请求，域名服务器返回对应的结果\n * 本地dns服务器将返回结果保存在缓存中，便于下次使用\n * 本地dns服务器将返回结果返回给浏览器\n\n比如要查询 www.baidu.com 的 ip 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 dns 服务器中，本地dns服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 ip 地址的列表。然后本地 dns 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 ip 地址列表。然后本地 dns 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 ip 地址列表。\n\n\n# 4. 迭代查询与递归查询\n\n实际上，dns解析是一个包含迭代查询和递归查询的过程。\n\n * 递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。\n * 迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。\n\n一般我们向本地 dns 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 dns 服务器返回给我 们最终的请求结果。而本地 dns 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 dns 服务器自己进行。\n\n\n# 5. dns 记录和报文\n\ndns 服务器中以资源记录的形式存储信息，每一个 dns 响应报文一般包含多条资源记录。一条资源记录的具体的格式为\n\n（name，value，type，ttl）\n\n\n其中 ttl 是资源记录的生存时间，它定义了资源记录能够被其他的 dns 服务器缓存多长时间。\n\n常用的一共有四种 type 的值，分别是 a、ns、cname 和 mx ，不同 type 的值，对应资源记录代表的意义不同：\n\n * 如果 type = a，则 name 是主机名，value 是主机名对应的 ip 地址。因此一条记录为 a 的资源记录，提供了标 准的主机名到 ip 地址的映射。\n * 如果 type = ns，则 name 是个域名，value 是负责该域名的 dns 服务器的主机名。这个记录主要用于 dns 链式 查询时，返回下一级需要查询的 dns 服务器的信息。\n * 如果 type = cname，则 name 为别名，value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 ip 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。\n * 如果 type = mx，则 name 为一个邮件服务器的别名，value 为邮件服务器的规范主机名。它的作用和 cname 是一 样的，都是为了解决规范主机名不利于记忆的缺点。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "网络模型",
      "frontmatter": {
        "title": "网络模型",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/network/model/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/50.%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.html",
      "relativePath": "50.性能&网络篇/10.计算机网络篇/50.网络模型.md",
      "key": "v-1fb8fd07",
      "path": "/pages/network/model/",
      "headers": [
        {
          "level": 3,
          "title": "1. OSI七层模型",
          "slug": "_1-osi七层模型",
          "normalizedTitle": "1. osi七层模型",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. TCP/IP五层协议",
          "slug": "_2-tcp-ip五层协议",
          "normalizedTitle": "2. tcp/ip五层协议",
          "charIndex": 1367
        }
      ],
      "headersStr": "1. OSI七层模型 2. TCP/IP五层协议",
      "content": "# 1. OSI七层模型\n\nISO为了更好的使网络应用更为普及，推出了OSI参考模型。\n\n# （1）应用层\n\nOSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。\n\n * 在客户端与服务器中经常会有数据的请求，这个时候就是会用到http(hyper text transfer protocol)(超文本传输协议)或者https.在后端设计数据接口时，我们常常使用到这个协议。\n * FTP是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如百度网盘``迅雷应该是基于此协议的。\n * SMTP是simple mail transfer protocol（简单邮件传输协议）。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。\n\n# （2）表示层\n\n表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。\n\n在项目开发中，为了方便数据传输，可以使用base64对数据进行编解码。如果按功能来划分，base64应该是工作在表示层。\n\n# （3）会话层\n\n会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。\n\n# （4）传输层\n\n传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。\n\n# （5）网络层\n\n本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。\n\n# （6）数据链路层\n\n将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。 网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。\n\n# （7）物理层\n\n实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。\n\nOSI七层模型通信特点：对等通信 对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。\n\n\n# 2. TCP/IP五层协议\n\nTCP/IP五层协议和OSI的七层协议对应关系如下：\n\n * 应用层 (application layer)：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。\n\n * 传输层 (transport layer)\n   \n   ：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：\n   \n   * 传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；\n   * 用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。\n\n * 网络层 (internet layer)：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。\n\n * 数据链路层 (data link layer)：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。\n\n * 物理层 (physical Layer)：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。\n\n从上图中可以看出，TCP/IP模型比OSI模型更加简洁，它把应用层/表示层/会话层全部整合为了应用层。\n\n在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。 在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议：\n\n同样，TCP/IP五层协议的通信方式也是对等通信：",
      "normalizedContent": "# 1. osi七层模型\n\niso为了更好的使网络应用更为普及，推出了osi参考模型。\n\n# （1）应用层\n\nosi参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：http，https，ftp，pop3、smtp等。\n\n * 在客户端与服务器中经常会有数据的请求，这个时候就是会用到http(hyper text transfer protocol)(超文本传输协议)或者https.在后端设计数据接口时，我们常常使用到这个协议。\n * ftp是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如百度网盘``迅雷应该是基于此协议的。\n * smtp是simple mail transfer protocol（简单邮件传输协议）。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。\n\n# （2）表示层\n\n表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。\n\n在项目开发中，为了方便数据传输，可以使用base64对数据进行编解码。如果按功能来划分，base64应该是工作在表示层。\n\n# （3）会话层\n\n会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。\n\n# （4）传输层\n\n传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，tcp udp就是在这一层。端口号既是这里的“端”。\n\n# （5）网络层\n\n本层通过ip寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的ip层。这一层就是我们经常说的ip协议层。ip协议是internet的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。\n\n# （6）数据链路层\n\n将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用mac地址)来访问介质,并进行差错检测。 网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。\n\n# （7）物理层\n\n实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。\n\nosi七层模型通信特点：对等通信 对等通信，为了使数据分组从源传送到目的地，源端osi模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。\n\n\n# 2. tcp/ip五层协议\n\ntcp/ip五层协议和osi的七层协议对应关系如下：\n\n * 应用层 (application layer)：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 http协议（万维网服务）、ftp协议（文件传输）、smtp协议（电子邮件）、dns（域名查询）等。\n\n * 传输层 (transport layer)\n   \n   ：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：\n   \n   * 传输控制协议 (transmission control protocol，tcp)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；\n   * 用户数据报协议 (user datagram protocol，udp)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。\n\n * 网络层 (internet layer)：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。\n\n * 数据链路层 (data link layer)：负责将网络层交下来的 ip 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。\n\n * 物理层 (physical layer)：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。\n\n从上图中可以看出，tcp/ip模型比osi模型更加简洁，它把应用层/表示层/会话层全部整合为了应用层。\n\n在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。 在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议：\n\n同样，tcp/ip五层协议的通信方式也是对等通信：",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "TCP与UDP",
      "frontmatter": {
        "title": "TCP与UDP",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/network/tcp/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/60.TCP%E4%B8%8EUDP.html",
      "relativePath": "50.性能&网络篇/10.计算机网络篇/60.TCP与UDP.md",
      "key": "v-7e736906",
      "path": "/pages/network/tcp/",
      "headers": [
        {
          "level": 3,
          "title": "1. TCP 和 UDP的概念及特点",
          "slug": "_1-tcp-和-udp的概念及特点",
          "normalizedTitle": "1. tcp 和 udp的概念及特点",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. TCP和UDP的区别",
          "slug": "_2-tcp和udp的区别",
          "normalizedTitle": "2. tcp和udp的区别",
          "charIndex": 1663
        },
        {
          "level": 3,
          "title": "3. TCP和UDP的使用场景",
          "slug": "_3-tcp和udp的使用场景",
          "normalizedTitle": "3. tcp和udp的使用场景",
          "charIndex": 2000
        },
        {
          "level": 3,
          "title": "4. UDP协议为什么不可靠？",
          "slug": "_4-udp协议为什么不可靠",
          "normalizedTitle": "4. udp协议为什么不可靠？",
          "charIndex": 2236
        },
        {
          "level": 3,
          "title": "5. TCP的重传机制",
          "slug": "_5-tcp的重传机制",
          "normalizedTitle": "5. tcp的重传机制",
          "charIndex": 2422
        },
        {
          "level": 3,
          "title": "6. TCP的拥塞控制机制",
          "slug": "_6-tcp的拥塞控制机制",
          "normalizedTitle": "6. tcp的拥塞控制机制",
          "charIndex": 2644
        },
        {
          "level": 3,
          "title": "7. TCP的流量控制机制",
          "slug": "_7-tcp的流量控制机制",
          "normalizedTitle": "7. tcp的流量控制机制",
          "charIndex": 3571
        },
        {
          "level": 3,
          "title": "8. TCP的可靠传输机制",
          "slug": "_8-tcp的可靠传输机制",
          "normalizedTitle": "8. tcp的可靠传输机制",
          "charIndex": 3973
        },
        {
          "level": 3,
          "title": "9. TCP的三次握手和四次挥手",
          "slug": "_9-tcp的三次握手和四次挥手",
          "normalizedTitle": "9. tcp的三次握手和四次挥手",
          "charIndex": 4758
        },
        {
          "level": 3,
          "title": "10. TCP粘包是怎么回事，如何处理?",
          "slug": "_10-tcp粘包是怎么回事-如何处理",
          "normalizedTitle": "10. tcp粘包是怎么回事，如何处理?",
          "charIndex": 8012
        },
        {
          "level": 3,
          "title": "11. 为什么udp不会粘包？",
          "slug": "_11-为什么udp不会粘包",
          "normalizedTitle": "11. 为什么udp不会粘包？",
          "charIndex": 9032
        }
      ],
      "headersStr": "1. TCP 和 UDP的概念及特点 2. TCP和UDP的区别 3. TCP和UDP的使用场景 4. UDP协议为什么不可靠？ 5. TCP的重传机制 6. TCP的拥塞控制机制 7. TCP的流量控制机制 8. TCP的可靠传输机制 9. TCP的三次握手和四次挥手 10. TCP粘包是怎么回事，如何处理? 11. 为什么udp不会粘包？",
      "content": "# 1. TCP 和 UDP的概念及特点\n\nTCP 和 UDP都是传输层协议，他们都属于TCP/IP协议族：\n\n（1）UDP\n\nUDP的全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。\n\n它的特点如下：\n\n1）面向无连接\n\n首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。\n\n具体来说就是：\n\n * 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了\n * 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作\n\n2）有单播，多播，广播的功能\n\nUDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。\n\n3）面向报文\n\n发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文\n\n4）不可靠性\n\n首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。\n\n并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。\n\n再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。\n\n5）头部开销小，传输数据报文时是很高效的。\n\nUDP 头部包含了以下几个数据：\n\n * 两个十六位的端口号，分别为源端口（可选字段）和目标端口\n * 整个数据报文的长度\n * 整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误\n\n因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。\n\n（2）TCP TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。\n\n它有以下几个特点：\n\n1）面向连接\n\n面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。\n\n2）仅支持单播传输\n\n每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。\n\n3）面向字节流\n\nTCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。\n\n4）可靠传输\n\n对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。\n\n5）提供拥塞控制\n\n当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。\n\n6）提供全双工通信\n\nTCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）\n\n\n# 2. TCP和UDP的区别\n\n         UDP                     TCP\n是否连接     无连接                     面向连接\n是否可靠     不可靠传输，不使用流量控制和拥塞控制      可靠传输（数据顺序和正确性），使用流量控制和拥塞控制\n连接对象个数   支持一对一，一对多，多对一和多对多交互通信   只能是一对一通信\n传输方式     面向报文                    面向字节流\n首部开销     首部开销小，仅8字节              首部最小20字节，最大60字节\n适用场景     适用于实时应用，例如视频会议、直播       适用于要求可靠传输的应用，例如文件传输\n\n\n# 3. TCP和UDP的使用场景\n\n * TCP应用场景： 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。\n * UDP应用场景： 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。\n\n\n# 4. UDP协议为什么不可靠？\n\nUDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：\n\n * 不保证消息交付：不确认，不重传，无超时\n * 不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞\n * 不跟踪连接状态：不必建立连接或重启状态机\n * 不进行拥塞控制：不内置客户端或网络反馈机制\n\n\n# 5. TCP的重传机制\n\n由于TCP的下层网络（网络层）可能出现丢失、重复或失序的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是基于时间，二是基于确认信息。\n\nTCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。\n\n\n# 6. TCP的拥塞控制机制\n\nTCP的拥塞控制机制主要是以下四种机制：\n\n * 慢启动（慢开始）\n * 拥塞避免\n * 快速重传\n * 快速恢复\n\n（1）慢启动（慢开始）\n\n * 在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）\n * 思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。\n * 为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)\n   * 当cnwd < ssthresh，使用慢开始算法\n   * 当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法\n   * 当cnwd > ssthresh，使用拥塞避免算法\n\n（2）拥塞避免\n\n * 拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。\n * 思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一\n * 无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示: 其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。\n\n（3）快速重传\n\n * 快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。\n * 由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量\n\n（4）快速恢复\n\n * 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。\n * 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。\n\n\n# 7. TCP的流量控制机制\n\n一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。\n\n * 当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。\n * 当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）\n * 如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。\n * 如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。\n\n\n# 8. TCP的可靠传输机制\n\nTCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。\n\nTCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。\n\n接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。\n\n发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。\n\n但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。\n\n\n# 9. TCP的三次握手和四次挥手\n\n# （1）三次握手\n\n三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。\n\n刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。\n\n * 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。\n\n> 首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。\n\n * 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。\n\n> 在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y\n\n * 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。\n\n> 确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。\n\n那为什么要三次握手呢？两次不行吗？\n\n * 为了确认双方的接收能力和发送能力都正常\n * 如果是用两次握手，则会出现下面这种情况：\n\n> 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。\n\n简单来说就是以下三步：\n\n * 第一次握手： 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。\n * 第二次握手： 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。\n * 第三次握手： 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。\n\nTCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。\n\n# （2）四次挥手\n\n刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：\n\n * 第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。\n\n> 即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。\n\n * 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。\n\n> 即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。\n\n * 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。\n\n> 即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。\n\n * 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。\n\n> 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。\n\n那为什么需要四次挥手呢？\n\n> 因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。\n\n简单来说就是以下四步：\n\n * 第一次挥手： 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。\n * 第二次挥手：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。\n * 第三次挥手：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。\n * 第四次挥手： 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。\n\nTCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。\n\n最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。\n\n\n# 10. TCP粘包是怎么回事，如何处理?\n\n默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能.\n\n如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.\n\n下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况: A. 先接收到 data1, 然后接收到 data2 . B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部. C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据. D. ⼀次性接收到了 data1 和 data2 的全部数据.\n\n其中的 BCD 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有:\n\n * 多次发送之前间隔⼀个等待时间：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.\n * 关闭 Nagle 算法：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)\n * 进⾏封包/拆包： 封包/拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前/后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。\n\n\n# 11. 为什么udp不会粘包？\n\n * TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据\n * UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。",
      "normalizedContent": "# 1. tcp 和 udp的概念及特点\n\ntcp 和 udp都是传输层协议，他们都属于tcp/ip协议族：\n\n（1）udp\n\nudp的全称是用户数据报协议，在网络中它与tcp协议一样用于处理数据包，是一种无连接的协议。在osi模型中，在传输层，处于ip协议的上一层。udp有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。\n\n它的特点如下：\n\n1）面向无连接\n\n首先 udp 是不需要和 tcp一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。\n\n具体来说就是：\n\n * 在发送端，应用层将数据传递给传输层的 udp 协议，udp 只会给数据增加一个 udp 头标识下是 udp 协议，然后就传递给网络层了\n * 在接收端，网络层将数据传递给传输层，udp 只去除 ip 报文头就传递给应用层，不会任何拼接操作\n\n2）有单播，多播，广播的功能\n\nudp 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 udp 提供了单播，多播，广播的功能。\n\n3）面向报文\n\n发送方的udp对应用程序交下来的报文，在添加首部后就向下交付ip层。udp对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文\n\n4）不可靠性\n\n首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。\n\n并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。\n\n再者网络环境时好时坏，但是 udp 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 udp 而不是 tcp。\n\n5）头部开销小，传输数据报文时是很高效的。\n\nudp 头部包含了以下几个数据：\n\n * 两个十六位的端口号，分别为源端口（可选字段）和目标端口\n * 整个数据报文的长度\n * 整个数据报文的检验和（ipv4 可选字段），该字段用于发现头部信息和数据中的错误\n\n因此 udp 的头部开销小，只有8字节，相比 tcp 的至少20字节要少得多，在传输数据报文时是很高效的。\n\n（2）tcp tcp的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。tcp 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。\n\n它有以下几个特点：\n\n1）面向连接\n\n面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。\n\n2）仅支持单播传输\n\n每条tcp传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。\n\n3）面向字节流\n\ntcp不像udp一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。\n\n4）可靠传输\n\n对于可靠传输，判断丢包、误码靠的是tcp的段编号以及确认号。tcp为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ack)；如果发送端实体在合理的往返时延(rtt)内未收到确认，那么对应的数据（假设丢失了）将会被重传。\n\n5）提供拥塞控制\n\n当网络出现拥塞的时候，tcp能够减小向网络注入数据的速率和数量，缓解拥塞。\n\n6）提供全双工通信\n\ntcp允许通信双方的应用程序在任何时候都能发送数据，因为tcp连接的两端都设有缓存，用来临时存放双向通信的数据。当然，tcp可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于mss）\n\n\n# 2. tcp和udp的区别\n\n         udp                     tcp\n是否连接     无连接                     面向连接\n是否可靠     不可靠传输，不使用流量控制和拥塞控制      可靠传输（数据顺序和正确性），使用流量控制和拥塞控制\n连接对象个数   支持一对一，一对多，多对一和多对多交互通信   只能是一对一通信\n传输方式     面向报文                    面向字节流\n首部开销     首部开销小，仅8字节              首部最小20字节，最大60字节\n适用场景     适用于实时应用，例如视频会议、直播       适用于要求可靠传输的应用，例如文件传输\n\n\n# 3. tcp和udp的使用场景\n\n * tcp应用场景： 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有udp高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。\n * udp应用场景： 效率要求相对高，对准确性要求相对低的场景。例如：qq聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。\n\n\n# 4. udp协议为什么不可靠？\n\nudp在传输数据之前不需要先建立连接，远地主机的运输层在接收到udp报文后，不需要确认，提供不可靠交付。总结就以下四点：\n\n * 不保证消息交付：不确认，不重传，无超时\n * 不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞\n * 不跟踪连接状态：不必建立连接或重启状态机\n * 不进行拥塞控制：不内置客户端或网络反馈机制\n\n\n# 5. tcp的重传机制\n\n由于tcp的下层网络（网络层）可能出现丢失、重复或失序的情况，tcp协议提供可靠数据传输服务。为保证数据传输的正确性，tcp会重传其认为已丢失（包括报文中的比特错误）的包。tcp使用两套独立的机制来完成重传，一是基于时间，二是基于确认信息。\n\ntcp在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ack确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。\n\n\n# 6. tcp的拥塞控制机制\n\ntcp的拥塞控制机制主要是以下四种机制：\n\n * 慢启动（慢开始）\n * 拥塞避免\n * 快速重传\n * 快速恢复\n\n（1）慢启动（慢开始）\n\n * 在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）\n * 思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。\n * 为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)\n   * 当cnwd < ssthresh，使用慢开始算法\n   * 当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法\n   * 当cnwd > ssthresh，使用拥塞避免算法\n\n（2）拥塞避免\n\n * 拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。\n * 思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间rtt就把发送方的拥塞控制窗口加一\n * 无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示: 其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。\n\n（3）快速重传\n\n * 快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。\n * 由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量\n\n（4）快速恢复\n\n * 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。\n * 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。\n\n\n# 7. tcp的流量控制机制\n\n一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。tcp采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。\n\n * 当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。\n * 当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）\n * 如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。\n * 如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。\n\n\n# 8. tcp的可靠传输机制\n\ntcp 的可靠传输机制是基于连续 arq 协议和滑动窗口协议的。\n\ntcp 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。\n\n接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。\n\n发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，tcp 就是通过控制发送窗口的长度来控制报文 段的发送速率。\n\n但是 tcp 协议并不完全和滑动窗口协议相同，因为许多的 tcp 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 tcp 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。\n\n\n# 9. tcp的三次握手和四次挥手\n\n# （1）三次握手\n\n三次握手（three-way handshake）其实就是指建立一个tcp连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立tcp连接，并同步连接双方的序列号和确认号，交换tcp窗口大小信息。\n\n刚开始客户端处于 closed 的状态，服务端处于 listen 状态。\n\n * 第一次握手：客户端给服务端发一个 syn 报文，并指明客户端的初始化序列号 isn，此时客户端处于 syn_send 状态。\n\n> 首部的同步位syn=1，初始序号seq=x，syn=1的报文段不能携带数据，但要消耗掉一个序号。\n\n * 第二次握手：服务器收到客户端的 syn 报文之后，会以自己的 syn 报文作为应答，并且也是指定了自己的初始化序列号 isn。同时会把客户端的 isn + 1 作为ack 的值，表示自己已经收到了客户端的 syn，此时服务器处于 syn_revd 的状态。\n\n> 在确认报文段中syn=1，ack=1，确认号ack=x+1，初始序号seq=y\n\n * 第三次握手：客户端收到 syn 报文之后，会发送一个 ack 报文，当然，也是一样把服务器的 isn + 1 作为 ack 的值，表示已经收到了服务端的 syn 报文，此时客户端处于 established 状态。服务器收到 ack 报文之后，也处于 established 状态，此时，双方已建立起了连接。\n\n> 确认报文段ack=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ack报文段可以携带数据，不携带数据则不消耗序号。\n\n那为什么要三次握手呢？两次不行吗？\n\n * 为了确认双方的接收能力和发送能力都正常\n * 如果是用两次握手，则会出现下面这种情况：\n\n> 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。\n\n简单来说就是以下三步：\n\n * 第一次握手： 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 syn-sent 状态。\n * 第二次握手： 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 syn-received 状态。\n * 第三次握手： 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 established 状态，服务端收到这个应答后也进入 established 状态，此时连接建立成功。\n\ntcp 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。\n\n# （2）四次挥手\n\n刚开始双方都处于 established 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：\n\n * 第一次挥手： 客户端会发送一个 fin 报文，报文中会指定一个序列号。此时客户端处于 fin_wait1 状态。\n\n> 即发出连接释放报文段（fin=1，序号seq=u），并停止再发送数据，主动关闭tcp连接，进入fin_wait1（终止等待1）状态，等待服务端的确认。\n\n * 第二次挥手：服务端收到 fin 之后，会发送 ack 报文，且把客户端的序列号值 +1 作为 ack 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 close_wait 状态。\n\n> 即服务端收到连接释放报文段后即发出确认报文段（ack=1，确认号ack=u+1，序号seq=v），服务端进入close_wait（关闭等待）状态，此时的tcp处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入fin_wait2（终止等待2）状态，等待服务端发出的连接释放报文段。\n\n * 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 fin 报文，且指定一个序列号。此时服务端处于 last_ack 的状态。\n\n> 即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（fin=1，ack=1，序号seq=w，确认号ack=u+1），服务端进入last_ack（最后确认）状态，等待客户端的确认。\n\n * 第四次挥手：客户端收到 fin 之后，一样发送一个 ack 报文作为应答，且把服务端的序列号值 +1 作为自己 ack 报文的序列号值，此时客户端处于 time_wait 状态。需要过一阵子以确保服务端收到自己的 ack 报文之后才会进入 closed 状态，服务端收到 ack 报文之后，就处于关闭连接了，处于 closed 状态。\n\n> 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ack=1，seq=u+1，ack=w+1），客户端进入time_wait（时间等待）状态。此时tcp未释放掉，需要经过时间等待计时器设置的时间2msl后，客户端才进入closed状态。\n\n那为什么需要四次挥手呢？\n\n> 因为当服务端收到客户端的syn连接请求报文后，可以直接发送syn+ack报文。其中ack报文是用来应答的，syn报文是用来同步的。但是关闭连接时，当服务端收到fin报文时，很可能并不会立即关闭socket，所以只能先回复一个ack报文，告诉客户端，“你发的fin报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送fin报文，因此不能一起发送，故需要四次挥手。\n\n简单来说就是以下四步：\n\n * 第一次挥手： 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。\n * 第二次挥手：服务端收到连接释放请求后，会告诉应用层要释放 tcp 链接。然后会发送 ack 包，并进入 close_wait 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 tcp 连接是双向的，所以服务端仍旧可以发送数据给客户端。\n * 第三次挥手：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 last-ack 状态。\n * 第四次挥手： 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 time-wait 状态。该状态会持续 2msl（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 closed 状态。当服务端收到确认应答后，也便进入 closed 状态。\n\ntcp 使用四次挥手的原因是因为 tcp 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。\n\n最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。\n\n\n# 10. tcp粘包是怎么回事，如何处理?\n\n默认情况下, tcp 连接会启⽤延迟传送算法 (nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.buffersize ), 这样可以减少 io 消耗提⾼性能.\n\n如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.\n\n下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况: a. 先接收到 data1, 然后接收到 data2 . b. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部. c. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据. d. ⼀次性接收到了 data1 和 data2 的全部数据.\n\n其中的 bcd 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有:\n\n * 多次发送之前间隔⼀个等待时间：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.\n * 关闭 nagle 算法：关闭 nagle 算法, 在 node.js 中你可以通过 socket.setnodelay() ⽅法来关闭 nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 tcp 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)\n * 进⾏封包/拆包： 封包/拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前/后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。\n\n\n# 11. 为什么udp不会粘包？\n\n * tcp协议是⾯向流的协议，udp是⾯向消息的协议。udp段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据\n * udp具有保护消息边界，在每个udp包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "WebSocket",
      "frontmatter": {
        "title": "WebSocket",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/network/webSocket/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/10.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/70.WebSocket.html",
      "relativePath": "50.性能&网络篇/10.计算机网络篇/70.WebSocket.md",
      "key": "v-1c0eb3bc",
      "path": "/pages/network/webSocket/",
      "headers": [
        {
          "level": 3,
          "title": "1. 对 WebSocket 的理解",
          "slug": "_1-对-websocket-的理解",
          "normalizedTitle": "1. 对 websocket 的理解",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？",
          "slug": "_2-即时通讯的实现-短轮询、长轮询、sse-和-websocket-间的区别",
          "normalizedTitle": "2. 即时通讯的实现：短轮询、长轮询、sse 和 websocket 间的区别？",
          "charIndex": 1055
        }
      ],
      "headersStr": "1. 对 WebSocket 的理解 2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？",
      "content": "# 1. 对 WebSocket 的理解\n\nWebSocket是HTML5提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。\n\nWebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。\n\nWebSocket原理：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。\n\nWebSocket 特点的如下：\n\n * 支持双向通信，实时性更强\n * 可以发送文本，也可以发送二进制数据‘’\n * 建立在TCP协议之上，服务端的实现比较容易\n * 数据格式比较轻量，性能开销小，通信高效\n * 没有同源限制，客户端可以与任意服务器通信\n * 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL\n * 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。\n\nWebsocket的使用方法如下：\n\n在客户端中：\n\n// 在index.html中直接写WebSocket，设置服务端的端口号为 9999\nlet ws = new WebSocket('ws://localhost:9999');\n// 在客户端与服务端建立连接后触发\nws.onopen = function() {\n    console.log(\"Connection open.\"); \n    ws.send('hello');\n};\n// 在服务端给客户端发来消息的时候触发\nws.onmessage = function(res) {\n    console.log(res);       // 打印的是MessageEvent对象\n    console.log(res.data);  // 打印的是收到的消息\n};\n// 在客户端与服务端建立关闭后触发\nws.onclose = function(evt) {\n  console.log(\"Connection closed.\");\n}; \n\n\n\n# 2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？\n\n短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。\n\n短轮询的基本思路： 浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。\n\n长轮询的基本思路： 首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。\n\nSSE 的基本思想： 服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。\n\nWebSocket 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。\n\n上面的四个通信协议，前三个都是基于HTTP协议的。\n\n对于这四种即使通信协议，从性能的角度来看： WebSocket > 长连接（SEE） > 长轮询 > 短轮询 但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了： 短轮询 > 长轮询 > 长连接（SEE） > WebSocket 所以，还是要根据具体的使用场景来判断使用哪种方式。",
      "normalizedContent": "# 1. 对 websocket 的理解\n\nwebsocket是html5提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于tcp传输协议，并复用http的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。\n\nwebsocket 的出现就解决了半双工通信的弊端。它最大的特点是：服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。\n\nwebsocket原理：客户端向 websocket 服务器通知（notify）一个带有所有接收者id（recipients ids）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有id在接收者id序列中的客户端才会处理这个事件。\n\nwebsocket 特点的如下：\n\n * 支持双向通信，实时性更强\n * 可以发送文本，也可以发送二进制数据‘’\n * 建立在tcp协议之上，服务端的实现比较容易\n * 数据格式比较轻量，性能开销小，通信高效\n * 没有同源限制，客户端可以与任意服务器通信\n * 协议标识符是ws（如果加密，则为wss），服务器网址就是 url\n * 与 http 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 http 协议，因此握手时不容易屏蔽，能通过各种 http 代理服务器。\n\nwebsocket的使用方法如下：\n\n在客户端中：\n\n// 在index.html中直接写websocket，设置服务端的端口号为 9999\nlet ws = new websocket('ws://localhost:9999');\n// 在客户端与服务端建立连接后触发\nws.onopen = function() {\n    console.log(\"connection open.\"); \n    ws.send('hello');\n};\n// 在服务端给客户端发来消息的时候触发\nws.onmessage = function(res) {\n    console.log(res);       // 打印的是messageevent对象\n    console.log(res.data);  // 打印的是收到的消息\n};\n// 在客户端与服务端建立关闭后触发\nws.onclose = function(evt) {\n  console.log(\"connection closed.\");\n}; \n\n\n\n# 2. 即时通讯的实现：短轮询、长轮询、sse 和 websocket 间的区别？\n\n短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。\n\n短轮询的基本思路： 浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。\n\n长轮询的基本思路： 首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 javascript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。\n\nsse 的基本思想： 服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。sse 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 ie/edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。\n\nwebsocket 是 html5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 websocket 协议的缺点是在服务器端的配置比较复杂。websocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 sse 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。\n\n上面的四个通信协议，前三个都是基于http协议的。\n\n对于这四种即使通信协议，从性能的角度来看： websocket > 长连接（see） > 长轮询 > 短轮询 但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了： 短轮询 > 长轮询 > 长连接（see） > websocket 所以，还是要根据具体的使用场景来判断使用哪种方式。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "浏览器安全",
      "frontmatter": {
        "title": "浏览器安全",
        "date": "2022-08-03T21:31:15.000Z",
        "permalink": "/pages/browser/security/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/20.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/10.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8.html",
      "relativePath": "50.性能&网络篇/20.浏览器原理篇/10.浏览器安全.md",
      "key": "v-152dcd41",
      "path": "/pages/browser/security/",
      "headers": [
        {
          "level": 3,
          "title": "1.  什么是 XSS 攻击？",
          "slug": "_1-什么是-xss-攻击",
          "normalizedTitle": "1.  什么是 xss 攻击？",
          "charIndex": null
        },
        {
          "level": 3,
          "title": "2. 如何防御 XSS 攻击？",
          "slug": "_2-如何防御-xss-攻击",
          "normalizedTitle": "2. 如何防御 xss 攻击？",
          "charIndex": 1378
        },
        {
          "level": 3,
          "title": "3. 什么是 CSRF 攻击？",
          "slug": "_3-什么是-csrf-攻击",
          "normalizedTitle": "3. 什么是 csrf 攻击？",
          "charIndex": 1876
        },
        {
          "level": 3,
          "title": "4. 如何防御 CSRF 攻击？",
          "slug": "_4-如何防御-csrf-攻击",
          "normalizedTitle": "4. 如何防御 csrf 攻击？",
          "charIndex": 2276
        },
        {
          "level": 3,
          "title": "5. 什么是中间人攻击？如何防范中间人攻击？",
          "slug": "_5-什么是中间人攻击-如何防范中间人攻击",
          "normalizedTitle": "5. 什么是中间人攻击？如何防范中间人攻击？",
          "charIndex": 3302
        },
        {
          "level": 3,
          "title": "6. 有哪些可能引起前端安全的问题?",
          "slug": "_6-有哪些可能引起前端安全的问题",
          "normalizedTitle": "6. 有哪些可能引起前端安全的问题?",
          "charIndex": 3678
        },
        {
          "level": 3,
          "title": "7. 网络劫持有哪几种，如何防范？",
          "slug": "_7-网络劫持有哪几种-如何防范",
          "normalizedTitle": "7. 网络劫持有哪几种，如何防范？",
          "charIndex": 4162
        }
      ],
      "headersStr": "1.  什么是 XSS 攻击？ 2. 如何防御 XSS 攻击？ 3. 什么是 CSRF 攻击？ 4. 如何防御 CSRF 攻击？ 5. 什么是中间人攻击？如何防范中间人攻击？ 6. 有哪些可能引起前端安全的问题? 7. 网络劫持有哪几种，如何防范？",
      "content": "# 1. 什么是 XSS 攻击？\n\n# （1）概念\n\nXSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。\n\nXSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。\n\n攻击者可以通过这种攻击方式可以进行以下操作：\n\n * 获取页面的数据，如DOM、cookie、localStorage；\n * DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；\n * 破坏页面结构；\n * 流量劫持（将链接指向某网站）；\n\n# （2）攻击类型\n\nXSS 可以分为存储型、反射型和 DOM 型：\n\n * 存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。\n * 反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。\n * DOM 型指的通过修改页面的 DOM 节点形成的 XSS。\n\n1）存储型 XSS 的攻击步骤：\n\n 1. 攻击者将恶意代码提交到⽬标⽹站的数据库中。\n 2. ⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。\n 3. ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。\n 4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n\n这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。\n\n2）反射型 XSS 的攻击步骤：\n\n 1. 攻击者构造出特殊的 URL，其中包含恶意代码。\n 2. ⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。\n 3. ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。\n 4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n\n反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。\n\n反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。\n\n3）DOM 型 XSS 的攻击步骤：\n\n 1. 攻击者构造出特殊的 URL，其中包含恶意代码。\n 2. ⽤户打开带有恶意代码的 URL。\n 3. ⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。\n 4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n\nDOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。\n\n\n# 2. 如何防御 XSS 攻击？\n\n可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：\n\n * 可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。\n * 使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。\n\n>  1. CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。\n>  2. 通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式\n\n * 对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。\n\n\n# 3. 什么是 CSRF 攻击？\n\n# （1）概念\n\nCSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。\n\nCSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。\n\n# （2）攻击类型\n\n常见的 CSRF 攻击有三种：\n\n * GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。\n * POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。\n * 链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。\n\n\n# 4. 如何防御 CSRF 攻击？\n\nCSRF 攻击可以使用以下方法来防护：\n\n * 进行同源检测，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）\n * 使用 CSRF Token 进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。\n * 对 Cookie 进行双重验证，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。\n * 在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。\n\n\n# 5. 什么是中间人攻击？如何防范中间人攻击？\n\n中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。\n\n攻击过程如下:\n\n * 客户端发送请求到服务端，请求被中间⼈截获\n * 服务器向客户端发送公钥\n * 中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个伪造的公钥，发给客户端\n * 客户端收到伪造的公钥后，⽣成加密hash值发给服务器\n * 中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器\n * 服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端\n\n\n# 6. 有哪些可能引起前端安全的问题?\n\n * 跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等；\n * iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；\n * 跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击\n * 恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。\n\n\n# 7. 网络劫持有哪几种，如何防范？\n\n⽹络劫持分为两种:\n\n（1）DNS劫持: (输⼊京东被强制跳转到淘宝这就属于dns劫持)\n\n * DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器\n * 302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容\n\n（2）HTTP劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)\n\nDNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。",
      "normalizedContent": "# 1. 什么是 xss 攻击？\n\n# （1）概念\n\nxss 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。\n\nxss 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。\n\n攻击者可以通过这种攻击方式可以进行以下操作：\n\n * 获取页面的数据，如dom、cookie、localstorage；\n * dos攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；\n * 破坏页面结构；\n * 流量劫持（将链接指向某网站）；\n\n# （2）攻击类型\n\nxss 可以分为存储型、反射型和 dom 型：\n\n * 存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。\n * 反射型指的是攻击者诱导用户访问一个带有恶意代码的 url 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 xss 代码的数据后当做脚本执行，最终完成 xss 攻击。\n * dom 型指的通过修改页面的 dom 节点形成的 xss。\n\n1）存储型 xss 的攻击步骤：\n\n 1. 攻击者将恶意代码提交到⽬标⽹站的数据库中。\n 2. ⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 html 中返回给浏览器。\n 3. ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。\n 4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n\n这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。\n\n2）反射型 xss 的攻击步骤：\n\n 1. 攻击者构造出特殊的 url，其中包含恶意代码。\n 2. ⽤户打开带有恶意代码的 url 时，⽹站服务端将恶意代码从 url 中取出，拼接在 html 中返回给浏览器。\n 3. ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。\n 4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n\n反射型 xss 跟存储型 xss 的区别是：存储型 xss 的恶意代码存在数据库⾥，反射型 xss 的恶意代码存在 url ⾥。\n\n反射型 xss 漏洞常⻅于通过 url 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 url 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。\n\n3）dom 型 xss 的攻击步骤：\n\n 1. 攻击者构造出特殊的 url，其中包含恶意代码。\n 2. ⽤户打开带有恶意代码的 url。\n 3. ⽤户浏览器接收到响应后解析执⾏，前端 javascript 取出 url 中的恶意代码并执⾏。\n 4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n\ndom 型 xss 跟前两种 xss 的区别：dom 型 xss 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端javascript ⾃身的安全漏洞，⽽其他两种 xss 都属于服务端的安全漏洞。\n\n\n# 2. 如何防御 xss 攻击？\n\n可以看到xss危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：\n\n * 可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 html 中的代码做好充分的转义。对于 dom 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。\n * 使用 csp ，csp 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。\n\n>  1. csp 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。\n>  2. 通常有两种方式来开启 csp，一种是设置 http 首部中的 content-security-policy，一种是设置 meta 标签的方式\n\n * 对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。\n\n\n# 3. 什么是 csrf 攻击？\n\n# （1）概念\n\ncsrf 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。\n\ncsrf 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。\n\n# （2）攻击类型\n\n常见的 csrf 攻击有三种：\n\n * get 类型的 csrf 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。\n * post 类型的 csrf 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。\n * 链接类型的 csrf 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。\n\n\n# 4. 如何防御 csrf 攻击？\n\ncsrf 攻击可以使用以下方法来防护：\n\n * 进行同源检测，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（referer 字段会告诉服务器该网页是从哪个页面链接过来的）\n * 使用 csrf token 进行验证，服务器向用户返回一个随机数 token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。\n * 对 cookie 进行双重验证，服务器在用户访问网站页面时，向请求域名注入一个cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 url 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 csrf token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 xss 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。\n * 在设置 cookie 属性的时候设置 samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 cookie 使用，在宽松模式下，cookie 可以被请求是 get 请求，且会发生页面跳转的请求所使用。\n\n\n# 5. 什么是中间人攻击？如何防范中间人攻击？\n\n中间⼈ (man-in-the-middle attack, mitm) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。\n\n攻击过程如下:\n\n * 客户端发送请求到服务端，请求被中间⼈截获\n * 服务器向客户端发送公钥\n * 中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个伪造的公钥，发给客户端\n * 客户端收到伪造的公钥后，⽣成加密hash值发给服务器\n * 中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器\n * 服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端\n\n\n# 6. 有哪些可能引起前端安全的问题?\n\n * 跨站脚本 (cross-site scripting, xss): ⼀种代码注⼊⽅式, 为了与 css 区分所以被称作 xss。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 javascript / css / flash 等；\n * iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏javascirpt脚本、flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；\n * 跨站点请求伪造（cross-site request forgeries，csrf）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击\n * 恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。\n\n\n# 7. 网络劫持有哪几种，如何防范？\n\n⽹络劫持分为两种:\n\n（1）dns劫持: (输⼊京东被强制跳转到淘宝这就属于dns劫持)\n\n * dns强制解析: 通过修改运营商的本地dns记录，来引导⽤户流量到缓存服务器\n * 302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容\n\n（2）http劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)\n\ndns劫持由于涉嫌违法，已经被监管起来，现在很少会有dns劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站https，将http加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "进程与线程",
      "frontmatter": {
        "title": "进程与线程",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/browser/process/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/20.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/20.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html",
      "relativePath": "50.性能&网络篇/20.浏览器原理篇/20.进程与线程.md",
      "key": "v-4f6a7e13",
      "path": "/pages/browser/process/",
      "headers": [
        {
          "level": 3,
          "title": "1. 进程与线程的概念",
          "slug": "_1-进程与线程的概念",
          "normalizedTitle": "1. 进程与线程的概念",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 进程和线程的区别",
          "slug": "_2-进程和线程的区别",
          "normalizedTitle": "2. 进程和线程的区别",
          "charIndex": 1579
        },
        {
          "level": 3,
          "title": "3. 浏览器渲染进程的线程有哪些",
          "slug": "_3-浏览器渲染进程的线程有哪些",
          "normalizedTitle": "3. 浏览器渲染进程的线程有哪些",
          "charIndex": 1970
        },
        {
          "level": 3,
          "title": "4. 进程之前的通信方式",
          "slug": "_4-进程之前的通信方式",
          "normalizedTitle": "4. 进程之前的通信方式",
          "charIndex": 2935
        },
        {
          "level": 3,
          "title": "5. 僵尸进程和孤儿进程是什么？",
          "slug": "_5-僵尸进程和孤儿进程是什么",
          "normalizedTitle": "5. 僵尸进程和孤儿进程是什么？",
          "charIndex": 4050
        },
        {
          "level": 3,
          "title": "6. 死锁产生的原因？ 如果解决死锁的问题？",
          "slug": "_6-死锁产生的原因-如果解决死锁的问题",
          "normalizedTitle": "6. 死锁产生的原因？ 如果解决死锁的问题？",
          "charIndex": 4231
        },
        {
          "level": 3,
          "title": "7. 如何实现浏览器内多个标签页之间的通信?",
          "slug": "_7-如何实现浏览器内多个标签页之间的通信",
          "normalizedTitle": "7. 如何实现浏览器内多个标签页之间的通信?",
          "charIndex": 5158
        },
        {
          "level": 3,
          "title": "8. 对Service Worker的理解",
          "slug": "_8-对service-worker的理解",
          "normalizedTitle": "8. 对service worker的理解",
          "charIndex": 5699
        }
      ],
      "headersStr": "1. 进程与线程的概念 2. 进程和线程的区别 3. 浏览器渲染进程的线程有哪些 4. 进程之前的通信方式 5. 僵尸进程和孤儿进程是什么？ 6. 死锁产生的原因？ 如果解决死锁的问题？ 7. 如何实现浏览器内多个标签页之间的通信? 8. 对Service Worker的理解",
      "content": "# 1. 进程与线程的概念\n\n从本质上说，进程和线程都是 CPU 工作时间片的一个描述：\n\n * 进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。\n * 线程是进程中的更小单位，描述了执行一段指令所需的时间。\n\n进程是资源分配的最小单位，线程是CPU调度的最小单位。\n\n一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。\n\n如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。\n\n进程和线程之间的关系有以下四个特点：\n\n（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。\n\n（2）线程之间共享进程中的数据。\n\n（3）当一个进程关闭之后，操作系统会回收进程所占用的内存， 当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。\n\n（4）进程之间的内容相互隔离。 进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。\n\nChrome浏览器的架构图： 从图中可以看出，最新的 Chrome 浏览器包括：\n\n * 1 个浏览器主进程\n * 1 个 GPU 进程\n * 1 个网络进程\n * 多个渲染进程\n * 多个插件进程\n\n这些进程的功能：\n\n * 浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。\n * 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。\n * GPU 进程：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。\n * 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。\n * 插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。\n\n所以，打开一个网页，最少需要四个进程：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。\n\n虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：\n\n * 更高的资源占用：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。\n * 更复杂的体系架构：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。\n\n\n# 2. 进程和线程的区别\n\n * 进程可以看做独立应用，线程不能\n * 资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。\n * 通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。\n * 调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。\n * 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。\n\n\n# 3. 浏览器渲染进程的线程有哪些\n\n浏览器的渲染进程的线程总共有五种： （1）GUI渲染线程 负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，该线程就会执行。\n\n注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。\n\n（2）JS引擎线程 JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；\n\n注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n\n（3）时间触发线程 时间触发线程属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；\n\n注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；\n\n（4）定时器触发进程 定时器触发进程即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；\n\n注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。\n\n（5）异步http请求线程\n\n * XMLHttpRequest连接后通过浏览器新开一个线程请求；\n * 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；\n\n\n# 4. 进程之前的通信方式\n\n（1）管道通信\n\n管道是一种最基本的进程间通信机制。管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。\n\n管道的特点：\n\n * 只能单向通信\n * 只能血缘关系的进程进行通信\n * 依赖于文件系统\n * 生命周期随进程\n * 面向字节流的服务\n * 管道内部提供了同步机制\n\n（2）消息队列通信\n\n消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。\n\n使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。\n\n（3）信号量通信\n\n共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。\n\n（4）信号通信\n\n信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。\n\n（5）共享内存通信\n\n共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。\n\n（6）套接字通信\n\n上面说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。\n\n\n# 5. 僵尸进程和孤儿进程是什么？\n\n * 孤儿进程：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。\n * 僵尸进程：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。\n\n\n# 6. 死锁产生的原因？ 如果解决死锁的问题？\n\n所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。\n\n系统中的资源可以分为两类：\n\n * 可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；\n * 不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。\n\n产生死锁的原因：\n\n（1）竞争资源\n\n * 产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）\n * 产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁\n\n（2）进程间推进顺序非法\n\n若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁\n\n产生死锁的必要条件：\n\n * 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。\n * 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。\n * 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。\n * 环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。\n\n预防死锁的方法：\n\n * 资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）\n * 只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）\n * 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）\n * 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）\n\n\n# 7. 如何实现浏览器内多个标签页之间的通信?\n\n实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：\n\n * 使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。\n * 使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。\n * 使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。\n * 使用 postMessage 方法，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。\n\n\n# 8. 对Service Worker的理解\n\nService Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。\n\nService Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：\n\n// index.js\nif (navigator.serviceWorker) {\n  navigator.serviceWorker\n    .register('sw.js')\n    .then(function(registration) {\n      console.log('service worker 注册成功')\n    })\n    .catch(function(err) {\n      console.log('servcie worker 注册失败')\n    })\n}\n// sw.js\n// 监听 `install` 事件，回调中缓存所需文件\nself.addEventListener('install', e => {\n  e.waitUntil(\n    caches.open('my-cache').then(function(cache) {\n      return cache.addAll(['./index.html', './index.js'])\n    })\n  )\n})\n// 拦截所有请求事件\n// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据\nself.addEventListener('fetch', e => {\n  e.respondWith(\n    caches.match(e.request).then(function(response) {\n      if (response) {\n        return response\n      }\n      console.log('fetch source')\n    })\n  )\n})\n\n\n打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了： 在 Cache 中也可以发现所需的文件已被缓存：",
      "normalizedContent": "# 1. 进程与线程的概念\n\n从本质上说，进程和线程都是 cpu 工作时间片的一个描述：\n\n * 进程描述了 cpu 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。\n * 线程是进程中的更小单位，描述了执行一段指令所需的时间。\n\n进程是资源分配的最小单位，线程是cpu调度的最小单位。\n\n一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。\n\n如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。\n\n进程和线程之间的关系有以下四个特点：\n\n（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。\n\n（2）线程之间共享进程中的数据。\n\n（3）当一个进程关闭之后，操作系统会回收进程所占用的内存， 当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。\n\n（4）进程之间的内容相互隔离。 进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 a 写入数据到进程 b 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。\n\nchrome浏览器的架构图： 从图中可以看出，最新的 chrome 浏览器包括：\n\n * 1 个浏览器主进程\n * 1 个 gpu 进程\n * 1 个网络进程\n * 多个渲染进程\n * 多个插件进程\n\n这些进程的功能：\n\n * 浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。\n * 渲染进程：核心任务是将 html、css 和 javascript 转换为用户可以与之交互的网页，排版引擎 blink 和 javascript 引擎 v8 都是运行在该进程中，默认情况下，chrome 会为每个 tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。\n * gpu 进程：其实， gpu 的使用初衷是为了实现 3d css 的效果，只是随后网页、chrome 的 ui 界面都选择采用 gpu 来绘制，这使得 gpu 成为浏览器普遍的需求。最后，chrome 在其多进程架构上也引入了 gpu 进程。\n * 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。\n * 插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。\n\n所以，打开一个网页，最少需要四个进程：1 个网络进程、1 个浏览器进程、1 个 gpu 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。\n\n虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：\n\n * 更高的资源占用：因为每个进程都会包含公共基础结构的副本（如 javascript 运行环境），这就意味着浏览器会消耗更多的内存资源。\n * 更复杂的体系架构：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。\n\n\n# 2. 进程和线程的区别\n\n * 进程可以看做独立应用，线程不能\n * 资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。\n * 通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。\n * 调度：进程切换比线程切换的开销要大。线程是cpu调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。\n * 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、i/o 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 cpu 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。\n\n\n# 3. 浏览器渲染进程的线程有哪些\n\n浏览器的渲染进程的线程总共有五种： （1）gui渲染线程 负责渲染浏览器页面，解析html、css，构建dom树、构建cssom树、构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，该线程就会执行。\n\n注意：gui渲染线程和js引擎线程是互斥的，当js引擎执行时gui线程会被挂起，gui更新会被保存在一个队列中等到js引擎空闲时立即被执行。\n\n（2）js引擎线程 js引擎线程也称为js内核，负责处理javascript脚本程序，解析javascript脚本，运行代码；js引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个tab页中无论什么时候都只有一个js引擎线程在运行js程序；\n\n注意：gui渲染线程与js引擎线程的互斥关系，所以如果js执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n\n（3）时间触发线程 时间触发线程属于浏览器而不是js引擎，用来控制事件循环；当js引擎执行代码块如settimeout时（也可是来自浏览器内核的其他线程,如鼠标点击、ajax异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待js引擎的处理；\n\n注意：由于js的单线程关系，所以这些待处理队列中的事件都得排队等待js引擎处理（当js引擎空闲时才会去执行）；\n\n（4）定时器触发进程 定时器触发进程即setinterval与settimeout所在线程；浏览器定时计数器并不是由js引擎计数的，因为js引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待js引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；\n\n注意：w3c在html标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。\n\n（5）异步http请求线程\n\n * xmlhttprequest连接后通过浏览器新开一个线程请求；\n * 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待js引擎空闲后执行；\n\n\n# 4. 进程之前的通信方式\n\n（1）管道通信\n\n管道是一种最基本的进程间通信机制。管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。\n\n管道的特点：\n\n * 只能单向通信\n * 只能血缘关系的进程进行通信\n * 依赖于文件系统\n * 生命周期随进程\n * 面向字节流的服务\n * 管道内部提供了同步机制\n\n（2）消息队列通信\n\n消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。\n\n使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。\n\n（3）信号量通信\n\n共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。\n\n（4）信号通信\n\n信号（signals ）是unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。\n\n（5）共享内存通信\n\n共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 ipc 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。\n\n（6）套接字通信\n\n上面说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 socket 的通信方式了。\n\n\n# 5. 僵尸进程和孤儿进程是什么？\n\n * 孤儿进程：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。\n * 僵尸进程：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。\n\n\n# 6. 死锁产生的原因？ 如果解决死锁的问题？\n\n所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。\n\n系统中的资源可以分为两类：\n\n * 可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，cpu和主存均属于可剥夺性资源；\n * 不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。\n\n产生死锁的原因：\n\n（1）竞争资源\n\n * 产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程p1使用，假定p1已占用了打印机，若p2继续要求打印机打印将阻塞）\n * 产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁\n\n（2）进程间推进顺序非法\n\n若p1保持了资源r1，p2保持了资源r2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当p1运行到p1：request（r2）时，将因r2已被p2占用而阻塞；当p2运行到p2：request（r1）时，也将因r1已被p1占用而阻塞，于是发生进程死锁\n\n产生死锁的必要条件：\n\n * 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。\n * 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。\n * 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。\n * 环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。\n\n预防死锁的方法：\n\n * 资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）\n * 只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）\n * 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）\n * 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）\n\n\n# 7. 如何实现浏览器内多个标签页之间的通信?\n\n实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：\n\n * 使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。\n * 使用 shareworker 的方式，shareworker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。\n * 使用 localstorage 的方式，我们可以在一个标签页对 localstorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localstorage 对象就是充当的中介者的角色。\n * 使用 postmessage 方法，如果我们能够获得对应标签页的引用，就可以使用postmessage 方法，进行通信。\n\n\n# 8. 对service worker的理解\n\nservice worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 service worker的话，传输协议必须为 https。因为 service worker 中涉及到请求拦截，所以必须使用 https 协议来保障安全。\n\nservice worker 实现缓存功能一般分为三个步骤：首先需要先注册 service worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：\n\n// index.js\nif (navigator.serviceworker) {\n  navigator.serviceworker\n    .register('sw.js')\n    .then(function(registration) {\n      console.log('service worker 注册成功')\n    })\n    .catch(function(err) {\n      console.log('servcie worker 注册失败')\n    })\n}\n// sw.js\n// 监听 `install` 事件，回调中缓存所需文件\nself.addeventlistener('install', e => {\n  e.waituntil(\n    caches.open('my-cache').then(function(cache) {\n      return cache.addall(['./index.html', './index.js'])\n    })\n  )\n})\n// 拦截所有请求事件\n// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据\nself.addeventlistener('fetch', e => {\n  e.respondwith(\n    caches.match(e.request).then(function(response) {\n      if (response) {\n        return response\n      }\n      console.log('fetch source')\n    })\n  )\n})\n\n\n打开页面，可以在开发者工具中的 application 看到 service worker 已经启动了： 在 cache 中也可以发现所需的文件已被缓存：",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "浏览器组成",
      "frontmatter": {
        "title": "浏览器组成",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/browser/form/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/20.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/40.%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%84%E6%88%90.html",
      "relativePath": "50.性能&网络篇/20.浏览器原理篇/40.浏览器组成.md",
      "key": "v-5708471d",
      "path": "/pages/browser/form/",
      "headers": [
        {
          "level": 3,
          "title": "1. 对浏览器的理解",
          "slug": "_1-对浏览器的理解",
          "normalizedTitle": "1. 对浏览器的理解",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 对浏览器内核的理解",
          "slug": "_2-对浏览器内核的理解",
          "normalizedTitle": "2. 对浏览器内核的理解",
          "charIndex": 488
        },
        {
          "level": 3,
          "title": "3. 常见的浏览器内核比较",
          "slug": "_3-常见的浏览器内核比较",
          "normalizedTitle": "3. 常见的浏览器内核比较",
          "charIndex": 719
        },
        {
          "level": 3,
          "title": "4. 常见浏览器所用内核",
          "slug": "_4-常见浏览器所用内核",
          "normalizedTitle": "4. 常见浏览器所用内核",
          "charIndex": 1674
        },
        {
          "level": 3,
          "title": "5. 浏览器的主要组成部分",
          "slug": "_5-浏览器的主要组成部分",
          "normalizedTitle": "5. 浏览器的主要组成部分",
          "charIndex": 2178
        }
      ],
      "headersStr": "1. 对浏览器的理解 2. 对浏览器内核的理解 3. 常见的浏览器内核比较 4. 常见浏览器所用内核 5. 浏览器的主要组成部分",
      "content": "# 1. 对浏览器的理解\n\n浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。\n\nHTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。\n\n浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。\n\n * shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。\n * 内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。\n\n\n# 2. 对浏览器内核的理解\n\n浏览器内核主要分成两部分：\n\n * 渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。\n * JS 引擎：解析和执行 javascript 来实现网页的动态效果。\n\n最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。\n\n\n# 3. 常见的浏览器内核比较\n\n * Trident： 这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。\n * Gecko： 这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。\n * Presto： Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。\n * Webkit： Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。\n * Blink： 谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。\n\n\n# 4. 常见浏览器所用内核\n\n（1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；\n\n（2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；\n\n（3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；\n\n（4） Safari 浏览器内核：Webkit 内核；\n\n（5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；\n\n（6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；\n\n（7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；\n\n（8） 百度浏览器、世界之窗内核：IE 内核；\n\n（9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；\n\n（10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。\n\n\n# 5. 浏览器的主要组成部分\n\n * ⽤户界⾯ 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗⼝显示的您请求的⻚⾯外，其他显示的各个部分都属于⽤户界⾯。\n * 浏览器引擎 在⽤户界⾯和呈现引擎之间传送指令。\n * 呈现引擎 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。\n * ⽹络 ⽤于⽹络调⽤，⽐如 HTTP 请求。其接⼝与平台⽆关，并为所有平台提供底层实现。\n * ⽤户界⾯后端 ⽤于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。其公开了与平台⽆关的通⽤接⼝，⽽在底层使⽤操作系统的⽤户界⾯⽅法。\n * JavaScript 解释器。⽤于解析和执⾏ JavaScript 代码。\n * 数据存储 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“⽹络数据库”，这是⼀个完整（但是轻便）的浏览器内数据库。\n\n值得注意的是，和⼤多数浏览器不同，Chrome 浏览器的每个标签⻚都分别对应⼀个呈现引擎实例。每个标签⻚都是⼀个独⽴的进程。",
      "normalizedContent": "# 1. 对浏览器的理解\n\n浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 html，也包括 pdf、image 及其他格式。用户用 uri（uniform resource identifier 统一资源标识符）来指定所请求资源的位置。\n\nhtml 和 css 规范中规定了浏览器解释 html 文档的方式，由 w3c 组织对这些规范进行维护，w3c 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。\n\n浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。也有一些浏览器并不区分外壳和内核。从 mozilla 将 gecko 独立出来后，才有了外壳和内核的明确划分。\n\n * shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。\n * 内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。\n\n\n# 2. 对浏览器内核的理解\n\n浏览器内核主要分成两部分：\n\n * 渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 pdf 阅读器插件，可以显示 pdf 格式。\n * js 引擎：解析和执行 javascript 来实现网页的动态效果。\n\n最开始渲染引擎和 js 引擎并没有区分的很明确，后来 js 引擎越来越独立，内核就倾向于只指渲染引擎。\n\n\n# 3. 常见的浏览器内核比较\n\n * trident： 这种浏览器内核是 ie 浏览器用的内核，因为在早期 ie 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 ie 的高市场占有率，微软也很长时间没有更新 trident 内核，就导致了 trident 内核和 w3c 标准脱节。还有就是 trident 内核的大量 bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 ie 浏览器不安全的观点，使很多用户开始转向其他浏览器。\n * gecko： 这是 firefox 和 flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。\n * presto： opera 曾经采用的就是 presto 内核，presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 js 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。\n * webkit： webkit 是 safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 presto 但是也胜于 gecko 和 trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。webkit 前身是 kde 小组的 khtml 引擎，可以说 webkit 是 khtml 的一个开源的分支。\n * blink： 谷歌在 chromium blog 上发表博客，称将与苹果的开源浏览器核心 webkit 分道扬镳，在 chromium 项目中研发 blink 渲染引擎（即浏览器核心），内置于 chrome 浏览器之中。其实 blink 引擎就是 webkit 的一个分支，就像 webkit 是khtml 的分支一样。blink 引擎现在是谷歌公司与 opera software 共同研发，上面提到过的，opera 弃用了自己的 presto 内核，加入 google 阵营，跟随谷歌一起研发 blink。\n\n\n# 4. 常见浏览器所用内核\n\n（1） ie 浏览器内核：trident 内核，也是俗称的 ie 内核；\n\n（2） chrome 浏览器内核：统称为 chromium 内核或 chrome 内核，以前是 webkit 内核，现在是 blink内核；\n\n（3） firefox 浏览器内核：gecko 内核，俗称 firefox 内核；\n\n（4） safari 浏览器内核：webkit 内核；\n\n（5） opera 浏览器内核：最初是自己的 presto 内核，后来加入谷歌大军，从 webkit 又到了 blink 内核；\n\n（6） 360浏览器、猎豹浏览器内核：ie + chrome 双内核；\n\n（7） 搜狗、遨游、qq 浏览器内核：trident（兼容模式）+ webkit（高速模式）；\n\n（8） 百度浏览器、世界之窗内核：ie 内核；\n\n（9） 2345浏览器内核：好像以前是 ie 内核，现在也是 ie + chrome 双内核了；\n\n（10）uc 浏览器内核：这个众口不一，uc 说是他们自己研发的 u3 内核，但好像还是基于 webkit 和 trident ，还有说是基于火狐内核。\n\n\n# 5. 浏览器的主要组成部分\n\n * ⽤户界⾯ 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗⼝显示的您请求的⻚⾯外，其他显示的各个部分都属于⽤户界⾯。\n * 浏览器引擎 在⽤户界⾯和呈现引擎之间传送指令。\n * 呈现引擎 负责显示请求的内容。如果请求的内容是 html，它就负责解析 html 和 css 内容，并将解析后的内容显示在屏幕上。\n * ⽹络 ⽤于⽹络调⽤，⽐如 http 请求。其接⼝与平台⽆关，并为所有平台提供底层实现。\n * ⽤户界⾯后端 ⽤于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。其公开了与平台⽆关的通⽤接⼝，⽽在底层使⽤操作系统的⽤户界⾯⽅法。\n * javascript 解释器。⽤于解析和执⾏ javascript 代码。\n * 数据存储 这是持久层。浏览器需要在硬盘上保存各种数据，例如 cookie。新的 html 规范 (html5) 定义了“⽹络数据库”，这是⼀个完整（但是轻便）的浏览器内数据库。\n\n值得注意的是，和⼤多数浏览器不同，chrome 浏览器的每个标签⻚都分别对应⼀个呈现引擎实例。每个标签⻚都是⼀个独⽴的进程。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "浏览器渲染原理",
      "frontmatter": {
        "title": "浏览器渲染原理",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/browser/principles/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/20.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/50.%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.html",
      "relativePath": "50.性能&网络篇/20.浏览器原理篇/50.浏览器渲染原理.md",
      "key": "v-ab76377e",
      "path": "/pages/browser/principles/",
      "headers": [
        {
          "level": 3,
          "title": "1. 浏览器的渲染过程",
          "slug": "_1-浏览器的渲染过程",
          "normalizedTitle": "1. 浏览器的渲染过程",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 浏览器渲染优化",
          "slug": "_2-浏览器渲染优化",
          "normalizedTitle": "2. 浏览器渲染优化",
          "charIndex": 595
        },
        {
          "level": 3,
          "title": "3. 渲染过程中遇到 JS 文件如何处理？",
          "slug": "_3-渲染过程中遇到-js-文件如何处理",
          "normalizedTitle": "3. 渲染过程中遇到 js 文件如何处理？",
          "charIndex": 2131
        },
        {
          "level": 3,
          "title": "4. 什么是文档的预解析？",
          "slug": "_4-什么是文档的预解析",
          "normalizedTitle": "4. 什么是文档的预解析？",
          "charIndex": 2432
        },
        {
          "level": 3,
          "title": "5. CSS 如何阻塞文档解析？",
          "slug": "_5-css-如何阻塞文档解析",
          "normalizedTitle": "5. css 如何阻塞文档解析？",
          "charIndex": 2611
        },
        {
          "level": 3,
          "title": "6. 如何优化关键渲染路径？",
          "slug": "_6-如何优化关键渲染路径",
          "normalizedTitle": "6. 如何优化关键渲染路径？",
          "charIndex": 2895
        },
        {
          "level": 3,
          "title": "7. 什么情况会阻塞渲染？",
          "slug": "_7-什么情况会阻塞渲染",
          "normalizedTitle": "7. 什么情况会阻塞渲染？",
          "charIndex": 3375
        }
      ],
      "headersStr": "1. 浏览器的渲染过程 2. 浏览器渲染优化 3. 渲染过程中遇到 JS 文件如何处理？ 4. 什么是文档的预解析？ 5. CSS 如何阻塞文档解析？ 6. 如何优化关键渲染路径？ 7. 什么情况会阻塞渲染？",
      "content": "# 1. 浏览器的渲染过程\n\n浏览器渲染主要有以下步骤：\n\n * 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。\n * 然后对 CSS 进行解析，生成 CSSOM 规则树。\n * 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。\n * 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。\n * 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。\n\n大致过程如图所示：\n\n注意： 这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。\n\n\n# 2. 浏览器渲染优化\n\n（1）针对JavaScript： JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：\n\n（1）尽量将JavaScript文件放在body的最后\n\n（2） body中间尽量不要写<script>标签\n\n（3）<script>标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：\n\n * script 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；\n * async 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；\n * defer 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。\n\n**（2）针对CSS：*使用CSS有三种方式：使用*link、@import、内联样式，其中link和@import都是导入外部样式。它们之间的区别：\n\n * link：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码\n * @import：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)\n * style：GUI直接渲染\n\n外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。\n\n所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。\n\n（3）针对DOM树、CSSOM树： 可以通过以下几种方式来减少渲染的时间：\n\n * HTML文件的代码层级尽量不要太深\n * 使用语义化的标签，来避免不标准语义化的特殊处理\n * 减少CSSD代码的层级，因为选择器是从左向右进行解析的\n\n（4）减少回流与重绘：\n\n * 操作DOM时，尽量在低层级的DOM节点进行操作\n * 不要使用table布局， 一个小的改动可能会使整个table进行重新布局\n * 使用CSS的表达式\n * 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。\n * 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素\n * 避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中\n * 将元素先设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。\n * 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。\n\n浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列\n\n浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。\n\n将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。\n\n\n# 3. 渲染过程中遇到 JS 文件如何处理？\n\nJavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。\n\n\n# 4. 什么是文档的预解析？\n\nWebkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。\n\n\n# 5. CSS 如何阻塞文档解析？\n\n理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。\n\n\n# 6. 如何优化关键渲染路径？\n\n为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：\n\n（1）关键资源的数量。\n\n（2）关键路径长度。\n\n（3）关键字节的数量。\n\n关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。\n\n优化关键渲染路径的常规步骤如下：\n\n（1）对关键路径进行分析和特性描述：资源数、字节数、长度。\n\n（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。\n\n（3）优化关键字节数以缩短下载时间（往返次数）。\n\n（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度\n\n\n# 7. 什么情况会阻塞渲染？\n\n首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。\n\n当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。",
      "normalizedContent": "# 1. 浏览器的渲染过程\n\n浏览器渲染主要有以下步骤：\n\n * 首先解析收到的文档，根据文档定义构建一棵 dom 树，dom 树是由 dom 元素及属性节点组成的。\n * 然后对 css 进行解析，生成 cssom 规则树。\n * 根据 dom 树和 cssom 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 dom 元素相对应，但这种对应关系不是一对一的，不可见的 dom 元素不会被插入渲染树。还有一些 dom元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。\n * 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。\n * 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 ui 基础组件。\n\n大致过程如图所示：\n\n注意： 这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。\n\n\n# 2. 浏览器渲染优化\n\n（1）针对javascript： javascript既会阻塞html的解析，也会阻塞css的解析。因此我们可以对javascript的加载方式进行改变，来进行优化：\n\n（1）尽量将javascript文件放在body的最后\n\n（2） body中间尽量不要写<script>标签\n\n（3）<script>标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的js文件，不会阻塞dom的解析（尽量使用异步加载）。三者的区别如下：\n\n * script 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；\n * async 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；\n * defer 是在下载完成之后，立即异步加载。加载好后，如果 dom 树还没构建好，则先等 dom 树解析好再执行；如果dom树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。\n\n**（2）针对css：*使用css有三种方式：使用*link、@import、内联样式，其中link和@import都是导入外部样式。它们之间的区别：\n\n * link：浏览器会派发一个新等线程(http线程)去加载资源文件，与此同时gui渲染线程会继续向下渲染代码\n * @import：gui渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)\n * style：gui直接渲染\n\n外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以css一般写在headr中，让浏览器尽快发送请求去获取css样式。\n\n所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。\n\n（3）针对dom树、cssom树： 可以通过以下几种方式来减少渲染的时间：\n\n * html文件的代码层级尽量不要太深\n * 使用语义化的标签，来避免不标准语义化的特殊处理\n * 减少cssd代码的层级，因为选择器是从左向右进行解析的\n\n（4）减少回流与重绘：\n\n * 操作dom时，尽量在低层级的dom节点进行操作\n * 不要使用table布局， 一个小的改动可能会使整个table进行重新布局\n * 使用css的表达式\n * 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。\n * 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素\n * 避免频繁操作dom，可以创建一个文档片段documentfragment，在它上面应用所有dom操作，最后再把它添加到文档中\n * 将元素先设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的dom操作不会引发回流和重绘。\n * 将dom的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。\n\n浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列\n\n浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。\n\n将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。\n\n\n# 3. 渲染过程中遇到 js 文件如何处理？\n\njavascript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 dom 时，html 解析器若遇到了 javascript，那么它会暂停文档的解析，将控制权移交给 javascript 引擎，等 javascript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 js 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。\n\n\n# 4. 什么是文档的预解析？\n\nwebkit 和 firefox 都做了这个优化，当执行 javascript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 dom 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。\n\n\n# 5. css 如何阻塞文档解析？\n\n理论上，既然样式表不改变 dom 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，javascript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 cssom 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 javascript 脚本执行和文档的解析，直至其完成 cssom 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 cssom，然后再执行 javascript，最后再继续文档的解析。\n\n\n# 6. 如何优化关键渲染路径？\n\n为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：\n\n（1）关键资源的数量。\n\n（2）关键路径长度。\n\n（3）关键字节的数量。\n\n关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 cpu 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。\n\n优化关键渲染路径的常规步骤如下：\n\n（1）对关键路径进行分析和特性描述：资源数、字节数、长度。\n\n（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。\n\n（3）优化关键字节数以缩短下载时间（往返次数）。\n\n（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度\n\n\n# 7. 什么情况会阻塞渲染？\n\n首先渲染的前提是生成渲染树，所以 html 和 css 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 dom，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 js 文件，这也是都建议将 script 标签放在 body 标签底部的原因。\n\n当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 js 文件会并行下载，但是会放到 html 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 js 文件可以加上 async 属性，表示 js 文件下载和解析不会阻塞渲染。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "浏览器缓存",
      "frontmatter": {
        "title": "浏览器缓存",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/browser/cache/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/20.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/30.%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.html",
      "relativePath": "50.性能&网络篇/20.浏览器原理篇/30.浏览器缓存.md",
      "key": "v-786bd14a",
      "path": "/pages/browser/cache/",
      "headers": [
        {
          "level": 3,
          "title": "1. 对浏览器的缓存机制的理解",
          "slug": "_1-对浏览器的缓存机制的理解",
          "normalizedTitle": "1. 对浏览器的缓存机制的理解",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "3. 协商缓存和强缓存的区别",
          "slug": "_3-协商缓存和强缓存的区别",
          "normalizedTitle": "3. 协商缓存和强缓存的区别",
          "charIndex": 664
        },
        {
          "level": 3,
          "title": "4. 为什么需要浏览器缓存？",
          "slug": "_4-为什么需要浏览器缓存",
          "normalizedTitle": "4. 为什么需要浏览器缓存？",
          "charIndex": 3018
        },
        {
          "level": 3,
          "title": "5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？",
          "slug": "_5-点击刷新按钮或者按-f5、按-ctrl-f5-强制刷新-、地址栏回车有什么区别",
          "normalizedTitle": "5. 点击刷新按钮或者按 f5、按 ctrl+f5 （强制刷新）、地址栏回车有什么区别？",
          "charIndex": 3360
        }
      ],
      "headersStr": "1. 对浏览器的缓存机制的理解 3. 协商缓存和强缓存的区别 4. 为什么需要浏览器缓存？ 5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？",
      "content": "# 1. 对浏览器的缓存机制的理解\n\n浏览器缓存的全过程：\n\n * 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；\n * 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；\n * 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；\n * 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；\n * 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；\n\n很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。\n\n\n# 3. 协商缓存和强缓存的区别\n\n# （1）强缓存\n\n使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\n\n强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。\n\n（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。\n\n（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，\n\nCache-Control可设置的字段：\n\n * public：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；\n * private：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；\n * no-cache：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；\n * no-store：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；\n * max-age=：设置缓存的最大有效期，单位为秒；\n * s-maxage=：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；\n * max-stale[=]：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。\n\n一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。\n\nno-cache和no-store很容易混淆：\n\n * no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；\n * no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。\n\n# （2）协商缓存\n\n如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。\n\n上面已经说到了，命中协商缓存的条件有两个：\n\n * max-age=xxx 过期了\n * 值为no-store\n\n使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。\n\n协商缓存也可以通过两种方式来设置，分别是 http 头信息中的Etag 和Last-Modified属性。\n\n（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。\n\n（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。\n\n当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。\n\n总结：\n\n强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。\n\n\n# 4. 为什么需要浏览器缓存？\n\n对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。\n\n所谓的浏览器缓存指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。\n\n使用浏览器缓存，有以下优点：\n\n * 减少了服务器的负担，提高了网站的性能\n * 加快了客户端网页的加载速度\n * 减少了多余网络数据传输\n\n\n# 5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？\n\n * 点击刷新按钮或者按 F5： 浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。\n * 用户按 Ctrl+F5（强制刷新）： 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。\n * 地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。",
      "normalizedContent": "# 1. 对浏览器的缓存机制的理解\n\n浏览器缓存的全过程：\n\n * 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；\n * 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持http1.1，则使用 expires 头判断是否过期；\n * 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 if-none-match 和 if-modified-since 的请求；\n * 服务器收到请求后，优先根据 etag 的值判断被请求的文件有没有做修改，etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 etag 值并返回 200；\n * 如果服务器收到的请求没有 etag 值，则将 if-modified-since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；\n\n很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 js 或 css 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 js 或 css 文件 ，以保证用户能够及时获得网站的最新更新。\n\n\n# 3. 协商缓存和强缓存的区别\n\n# （1）强缓存\n\n使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\n\n强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 expires 属性和 cache-control 属性。\n\n（1）服务器通过在响应头中添加 expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。\n\n（2）expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 cache-control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，\n\ncache-control可设置的字段：\n\n * public：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；\n * private：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的html，通常都要设置这个字段值，避免代理服务器(cdn)缓存；\n * no-cache：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；\n * no-store：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；\n * max-age=：设置缓存的最大有效期，单位为秒；\n * s-maxage=：优先级高于max-age=，仅适用于共享缓存(cdn)，优先级高于max-age或者expires头；\n * max-stale[=]：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。\n\n一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，cache-control 的优先级要高于 expires。\n\nno-cache和no-store很容易混淆：\n\n * no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；\n * no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。\n\n# （2）协商缓存\n\n如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。\n\n上面已经说到了，命中协商缓存的条件有两个：\n\n * max-age=xxx 过期了\n * 值为no-store\n\n使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。\n\n协商缓存也可以通过两种方式来设置，分别是 http 头信息中的etag 和last-modified属性。\n\n（1）服务器通过在响应头中添加 last-modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 if-modified-since 的属性，属性值为上一次资源返回时的 last-modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 last-modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 last-modified 却没有改变，这样会造成缓存命中的不准确。\n\n（2）因为 last-modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 etag 属性。服务器在返回资源的时候，在头信息中添加了 etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 if-none-match 属性，这个属性的值就是上次返回的资源的 etag 的值。服务接收到请求后会根据这个值来和资源当前的 etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 last-modified 的方式更加精确。\n\n当 last-modified 和 etag 属性同时出现的时候，etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 last-modified 应该保持一致，因为每个服务器上 etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 etag 属性。\n\n总结：\n\n强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。\n\n\n# 4. 为什么需要浏览器缓存？\n\n对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。\n\n所谓的浏览器缓存指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。\n\n使用浏览器缓存，有以下优点：\n\n * 减少了服务器的负担，提高了网站的性能\n * 加快了客户端网页的加载速度\n * 减少了多余网络数据传输\n\n\n# 5. 点击刷新按钮或者按 f5、按 ctrl+f5 （强制刷新）、地址栏回车有什么区别？\n\n * 点击刷新按钮或者按 f5： 浏览器直接对本地的缓存文件过期，但是会带上if-modifed-since，if-none-match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。\n * 用户按 ctrl+f5（强制刷新）： 浏览器不仅会对本地文件过期，而且不会带上 if-modifed-since，if-none-match，相当于之前从来没有请求过，返回结果是 200。\n * 地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "浏览器本地存储",
      "frontmatter": {
        "title": "浏览器本地存储",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/browser/storage/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/20.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/60.%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.html",
      "relativePath": "50.性能&网络篇/20.浏览器原理篇/60.浏览器本地存储.md",
      "key": "v-584d26e7",
      "path": "/pages/browser/storage/",
      "headers": [
        {
          "level": 3,
          "title": "1. 浏览器本地存储方式及使用场景",
          "slug": "_1-浏览器本地存储方式及使用场景",
          "normalizedTitle": "1. 浏览器本地存储方式及使用场景",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. Cookie有哪些字段，作用分别是什么",
          "slug": "_2-cookie有哪些字段-作用分别是什么",
          "normalizedTitle": "2. cookie有哪些字段，作用分别是什么",
          "charIndex": 2278
        },
        {
          "level": 3,
          "title": "3. Cookie、LocalStorage、SessionStorage区别",
          "slug": "_3-cookie、localstorage、sessionstorage区别",
          "normalizedTitle": "3. cookie、localstorage、sessionstorage区别",
          "charIndex": 3621
        },
        {
          "level": 3,
          "title": "4. 前端储存的⽅式有哪些？",
          "slug": "_4-前端储存的方式有哪些",
          "normalizedTitle": "4. 前端储存的⽅式有哪些？",
          "charIndex": 4254
        },
        {
          "level": 3,
          "title": "5. IndexedDB有哪些特点？",
          "slug": "_5-indexeddb有哪些特点",
          "normalizedTitle": "5. indexeddb有哪些特点？",
          "charIndex": 4814
        }
      ],
      "headersStr": "1. 浏览器本地存储方式及使用场景 2. Cookie有哪些字段，作用分别是什么 3. Cookie、LocalStorage、SessionStorage区别 4. 前端储存的⽅式有哪些？ 5. IndexedDB有哪些特点？",
      "content": "# 1. 浏览器本地存储方式及使用场景\n\n# （1）Cookie\n\nCookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。\n\nCookie的特性：\n\n * Cookie一旦创建成功，名称就无法修改\n * Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie\n * 每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb\n * 有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的\n * Cookie在请求一个新的页面的时候都会被发送过去\n\n如果需要域名之间跨域共享Cookie，有两种方法：\n\n 1. 使用Nginx反向代理\n 2. 在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId\n\nCookie的使用场景：\n\n * 最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。\n * 可以用来统计页面的点击次数\n\n# （2）LocalStorage\n\nLocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。\n\nLocalStorage的优点：\n\n * 在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息\n * LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在\n * 仅储存在本地，不像Cookie那样每次HTTP请求都会被携带\n\nLocalStorage的缺点：\n\n * 存在浏览器兼容问题，IE8以下版本的浏览器不支持\n * 如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage\n * LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问\n\nLocalStorage的常用API：\n\n// 保存数据到 localStorage\nlocalStorage.setItem('key', 'value');\n\n// 从 localStorage 获取数据\nlet data = localStorage.getItem('key');\n\n// 从 localStorage 删除保存的数据\nlocalStorage.removeItem('key');\n\n// 从 localStorage 删除所有保存的数据\nlocalStorage.clear();\n\n// 获取某个索引的Key\nlocalStorage.key(index)\n\n\nLocalStorage的使用场景：\n\n * 有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可\n * 在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中\n\n# （3）SessionStorage\n\nSessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。\n\nSessionStorage与LocalStorage对比：\n\n * SessionStorage和LocalStorage都在本地进行数据存储；\n * SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage只有在同一浏览器的同一窗口下才能够共享；\n * LocalStorage和SessionStorage都不能被爬虫爬取；\n\nSessionStorage的常用API：\n\n// 保存数据到 sessionStorage\nsessionStorage.setItem('key', 'value');\n\n// 从 sessionStorage 获取数据\nlet data = sessionStorage.getItem('key');\n\n// 从 sessionStorage 删除保存的数据\nsessionStorage.removeItem('key');\n\n// 从 sessionStorage 删除所有保存的数据\nsessionStorage.clear();\n\n// 获取某个索引的Key\nsessionStorage.key(index)\n\n\nSessionStorage的使用场景\n\n * 由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。\n\n\n# 2. Cookie有哪些字段，作用分别是什么\n\nCookie由以下字段组成：\n\n * Name：cookie的名称\n * Value：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；\n * Size： cookie的大小\n * Path：可以访问此cookie的页面路径。 比如domain是abc.com，path是/test，那么只有/test路径下的页面可以读取此cookie。\n * Secure： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。\n * Domain：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。\n * HTTP： 该字段包含HTTPOnly 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过document.cookie属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。\n * Expires/Max-size ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。\n\n总结： 服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。\n\n\n# 3. Cookie、LocalStorage、SessionStorage区别\n\n浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。\n\n * cookie： 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。\n * sessionStorage： html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。\n * localStorage： html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。\n\n上面几种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。\n\n\n# 4. 前端储存的⽅式有哪些？\n\n * cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；\n * localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；\n * sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式；\n * Web SQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐；\n * IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。\n\n\n# 5. IndexedDB有哪些特点？\n\nIndexedDB 具有以下特点：\n\n * 键值对储存：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以\"键值对\"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。\n * 异步：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。\n * 支持事务：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。\n * 同源限制： IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。\n * 储存空间大：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。\n * 支持二进制储存：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。",
      "normalizedContent": "# 1. 浏览器本地存储方式及使用场景\n\n# （1）cookie\n\ncookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，cookie就出现了。cookie的大小只有4kb，它是一种纯文本文件，每次发起http请求都会携带cookie。\n\ncookie的特性：\n\n * cookie一旦创建成功，名称就无法修改\n * cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的cookie\n * 每个域名下cookie的数量不能超过20个，每个cookie的大小不能超过4kb\n * 有安全问题，如果cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的\n * cookie在请求一个新的页面的时候都会被发送过去\n\n如果需要域名之间跨域共享cookie，有两种方法：\n\n 1. 使用nginx反向代理\n 2. 在一个站点登陆之后，往其他网站写cookie。服务端的session存储到一个节点，cookie存储sessionid\n\ncookie的使用场景：\n\n * 最常见的使用场景就是cookie和session结合使用，我们将sessionid存储到cookie中，每次发请求都会携带这个sessionid，这样服务端就知道是谁发起的请求，从而响应相应的信息。\n * 可以用来统计页面的点击次数\n\n# （2）localstorage\n\nlocalstorage是html5新引入的特性，由于有的时候我们存储的信息较大，cookie就不能满足我们的需求，这时候localstorage就派上用场了。\n\nlocalstorage的优点：\n\n * 在大小方面，localstorage的大小一般为5mb，可以储存更多的信息\n * localstorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在\n * 仅储存在本地，不像cookie那样每次http请求都会被携带\n\nlocalstorage的缺点：\n\n * 存在浏览器兼容问题，ie8以下版本的浏览器不支持\n * 如果浏览器设置为隐私模式，那我们将无法读取到localstorage\n * localstorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问\n\nlocalstorage的常用api：\n\n// 保存数据到 localstorage\nlocalstorage.setitem('key', 'value');\n\n// 从 localstorage 获取数据\nlet data = localstorage.getitem('key');\n\n// 从 localstorage 删除保存的数据\nlocalstorage.removeitem('key');\n\n// 从 localstorage 删除所有保存的数据\nlocalstorage.clear();\n\n// 获取某个索引的key\nlocalstorage.key(index)\n\n\nlocalstorage的使用场景：\n\n * 有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的localstorage中，当需要换肤的时候，直接操作localstorage即可\n * 在网站中的用户浏览信息也会存储在localstorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的localstorage中\n\n# （3）sessionstorage\n\nsessionstorage和localstorage都是在html5才提出来的存储方案，sessionstorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。\n\nsessionstorage与localstorage对比：\n\n * sessionstorage和localstorage都在本地进行数据存储；\n * sessionstorage也有同源策略的限制，但是sessionstorage有一条更加严格的限制，sessionstorage只有在同一浏览器的同一窗口下才能够共享；\n * localstorage和sessionstorage都不能被爬虫爬取；\n\nsessionstorage的常用api：\n\n// 保存数据到 sessionstorage\nsessionstorage.setitem('key', 'value');\n\n// 从 sessionstorage 获取数据\nlet data = sessionstorage.getitem('key');\n\n// 从 sessionstorage 删除保存的数据\nsessionstorage.removeitem('key');\n\n// 从 sessionstorage 删除所有保存的数据\nsessionstorage.clear();\n\n// 获取某个索引的key\nsessionstorage.key(index)\n\n\nsessionstorage的使用场景\n\n * 由于sessionstorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。\n\n\n# 2. cookie有哪些字段，作用分别是什么\n\ncookie由以下字段组成：\n\n * name：cookie的名称\n * value：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；\n * size： cookie的大小\n * path：可以访问此cookie的页面路径。 比如domain是abc.com，path是/test，那么只有/test路径下的页面可以读取此cookie。\n * secure： 指定是否使用https安全协议发送cookie。使用https安全协议，可以保护cookie在浏览器和web服务器间的传输过程中不被窃取和篡改。该方法也可用于web站点的身份鉴别，即在https的连接建立阶段，浏览器会检查web网站的ssl证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到ssl证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。\n * domain：可以访问该cookie的域名，cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 cookie。当需要实现单点登录方案时，cookie 的上述特性非常有用，然而也增加了 cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。\n * http： 该字段包含httponly 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httponly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过document.cookie属性访问cookie，有助于保护cookie不被跨站脚本攻击窃取或篡改。但是，httponly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过xmlhttp对象读取http响应中的set-cookie头。\n * expires/max-size ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。\n\n总结： 服务器端可以使用 set-cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、httponly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，httponly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。\n\n\n# 3. cookie、localstorage、sessionstorage区别\n\n浏览器端常用的存储技术是 cookie 、localstorage 和 sessionstorage。\n\n * cookie： 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。\n * sessionstorage： html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5m 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionstorage 只能被同一个窗口的同源页面所访问共享。\n * localstorage： html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5m 或者更大的数据。它和 sessionstorage 不同的是，除非手动删除它，否则它不会失效，并且 localstorage 也只能被同源页面所访问共享。\n\n上面几种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 indexdb 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 nosql 数据库。\n\n\n# 4. 前端储存的⽅式有哪些？\n\n * cookies： 在html5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；\n * localstorage：html5加⼊的以键值对(key-value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5m，兼容ie8+ ；\n * sessionstorage：与localstorage基本类似，区别是sessionstorage当⻚⾯关闭后会被清理，⽽且与cookie、localstorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式；\n * web sql：2010年被w3c废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于sqlite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤javascript时要进⾏转换，较为繁琐；\n * indexeddb： 是被正式纳⼊html5标准的数据库储存⽅案，它是nosql数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤javascript进⾏操作会⾮常便。\n\n\n# 5. indexeddb有哪些特点？\n\nindexeddb 具有以下特点：\n\n * 键值对储存：indexeddb 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 javascript 对象。对象仓库中，数据以\"键值对\"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。\n * 异步：indexeddb 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 localstorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。\n * 支持事务：indexeddb 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。\n * 同源限制： indexeddb 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。\n * 储存空间大：indexeddb 的储存空间比 localstorage 大得多，一般来说不少于 250mb，甚至没有上限。\n * 支持二进制储存：indexeddb 不仅可以储存字符串，还可以储存二进制数据（arraybuffer 对象和 blob 对象）。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "浏览器同源策略",
      "frontmatter": {
        "title": "浏览器同源策略",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/browser/cognate/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/20.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/70.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5.html",
      "relativePath": "50.性能&网络篇/20.浏览器原理篇/70.浏览器同源策略.md",
      "key": "v-4576f5d3",
      "path": "/pages/browser/cognate/",
      "headers": [
        {
          "level": 3,
          "title": "1. 什么是同源策略",
          "slug": "_1-什么是同源策略",
          "normalizedTitle": "1. 什么是同源策略",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 如何解决跨越问题",
          "slug": "_2-如何解决跨越问题",
          "normalizedTitle": "2. 如何解决跨越问题",
          "charIndex": 779
        },
        {
          "level": 3,
          "title": "3. 正向代理和反向代理的区别",
          "slug": "_3-正向代理和反向代理的区别",
          "normalizedTitle": "3. 正向代理和反向代理的区别",
          "charIndex": 13128
        },
        {
          "level": 3,
          "title": "4. Nginx的概念及其工作原理",
          "slug": "_4-nginx的概念及其工作原理",
          "normalizedTitle": "4. nginx的概念及其工作原理",
          "charIndex": 13652
        }
      ],
      "headersStr": "1. 什么是同源策略 2. 如何解决跨越问题 3. 正向代理和反向代理的区别 4. Nginx的概念及其工作原理",
      "content": "# 1. 什么是同源策略\n\n跨域问题其实就是浏览器的同源策略造成的。\n\n> 同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：协议、端口号、域名必须一致。\n\n下表给出了与 URL store.company.com/dir/page.ht… 的源进行对比的示例:\n\nURL                                 是否跨域   原因\nstore.company.com/dir/page.ht…      同源     完全相同\nstore.company.com/dir/inner/a…      同源     只有路径不同\nstore.company.com/secure.html       跨域     协议不同\nstore.company.com:81/dir/etc.htm…   跨域     端口不同 ( http:// 默认端口是80)\nnews.company.com/dir/other.h…       跨域     主机不同\n\n同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。\n\n同源政策主要限制了三个方面：\n\n * 当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。\n * 当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。\n * 当前域下 ajax 无法发送跨域请求。\n\n同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。\n\n\n# 2. 如何解决跨越问题\n\n# （1）CORS\n\n下面是MDN对于CORS的定义：\n\n> 跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。\n\nCORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现CORS的关键就是服务器，只要服务器实现了CORS请求，就可以跨源通信了。\n\n浏览器将CORS分为简单请求和非简单请求：\n\n简单请求不会触发CORS预检请求。若该请求满足以下两个条件，就可以看作是简单请求：\n\n1）请求方法是以下三种方法之一：\n\n * HEAD\n * GET\n * POST\n\n2）HTTP的头信息不超出以下几种字段：\n\n * Accept\n * Accept-Language\n * Content-Language\n * Last-Event-ID\n * Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n若不满足以上条件，就属于非简单请求了。\n\n（1）简单请求过程：\n\n对于简单请求，浏览器会直接发出CORS请求，它会在请求的头信息中增加一个Orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Orign指定的域名在许可范围之内，服务器返回的响应就会多出以下信息头：\n\nAccess-Control-Allow-Origin: http://api.bob.com  // 和Orign一直\nAccess-Control-Allow-Credentials: true   // 表示是否允许发送Cookie\nAccess-Control-Expose-Headers: FooBar   // 指定返回其他字段的值\nContent-Type: text/html; charset=utf-8   // 表示文档类型\n\n\n如果Orign指定的域名不在许可范围之内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。\n\n在简单请求中，在服务器内，至少需要设置字段：Access-Control-Allow-Origin\n\n（2）非简单请求过程\n\n非简单请求是对服务器有特殊要求的请求，比如请求方法为DELETE或者PUT等。非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，称为预检请求。\n\n浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。\n\n预检请求使用的请求方法是OPTIONS，表示这个请求是来询问的。他的头信息中的关键字段是Orign，表示请求来自哪个源。除此之外，头信息中还包括两个字段：\n\n * Access-Control-Request-Method：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。\n * Access-Control-Request-Headers： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。\n\n服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有Access-Control-Allow-Origin这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。\n\n服务器回应的CORS的字段如下：\n\nAccess-Control-Allow-Origin: http://api.bob.com  // 允许跨域的源地址\nAccess-Control-Allow-Methods: GET, POST, PUT // 服务器支持的所有跨域请求的方法\nAccess-Control-Allow-Headers: X-Custom-Header  // 服务器支持的所有头信息字段\nAccess-Control-Allow-Credentials: true   // 表示是否允许发送Cookie\nAccess-Control-Max-Age: 1728000  // 用来指定本次预检请求的有效期，单位为秒\n\n\n只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。\n\n在非简单请求中，至少需要设置以下字段：\n\n'Access-Control-Allow-Origin'  \n'Access-Control-Allow-Methods'\n'Access-Control-Allow-Headers'\n\n\n# 减少OPTIONS请求次数：\n\nOPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。\n\n# CORS中Cookie相关问题：\n\n在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：\n\n * 在请求中设置 withCredentials\n\n默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie.\n\n// 原生 xml 的设置方式\nvar xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n// axios 设置方式\naxios.defaults.withCredentials = true;\n\n\n * Access-Control-Allow-Credentials 设置为 true\n * Access-Control-Allow-Origin 设置为非 *\n\n# （2）JSONP\n\njsonp的原理就是利用<script>标签没有跨域限制，通过<script>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。 1）原生JS实现：\n\n<script>\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数\n    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';\n    document.head.appendChild(script);\n    // 回调执行函数\n    function handleCallback(res) {\n        alert(JSON.stringify(res));\n    }\n </script>\n\n\n服务端返回如下（返回时即执行全局函数）：\n\nhandleCallback({\"success\": true, \"user\": \"admin\"})\n\n\n2）Vue axios实现：\n\nthis.$http = axios;\nthis.$http.jsonp('http://www.domain2.com:8080/login', {\n    params: {},\n    jsonp: 'handleCallback'\n}).then((res) => {\n    console.log(res); \n})\n\n\n后端node.js代码：\n\nvar querystring = require('querystring');\nvar http = require('http');\nvar server = http.createServer();\nserver.on('request', function(req, res) {\n    var params = querystring.parse(req.url.split('?')[1]);\n    var fn = params.callback;\n    // jsonp返回设置\n    res.writeHead(200, { 'Content-Type': 'text/javascript' });\n    res.write(fn + '(' + JSON.stringify(params) + ')');\n    res.end();\n});\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');\n\n\nJSONP的缺点：\n\n * 具有局限性， 仅支持get方法\n * 不安全，可能会遭受XSS攻击\n\n# （3）postMessage 跨域\n\npostMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：\n\n * 页面和其打开的新窗口的数据传递\n * 多窗口之间消息传递\n * 页面与嵌套的iframe消息传递\n * 上面三个场景的跨域数据传递\n\n用法：postMessage(data,origin)方法接受两个参数：\n\n * data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。\n * origin： 协议+主机+端口号，也可以设置为\"*\"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为\"/\"。\n\n1）a.html：(domain1.com/a.html)\n\n<iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"></iframe>\n<script>       \n    var iframe = document.getElementById('iframe');\n    iframe.onload = function() {\n        var data = {\n            name: 'aym'\n        };\n        // 向domain2传送跨域数据\n        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');\n    };\n    // 接受domain2返回数据\n    window.addEventListener('message', function(e) {\n        alert('data from domain2 ---> ' + e.data);\n    }, false);\n</script>\n\n\n2）b.html：(domain2.com/b.html)\n\n<script>\n    // 接收domain1的数据\n    window.addEventListener('message', function(e) {\n        alert('data from domain1 ---> ' + e.data);\n        var data = JSON.parse(e.data);\n        if (data) {\n            data.number = 16;\n            // 处理后再发回domain1\n            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');\n        }\n    }, false);\n</script>\n\n\n# （4）nginx代理跨域\n\nnginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。\n\n1）nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。\n\nlocation / {\n  add_header Access-Control-Allow-Origin *;\n}\n\n\n2）nginx反向代理接口跨域 跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。 实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。\n\nnginx具体配置：\n\n#proxy服务器\nserver {\n    listen       81;\n    server_name  www.domain1.com;\n    location / {\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    }\n}\n\n\n# （5）nodejs 中间件代理跨域\n\nnode中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。\n\n1）非vue框架的跨域 使用node + express + http-proxy-middleware搭建一个proxy服务器。\n\n * 前端代码：\n\nvar xhr = new XMLHttpRequest();\n// 前端开关：浏览器是否读写cookie\nxhr.withCredentials = true;\n// 访问http-proxy-middleware代理服务器\nxhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);\nxhr.send();\n\n\n * 中间件服务器代码：\n\nvar express = require('express');\nvar proxy = require('http-proxy-middleware');\nvar app = express();\napp.use('/', proxy({\n    // 代理跨域目标接口\n    target: 'http://www.domain2.com:8080',\n    changeOrigin: true,\n    // 修改响应头信息，实现跨域并允许带cookie\n    onProxyRes: function(proxyRes, req, res) {\n        res.header('Access-Control-Allow-Origin', 'http://www.domain1.com');\n        res.header('Access-Control-Allow-Credentials', 'true');\n    },\n    // 修改响应信息中的cookie域名\n    cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改\n}));\napp.listen(3000);\nconsole.log('Proxy server is listen at port 3000...');\n\n\n2）vue框架的跨域\n\nnode + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。\n\nwebpack.config.js部分配置：\n\nmodule.exports = {\n    entry: {},\n    module: {},\n    ...\n    devServer: {\n        historyApiFallback: true,\n        proxy: [{\n            context: '/login',\n            target: 'http://www.domain2.com:8080',  // 代理跨域目标接口\n            changeOrigin: true,\n            secure: false,  // 当代理某些https服务报错时用\n            cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改\n        }],\n        noInfo: true\n    }\n}\n\n\n# （6）document.domain + iframe跨域\n\n此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1）父窗口：(domain.com/a.html)\n\n<iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"></iframe>\n<script>\n    document.domain = 'domain.com';\n    var user = 'admin';\n</script>\n\n\n1）子窗口：(child.domain.com/a.html)\n\n<script>\n    document.domain = 'domain.com';\n    // 获取父窗口中变量\n    console.log('get js data from parent ---> ' + window.parent.user);\n</script>\n\n\n# （7）location.hash + iframe跨域\n\n实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。\n\n具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。\n\n1）a.html：(domain1.com/a.html)\n\n<iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"></iframe>\n<script>\n    var iframe = document.getElementById('iframe');\n    // 向b.html传hash值\n    setTimeout(function() {\n        iframe.src = iframe.src + '#user=admin';\n    }, 1000);\n    \n    // 开放给同域c.html的回调方法\n    function onCallback(res) {\n        alert('data from c.html ---> ' + res);\n    }\n</script>\n\n\n2）b.html：(.domain2.com/b.html)\n\n<iframe id=\"iframe\" src=\"http://www.domain1.com/c.html\" style=\"display:none;\"></iframe>\n<script>\n    var iframe = document.getElementById('iframe');\n    // 监听a.html传来的hash值，再传给c.html\n    window.onhashchange = function () {\n        iframe.src = iframe.src + location.hash;\n    };\n</script>\n\n\n3）c.html：(www.domain1.com/c.html)\n\n<script>\n    // 监听b.html传来的hash值\n    window.onhashchange = function () {\n        // 再通过操作同域a.html的js回调，将结果传回\n        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));\n    };\n</script>\n\n\n# （8）window.name + iframe跨域\n\nwindow.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。\n\n1）a.html：(domain1.com/a.html)\n\nvar proxy = function(url, callback) {\n    var state = 0;\n    var iframe = document.createElement('iframe');\n    // 加载跨域页面\n    iframe.src = url;\n    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name\n    iframe.onload = function() {\n        if (state === 1) {\n            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据\n            callback(iframe.contentWindow.name);\n            destoryFrame();\n        } else if (state === 0) {\n            // 第1次onload(跨域页)成功后，切换到同域代理页面\n            iframe.contentWindow.location = 'http://www.domain1.com/proxy.html';\n            state = 1;\n        }\n    };\n    document.body.appendChild(iframe);\n    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）\n    function destoryFrame() {\n        iframe.contentWindow.document.write('');\n        iframe.contentWindow.close();\n        document.body.removeChild(iframe);\n    }\n};\n// 请求跨域b页面数据\nproxy('http://www.domain2.com/b.html', function(data){\n    alert(data);\n});\n\n\n2）proxy.html：(domain1.com/proxy.html)\n\n中间代理页，与a.html同域，内容为空即可。 3）b.html：(domain2.com/b.html)\n\n<script>    \n    window.name = 'This is domain2 data!';\n</script>\n\n\n通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。\n\n# （9）WebSocket协议跨域\n\nWebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。\n\n原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。\n\n1）前端代码：\n\n<div>user input：<input type=\"text\"></div>\n<script src=\"https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js\"></script>\n<script>\nvar socket = io('http://www.domain2.com:8080');\n// 连接成功处理\nsocket.on('connect', function() {\n    // 监听服务端消息\n    socket.on('message', function(msg) {\n        console.log('data from server: ---> ' + msg); \n    });\n    // 监听服务端关闭\n    socket.on('disconnect', function() { \n        console.log('Server socket has closed.'); \n    });\n});\ndocument.getElementsByTagName('input')[0].onblur = function() {\n    socket.send(this.value);\n};\n</script>\n\n\n2）Nodejs socket后台：\n\nvar http = require('http');\nvar socket = require('socket.io');\n// 启http服务\nvar server = http.createServer(function(req, res) {\n    res.writeHead(200, {\n        'Content-type': 'text/html'\n    });\n    res.end();\n});\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');\n// 监听socket连接\nsocket.listen(server).on('connection', function(client) {\n    // 接收信息\n    client.on('message', function(msg) {\n        client.send('hello：' + msg);\n        console.log('data from client: ---> ' + msg);\n    });\n    // 断开处理\n    client.on('disconnect', function() {\n        console.log('Client socket has closed.'); \n    });\n});\n\n\n\n# 3. 正向代理和反向代理的区别\n\n * 正向代理：\n\n客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。\n\n * 反向代理：\n\n服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。 一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。\n\n两者区别如图示： 正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。\n\n\n# 4. Nginx的概念及其工作原理\n\nNginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。\n\n传统的 Web 服务器如 Apache 是 process-based 模型的，而 Nginx 是基于event-driven模型的。正是这个主要的区别带给了 Nginx 在性能上的优势。\n\nNginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的HTTP请求，而每个 Apache process 只能处理一个。",
      "normalizedContent": "# 1. 什么是同源策略\n\n跨域问题其实就是浏览器的同源策略造成的。\n\n> 同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：协议、端口号、域名必须一致。\n\n下表给出了与 url store.company.com/dir/page.ht… 的源进行对比的示例:\n\nurl                                 是否跨域   原因\nstore.company.com/dir/page.ht…      同源     完全相同\nstore.company.com/dir/inner/a…      同源     只有路径不同\nstore.company.com/secure.html       跨域     协议不同\nstore.company.com:81/dir/etc.htm…   跨域     端口不同 ( http:// 默认端口是80)\nnews.company.com/dir/other.h…       跨域     主机不同\n\n同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。\n\n同源政策主要限制了三个方面：\n\n * 当前域下的 js 脚本不能够访问其他域下的 cookie、localstorage 和 indexdb。\n * 当前域下的 js 脚本不能够操作访问操作其他域下的 dom。\n * 当前域下 ajax 无法发送跨域请求。\n\n同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。\n\n\n# 2. 如何解决跨越问题\n\n# （1）cors\n\n下面是mdn对于cors的定义：\n\n> 跨域资源共享(cors) 是一种机制，它使用额外的 http 头来告诉浏览器 让运行在一个 origin (domain)上的web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域http 请求。\n\ncors需要浏览器和服务器同时支持，整个cors过程都是浏览器完成的，无需用户参与。因此实现cors的关键就是服务器，只要服务器实现了cors请求，就可以跨源通信了。\n\n浏览器将cors分为简单请求和非简单请求：\n\n简单请求不会触发cors预检请求。若该请求满足以下两个条件，就可以看作是简单请求：\n\n1）请求方法是以下三种方法之一：\n\n * head\n * get\n * post\n\n2）http的头信息不超出以下几种字段：\n\n * accept\n * accept-language\n * content-language\n * last-event-id\n * content-type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n若不满足以上条件，就属于非简单请求了。\n\n（1）简单请求过程：\n\n对于简单请求，浏览器会直接发出cors请求，它会在请求的头信息中增加一个orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果orign指定的域名在许可范围之内，服务器返回的响应就会多出以下信息头：\n\naccess-control-allow-origin: http://api.bob.com  // 和orign一直\naccess-control-allow-credentials: true   // 表示是否允许发送cookie\naccess-control-expose-headers: foobar   // 指定返回其他字段的值\ncontent-type: text/html; charset=utf-8   // 表示文档类型\n\n\n如果orign指定的域名不在许可范围之内，服务器会返回一个正常的http回应，浏览器发现没有上面的access-control-allow-origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。\n\n在简单请求中，在服务器内，至少需要设置字段：access-control-allow-origin\n\n（2）非简单请求过程\n\n非简单请求是对服务器有特殊要求的请求，比如请求方法为delete或者put等。非简单请求的cors请求会在正式通信之前进行一次http查询请求，称为预检请求。\n\n浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些http请求方式和头信息字段，只有得到肯定的回复，才会进行正式的http请求，否则就会报错。\n\n预检请求使用的请求方法是options，表示这个请求是来询问的。他的头信息中的关键字段是orign，表示请求来自哪个源。除此之外，头信息中还包括两个字段：\n\n * access-control-request-method：该字段是必须的，用来列出浏览器的cors请求会用到哪些http方法。\n * access-control-request-headers： 该字段是一个逗号分隔的字符串，指定浏览器cors请求会额外发送的头信息字段。\n\n服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有access-control-allow-origin这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。\n\n服务器回应的cors的字段如下：\n\naccess-control-allow-origin: http://api.bob.com  // 允许跨域的源地址\naccess-control-allow-methods: get, post, put // 服务器支持的所有跨域请求的方法\naccess-control-allow-headers: x-custom-header  // 服务器支持的所有头信息字段\naccess-control-allow-credentials: true   // 表示是否允许发送cookie\naccess-control-max-age: 1728000  // 用来指定本次预检请求的有效期，单位为秒\n\n\n只要服务器通过了预检请求，在以后每次的cors请求都会自带一个origin头信息字段。服务器的回应，也都会有一个access-control-allow-origin头信息字段。\n\n在非简单请求中，至少需要设置以下字段：\n\n'access-control-allow-origin'  \n'access-control-allow-methods'\n'access-control-allow-headers'\n\n\n# 减少options请求次数：\n\noptions请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少options请求次数，可以后端在请求的返回头部添加：access-control-max-age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的url的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。\n\n# cors中cookie相关问题：\n\n在cors请求中，如果想要传递cookie，就要满足以下三个条件：\n\n * 在请求中设置 withcredentials\n\n默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withcredentials 来进行传递 cookie.\n\n// 原生 xml 的设置方式\nvar xhr = new xmlhttprequest();\nxhr.withcredentials = true;\n// axios 设置方式\naxios.defaults.withcredentials = true;\n\n\n * access-control-allow-credentials 设置为 true\n * access-control-allow-origin 设置为非 *\n\n# （2）jsonp\n\njsonp的原理就是利用<script>标签没有跨域限制，通过<script>标签src属性，发送带有callback参数的get请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。 1）原生js实现：\n\n<script>\n    var script = document.createelement('script');\n    script.type = 'text/javascript';\n    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数\n    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handlecallback';\n    document.head.appendchild(script);\n    // 回调执行函数\n    function handlecallback(res) {\n        alert(json.stringify(res));\n    }\n </script>\n\n\n服务端返回如下（返回时即执行全局函数）：\n\nhandlecallback({\"success\": true, \"user\": \"admin\"})\n\n\n2）vue axios实现：\n\nthis.$http = axios;\nthis.$http.jsonp('http://www.domain2.com:8080/login', {\n    params: {},\n    jsonp: 'handlecallback'\n}).then((res) => {\n    console.log(res); \n})\n\n\n后端node.js代码：\n\nvar querystring = require('querystring');\nvar http = require('http');\nvar server = http.createserver();\nserver.on('request', function(req, res) {\n    var params = querystring.parse(req.url.split('?')[1]);\n    var fn = params.callback;\n    // jsonp返回设置\n    res.writehead(200, { 'content-type': 'text/javascript' });\n    res.write(fn + '(' + json.stringify(params) + ')');\n    res.end();\n});\nserver.listen('8080');\nconsole.log('server is running at port 8080...');\n\n\njsonp的缺点：\n\n * 具有局限性， 仅支持get方法\n * 不安全，可能会遭受xss攻击\n\n# （3）postmessage 跨域\n\npostmessage是html5 xmlhttprequest level 2中的api，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：\n\n * 页面和其打开的新窗口的数据传递\n * 多窗口之间消息传递\n * 页面与嵌套的iframe消息传递\n * 上面三个场景的跨域数据传递\n\n用法：postmessage(data,origin)方法接受两个参数：\n\n * data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用json.stringify()序列化。\n * origin： 协议+主机+端口号，也可以设置为\"*\"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为\"/\"。\n\n1）a.html：(domain1.com/a.html)\n\n<iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"></iframe>\n<script>       \n    var iframe = document.getelementbyid('iframe');\n    iframe.onload = function() {\n        var data = {\n            name: 'aym'\n        };\n        // 向domain2传送跨域数据\n        iframe.contentwindow.postmessage(json.stringify(data), 'http://www.domain2.com');\n    };\n    // 接受domain2返回数据\n    window.addeventlistener('message', function(e) {\n        alert('data from domain2 ---> ' + e.data);\n    }, false);\n</script>\n\n\n2）b.html：(domain2.com/b.html)\n\n<script>\n    // 接收domain1的数据\n    window.addeventlistener('message', function(e) {\n        alert('data from domain1 ---> ' + e.data);\n        var data = json.parse(e.data);\n        if (data) {\n            data.number = 16;\n            // 处理后再发回domain1\n            window.parent.postmessage(json.stringify(data), 'http://www.domain1.com');\n        }\n    }, false);\n</script>\n\n\n# （4）nginx代理跨域\n\nnginx代理跨域，实质和cors跨域原理一样，通过配置文件设置请求响应头access-control-allow-origin…等字段。\n\n1）nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。\n\nlocation / {\n  add_header access-control-allow-origin *;\n}\n\n\n2）nginx反向代理接口跨域 跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用http接口只是使用http协议，不需要同源策略，也就不存在跨域问题。 实现思路：通过nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。\n\nnginx具体配置：\n\n#proxy服务器\nserver {\n    listen       81;\n    server_name  www.domain1.com;\n    location / {\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header access-control-allow-origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header access-control-allow-credentials true;\n    }\n}\n\n\n# （5）nodejs 中间件代理跨域\n\nnode中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookiedomainrewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。\n\n1）非vue框架的跨域 使用node + express + http-proxy-middleware搭建一个proxy服务器。\n\n * 前端代码：\n\nvar xhr = new xmlhttprequest();\n// 前端开关：浏览器是否读写cookie\nxhr.withcredentials = true;\n// 访问http-proxy-middleware代理服务器\nxhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);\nxhr.send();\n\n\n * 中间件服务器代码：\n\nvar express = require('express');\nvar proxy = require('http-proxy-middleware');\nvar app = express();\napp.use('/', proxy({\n    // 代理跨域目标接口\n    target: 'http://www.domain2.com:8080',\n    changeorigin: true,\n    // 修改响应头信息，实现跨域并允许带cookie\n    onproxyres: function(proxyres, req, res) {\n        res.header('access-control-allow-origin', 'http://www.domain1.com');\n        res.header('access-control-allow-credentials', 'true');\n    },\n    // 修改响应信息中的cookie域名\n    cookiedomainrewrite: 'www.domain1.com'  // 可以为false，表示不修改\n}));\napp.listen(3000);\nconsole.log('proxy server is listen at port 3000...');\n\n\n2）vue框架的跨域\n\nnode + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。\n\nwebpack.config.js部分配置：\n\nmodule.exports = {\n    entry: {},\n    module: {},\n    ...\n    devserver: {\n        historyapifallback: true,\n        proxy: [{\n            context: '/login',\n            target: 'http://www.domain2.com:8080',  // 代理跨域目标接口\n            changeorigin: true,\n            secure: false,  // 当代理某些https服务报错时用\n            cookiedomainrewrite: 'www.domain1.com'  // 可以为false，表示不修改\n        }],\n        noinfo: true\n    }\n}\n\n\n# （6）document.domain + iframe跨域\n\n此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1）父窗口：(domain.com/a.html)\n\n<iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"></iframe>\n<script>\n    document.domain = 'domain.com';\n    var user = 'admin';\n</script>\n\n\n1）子窗口：(child.domain.com/a.html)\n\n<script>\n    document.domain = 'domain.com';\n    // 获取父窗口中变量\n    console.log('get js data from parent ---> ' + window.parent.user);\n</script>\n\n\n# （7）location.hash + iframe跨域\n\n实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。\n\n具体实现：a域：a.html -> b域：b.html -> a域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。\n\n1）a.html：(domain1.com/a.html)\n\n<iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"></iframe>\n<script>\n    var iframe = document.getelementbyid('iframe');\n    // 向b.html传hash值\n    settimeout(function() {\n        iframe.src = iframe.src + '#user=admin';\n    }, 1000);\n    \n    // 开放给同域c.html的回调方法\n    function oncallback(res) {\n        alert('data from c.html ---> ' + res);\n    }\n</script>\n\n\n2）b.html：(.domain2.com/b.html)\n\n<iframe id=\"iframe\" src=\"http://www.domain1.com/c.html\" style=\"display:none;\"></iframe>\n<script>\n    var iframe = document.getelementbyid('iframe');\n    // 监听a.html传来的hash值，再传给c.html\n    window.onhashchange = function () {\n        iframe.src = iframe.src + location.hash;\n    };\n</script>\n\n\n3）c.html：(www.domain1.com/c.html)\n\n<script>\n    // 监听b.html传来的hash值\n    window.onhashchange = function () {\n        // 再通过操作同域a.html的js回调，将结果传回\n        window.parent.parent.oncallback('hello: ' + location.hash.replace('#user=', ''));\n    };\n</script>\n\n\n# （8）window.name + iframe跨域\n\nwindow.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2mb）。\n\n1）a.html：(domain1.com/a.html)\n\nvar proxy = function(url, callback) {\n    var state = 0;\n    var iframe = document.createelement('iframe');\n    // 加载跨域页面\n    iframe.src = url;\n    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name\n    iframe.onload = function() {\n        if (state === 1) {\n            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据\n            callback(iframe.contentwindow.name);\n            destoryframe();\n        } else if (state === 0) {\n            // 第1次onload(跨域页)成功后，切换到同域代理页面\n            iframe.contentwindow.location = 'http://www.domain1.com/proxy.html';\n            state = 1;\n        }\n    };\n    document.body.appendchild(iframe);\n    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）\n    function destoryframe() {\n        iframe.contentwindow.document.write('');\n        iframe.contentwindow.close();\n        document.body.removechild(iframe);\n    }\n};\n// 请求跨域b页面数据\nproxy('http://www.domain2.com/b.html', function(data){\n    alert(data);\n});\n\n\n2）proxy.html：(domain1.com/proxy.html)\n\n中间代理页，与a.html同域，内容为空即可。 3）b.html：(domain2.com/b.html)\n\n<script>    \n    window.name = 'this is domain2 data!';\n</script>\n\n\n通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。\n\n# （9）websocket协议跨域\n\nwebsocket protocol是html5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。\n\n原生websocket api使用起来不太方便，我们使用socket.io，它很好地封装了websocket接口，提供了更简单、灵活的接口，也对不支持websocket的浏览器提供了向下兼容。\n\n1）前端代码：\n\n<div>user input：<input type=\"text\"></div>\n<script src=\"https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js\"></script>\n<script>\nvar socket = io('http://www.domain2.com:8080');\n// 连接成功处理\nsocket.on('connect', function() {\n    // 监听服务端消息\n    socket.on('message', function(msg) {\n        console.log('data from server: ---> ' + msg); \n    });\n    // 监听服务端关闭\n    socket.on('disconnect', function() { \n        console.log('server socket has closed.'); \n    });\n});\ndocument.getelementsbytagname('input')[0].onblur = function() {\n    socket.send(this.value);\n};\n</script>\n\n\n2）nodejs socket后台：\n\nvar http = require('http');\nvar socket = require('socket.io');\n// 启http服务\nvar server = http.createserver(function(req, res) {\n    res.writehead(200, {\n        'content-type': 'text/html'\n    });\n    res.end();\n});\nserver.listen('8080');\nconsole.log('server is running at port 8080...');\n// 监听socket连接\nsocket.listen(server).on('connection', function(client) {\n    // 接收信息\n    client.on('message', function(msg) {\n        client.send('hello：' + msg);\n        console.log('data from client: ---> ' + msg);\n    });\n    // 断开处理\n    client.on('disconnect', function() {\n        console.log('client socket has closed.'); \n    });\n});\n\n\n\n# 3. 正向代理和反向代理的区别\n\n * 正向代理：\n\n客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。\n\n * 反向代理：\n\n服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。 一般使用反向代理后，需要通过修改 dns 让域名解析到代理服务器 ip，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。\n\n两者区别如图示： 正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。\n\n\n# 4. nginx的概念及其工作原理\n\nnginx 是一款轻量级的 web 服务器，也可以用于反向代理、负载平衡和 http 缓存等。nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 http 服务器。\n\n传统的 web 服务器如 apache 是 process-based 模型的，而 nginx 是基于event-driven模型的。正是这个主要的区别带给了 nginx 在性能上的优势。\n\nnginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和apache 非常像，但是 nginx 的 worker process 可以同时处理大量的http请求，而每个 apache process 只能处理一个。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "浏览器事件机制",
      "frontmatter": {
        "title": "浏览器事件机制",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/browser/event/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/20.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/80.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6.html",
      "relativePath": "50.性能&网络篇/20.浏览器原理篇/80.浏览器事件机制.md",
      "key": "v-4919507d",
      "path": "/pages/browser/event/",
      "headers": [
        {
          "level": 3,
          "title": "1. 事件是什么？事件模型？",
          "slug": "_1-事件是什么-事件模型",
          "normalizedTitle": "1. 事件是什么？事件模型？",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 如何阻止事件冒泡",
          "slug": "_2-如何阻止事件冒泡",
          "normalizedTitle": "2. 如何阻止事件冒泡",
          "charIndex": 694
        },
        {
          "level": 3,
          "title": "3. 对事件委托的理解",
          "slug": "_3-对事件委托的理解",
          "normalizedTitle": "3. 对事件委托的理解",
          "charIndex": 784
        },
        {
          "level": 3,
          "title": "4. 事件委托的使用场景",
          "slug": "_4-事件委托的使用场景",
          "normalizedTitle": "4. 事件委托的使用场景",
          "charIndex": 2390
        },
        {
          "level": 3,
          "title": "5. 同步和异步的区别",
          "slug": "_5-同步和异步的区别",
          "normalizedTitle": "5. 同步和异步的区别",
          "charIndex": 2966
        },
        {
          "level": 3,
          "title": "6. 对事件循环的理解",
          "slug": "_6-对事件循环的理解",
          "normalizedTitle": "6. 对事件循环的理解",
          "charIndex": 3141
        },
        {
          "level": 3,
          "title": "7. 宏任务和微任务分别有哪些",
          "slug": "_7-宏任务和微任务分别有哪些",
          "normalizedTitle": "7. 宏任务和微任务分别有哪些",
          "charIndex": 3568
        },
        {
          "level": 3,
          "title": "8. 什么是执行栈",
          "slug": "_8-什么是执行栈",
          "normalizedTitle": "8. 什么是执行栈",
          "charIndex": 3755
        },
        {
          "level": 3,
          "title": "9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？",
          "slug": "_9-node-中的-event-loop-和浏览器中的有什么区别-process-nexttick-执行顺序",
          "normalizedTitle": "9. node 中的 event loop 和浏览器中的有什么区别？process.nexttick 执行顺序？",
          "charIndex": 4096
        },
        {
          "level": 3,
          "title": "10. 事件触发的过程是怎样的",
          "slug": "_10-事件触发的过程是怎样的",
          "normalizedTitle": "10. 事件触发的过程是怎样的",
          "charIndex": 6479
        }
      ],
      "headersStr": "1. 事件是什么？事件模型？ 2. 如何阻止事件冒泡 3. 对事件委托的理解 4. 事件委托的使用场景 5. 同步和异步的区别 6. 对事件循环的理解 7. 宏任务和微任务分别有哪些 8. 什么是执行栈 9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？ 10. 事件触发的过程是怎样的",
      "content": "# 1. 事件是什么？事件模型？\n\n事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。\n\n事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：\n\n * DOM0 级事件模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。\n * IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。\n * DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。\n\n\n# 2. 如何阻止事件冒泡\n\n * 普通浏览器使用：event.stopPropagation()\n * IE浏览器使用：event.cancelBubble = true;\n\n\n# 3. 对事件委托的理解\n\n# （1）事件委托的概念\n\n事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。\n\n使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。\n\n# （2）事件委托的特点\n\n * 减少内存消耗\n\n如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：\n\n<ul id=\"list\">\n  <li>item 1</li>\n  <li>item 2</li>\n  <li>item 3</li>\n  ......\n  <li>item n</li>\n</ul>\n\n\n如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。\n\n * 动态绑定事件\n\n给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。\n\n// 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：\n// 给父层元素绑定事件\ndocument.getElementById('list').addEventListener('click', function (e) {\n  // 兼容性处理\n  var event = e || window.event;\n  var target = event.target || event.srcElement;\n  // 判断是否匹配目标元素\n  if (target.nodeName.toLocaleLowerCase === 'li') {\n    console.log('the content is: ', target.innerHTML);\n  }\n});\n\n\n在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；\n\n# （3）局限性\n\n当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。\n\n当然事件委托不是只有优点，它也是有缺点的，事件委托会影响页面性能，主要影响因素有：\n\n * 元素中，绑定事件委托的次数；\n * 点击的最底层元素，到绑定事件元素之间的DOM层数；\n\n在必须使用事件委托的地方，可以进行如下的处理：\n\n * 只在必须的地方，使用事件委托，比如：ajax的局部刷新区域\n * 尽量的减少绑定的层级，不在body元素上，进行绑定\n * 减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。\n\n\n# 4. 事件委托的使用场景\n\n场景：给页面的所有的a标签添加click事件，代码如下：\n\ndocument.addEventListener(\"click\", function(e) {\n\tif (e.target.nodeName == \"A\")\n\t\tconsole.log(\"a\");\n}, false);\n\n\n但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。\n\n这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：\n\ndocument.addEventListener(\"click\", function(e) {\n\tvar node = e.target;\n\twhile (node.parentNode.nodeName != \"BODY\") {\n\t\tif (node.nodeName == \"A\") {\n\t\t\tconsole.log(\"a\");\n\t\t\tbreak;\n\t\t}\n\t\tnode = node.parentNode;\n\t}\n}, false);\n\n\n\n# 5. 同步和异步的区别\n\n * 同步指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。\n * 异步指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。\n\n\n# 6. 对事件循环的理解\n\n因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。\n\n\n\nEvent Loop 执行顺序如下所示：\n\n * 首先执行同步代码，这属于宏任务\n * 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行\n * 执行所有微任务\n * 当执行完所有微任务后，如有必要会渲染页面\n * 然后开始下一轮 Event Loop，执行宏任务中的异步代码\n\n\n# 7. 宏任务和微任务分别有哪些\n\n * 微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。\n * 宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。\n\n\n# 8. 什么是执行栈\n\n可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。 当开始执行 JS 代码时，根据先进后出的原则，后执行的函数会先弹出栈，可以看到，foo 函数后执行，当执行完毕后就从栈中弹出了。\n\n平时在开发中，可以在报错中找到执行栈的痕迹：\n\nfunction foo() {\n  throw new Error('error')\n}\nfunction bar() {\n  foo()\n}\nbar()\n\n\n可以看到报错在 foo 函数，foo 函数又是在 bar 函数中调用的。当使用递归时，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题\n\nfunction bar() {  bar()}bar()\n\n\n\n\n\n# 9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？\n\nNode 中的 Event Loop 和浏览器中的是完全不相同的东西。\n\nNode 的 Event Loop 分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。\n\n（1）Timers（计时器阶段）：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。\n\n（2）Pending callbacks：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。\n\n（3）Idle/Prepare：仅供内部使用。\n\n（4）Poll（轮询阶段）：\n\n * 当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。\n * 当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I/O操作完成，并马上执行相应的回调，直到所有回调执行完毕。\n\n（5）Check（查询阶段）：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。\n\n（6）Close callbacks：执行一些关闭回调，比如socket.on('close', ...)等。\n\n下面来看一个例子，首先在有些情况下，定时器的执行顺序其实是随机的\n\nsetTimeout(() => {    console.log('setTimeout')}, 0)setImmediate(() => {    console.log('setImmediate')})\n\n\n对于以上代码来说，setTimeout 可能执行在前，也可能执行在后\n\n * 首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的\n * 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调\n * 那么如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了\n\n当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：\n\nconst fs = require('fs')\nfs.readFile(__filename, () => {\n    setTimeout(() => {\n        console.log('timeout');\n    }, 0)\n    setImmediate(() => {\n        console.log('immediate')\n    })\n})\n\n\n在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。\n\n上面都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前清空 microtask 队列，下图中的 Tick 就代表了 microtask\n\nsetTimeout(() => {\n  console.log('timer21')\n}, 0)\nPromise.resolve().then(function() {\n  console.log('promise1')\n})\n\n\n对于以上代码来说，其实和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。\n\n最后来看 Node 中的 process.nextTick，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。\n\nsetTimeout(() => {\n console.log('timer1')\n Promise.resolve().then(function() {\n   console.log('promise1')\n })\n}, 0)\nprocess.nextTick(() => {\n console.log('nextTick')\n process.nextTick(() => {\n   console.log('nextTick')\n   process.nextTick(() => {\n     console.log('nextTick')\n     process.nextTick(() => {\n       console.log('nextTick')\n     })\n   })\n })\n})\n\n\n对于以上代码，永远都是先把 nextTick 全部打印出来。\n\n\n# 10. 事件触发的过程是怎样的\n\n事件触发有三个阶段：\n\n * window 往事件触发处传播，遇到注册的捕获事件会触发\n * 传播到事件触发处时触发注册的事件\n * 从事件触发处往 window 传播，遇到注册的冒泡事件会触发\n\n事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个 *body* 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。\n\n// 以下会先打印冒泡然后是捕获\nnode.addEventListener(\n  'click',\n  event => {\n    console.log('冒泡')\n  },\n  false\n)\nnode.addEventListener(\n  'click',\n  event => {\n    console.log('捕获 ')\n  },\n  true\n)\n\n\n通常使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false ，useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：\n\n * capture：布尔值，和 useCapture 作用一样\n * once：布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听\n * passive：布尔值，表示永远不会调用 preventDefault\n\n一般来说，如果只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。\n\nstopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。\n\nnode.addEventListener(\n  'click',\n  event => {\n    event.stopImmediatePropagation()\n    console.log('冒泡')\n  },\n  false\n)\n// 点击 node 只会执行上面的函数，该函数不会执行\nnode.addEventListener(\n  'click',\n  event => {\n    console.log('捕获 ')\n  },\n  true\n)\n",
      "normalizedContent": "# 1. 事件是什么？事件模型？\n\n事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。\n\n事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：\n\n * dom0 级事件模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是dom0写法。\n * ie 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachevent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。\n * dom2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 ie 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addeventlistener，其中第三个参数可以指定事件是否在捕获阶段执行。\n\n\n# 2. 如何阻止事件冒泡\n\n * 普通浏览器使用：event.stoppropagation()\n * ie浏览器使用：event.cancelbubble = true;\n\n\n# 3. 对事件委托的理解\n\n# （1）事件委托的概念\n\n事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。\n\n使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。\n\n# （2）事件委托的特点\n\n * 减少内存消耗\n\n如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：\n\n<ul id=\"list\">\n  <li>item 1</li>\n  <li>item 2</li>\n  <li>item 3</li>\n  ......\n  <li>item n</li>\n</ul>\n\n\n如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。\n\n * 动态绑定事件\n\n给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 ajax 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。\n\n// 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：\n// 给父层元素绑定事件\ndocument.getelementbyid('list').addeventlistener('click', function (e) {\n  // 兼容性处理\n  var event = e || window.event;\n  var target = event.target || event.srcelement;\n  // 判断是否匹配目标元素\n  if (target.nodename.tolocalelowercase === 'li') {\n    console.log('the content is: ', target.innerhtml);\n  }\n});\n\n\n在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodename，id 等等）可以更精确地匹配到某一类 #list li 元素之上；\n\n# （3）局限性\n\n当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。\n\n当然事件委托不是只有优点，它也是有缺点的，事件委托会影响页面性能，主要影响因素有：\n\n * 元素中，绑定事件委托的次数；\n * 点击的最底层元素，到绑定事件元素之间的dom层数；\n\n在必须使用事件委托的地方，可以进行如下的处理：\n\n * 只在必须的地方，使用事件委托，比如：ajax的局部刷新区域\n * 尽量的减少绑定的层级，不在body元素上，进行绑定\n * 减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。\n\n\n# 4. 事件委托的使用场景\n\n场景：给页面的所有的a标签添加click事件，代码如下：\n\ndocument.addeventlistener(\"click\", function(e) {\n\tif (e.target.nodename == \"a\")\n\t\tconsole.log(\"a\");\n}, false);\n\n\n但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。\n\n这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：\n\ndocument.addeventlistener(\"click\", function(e) {\n\tvar node = e.target;\n\twhile (node.parentnode.nodename != \"body\") {\n\t\tif (node.nodename == \"a\") {\n\t\t\tconsole.log(\"a\");\n\t\t\tbreak;\n\t\t}\n\t\tnode = node.parentnode;\n\t}\n}, false);\n\n\n\n# 5. 同步和异步的区别\n\n * 同步指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。\n * 异步指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。\n\n\n# 6. 对事件循环的理解\n\n因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。\n\n\n\nevent loop 执行顺序如下所示：\n\n * 首先执行同步代码，这属于宏任务\n * 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行\n * 执行所有微任务\n * 当执行完所有微任务后，如有必要会渲染页面\n * 然后开始下一轮 event loop，执行宏任务中的异步代码\n\n\n# 7. 宏任务和微任务分别有哪些\n\n * 微任务包括： promise 的回调、node 中的 process.nexttick 、对 dom 变化监听的 mutationobserver。\n * 宏任务包括： script 脚本的执行、settimeout ，setinterval ，setimmediate 一类的定时事件，还有如 i/o 操作、ui 渲染等。\n\n\n# 8. 什么是执行栈\n\n可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。 当开始执行 js 代码时，根据先进后出的原则，后执行的函数会先弹出栈，可以看到，foo 函数后执行，当执行完毕后就从栈中弹出了。\n\n平时在开发中，可以在报错中找到执行栈的痕迹：\n\nfunction foo() {\n  throw new error('error')\n}\nfunction bar() {\n  foo()\n}\nbar()\n\n\n可以看到报错在 foo 函数，foo 函数又是在 bar 函数中调用的。当使用递归时，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题\n\nfunction bar() {  bar()}bar()\n\n\n\n\n\n# 9. node 中的 event loop 和浏览器中的有什么区别？process.nexttick 执行顺序？\n\nnode 中的 event loop 和浏览器中的是完全不相同的东西。\n\nnode 的 event loop 分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。\n\n（1）timers（计时器阶段）：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 settimeout 和 setinterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 pending callbacks 阶段。\n\n（2）pending callbacks：执行推迟到下一个循环迭代的i / o回调（系统调用相关的回调）。\n\n（3）idle/prepare：仅供内部使用。\n\n（4）poll（轮询阶段）：\n\n * 当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。\n * 当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（settimeout、setinterval和setimmediate）没有执行，会结束轮询阶段，进入 check 阶段。否则会阻塞并等待任何正在执行的i/o操作完成，并马上执行相应的回调，直到所有回调执行完毕。\n\n（5）check（查询阶段）：会检查是否存在 setimmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 close callbacks 阶段。\n\n（6）close callbacks：执行一些关闭回调，比如socket.on('close', ...)等。\n\n下面来看一个例子，首先在有些情况下，定时器的执行顺序其实是随机的\n\nsettimeout(() => {    console.log('settimeout')}, 0)setimmediate(() => {    console.log('setimmediate')})\n\n\n对于以上代码来说，settimeout 可能执行在前，也可能执行在后\n\n * 首先 settimeout(fn, 0) === settimeout(fn, 1)，这是由源码决定的\n * 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 settimeout 回调\n * 那么如果准备时间花费小于 1ms，那么就是 setimmediate 回调先执行了\n\n当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：\n\nconst fs = require('fs')\nfs.readfile(__filename, () => {\n    settimeout(() => {\n        console.log('timeout');\n    }, 0)\n    setimmediate(() => {\n        console.log('immediate')\n    })\n})\n\n\n在上述代码中，setimmediate 永远先执行。因为两个代码写在 io 回调中，io 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setimmediate 回调，所以就直接跳转到 check 阶段去执行回调了。\n\n上面都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前清空 microtask 队列，下图中的 tick 就代表了 microtask\n\nsettimeout(() => {\n  console.log('timer21')\n}, 0)\npromise.resolve().then(function() {\n  console.log('promise1')\n})\n\n\n对于以上代码来说，其实和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。\n\n最后来看 node 中的 process.nexttick，这个函数其实是独立于 event loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nexttick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。\n\nsettimeout(() => {\n console.log('timer1')\n promise.resolve().then(function() {\n   console.log('promise1')\n })\n}, 0)\nprocess.nexttick(() => {\n console.log('nexttick')\n process.nexttick(() => {\n   console.log('nexttick')\n   process.nexttick(() => {\n     console.log('nexttick')\n     process.nexttick(() => {\n       console.log('nexttick')\n     })\n   })\n })\n})\n\n\n对于以上代码，永远都是先把 nexttick 全部打印出来。\n\n\n# 10. 事件触发的过程是怎样的\n\n事件触发有三个阶段：\n\n * window 往事件触发处传播，遇到注册的捕获事件会触发\n * 传播到事件触发处时触发注册的事件\n * 从事件触发处往 window 传播，遇到注册的冒泡事件会触发\n\n事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个 *body* 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。\n\n// 以下会先打印冒泡然后是捕获\nnode.addeventlistener(\n  'click',\n  event => {\n    console.log('冒泡')\n  },\n  false\n)\nnode.addeventlistener(\n  'click',\n  event => {\n    console.log('捕获 ')\n  },\n  true\n)\n\n\n通常使用 addeventlistener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 usecapture 参数来说，该参数默认值为 false ，usecapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：\n\n * capture：布尔值，和 usecapture 作用一样\n * once：布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听\n * passive：布尔值，表示永远不会调用 preventdefault\n\n一般来说，如果只希望事件只触发在目标上，这时候可以使用 stoppropagation 来阻止事件的进一步传播。通常认为 stoppropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。\n\nstopimmediatepropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。\n\nnode.addeventlistener(\n  'click',\n  event => {\n    event.stopimmediatepropagation()\n    console.log('冒泡')\n  },\n  false\n)\n// 点击 node 只会执行上面的函数，该函数不会执行\nnode.addeventlistener(\n  'click',\n  event => {\n    console.log('捕获 ')\n  },\n  true\n)\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "浏览器垃圾回收机制",
      "frontmatter": {
        "title": "浏览器垃圾回收机制",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/browser/recovery/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/20.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/90.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html",
      "relativePath": "50.性能&网络篇/20.浏览器原理篇/90.浏览器垃圾回收机制.md",
      "key": "v-8824b5c2",
      "path": "/pages/browser/recovery/",
      "headers": [
        {
          "level": 3,
          "title": "1. V8的垃圾回收机制是怎样的",
          "slug": "_1-v8的垃圾回收机制是怎样的",
          "normalizedTitle": "1. v8的垃圾回收机制是怎样的",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 哪些操作会造成内存泄漏？",
          "slug": "_2-哪些操作会造成内存泄漏",
          "normalizedTitle": "2. 哪些操作会造成内存泄漏？",
          "charIndex": 1404
        }
      ],
      "headersStr": "1. V8的垃圾回收机制是怎样的 2. 哪些操作会造成内存泄漏？",
      "content": "# 1. V8的垃圾回收机制是怎样的\n\nV8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。\n\n（1）新生代算法\n\n新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。\n\n在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。\n\n（2）老生代算法\n\n老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。\n\n先来说下什么情况下对象会出现在老生代空间中：\n\n * 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。\n * To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。\n\n老生代中的空间很复杂，有如下几个空间\n\nenum AllocationSpace {\n  // TODO(v8:7464): Actually map this space's memory as read-only.\n  RO_SPACE,    // 不变的对象空间\n  NEW_SPACE,   // 新生代用于 GC 复制算法的空间\n  OLD_SPACE,   // 老生代常驻对象空间\n  CODE_SPACE,  // 老生代代码对象空间\n  MAP_SPACE,   // 老生代 map 对象\n  LO_SPACE,    // 老生代大空间对象\n  NEW_LO_SPACE,  // 新生代大空间对象\n  FIRST_SPACE = RO_SPACE,\n  LAST_SPACE = NEW_LO_SPACE,\n  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,\n  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE\n};\n\n\n在老生代中，以下情况会先启动标记清除算法：\n\n * 某一个空间没有分块的时候\n * 空间中被对象超过一定限制\n * 空间不能保证新生代中的对象移动到老生代中\n\n在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。\n\n清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。\n\n\n# 2. 哪些操作会造成内存泄漏？\n\n * 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\n * 第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。\n * 第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。\n * 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。",
      "normalizedContent": "# 1. v8的垃圾回收机制是怎样的\n\nv8 实现了准确式 gc，gc 算法采用了分代式垃圾回收机制。因此，v8 将内存（堆）分为新生代和老生代两部分。\n\n（1）新生代算法\n\n新生代中的对象一般存活时间较短，使用 scavenge gc 算法。\n\n在新生代空间中，内存空间分为两部分，分别为 from 空间和 to 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 from 空间中，当 from 空间被占满时，新生代 gc 就会启动了。算法会检查 from 空间中存活的对象并复制到 to 空间中，如果有失活的对象就会销毁。当复制完成后将 from 空间和 to 空间互换，这样 gc 就结束了。\n\n（2）老生代算法\n\n老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。\n\n先来说下什么情况下对象会出现在老生代空间中：\n\n * 新生代中的对象是否已经经历过一次 scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。\n * to 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。\n\n老生代中的空间很复杂，有如下几个空间\n\nenum allocationspace {\n  // todo(v8:7464): actually map this space's memory as read-only.\n  ro_space,    // 不变的对象空间\n  new_space,   // 新生代用于 gc 复制算法的空间\n  old_space,   // 老生代常驻对象空间\n  code_space,  // 老生代代码对象空间\n  map_space,   // 老生代 map 对象\n  lo_space,    // 老生代大空间对象\n  new_lo_space,  // 新生代大空间对象\n  first_space = ro_space,\n  last_space = new_lo_space,\n  first_growable_paged_space = old_space,\n  last_growable_paged_space = map_space\n};\n\n\n在老生代中，以下情况会先启动标记清除算法：\n\n * 某一个空间没有分块的时候\n * 空间中被对象超过一定限制\n * 空间不能保证新生代中的对象移动到老生代中\n\n在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，v8 从 stop-the-world 标记切换到增量标志。在增量标记期间，gc 将标记工作分解为更小的模块，可以让 js 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，gc 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 gc 扫描和标记对象时，同时允许 js 运行。\n\n清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。\n\n\n# 2. 哪些操作会造成内存泄漏？\n\n * 第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\n * 第二种情况是设置了 setinterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。\n * 第三种情况是获取一个 dom 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。\n * 第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "懒加载",
      "frontmatter": {
        "title": "懒加载",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/performance/loading/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/30.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/20.%E6%87%92%E5%8A%A0%E8%BD%BD.html",
      "relativePath": "50.性能&网络篇/30.前端性能优化篇/20.懒加载.md",
      "key": "v-0ea48678",
      "path": "/pages/performance/loading/",
      "headers": [
        {
          "level": 3,
          "title": "1. 懒加载的概念",
          "slug": "_1-懒加载的概念",
          "normalizedTitle": "1. 懒加载的概念",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 懒加载的特点",
          "slug": "_2-懒加载的特点",
          "normalizedTitle": "2. 懒加载的特点",
          "charIndex": 236
        },
        {
          "level": 3,
          "title": "3. 懒加载的实现原理",
          "slug": "_3-懒加载的实现原理",
          "normalizedTitle": "3. 懒加载的实现原理",
          "charIndex": 400
        },
        {
          "level": 3,
          "title": "4. 懒加载与预加载的区别",
          "slug": "_4-懒加载与预加载的区别",
          "normalizedTitle": "4. 懒加载与预加载的区别",
          "charIndex": 1647
        }
      ],
      "headersStr": "1. 懒加载的概念 2. 懒加载的特点 3. 懒加载的实现原理 4. 懒加载与预加载的区别",
      "content": "# 1. 懒加载的概念\n\n懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。\n\n如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。\n\n\n# 2. 懒加载的特点\n\n * 减少无用资源的加载：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。\n * 提升用户体验: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。\n * 防止加载过多图片而影响其他资源文件的加载 ：会影响网站应用的正常使用。\n\n\n# 3. 懒加载的实现原理\n\n图片的加载是由src引起的，当对src赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的data-xxx属性来储存图片的路径，在需要加载图片的时候，将data-xxx中图片的路径赋值给src，这样就实现了图片的按需加载，即懒加载。\n\n注意：data-xxx 中的xxx可以自定义，这里我们使用data-src来定义。\n\n懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。\n\n使用原生JavaScript实现懒加载：\n\n知识点：\n\n（1）window.innerHeight 是浏览器可视区的高度\n\n（2）document.body.scrollTop || document.documentElement.scrollTop 是浏览器滚动的过的距离\n\n（3）imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）\n\n（4）图片加载条件：img.offsetTop < window.innerHeight + document.body.scrollTop;\n\n图示： 代码实现：\n\n<div class=\"container\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n</div>\n<script>\nvar imgs = document.querySelectorAll('img');\nfunction lozyLoad(){\n\t\tvar scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n\t\tvar winHeight= window.innerHeight;\n\t\tfor(var i=0;i < imgs.length;i++){\n\t\t\tif(imgs[i].offsetTop < scrollTop + winHeight ){\n\t\t\t\timgs[i].src = imgs[i].getAttribute('data-src');\n\t\t\t}\n\t\t}\n\t}\n  window.onscroll = lozyLoad();\n</script>\n\n\n\n# 4. 懒加载与预加载的区别\n\n这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n\n * 懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。\n * 预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。 通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。",
      "normalizedContent": "# 1. 懒加载的概念\n\n懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。\n\n如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。\n\n\n# 2. 懒加载的特点\n\n * 减少无用资源的加载：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。\n * 提升用户体验: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。\n * 防止加载过多图片而影响其他资源文件的加载 ：会影响网站应用的正常使用。\n\n\n# 3. 懒加载的实现原理\n\n图片的加载是由src引起的，当对src赋值时，浏览器就会请求图片资源。根据这个原理，我们使用html5 的data-xxx属性来储存图片的路径，在需要加载图片的时候，将data-xxx中图片的路径赋值给src，这样就实现了图片的按需加载，即懒加载。\n\n注意：data-xxx 中的xxx可以自定义，这里我们使用data-src来定义。\n\n懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。\n\n使用原生javascript实现懒加载：\n\n知识点：\n\n（1）window.innerheight 是浏览器可视区的高度\n\n（2）document.body.scrolltop || document.documentelement.scrolltop 是浏览器滚动的过的距离\n\n（3）imgs.offsettop 是元素顶部距离文档顶部的高度（包括滚动条的距离）\n\n（4）图片加载条件：img.offsettop < window.innerheight + document.body.scrolltop;\n\n图示： 代码实现：\n\n<div class=\"container\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n     <img src=\"loading.gif\"  data-src=\"pic.png\">\n</div>\n<script>\nvar imgs = document.queryselectorall('img');\nfunction lozyload(){\n\t\tvar scrolltop = document.body.scrolltop || document.documentelement.scrolltop;\n\t\tvar winheight= window.innerheight;\n\t\tfor(var i=0;i < imgs.length;i++){\n\t\t\tif(imgs[i].offsettop < scrolltop + winheight ){\n\t\t\t\timgs[i].src = imgs[i].getattribute('data-src');\n\t\t\t}\n\t\t}\n\t}\n  window.onscroll = lozyload();\n</script>\n\n\n\n# 4. 懒加载与预加载的区别\n\n这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n\n * 懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。\n * 预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。 通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "回流与重绘",
      "frontmatter": {
        "title": "回流与重绘",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/performance/redraw/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/30.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/30.%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98.html",
      "relativePath": "50.性能&网络篇/30.前端性能优化篇/30.回流与重绘.md",
      "key": "v-eab101d6",
      "path": "/pages/performance/redraw/",
      "headers": [
        {
          "level": 3,
          "title": "1. 回流与重绘的概念及触发条件",
          "slug": "_1-回流与重绘的概念及触发条件",
          "normalizedTitle": "1. 回流与重绘的概念及触发条件",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 如何避免回流与重绘？",
          "slug": "_2-如何避免回流与重绘",
          "normalizedTitle": "2. 如何避免回流与重绘？",
          "charIndex": 628
        },
        {
          "level": 3,
          "title": "3. 如何优化动画？",
          "slug": "_3-如何优化动画",
          "normalizedTitle": "3. 如何优化动画？",
          "charIndex": 1204
        },
        {
          "level": 3,
          "title": "4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？",
          "slug": "_4-documentfragment-是什么-用它跟直接操作-dom-的区别是什么",
          "normalizedTitle": "4. documentfragment 是什么？用它跟直接操作 dom 的区别是什么？",
          "charIndex": 1329
        }
      ],
      "headersStr": "1. 回流与重绘的概念及触发条件 2. 如何避免回流与重绘？ 3. 如何优化动画？ 4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？",
      "content": "# 1. 回流与重绘的概念及触发条件\n\n# （1）回流\n\n当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流。\n\n下面这些操作会导致回流：\n\n * 页面的首次渲染\n * 浏览器的窗口大小发生变化\n * 元素的内容发生变化\n * 元素的尺寸或者位置发生变化\n * 元素的字体大小发生变化\n * 激活CSS伪类\n * 查询某些属性或者调用某些方法\n * 添加或者删除可见的DOM元素\n\n在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：\n\n * 全局范围：从根节点开始，对整个渲染树进行重新布局\n * 局部范围：对渲染树的某部分或者一个渲染对象进行重新布局\n\n# （2）重绘\n\n当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。\n\n下面这些操作会导致回流：\n\n * color、background 相关属性：background-color、background-image 等\n * outline 相关属性：outline-color、outline-width 、text-decoration\n * border-radius、visibility、box-shadow\n\n注意： 当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。\n\n\n# 2. 如何避免回流与重绘？\n\n减少回流与重绘的措施：\n\n * 操作DOM时，尽量在低层级的DOM节点进行操作\n * 不要使用table布局， 一个小的改动可能会使整个table进行重新布局\n * 使用CSS的表达式\n * 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。\n * 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素\n * 避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中\n * 将元素先设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。\n * 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。\n\n浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列\n\n浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。\n\n上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。\n\n\n# 3. 如何优化动画？\n\n对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就就会导致页面的性能问题，我们可以将动画的position属性设置为absolute或者fixed，将动画脱离文档流，这样他的回流就不会影响到页面了。\n\n\n# 4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？\n\nMDN中对documentFragment的解释：\n\n> DocumentFragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 Document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。\n\n当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将DocumentFragment 节点插入DOM树时，不会触发页面的重绘，这样就大大提高了页面的性能。",
      "normalizedContent": "# 1. 回流与重绘的概念及触发条件\n\n# （1）回流\n\n当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流。\n\n下面这些操作会导致回流：\n\n * 页面的首次渲染\n * 浏览器的窗口大小发生变化\n * 元素的内容发生变化\n * 元素的尺寸或者位置发生变化\n * 元素的字体大小发生变化\n * 激活css伪类\n * 查询某些属性或者调用某些方法\n * 添加或者删除可见的dom元素\n\n在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的dom元素重新排列，它的影响范围有两种：\n\n * 全局范围：从根节点开始，对整个渲染树进行重新布局\n * 局部范围：对渲染树的某部分或者一个渲染对象进行重新布局\n\n# （2）重绘\n\n当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。\n\n下面这些操作会导致回流：\n\n * color、background 相关属性：background-color、background-image 等\n * outline 相关属性：outline-color、outline-width 、text-decoration\n * border-radius、visibility、box-shadow\n\n注意： 当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。\n\n\n# 2. 如何避免回流与重绘？\n\n减少回流与重绘的措施：\n\n * 操作dom时，尽量在低层级的dom节点进行操作\n * 不要使用table布局， 一个小的改动可能会使整个table进行重新布局\n * 使用css的表达式\n * 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。\n * 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素\n * 避免频繁操作dom，可以创建一个文档片段documentfragment，在它上面应用所有dom操作，最后再把它添加到文档中\n * 将元素先设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的dom操作不会引发回流和重绘。\n * 将dom的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。\n\n浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列\n\n浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。\n\n上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。\n\n\n# 3. 如何优化动画？\n\n对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作dom，就就会导致页面的性能问题，我们可以将动画的position属性设置为absolute或者fixed，将动画脱离文档流，这样他的回流就不会影响到页面了。\n\n\n# 4. documentfragment 是什么？用它跟直接操作 dom 的区别是什么？\n\nmdn中对documentfragment的解释：\n\n> documentfragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是documentfragment不是真实 dom 树的一部分，它的变化不会触发 dom 树的重新渲染，且不会导致性能等问题。\n\n当我们把一个 documentfragment 节点插入文档树时，插入的不是 documentfragment 自身，而是它的所有子孙节点。在频繁的dom操作时，我们就可以将dom元素插入documentfragment，之后一次性的将所有的子孙节点插入文档中。和直接操作dom相比，将documentfragment 节点插入dom树时，不会触发页面的重绘，这样就大大提高了页面的性能。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "节流与防抖",
      "frontmatter": {
        "title": "节流与防抖",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/performance/shaking/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/30.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/40.%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96.html",
      "relativePath": "50.性能&网络篇/30.前端性能优化篇/40.节流与防抖.md",
      "key": "v-469b44b1",
      "path": "/pages/performance/shaking/",
      "headers": [
        {
          "level": 3,
          "title": "1. 对节流与防抖的理解",
          "slug": "_1-对节流与防抖的理解",
          "normalizedTitle": "1. 对节流与防抖的理解",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 实现节流函数和防抖函数",
          "slug": "_2-实现节流函数和防抖函数",
          "normalizedTitle": "2. 实现节流函数和防抖函数",
          "charIndex": 430
        }
      ],
      "headersStr": "1. 对节流与防抖的理解 2. 实现节流函数和防抖函数",
      "content": "# 1. 对节流与防抖的理解\n\n * 函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。\n * 函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。\n\n防抖函数的应用场景：\n\n * 按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次\n * 服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce\n\n节流函数的适⽤场景：\n\n * 拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动\n * 缩放场景：监控浏览器resize\n * 动画场景：避免短时间内多次触发动画引起性能问题\n\n\n# 2. 实现节流函数和防抖函数\n\n函数防抖的实现：\n\nfunction debounce(fn, wait) {\n  var timer = null;\n\n  return function() {\n    var context = this,\n      args = [...arguments];\n\n    // 如果此时存在定时器的话，则取消之前的定时器重新记时\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n\n    // 设置定时器，使事件间隔指定事件后执行\n    timer = setTimeout(() => {\n      fn.apply(context, args);\n    }, wait);\n  };\n}\n\n\n函数节流的实现：\n\n// 时间戳版\nfunction throttle(fn, delay) {\n  var preTime = Date.now();\n\n  return function() {\n    var context = this,\n      args = [...arguments],\n      nowTime = Date.now();\n\n    // 如果两次时间间隔超过了指定时间，则执行函数。\n    if (nowTime - preTime >= delay) {\n      preTime = Date.now();\n      return fn.apply(context, args);\n    }\n  };\n}\n\n// 定时器版\nfunction throttle (fun, wait){\n  let timeout = null\n  return function(){\n    let context = this\n    let args = [...arguments]\n    if(!timeout){\n      timeout = setTimeout(() => {\n        fun.apply(context, args)\n        timeout = null \n      }, wait)\n    }\n  }\n}\n",
      "normalizedContent": "# 1. 对节流与防抖的理解\n\n * 函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。\n * 函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。\n\n防抖函数的应用场景：\n\n * 按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次\n * 服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce\n\n节流函数的适⽤场景：\n\n * 拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动\n * 缩放场景：监控浏览器resize\n * 动画场景：避免短时间内多次触发动画引起性能问题\n\n\n# 2. 实现节流函数和防抖函数\n\n函数防抖的实现：\n\nfunction debounce(fn, wait) {\n  var timer = null;\n\n  return function() {\n    var context = this,\n      args = [...arguments];\n\n    // 如果此时存在定时器的话，则取消之前的定时器重新记时\n    if (timer) {\n      cleartimeout(timer);\n      timer = null;\n    }\n\n    // 设置定时器，使事件间隔指定事件后执行\n    timer = settimeout(() => {\n      fn.apply(context, args);\n    }, wait);\n  };\n}\n\n\n函数节流的实现：\n\n// 时间戳版\nfunction throttle(fn, delay) {\n  var pretime = date.now();\n\n  return function() {\n    var context = this,\n      args = [...arguments],\n      nowtime = date.now();\n\n    // 如果两次时间间隔超过了指定时间，则执行函数。\n    if (nowtime - pretime >= delay) {\n      pretime = date.now();\n      return fn.apply(context, args);\n    }\n  };\n}\n\n// 定时器版\nfunction throttle (fun, wait){\n  let timeout = null\n  return function(){\n    let context = this\n    let args = [...arguments]\n    if(!timeout){\n      timeout = settimeout(() => {\n        fun.apply(context, args)\n        timeout = null \n      }, wait)\n    }\n  }\n}\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "Webpack优化",
      "frontmatter": {
        "title": "Webpack优化",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/performance/webpack/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/30.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/60.Webpack%E4%BC%98%E5%8C%96.html",
      "relativePath": "50.性能&网络篇/30.前端性能优化篇/60.Webpack优化.md",
      "key": "v-b922e182",
      "path": "/pages/performance/webpack/",
      "headers": [
        {
          "level": 3,
          "title": "1. 如何提⾼webpack的打包速度?",
          "slug": "_1-如何提高webpack的打包速度",
          "normalizedTitle": "1. 如何提⾼webpack的打包速度?",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 如何减少 Webpack 打包体积",
          "slug": "_2-如何减少-webpack-打包体积",
          "normalizedTitle": "2. 如何减少 webpack 打包体积",
          "charIndex": 2644
        },
        {
          "level": 3,
          "title": "3. 如何⽤webpack来优化前端性能？",
          "slug": "_3-如何用webpack来优化前端性能",
          "normalizedTitle": "3. 如何⽤webpack来优化前端性能？",
          "charIndex": 3841
        },
        {
          "level": 3,
          "title": "4. 如何提⾼webpack的构建速度？",
          "slug": "_4-如何提高webpack的构建速度",
          "normalizedTitle": "4. 如何提⾼webpack的构建速度？",
          "charIndex": 4357
        }
      ],
      "headersStr": "1. 如何提⾼webpack的打包速度? 2. 如何减少 Webpack 打包体积 3. 如何⽤webpack来优化前端性能？ 4. 如何提⾼webpack的构建速度？",
      "content": "# 1. 如何提⾼webpack的打包速度?\n\n# （1）优化 Loader\n\n对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，这是可以优化的。\n\n首先我们优化 Loader 的文件搜索范围\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        // js 文件才使用 babel\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        // 只在 src 文件夹下查找\n        include: [resolve('src')],\n        // 不会去查找的路径\n        exclude: /node_modules/\n      }\n    ]\n  }\n}\n\n\n对于 Babel 来说，希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以完全没有必要再去处理一遍。\n\n当然这样做还不够，还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间\n\nloader: 'babel-loader?cacheDirectory=true'\n\n\n# （2）HappyPack\n\n受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。\n\nHappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了\n\nmodule: {\n  loaders: [\n    {\n      test: /\\.js$/,\n      include: [resolve('src')],\n      exclude: /node_modules/,\n      // id 后面的内容对应下面\n      loader: 'happypack/loader?id=happybabel'\n    }\n  ]\n},\nplugins: [\n  new HappyPack({\n    id: 'happybabel',\n    loaders: ['babel-loader?cacheDirectory'],\n    // 开启 4 个线程\n    threads: 4\n  })\n]\n\n\n# （3）DllPlugin\n\nDllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。DllPlugin的使用方法如下：\n\n// 单独配置在一个文件中\n// webpack.dll.conf.js\nconst path = require('path')\nconst webpack = require('webpack')\nmodule.exports = {\n  entry: {\n    // 想统一打包的类库\n    vendor: ['react']\n  },\n  output: {\n    path: path.join(__dirname, 'dist'),\n    filename: '[name].dll.js',\n    library: '[name]-[hash]'\n  },\n  plugins: [\n    new webpack.DllPlugin({\n      // name 必须和 output.library 一致\n      name: '[name]-[hash]',\n      // 该属性需要与 DllReferencePlugin 中一致\n      context: __dirname,\n      path: path.join(__dirname, 'dist', '[name]-manifest.json')\n    })\n  ]\n}\n\n\n然后需要执行这个配置文件生成依赖文件，接下来需要使用 DllReferencePlugin 将依赖文件引入项目中\n\n// webpack.conf.js\nmodule.exports = {\n  // ...省略其他配置\n  plugins: [\n    new webpack.DllReferencePlugin({\n      context: __dirname,\n      // manifest 就是之前打包出来的 json 文件\n      manifest: require('./dist/vendor-manifest.json'),\n    })\n  ]\n}\n\n\n# （4）代码压缩\n\n在 Webpack3 中，一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，可以使用 webpack-parallel-uglify-plugin 来并行运行 UglifyJS，从而提高效率。\n\n在 Webpack4 中，不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能。\n\n# （5）其他\n\n可以通过一些小的优化点来加快打包速度\n\n * resolve.extensions：用来表明文件后缀列表，默认查找顺序是 ['.js', '.json']，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面\n * resolve.alias：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径\n * module.noParse：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助\n\n\n# 2. 如何减少 Webpack 打包体积\n\n# （1）按需加载\n\n在开发 SPA 项目的时候，项目中都会存在很多路由页面。如果将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，希望首页能加载的文件体积越小越好，这时候就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 loadash 这种大型类库同样可以使用这个功能。\n\n按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 Promise，当 Promise 成功以后去执行回调。\n\n# （2）Scope Hoisting\n\nScope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。\n\n比如希望打包两个文件：\n\n// test.js\nexport const a = 1\n// index.js\nimport { a } from './test.js'\n\n\n对于这种情况，打包出来的代码会类似这样：\n\n[\n  /* 0 */\n  function (module, exports, require) {\n    //...\n  },\n  /* 1 */\n  function (module, exports, require) {\n    //...\n  }\n]\n\n\n但是如果使用 Scope Hoisting ，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码：\n\n[\n  /* 0 */\n  function (module, exports, require) {\n    //...\n  }\n]\n\n\n这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules 就可以了：\n\nmodule.exports = {\n  optimization: {\n    concatenateModules: true\n  }\n}\n\n\n# （3）Tree Shaking\n\nTree Shaking 可以实现删除项目中未被引用的代码，比如：\n\n// test.js\nexport const a = 1\nexport const b = 2\n// index.js\nimport { a } from './test.js'\n\n\n对于以上情况，test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中。\n\n如果使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。\n\n\n# 3. 如何⽤webpack来优化前端性能？\n\n⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。\n\n * 压缩代码：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css\n * 利⽤CDN加速: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径\n * Tree Shaking: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 --optimize-minimize 来实现\n * Code Splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存\n * 提取公共第三⽅库: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码\n\n\n# 4. 如何提⾼webpack的构建速度？\n\n 1. 多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码\n 2. 通过 externals 配置来提取常⽤库\n 3. 利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。\n 4. 使⽤ Happypack 实现多线程加速编译\n 5. 使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度\n 6. 使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码",
      "normalizedContent": "# 1. 如何提⾼webpack的打包速度?\n\n# （1）优化 loader\n\n对于 loader 来说，影响打包效率首当其冲必属 babel 了。因为 babel 会将代码转为字符串生成 ast，然后对 ast 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，这是可以优化的。\n\n首先我们优化 loader 的文件搜索范围\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        // js 文件才使用 babel\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        // 只在 src 文件夹下查找\n        include: [resolve('src')],\n        // 不会去查找的路径\n        exclude: /node_modules/\n      }\n    ]\n  }\n}\n\n\n对于 babel 来说，希望只作用在 js 代码上的，然后 node_modules 中使用的代码都是编译过的，所以完全没有必要再去处理一遍。\n\n当然这样做还不够，还可以将 babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间\n\nloader: 'babel-loader?cachedirectory=true'\n\n\n# （2）happypack\n\n受限于 node 是单线程运行的，所以 webpack 在打包的过程中也是单线程的，特别是在执行 loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。\n\nhappypack 可以将 loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了\n\nmodule: {\n  loaders: [\n    {\n      test: /\\.js$/,\n      include: [resolve('src')],\n      exclude: /node_modules/,\n      // id 后面的内容对应下面\n      loader: 'happypack/loader?id=happybabel'\n    }\n  ]\n},\nplugins: [\n  new happypack({\n    id: 'happybabel',\n    loaders: ['babel-loader?cachedirectory'],\n    // 开启 4 个线程\n    threads: 4\n  })\n]\n\n\n# （3）dllplugin\n\ndllplugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。dllplugin的使用方法如下：\n\n// 单独配置在一个文件中\n// webpack.dll.conf.js\nconst path = require('path')\nconst webpack = require('webpack')\nmodule.exports = {\n  entry: {\n    // 想统一打包的类库\n    vendor: ['react']\n  },\n  output: {\n    path: path.join(__dirname, 'dist'),\n    filename: '[name].dll.js',\n    library: '[name]-[hash]'\n  },\n  plugins: [\n    new webpack.dllplugin({\n      // name 必须和 output.library 一致\n      name: '[name]-[hash]',\n      // 该属性需要与 dllreferenceplugin 中一致\n      context: __dirname,\n      path: path.join(__dirname, 'dist', '[name]-manifest.json')\n    })\n  ]\n}\n\n\n然后需要执行这个配置文件生成依赖文件，接下来需要使用 dllreferenceplugin 将依赖文件引入项目中\n\n// webpack.conf.js\nmodule.exports = {\n  // ...省略其他配置\n  plugins: [\n    new webpack.dllreferenceplugin({\n      context: __dirname,\n      // manifest 就是之前打包出来的 json 文件\n      manifest: require('./dist/vendor-manifest.json'),\n    })\n  ]\n}\n\n\n# （4）代码压缩\n\n在 webpack3 中，一般使用 uglifyjs 来压缩代码，但是这个是单线程运行的，为了加快效率，可以使用 webpack-parallel-uglify-plugin 来并行运行 uglifyjs，从而提高效率。\n\n在 webpack4 中，不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 js 代码，还可以压缩 html、css 代码，并且在压缩 js 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能。\n\n# （5）其他\n\n可以通过一些小的优化点来加快打包速度\n\n * resolve.extensions：用来表明文件后缀列表，默认查找顺序是 ['.js', '.json']，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面\n * resolve.alias：可以通过别名的方式来映射一个路径，能让 webpack 更快找到路径\n * module.noparse：如果你确定一个文件下没有其他依赖，就可以使用该属性让 webpack 不扫描该文件，这种方式对于大型的类库很有帮助\n\n\n# 2. 如何减少 webpack 打包体积\n\n# （1）按需加载\n\n在开发 spa 项目的时候，项目中都会存在很多路由页面。如果将这些页面全部打包进一个 js 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，希望首页能加载的文件体积越小越好，这时候就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 loadash 这种大型类库同样可以使用这个功能。\n\n按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 promise，当 promise 成功以后去执行回调。\n\n# （2）scope hoisting\n\nscope hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。\n\n比如希望打包两个文件：\n\n// test.js\nexport const a = 1\n// index.js\nimport { a } from './test.js'\n\n\n对于这种情况，打包出来的代码会类似这样：\n\n[\n  /* 0 */\n  function (module, exports, require) {\n    //...\n  },\n  /* 1 */\n  function (module, exports, require) {\n    //...\n  }\n]\n\n\n但是如果使用 scope hoisting ，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码：\n\n[\n  /* 0 */\n  function (module, exports, require) {\n    //...\n  }\n]\n\n\n这样的打包方式生成的代码明显比之前的少多了。如果在 webpack4 中你希望开启这个功能，只需要启用 optimization.concatenatemodules 就可以了：\n\nmodule.exports = {\n  optimization: {\n    concatenatemodules: true\n  }\n}\n\n\n# （3）tree shaking\n\ntree shaking 可以实现删除项目中未被引用的代码，比如：\n\n// test.js\nexport const a = 1\nexport const b = 2\n// index.js\nimport { a } from './test.js'\n\n\n对于以上情况，test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中。\n\n如果使用 webpack 4 的话，开启生产环境就会自动启动这个优化功能。\n\n\n# 3. 如何⽤webpack来优化前端性能？\n\n⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。\n\n * 压缩代码：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 uglifyjsplugin 和 paralleluglifyplugin 来压缩js⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css\n * 利⽤cdn加速: 在构建过程中，将引⽤的静态资源路径修改为cdn上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicpath 参数来修改资源路径\n * tree shaking: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 --optimize-minimize 来实现\n * code splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存\n * 提取公共第三⽅库: splitchunksplugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码\n\n\n# 4. 如何提⾼webpack的构建速度？\n\n 1. 多⼊⼝情况下，使⽤ commonschunkplugin 来提取公共代码\n 2. 通过 externals 配置来提取常⽤库\n 3. 利⽤ dllplugin 和 dllreferenceplugin 预编译资源模块 通过 dllplugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 dllreferenceplugin 将预编译的模块加载进来。\n 4. 使⽤ happypack 实现多线程加速编译\n 5. 使⽤ webpack-uglify-parallel 来提升 uglifyplugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度\n 6. 使⽤ tree-shaking 和 scope hoisting 来剔除多余代码",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "CDN",
      "frontmatter": {
        "title": "CDN",
        "date": "2022-08-03T21:31:15.000Z",
        "permalink": "/pages/performance/cdn/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/30.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/10.CDN.html",
      "relativePath": "50.性能&网络篇/30.前端性能优化篇/10.CDN.md",
      "key": "v-5cbffa76",
      "path": "/pages/performance/cdn/",
      "headers": [
        {
          "level": 3,
          "title": "1. CDN的概念",
          "slug": "_1-cdn的概念",
          "normalizedTitle": "1. cdn的概念",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. CDN的作用",
          "slug": "_2-cdn的作用",
          "normalizedTitle": "2. cdn的作用",
          "charIndex": 591
        },
        {
          "level": 3,
          "title": "3. CDN的原理",
          "slug": "_3-cdn的原理",
          "normalizedTitle": "3. cdn的原理",
          "charIndex": 951
        },
        {
          "level": 3,
          "title": "4. CDN的使用场景",
          "slug": "_4-cdn的使用场景",
          "normalizedTitle": "4. cdn的使用场景",
          "charIndex": 2043
        }
      ],
      "headersStr": "1. CDN的概念 2. CDN的作用 3. CDN的原理 4. CDN的使用场景",
      "content": "# 1. CDN的概念\n\nCDN（Content Delivery Network，内容分发网络）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。\n\n典型的CDN系统由下面三个部分组成：\n\n * 分发服务系统： 最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡量一个CDN系统服务能力的最基本的指标。\n * 负载均衡系统： 主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。全局负载均衡主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。本地负载均衡主要负责节点内部的设备负载均衡\n * 运营管理系统： 运营管理系统分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。\n\n\n# 2. CDN的作用\n\nCDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用CDN来加速这些资源的访问。\n\n（1）在性能方面，引入CDN的作用在于：\n\n * 用户收到的内容来自最近的数据中心，延迟更低，内容加载更快\n * 部分资源请求分配给了CDN，减少了服务器的负载\n\n（2）在安全方面，CDN有助于防御DDoS、MITM等网络攻击：\n\n * 针对DDoS：通过监控分析异常流量，限制其请求频率\n * 针对MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信\n\n除此之外，CDN作为一种基础的云服务，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。\n\n\n# 3. CDN的原理\n\nCDN和DNS有着密不可分的联系，先来看一下DNS的解析域名过程，在浏览器输入 www.test.com 的解析过程如下： （1） 检查浏览器缓存 （2）检查操作系统缓存，常见的如hosts文件 （3）检查路由器缓存 （4）如果前几步都没没找到，会向ISP(网络服务提供商)的LDNS服务器查询 （5）如果LDNS服务器没找到，会向根域名服务器(Root Server)请求解析，分为以下几步：\n\n * 根服务器返回顶级域名(TLD)服务器如.com，.cn，.org等的地址，该例子中会返回.com的地址\n * 接着向顶级域名服务器发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回.test的地址\n * 接着向次级域名服务器发送请求，然后会返回通过域名查询到的目标IP，本例子会返回www.test.com的地址\n * Local DNS Server会缓存结果，并返回给用户，缓存在系统中\n\nCDN的工作原理： （1）用户未使用CDN缓存资源的过程：\n\n 1. 浏览器通过DNS对域名进行解析（就是上面的DNS解析过程），依次得到此域名对应的IP地址\n 2. 浏览器根据得到的IP地址，向域名的服务主机发送数据请求\n 3. 服务器向浏览器返回响应数据\n\n（2）用户使用CDN缓存资源的过程：\n\n 1. 对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。\n 2. CND专用DNS服务器将CND的全局负载均衡设备IP地址返回给用户\n 3. 用户向CDN的全局负载均衡设备发起数据请求\n 4. CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求\n 5. 区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备\n 6. 全局负载均衡设备把服务器的IP地址返回给用户\n 7. 用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。\n\n如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。\n\nCNAME（意为：别名）：在域名解析中，实际上解析出来的指定域名对应的IP地址，或者该域名的一个CNAME，然后再根据这个CNAME来查找对应的IP地址。\n\n\n# 4. CDN的使用场景\n\n * **使用第三方的CDN服务：**如果想要开源一些项目，可以使用第三方的CDN服务\n * **使用CDN进行静态资源的缓存：**将自己网站的静态资源放在CDN上，比如js、css、图片等。可以将整个项目放在CDN上，完成一键部署。\n * **直播传送：**直播本质上是使用流媒体进行传送，CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。",
      "normalizedContent": "# 1. cdn的概念\n\ncdn（content delivery network，内容分发网络）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。\n\n典型的cdn系统由下面三个部分组成：\n\n * 分发服务系统： 最基本的工作单元就是cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。cache设备的数量、规模、总服务能力是衡量一个cdn系统服务能力的最基本的指标。\n * 负载均衡系统： 主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（gslb）和本地负载均衡（slb）。全局负载均衡主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。本地负载均衡主要负责节点内部的设备负载均衡\n * 运营管理系统： 运营管理系统分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。\n\n\n# 2. cdn的作用\n\ncdn一般会用来托管web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用cdn来加速这些资源的访问。\n\n（1）在性能方面，引入cdn的作用在于：\n\n * 用户收到的内容来自最近的数据中心，延迟更低，内容加载更快\n * 部分资源请求分配给了cdn，减少了服务器的负载\n\n（2）在安全方面，cdn有助于防御ddos、mitm等网络攻击：\n\n * 针对ddos：通过监控分析异常流量，限制其请求频率\n * 针对mitm：从源服务器到 cdn 节点到 isp（internet service provider），全链路 https 通信\n\n除此之外，cdn作为一种基础的云服务，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。\n\n\n# 3. cdn的原理\n\ncdn和dns有着密不可分的联系，先来看一下dns的解析域名过程，在浏览器输入 www.test.com 的解析过程如下： （1） 检查浏览器缓存 （2）检查操作系统缓存，常见的如hosts文件 （3）检查路由器缓存 （4）如果前几步都没没找到，会向isp(网络服务提供商)的ldns服务器查询 （5）如果ldns服务器没找到，会向根域名服务器(root server)请求解析，分为以下几步：\n\n * 根服务器返回顶级域名(tld)服务器如.com，.cn，.org等的地址，该例子中会返回.com的地址\n * 接着向顶级域名服务器发送请求，然后会返回次级域名(sld)服务器的地址，本例子会返回.test的地址\n * 接着向次级域名服务器发送请求，然后会返回通过域名查询到的目标ip，本例子会返回www.test.com的地址\n * local dns server会缓存结果，并返回给用户，缓存在系统中\n\ncdn的工作原理： （1）用户未使用cdn缓存资源的过程：\n\n 1. 浏览器通过dns对域名进行解析（就是上面的dns解析过程），依次得到此域名对应的ip地址\n 2. 浏览器根据得到的ip地址，向域名的服务主机发送数据请求\n 3. 服务器向浏览器返回响应数据\n\n（2）用户使用cdn缓存资源的过程：\n\n 1. 对于点击的数据的url，经过本地dns系统的解析，发现该url对应的是一个cdn专用的dns服务器，dns系统就会将域名解析权交给cname指向的cdn专用的dns服务器。\n 2. cnd专用dns服务器将cnd的全局负载均衡设备ip地址返回给用户\n 3. 用户向cdn的全局负载均衡设备发起数据请求\n 4. cdn的全局负载均衡设备根据用户的ip地址，以及用户请求的内容url，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求\n 5. 区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的ip地址返回给全局负载均衡设备\n 6. 全局负载均衡设备把服务器的ip地址返回给用户\n 7. 用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。\n\n如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。\n\ncname（意为：别名）：在域名解析中，实际上解析出来的指定域名对应的ip地址，或者该域名的一个cname，然后再根据这个cname来查找对应的ip地址。\n\n\n# 4. cdn的使用场景\n\n * **使用第三方的cdn服务：**如果想要开源一些项目，可以使用第三方的cdn服务\n * **使用cdn进行静态资源的缓存：**将自己网站的静态资源放在cdn上，比如js、css、图片等。可以将整个项目放在cdn上，完成一键部署。\n * **直播传送：**直播本质上是使用流媒体进行传送，cdn也是支持流媒体传送的，所以直播完全可以使用cdn来提高访问速度。cdn在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "HTML模块",
      "frontmatter": {
        "title": "HTML模块",
        "date": "2022-06-07T16:57:45.000Z",
        "permalink": "/pages/fine/",
        "article": false
      },
      "regularPath": "/60.%E7%B2%BE%E9%80%89%E7%AF%87/10.%E7%B2%BE%E9%80%89%E6%8C%87%E5%8D%97/10.HTML%E6%A8%A1%E5%9D%97.html",
      "relativePath": "60.精选篇/10.精选指南/10.HTML模块.md",
      "key": "v-f2de095e",
      "path": "/pages/fine/",
      "headers": [
        {
          "level": 3,
          "title": "1 如何理解HTML语义化",
          "slug": "_1-如何理解html语义化",
          "normalizedTitle": "1 如何理解html语义化",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2 H5的新特性有哪些",
          "slug": "_2-h5的新特性有哪些",
          "normalizedTitle": "2 h5的新特性有哪些",
          "charIndex": 181
        },
        {
          "level": 3,
          "title": "3 说一下 HTML5 drag api",
          "slug": "_3-说一下-html5-drag-api",
          "normalizedTitle": "3 说一下 html5 drag api",
          "charIndex": 1485
        },
        {
          "level": 3,
          "title": "4 iframe有那些缺点",
          "slug": "_4-iframe有那些缺点",
          "normalizedTitle": "4 iframe有那些缺点",
          "charIndex": 1780
        },
        {
          "level": 3,
          "title": "5 如何实现浏览器内多个标签页之间的通信",
          "slug": "_5-如何实现浏览器内多个标签页之间的通信",
          "normalizedTitle": "5 如何实现浏览器内多个标签页之间的通信",
          "charIndex": 1992
        },
        {
          "level": 3,
          "title": "6 简述一下src与href的区别",
          "slug": "_6-简述一下src与href的区别",
          "normalizedTitle": "6 简述一下src与href的区别",
          "charIndex": 3485
        },
        {
          "level": 3,
          "title": "7 知道的网页制作会用到的图片格式有哪些",
          "slug": "_7-知道的网页制作会用到的图片格式有哪些",
          "normalizedTitle": "7 知道的网页制作会用到的图片格式有哪些",
          "charIndex": 3990
        },
        {
          "level": 3,
          "title": "8 script标签中defer和async的区别",
          "slug": "_8-script标签中defer和async的区别",
          "normalizedTitle": "8 script标签中defer和async的区别",
          "charIndex": 4256
        },
        {
          "level": 3,
          "title": "9 说一下 web worker",
          "slug": "_9-说一下-web-worker",
          "normalizedTitle": "9 说一下 web worker",
          "charIndex": 4477
        },
        {
          "level": 3,
          "title": "10 用一个div模拟textarea的实现",
          "slug": "_10-用一个div模拟textarea的实现",
          "normalizedTitle": "10 用一个div模拟textarea的实现",
          "charIndex": 4742
        },
        {
          "level": 3,
          "title": "11 介绍下资源预加载 prefetch/preload",
          "slug": "_11-介绍下资源预加载-prefetch-preload",
          "normalizedTitle": "11 介绍下资源预加载 prefetch/preload",
          "charIndex": 4802
        },
        {
          "level": 3,
          "title": "12 介绍下 viewport",
          "slug": "_12-介绍下-viewport",
          "normalizedTitle": "12 介绍下 viewport",
          "charIndex": 5462
        },
        {
          "level": 3,
          "title": "13 如何解决a标点击后hover事件失效的问题?",
          "slug": "_13-如何解决a标点击后hover事件失效的问题",
          "normalizedTitle": "13 如何解决a标点击后hover事件失效的问题?",
          "charIndex": 5760
        },
        {
          "level": 3,
          "title": "14 点击一个input依次触发的事件",
          "slug": "_14-点击一个input依次触发的事件",
          "normalizedTitle": "14 点击一个input依次触发的事件",
          "charIndex": 6150
        },
        {
          "level": 3,
          "title": "15 有写过原生的自定义事件吗",
          "slug": "_15-有写过原生的自定义事件吗",
          "normalizedTitle": "15 有写过原生的自定义事件吗",
          "charIndex": 6524
        },
        {
          "level": 3,
          "title": "16 addEventListener和attachEvent的区别？",
          "slug": "_16-addeventlistener和attachevent的区别",
          "normalizedTitle": "16 addeventlistener和attachevent的区别？",
          "charIndex": 7794
        },
        {
          "level": 3,
          "title": "17 addEventListener函数的第三个参数",
          "slug": "_17-addeventlistener函数的第三个参数",
          "normalizedTitle": "17 addeventlistener函数的第三个参数",
          "charIndex": 7962
        },
        {
          "level": 3,
          "title": "18 DOM事件流是什么？",
          "slug": "_18-dom事件流是什么",
          "normalizedTitle": "18 dom事件流是什么？",
          "charIndex": 8088
        },
        {
          "level": 3,
          "title": "19 冒泡和捕获的具体过程",
          "slug": "_19-冒泡和捕获的具体过程",
          "normalizedTitle": "19 冒泡和捕获的具体过程",
          "charIndex": 8302
        },
        {
          "level": 3,
          "title": "20 关于一些兼容性",
          "slug": "_20-关于一些兼容性",
          "normalizedTitle": "20 关于一些兼容性",
          "charIndex": 8900
        },
        {
          "level": 3,
          "title": "21 如何阻止冒泡和默认事件(兼容写法)",
          "slug": "_21-如何阻止冒泡和默认事件-兼容写法",
          "normalizedTitle": "21 如何阻止冒泡和默认事件(兼容写法)",
          "charIndex": 9310
        },
        {
          "level": 3,
          "title": "22 所有的事件都有冒泡吗？",
          "slug": "_22-所有的事件都有冒泡吗",
          "normalizedTitle": "22 所有的事件都有冒泡吗？",
          "charIndex": 9681
        },
        {
          "level": 3,
          "title": "23 拖拽有哪些知识点",
          "slug": "_23-拖拽有哪些知识点",
          "normalizedTitle": "23 拖拽有哪些知识点",
          "charIndex": 9783
        },
        {
          "level": 3,
          "title": "24 offset、scroll、client的区别",
          "slug": "_24-offset、scroll、client的区别",
          "normalizedTitle": "24 offset、scroll、client的区别",
          "charIndex": 9950
        },
        {
          "level": 3,
          "title": "25 target=\"_blank\"有哪些问题？",
          "slug": "_25-target-blank-有哪些问题",
          "normalizedTitle": "25 target=&quot;_blank&quot;有哪些问题？",
          "charIndex": null
        },
        {
          "level": 3,
          "title": "26 children以及childNodes的区别",
          "slug": "_26-children以及childnodes的区别",
          "normalizedTitle": "26 children以及childnodes的区别",
          "charIndex": 10945
        }
      ],
      "headersStr": "1 如何理解HTML语义化 2 H5的新特性有哪些 3 说一下 HTML5 drag api 4 iframe有那些缺点 5 如何实现浏览器内多个标签页之间的通信 6 简述一下src与href的区别 7 知道的网页制作会用到的图片格式有哪些 8 script标签中defer和async的区别 9 说一下 web worker 10 用一个div模拟textarea的实现 11 介绍下资源预加载 prefetch/preload 12 介绍下 viewport 13 如何解决a标点击后hover事件失效的问题? 14 点击一个input依次触发的事件 15 有写过原生的自定义事件吗 16 addEventListener和attachEvent的区别？ 17 addEventListener函数的第三个参数 18 DOM事件流是什么？ 19 冒泡和捕获的具体过程 20 关于一些兼容性 21 如何阻止冒泡和默认事件(兼容写法) 22 所有的事件都有冒泡吗？ 23 拖拽有哪些知识点 24 offset、scroll、client的区别 25 target=\"_blank\"有哪些问题？ 26 children以及childNodes的区别",
      "content": "# 1 如何理解HTML语义化\n\n * 用正确的标签做正确的事情！\n * HTML语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；\n * 在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的。\n * 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。\n * 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解\n\n\n# 2 H5的新特性有哪些\n\n * 画布(Canvas) API\n\n * 地理(Geolocation) API\n\n * 音频、视频API(audio,video)\n\n * localStorage和sessionStorage\n\n * webworker, websocket\n\n * 新的一套标签 header,nav,footer,aside,article,section\n\n * web worker是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。\n\n * HTML5 History两个新增的API：history.pushState 和 history.replaceState，两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。\n\n> Hash就是url 中看到 # ,我们需要一个根据监听哈希变化触发的事件( hashchange) 事件。我们用 window.location处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。 可以为hash的改变添加监听事件：\n\nwindow.addEventListener(\"hashchange\", funcRef, false)\n\n\n * WebSocket 使用ws或wss协议，Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。WebSocket API最伟大之处在于服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息。WebSocket并不限于以Ajax(或XHR)方式通信，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息；XHR受到域的限制，而WebSocket允许跨域通信\n\n// 创建一个Socket实例\nvar socket = new WebSocket('ws://localhost:8080');\n// 打开Socket\nsocket.onopen = function(event) {\n  // 发送一个初始化消息\n  socket.send('I am the client and I\\'m listening!');\n  // 监听消息\n  socket.onmessage = function(event) {\n    console.log('Client received a message',event);\n  };\n  // 监听Socket的关闭\n  socket.onclose = function(event) {\n    console.log('Client notified socket has closed',event);\n  };\n  // 关闭Socket....\n  //socket.close()\n};\n \n\n\n\n# 3 说一下 HTML5 drag api\n\n * dragstart:事件主体是被拖放元素，在开始拖放被拖放元素时触发，。\n\n * darg:事件主体是被拖放元素，在正在拖放被拖放元素时触发。\n\n * dragenter:事件主体是目标元素，在被拖放元素进入某元素时触发。\n\n * dragover:事件主体是目标元素，在被拖放在某元素内移动时触发。\n\n * dragleave:事件主体是目标元素，在被拖放元素移出目标元素是触发。\n\n * drop:事件主体是目标元素，在目标元素完全接受被拖放元素时触发。\n\n * dragend:事件主体是被拖放元素，在整个拖放操作结束时触发\n\n\n# 4 iframe有那些缺点\n\n * iframe会阻塞主页面的Onload事件；\n\n * 搜索引擎的检索程序无法解读这种页面，不利于SEO;\n\n * iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。\n\n * 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript\n\n * 动态给iframe添加src属性值，这样可以绕开以上两个问题\n\n\n# 5 如何实现浏览器内多个标签页之间的通信\n\n 1. 使用WebSocket 可以实现多个标签页之间的通信\n\n 2. 调用localStorage\n\n * 在一个标签页里面使用 localStorage.setItem(key,value) 添加（修改、删除）内容；\n\n * 在另一个标签页里面监听 storage 事件。\n\n * 即可得到 localstorge 存储的值，实现不同标签页之间的通信\n\n标签页1\n\n<input id=\"name\">  \n<input type=\"button\" id=\"btn\" value=\"提交\">  \n<script type=\"text/javascript\">  \n    $(function(){    \n        $(\"#btn\").click(function(){    \n            var name=$(\"#name\").val();    \n            localStorage.setItem(\"name\", name);   \n        });    \n    });    \n</script>  \n\n\n标签页2：\n\n<script type=\"text/javascript\">  \n    $(function(){   \n        window.addEventListener(\"storage\", function(event){    \n            console.log(event.key + \"=\" + event.newValue);    \n        });     \n    });  \n</script>  \n\n\n 1. 调用cookie+setInterval()\n\n> 将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。\n\n页面1：\n\n<input id=\"name\">  \n<input type=\"button\" id=\"btn\" value=\"提交\">  \n<script type=\"text/javascript\">  \n    $(function(){    \n        $(\"#btn\").click(function(){    \n            var name=$(\"#name\").val();    \n            document.cookie=\"name=\"+name;    \n        });    \n    });    \n</script>  \n\n\n页面2：\n\n<script type=\"text/javascript\">  \n    $(function(){   \n        function getCookie(key) {    \n            return JSON.parse(\"{\\\"\" + document.cookie.replace(/;\\s+/gim,\"\\\",\\\"\").replace(/=/gim, \"\\\":\\\"\") + \"\\\"}\")[key];    \n        }     \n        setInterval(function(){    \n            console.log(\"name=\" + getCookie(\"name\"));    \n        }, 10000);    \n    });  \n</script>  \n\n\n\n# 6 简述一下src与href的区别\n\n * src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。\n\n * src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素\n\n&lt;script src =\"js.js\">&lt;/script>\n\n\n> 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部\n\n * href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加\n\n<link href=\"common.css\" rel=\"stylesheet\" />\n\n\n> 那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。\n\n\n# 7 知道的网页制作会用到的图片格式有哪些\n\n> png-8，png-24，jpeg，gif，svg\n\n但是上面的那些都不是面试官想要的最后答案。面试官希望听到是Webp。（是否有关注新技术，新鲜事物）\n\n> 科普一下Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。\n\n在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%\n\n\n# 8 script标签中defer和async的区别\n\n * script ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。\n\n * defer:浏览器指示脚本在文档被解析后执行，script被异步加载后并不会立刻执行，而是等待文档被解析完毕后执行。\n\n * async:同样是异步加载脚本，区别是脚本加载完毕后立即执行，这导致async属性下的脚本是乱序的，对于 script 有先后依赖关系的情况，并不适用\n\n\n# 9 说一下 web worker\n\n> 在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后， 页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面你 的性能。并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就 不会阻塞主线程了\n\n如何创建 web worker:\n\n * 检测浏览器对于 web worker 的支持性\n * 创建 web worker 文件(js，回传函数等)\n * 创建 web worker 对象\n\n\n# 10 用一个div模拟textarea的实现\n\n> 给div添加contenteditable=true 即可\n\n\n# 11 介绍下资源预加载 prefetch/preload\n\n> 都是告知浏览器提前加载文件(图片、视频、js、css等)，但执行上是有区别的。\n\n * prefetch：其利用浏览器空闲时间来下载或预取用户在不久的将来可能访问的文档。<link href=\"/js/xx.js\" rel=\"prefetch\">\n\n * preload : 可以指明哪些资源是在页面加载完成后即刻需要的，浏览器在主渲染机制介入前就进行预加载，这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能。 <link href=\"/js/xxx.js\" rel=\"preload\" as=\"script\">需要 as 指定资源类型目前可用的属性类型有如下：\n\naudio: 音频文件。\ndocument: 一个将要被嵌入到&lt;frame>或&lt;iframe>内部的HTML文档。\nembed: 一个将要被嵌入到&lt;embed>元素内部的资源。\nfetch: 那些将要通过fetch和XHR请求来获取的资源，比如一个ArrayBuffer或JSON文件。\nfont: 字体文件。\nimage: 图片文件。\nobject: 一个将会被嵌入到&lt;embed>元素内的文件。\nscript: JavaScript文件。\nstyle: 样式表。\ntrack: WebVTT文件。\nworker: 一个JavaScript的web worker或shared worker。\nvideo: 视频文件。\n\n\n\n# 12 介绍下 viewport\n\n<meta name=\"viewport\" content=\"width=500, initial-scale=1\">\n\n\n * width：页面宽度，可以取值具体的数字，也可以是 device-width，表示跟设备宽度相等。\n\n * height：页面高度，可以取值具体的数字，也可以是 device-height，表示跟设备高度相等。\n\n * initial-scale：初始缩放比例。\n\n * minimum-scale：最小缩放比例。\n\n * maximum-scale：最大缩放比例。\n\n * user-scalable：是否允许用户缩放。\n\n\n# 13 如何解决a标点击后hover事件失效的问题?\n\n改变a标签css属性的排列顺序\n\n只需要记住LoVe HAte原则就可以了(爱恨原则)：\n\nlink→visited→hover→active\n\n\n比如下面错误的代码顺序：\n\na:hover{\n  color: green;\n  text-decoration: none;\n}\na:visited{ /* visited在hover后面，这样的话hover事件就失效了 */\n  color: red;\n  text-decoration: none;\n}\n\n\n正确的做法是将两个事件的位置调整一下。\n\n注意⚠️各个阶段的含义：\n\n * a:link：未访问时的样式，一般省略成a\n\n * a:visited：已经访问后的样式\n\n * a:hover：鼠标移上去时的样式\n\n * a:active：鼠标按下时的样式\n\n\n# 14 点击一个input依次触发的事件\n\nconst text = document.getElementById('text');\ntext.onclick = function (e) {\n  console.log('onclick')\n}\ntext.onfocus = function (e) {\n  console.log('onfocus')\n}\ntext.onmousedown = function (e) {\n  console.log('onmousedown')\n}\ntext.onmouseenter = function (e) {\n  console.log('onmouseenter')\n}\n\n\n答案：\n\n'onmouseenter'\n'onmousedown'\n'onfocus'\n'onclick'\n\n\n\n# 15 有写过原生的自定义事件吗\n\n创建自定义事件\n\n原生自定义事件有三种写法：\n\n 1. 使用Event\n\nlet myEvent = new Event('event_name');\n\n\n 1. 使用customEvent （可以传参数）\n\nlet myEvent = new CustomEvent('event_name', {\n\tdetail: {\n\t\t// 将需要传递的参数放到这里\n\t\t// 可以在监听的回调函数中获取到：event.detail\n\t}\n})\n\n\n 1. 使用document.createEvent('CustomEvent')和initCustomEvent()\n\nlet myEvent = document.createEvent('CustomEvent');// 注意这里是为'CustomEvent'\nmyEvent.initEvent(\n\t// 1. event_name: 事件名称\n\t// 2. canBubble: 是否冒泡\n\t// 3. cancelable: 是否可以取消默认行为\n)\n\n\n * createEvent：创建一个事件\n\n * initEvent：初始化一个事件\n\n可以看到，initEvent可以指定3个参数。\n\n（有些文章中会说还有第四个参数detail，但是我查看了W3C上并没有这个参数，而且实践了一下也没有效果）\n\n事件的监听\n\n自定义事件的监听其实和普通事件的一样，使用addEventListener来监听：\n\nbutton.addEventListener('event_name', function (e) {})\n\n\n事件的触发\n\n触发自定义事件使用dispatchEvent(myEvent)。\n\n注意⚠️，这里的参数是要自定义事件的对象(也就是myEvent)，而不是自定义事件的名称('myEvent')\n\n案例\n\n来看个案例吧：\n\n// 1.\n// let myEvent = new Event('myEvent');\n// 2.\n// let myEvent = new CustomEvent('myEvent', {\n//   detail: {\n//     name: 'lindaidai'\n//   }\n// })\n// 3.\nlet myEvent = document.createEvent('CustomEvent');\nmyEvent.initEvent('myEvent', true, true)\n\nlet btn = document.getElementsByTagName('button')[0]\nbtn.addEventListener('myEvent', function (e) {\n  console.log(e)\n  console.log(e.detail)\n})\nsetTimeout(() => {\n  btn.dispatchEvent(myEvent)\n}, 2000)\n\n\n\n# 16 addEventListener和attachEvent的区别？\n\n * 前者是标准浏览器中的用法，后者IE8以下\n * addEventListener可有冒泡，可有捕获；attachEvent只有冒泡，没有捕获。\n * 前者事件名不带on，后者带on\n * 前者回调函数中的this指向当前元素，后者指向window\n\n\n# 17 addEventListener函数的第三个参数\n\n第三个参数涉及到冒泡和捕获，是true时为捕获，是false则为冒泡。\n\n> 或者是一个对象{passive: true}，针对的是Safari浏览器，禁止/开启使用滚动的时候要用到。\n\n\n# 18 DOM事件流是什么？\n\n事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程就叫做DOM事件流。\n\n> DOM事件流分为三个阶段：\n\n 1. 捕获阶段：事件从window发出，自上而下向目标节点传播的阶段\n\n 2. 目标阶段：真正的目标阶段正在处理事件的阶段\n\n 3. 冒泡阶段：事件从目标节点自下而上向window传播的阶段\n\n(注意⚠️：JS代码只能执行捕获或者冒泡其中一个阶段，要么是捕获要么是冒泡)\n\n\n# 19 冒泡和捕获的具体过程\n\n> 冒泡指的是：当给某个目标元素绑定了事件之后，这个事件会依次在它的父级元素中被触发(当然前提是这个父级元素也有这个同名称的事件，比如子元素和父元素都绑定了click事件就触发父元素的click)。\n\n捕获则是从上层向下层传递，与冒泡相反。\n\n（非常好记，你就想想水底有一个泡泡从下面往上传的，所以是冒泡）\n\n来看看这个例子：\n\n<!-- 会依次执行 button li ul -->\n<ul onclick=\"alert('ul')\">\n  <li onclick=\"alert('li')\">\n    <button onclick=\"alert('button')\">点击</button>\n  </li>\n</ul>\n<script>\n  window.addEventListener('click', function (e) {\n    alert('window')\n  })\n  document.addEventListener('click', function (e) {\n    alert('document')\n  })\n</script>\n\n\n * 冒泡结果：button > li > ul > document > window\n\n * 捕获结果：window > document > ul > li > button\n\n\n# 20 关于一些兼容性\n\n 1. event的兼容性\n\n * 其它浏览器window.event\n\n * 火狐下没有window.event，所以用传入的参数ev代替\n\n * 最终写法：var oEvent = ev || window.event\n\n 2. 事件源的兼容性\n\n * 其它浏览器event.target\n\n * IE下为event.srcElement\n\n * 最终写法：var target = event.target || event.srcElement\n\n 3. 阻止事件冒泡\n\n * 其它浏览器event.stopPropagation()\n\n * IE下为window.event.cancelBubble = true\n\n 4. 阻止默认事件\n\n * 其它浏览器e.preventDefault()\n\n * IE下为window.event.returnValue = false\n\n\n# 21 如何阻止冒泡和默认事件(兼容写法)\n\n阻止冒泡：\n\nfunction stopBubble (e) { // 阻止冒泡\n  if (e && e.stopPropagation) {\n    e.stopPropagation();\n  } else {\n    // 兼容 IE\n    window.event.cancelBubble = true;\n  }\n}\nfunction stopDefault (e) { // 阻止默认事件\n  if (e && e.preventDefault) {\n    e.preventDefault();\n  } else {\n    // 兼容 IE\n    window.event.returnValue = false;\n    return false;\n  }\n}\n\n\n\n# 22 所有的事件都有冒泡吗？\n\n并不是所有的事件都有冒泡的，例如以下事件就没有：\n\n * onblur\n\n * onfocus\n\n * onmouseenter\n\n * onmouseleave\n\n\n# 23 拖拽有哪些知识点\n\n 1. 可以通过给标签设置draggable属性来实现元素的拖拽，img和a标签默认是可以拖拽的\n\n 2. 拖拽者身上的三个事件：ondragstart、ondrag、ondragend\n\n 3. 拖拽要放到的元素：ondragenter、ondragover、ondragleave、ondrap\n\n\n# 24 offset、scroll、client的区别\n\nclient:\n\n * oEvent.clientX是指鼠标到可视区左边框的距离。\n\n * oEvent.clientY是指鼠标到可视区上边框的距离。\n\n * clientWidth是指可视区的宽度。\n\n * clientHeight是指可视区的高度。\n\n * clientLeft获取左边框的宽度。\n\n * clientTop获取上边框的宽度。\n\noffset:\n\n * offsetWidth是指div的宽度（包括div的边框）\n\n * offsetHeight是指div的高度（包括div的边框）\n\n * offsetLeft是指div到整个页面左边框的距离（不包括div的边框）\n\n * offsetTop是指div到整个页面上边框的距离（不包括div的边框）\n\nscroll:\n\n * scrollTop是指可视区顶部边框与整个页面上部边框的看不到的区域。\n\n * scrollLeft是指可视区左边边框与整个页面左边边框的看不到的区域。\n\n * scrollWidth是指左边看不到的区域加可视区加右边看不到的区域即整个页面的宽度（包括边框）\n\n * scrollHeight是指上边看不到的区域加可视区加右边看不到的区域即整个页面的高度（包括边框）\n\n\n# 25 target=\"_blank\"有哪些问题？\n\n存在问题：\n\n 1. 安全隐患：新打开的窗口可以通过window.opener获取到来源页面的window对象即使跨域也可以。某些属性的访问被拦截，是因为跨域安全策略的限制。 但是，比如修改window.opener.location的值，指向另外一个地址，这样新窗口有可能会把原来的网页地址改了并进行页面伪装来欺骗用户。\n\n 2. 新打开的窗口与原页面窗口共用一个进程，若是新页面有性能不好的代码也会影响原页面\n\n解决方案：\n\n 1. 尽量不用target=\"_blank\"\n\n 2. 如果一定要用，需要加上rel=\"noopener\"或者rel=\"noreferrer\"。这样新窗口的window.openner就是null了，而且会让新窗口运行在独立的进程里，不会拖累原来页面的进程。(不过，有些浏览器对性能做了优化，即使不加这个属性，新窗口也会在独立进程打开。不过为了安全考虑，还是加上吧。)\n\n\n# 26 children以及childNodes的区别\n\n * children和只获取该节点下的所有element节点\n\n * childNodes不仅仅获取element节点还会获取元素标签中的空白节点\n\n * firstElementChild只获取该节点下的第一个element节点\n\n * firstChild会获取空白节点",
      "normalizedContent": "# 1 如何理解html语义化\n\n * 用正确的标签做正确的事情！\n * html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；\n * 在没有样式css情况下也以一种文档格式显示，并且是容易阅读的。\n * 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 seo。\n * 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解\n\n\n# 2 h5的新特性有哪些\n\n * 画布(canvas) api\n\n * 地理(geolocation) api\n\n * 音频、视频api(audio,video)\n\n * localstorage和sessionstorage\n\n * webworker, websocket\n\n * 新的一套标签 header,nav,footer,aside,article,section\n\n * web worker是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postmessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。\n\n * html5 history两个新增的api：history.pushstate 和 history.replacestate，两个 api 都会操作浏览器的历史记录，而不会引起页面的刷新。\n\n> hash就是url 中看到 # ,我们需要一个根据监听哈希变化触发的事件( hashchange) 事件。我们用 window.location处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。 可以为hash的改变添加监听事件：\n\nwindow.addeventlistener(\"hashchange\", funcref, false)\n\n\n * websocket 使用ws或wss协议，websocket是一个持久化的协议，相对于http这种非持久的协议来说。websocket api最伟大之处在于服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息。websocket并不限于以ajax(或xhr)方式通信，因为ajax技术需要客户端发起请求，而websocket服务器和客户端可以彼此相互推送信息；xhr受到域的限制，而websocket允许跨域通信\n\n// 创建一个socket实例\nvar socket = new websocket('ws://localhost:8080');\n// 打开socket\nsocket.onopen = function(event) {\n  // 发送一个初始化消息\n  socket.send('i am the client and i\\'m listening!');\n  // 监听消息\n  socket.onmessage = function(event) {\n    console.log('client received a message',event);\n  };\n  // 监听socket的关闭\n  socket.onclose = function(event) {\n    console.log('client notified socket has closed',event);\n  };\n  // 关闭socket....\n  //socket.close()\n};\n \n\n\n\n# 3 说一下 html5 drag api\n\n * dragstart:事件主体是被拖放元素，在开始拖放被拖放元素时触发，。\n\n * darg:事件主体是被拖放元素，在正在拖放被拖放元素时触发。\n\n * dragenter:事件主体是目标元素，在被拖放元素进入某元素时触发。\n\n * dragover:事件主体是目标元素，在被拖放在某元素内移动时触发。\n\n * dragleave:事件主体是目标元素，在被拖放元素移出目标元素是触发。\n\n * drop:事件主体是目标元素，在目标元素完全接受被拖放元素时触发。\n\n * dragend:事件主体是被拖放元素，在整个拖放操作结束时触发\n\n\n# 4 iframe有那些缺点\n\n * iframe会阻塞主页面的onload事件；\n\n * 搜索引擎的检索程序无法解读这种页面，不利于seo;\n\n * iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。\n\n * 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript\n\n * 动态给iframe添加src属性值，这样可以绕开以上两个问题\n\n\n# 5 如何实现浏览器内多个标签页之间的通信\n\n 1. 使用websocket 可以实现多个标签页之间的通信\n\n 2. 调用localstorage\n\n * 在一个标签页里面使用 localstorage.setitem(key,value) 添加（修改、删除）内容；\n\n * 在另一个标签页里面监听 storage 事件。\n\n * 即可得到 localstorge 存储的值，实现不同标签页之间的通信\n\n标签页1\n\n<input id=\"name\">  \n<input type=\"button\" id=\"btn\" value=\"提交\">  \n<script type=\"text/javascript\">  \n    $(function(){    \n        $(\"#btn\").click(function(){    \n            var name=$(\"#name\").val();    \n            localstorage.setitem(\"name\", name);   \n        });    \n    });    \n</script>  \n\n\n标签页2：\n\n<script type=\"text/javascript\">  \n    $(function(){   \n        window.addeventlistener(\"storage\", function(event){    \n            console.log(event.key + \"=\" + event.newvalue);    \n        });     \n    });  \n</script>  \n\n\n 1. 调用cookie+setinterval()\n\n> 将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。\n\n页面1：\n\n<input id=\"name\">  \n<input type=\"button\" id=\"btn\" value=\"提交\">  \n<script type=\"text/javascript\">  \n    $(function(){    \n        $(\"#btn\").click(function(){    \n            var name=$(\"#name\").val();    \n            document.cookie=\"name=\"+name;    \n        });    \n    });    \n</script>  \n\n\n页面2：\n\n<script type=\"text/javascript\">  \n    $(function(){   \n        function getcookie(key) {    \n            return json.parse(\"{\\\"\" + document.cookie.replace(/;\\s+/gim,\"\\\",\\\"\").replace(/=/gim, \"\\\":\\\"\") + \"\\\"}\")[key];    \n        }     \n        setinterval(function(){    \n            console.log(\"name=\" + getcookie(\"name\"));    \n        }, 10000);    \n    });  \n</script>  \n\n\n\n# 6 简述一下src与href的区别\n\n * src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。\n\n * src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素\n\n&lt;script src =\"js.js\">&lt;/script>\n\n\n> 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部\n\n * href是hypertext reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加\n\n<link href=\"common.css\" rel=\"stylesheet\" />\n\n\n> 那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。\n\n\n# 7 知道的网页制作会用到的图片格式有哪些\n\n> png-8，png-24，jpeg，gif，svg\n\n但是上面的那些都不是面试官想要的最后答案。面试官希望听到是webp。（是否有关注新技术，新鲜事物）\n\n> 科普一下webp：webp格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有jpeg的2/3，并能节省大量的服务器带宽资源和数据空间。facebook ebay等知名网站已经开始测试并使用webp格式。\n\n在质量相同的情况下，webp格式图像的体积要比jpeg格式图像小40%\n\n\n# 8 script标签中defer和async的区别\n\n * script ：会阻碍 html 解析，只有下载好并执行完脚本才会继续解析 html。\n\n * defer:浏览器指示脚本在文档被解析后执行，script被异步加载后并不会立刻执行，而是等待文档被解析完毕后执行。\n\n * async:同样是异步加载脚本，区别是脚本加载完毕后立即执行，这导致async属性下的脚本是乱序的，对于 script 有先后依赖关系的情况，并不适用\n\n\n# 9 说一下 web worker\n\n> 在 html 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后， 页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面你 的性能。并且通过 postmessage 将结果回传到主线程。这样在进行复杂操作的时候，就 不会阻塞主线程了\n\n如何创建 web worker:\n\n * 检测浏览器对于 web worker 的支持性\n * 创建 web worker 文件(js，回传函数等)\n * 创建 web worker 对象\n\n\n# 10 用一个div模拟textarea的实现\n\n> 给div添加contenteditable=true 即可\n\n\n# 11 介绍下资源预加载 prefetch/preload\n\n> 都是告知浏览器提前加载文件(图片、视频、js、css等)，但执行上是有区别的。\n\n * prefetch：其利用浏览器空闲时间来下载或预取用户在不久的将来可能访问的文档。<link href=\"/js/xx.js\" rel=\"prefetch\">\n\n * preload : 可以指明哪些资源是在页面加载完成后即刻需要的，浏览器在主渲染机制介入前就进行预加载，这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能。 <link href=\"/js/xxx.js\" rel=\"preload\" as=\"script\">需要 as 指定资源类型目前可用的属性类型有如下：\n\naudio: 音频文件。\ndocument: 一个将要被嵌入到&lt;frame>或&lt;iframe>内部的html文档。\nembed: 一个将要被嵌入到&lt;embed>元素内部的资源。\nfetch: 那些将要通过fetch和xhr请求来获取的资源，比如一个arraybuffer或json文件。\nfont: 字体文件。\nimage: 图片文件。\nobject: 一个将会被嵌入到&lt;embed>元素内的文件。\nscript: javascript文件。\nstyle: 样式表。\ntrack: webvtt文件。\nworker: 一个javascript的web worker或shared worker。\nvideo: 视频文件。\n\n\n\n# 12 介绍下 viewport\n\n<meta name=\"viewport\" content=\"width=500, initial-scale=1\">\n\n\n * width：页面宽度，可以取值具体的数字，也可以是 device-width，表示跟设备宽度相等。\n\n * height：页面高度，可以取值具体的数字，也可以是 device-height，表示跟设备高度相等。\n\n * initial-scale：初始缩放比例。\n\n * minimum-scale：最小缩放比例。\n\n * maximum-scale：最大缩放比例。\n\n * user-scalable：是否允许用户缩放。\n\n\n# 13 如何解决a标点击后hover事件失效的问题?\n\n改变a标签css属性的排列顺序\n\n只需要记住love hate原则就可以了(爱恨原则)：\n\nlink→visited→hover→active\n\n\n比如下面错误的代码顺序：\n\na:hover{\n  color: green;\n  text-decoration: none;\n}\na:visited{ /* visited在hover后面，这样的话hover事件就失效了 */\n  color: red;\n  text-decoration: none;\n}\n\n\n正确的做法是将两个事件的位置调整一下。\n\n注意⚠️各个阶段的含义：\n\n * a:link：未访问时的样式，一般省略成a\n\n * a:visited：已经访问后的样式\n\n * a:hover：鼠标移上去时的样式\n\n * a:active：鼠标按下时的样式\n\n\n# 14 点击一个input依次触发的事件\n\nconst text = document.getelementbyid('text');\ntext.onclick = function (e) {\n  console.log('onclick')\n}\ntext.onfocus = function (e) {\n  console.log('onfocus')\n}\ntext.onmousedown = function (e) {\n  console.log('onmousedown')\n}\ntext.onmouseenter = function (e) {\n  console.log('onmouseenter')\n}\n\n\n答案：\n\n'onmouseenter'\n'onmousedown'\n'onfocus'\n'onclick'\n\n\n\n# 15 有写过原生的自定义事件吗\n\n创建自定义事件\n\n原生自定义事件有三种写法：\n\n 1. 使用event\n\nlet myevent = new event('event_name');\n\n\n 1. 使用customevent （可以传参数）\n\nlet myevent = new customevent('event_name', {\n\tdetail: {\n\t\t// 将需要传递的参数放到这里\n\t\t// 可以在监听的回调函数中获取到：event.detail\n\t}\n})\n\n\n 1. 使用document.createevent('customevent')和initcustomevent()\n\nlet myevent = document.createevent('customevent');// 注意这里是为'customevent'\nmyevent.initevent(\n\t// 1. event_name: 事件名称\n\t// 2. canbubble: 是否冒泡\n\t// 3. cancelable: 是否可以取消默认行为\n)\n\n\n * createevent：创建一个事件\n\n * initevent：初始化一个事件\n\n可以看到，initevent可以指定3个参数。\n\n（有些文章中会说还有第四个参数detail，但是我查看了w3c上并没有这个参数，而且实践了一下也没有效果）\n\n事件的监听\n\n自定义事件的监听其实和普通事件的一样，使用addeventlistener来监听：\n\nbutton.addeventlistener('event_name', function (e) {})\n\n\n事件的触发\n\n触发自定义事件使用dispatchevent(myevent)。\n\n注意⚠️，这里的参数是要自定义事件的对象(也就是myevent)，而不是自定义事件的名称('myevent')\n\n案例\n\n来看个案例吧：\n\n// 1.\n// let myevent = new event('myevent');\n// 2.\n// let myevent = new customevent('myevent', {\n//   detail: {\n//     name: 'lindaidai'\n//   }\n// })\n// 3.\nlet myevent = document.createevent('customevent');\nmyevent.initevent('myevent', true, true)\n\nlet btn = document.getelementsbytagname('button')[0]\nbtn.addeventlistener('myevent', function (e) {\n  console.log(e)\n  console.log(e.detail)\n})\nsettimeout(() => {\n  btn.dispatchevent(myevent)\n}, 2000)\n\n\n\n# 16 addeventlistener和attachevent的区别？\n\n * 前者是标准浏览器中的用法，后者ie8以下\n * addeventlistener可有冒泡，可有捕获；attachevent只有冒泡，没有捕获。\n * 前者事件名不带on，后者带on\n * 前者回调函数中的this指向当前元素，后者指向window\n\n\n# 17 addeventlistener函数的第三个参数\n\n第三个参数涉及到冒泡和捕获，是true时为捕获，是false则为冒泡。\n\n> 或者是一个对象{passive: true}，针对的是safari浏览器，禁止/开启使用滚动的时候要用到。\n\n\n# 18 dom事件流是什么？\n\n事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程就叫做dom事件流。\n\n> dom事件流分为三个阶段：\n\n 1. 捕获阶段：事件从window发出，自上而下向目标节点传播的阶段\n\n 2. 目标阶段：真正的目标阶段正在处理事件的阶段\n\n 3. 冒泡阶段：事件从目标节点自下而上向window传播的阶段\n\n(注意⚠️：js代码只能执行捕获或者冒泡其中一个阶段，要么是捕获要么是冒泡)\n\n\n# 19 冒泡和捕获的具体过程\n\n> 冒泡指的是：当给某个目标元素绑定了事件之后，这个事件会依次在它的父级元素中被触发(当然前提是这个父级元素也有这个同名称的事件，比如子元素和父元素都绑定了click事件就触发父元素的click)。\n\n捕获则是从上层向下层传递，与冒泡相反。\n\n（非常好记，你就想想水底有一个泡泡从下面往上传的，所以是冒泡）\n\n来看看这个例子：\n\n<!-- 会依次执行 button li ul -->\n<ul onclick=\"alert('ul')\">\n  <li onclick=\"alert('li')\">\n    <button onclick=\"alert('button')\">点击</button>\n  </li>\n</ul>\n<script>\n  window.addeventlistener('click', function (e) {\n    alert('window')\n  })\n  document.addeventlistener('click', function (e) {\n    alert('document')\n  })\n</script>\n\n\n * 冒泡结果：button > li > ul > document > window\n\n * 捕获结果：window > document > ul > li > button\n\n\n# 20 关于一些兼容性\n\n 1. event的兼容性\n\n * 其它浏览器window.event\n\n * 火狐下没有window.event，所以用传入的参数ev代替\n\n * 最终写法：var oevent = ev || window.event\n\n 2. 事件源的兼容性\n\n * 其它浏览器event.target\n\n * ie下为event.srcelement\n\n * 最终写法：var target = event.target || event.srcelement\n\n 3. 阻止事件冒泡\n\n * 其它浏览器event.stoppropagation()\n\n * ie下为window.event.cancelbubble = true\n\n 4. 阻止默认事件\n\n * 其它浏览器e.preventdefault()\n\n * ie下为window.event.returnvalue = false\n\n\n# 21 如何阻止冒泡和默认事件(兼容写法)\n\n阻止冒泡：\n\nfunction stopbubble (e) { // 阻止冒泡\n  if (e && e.stoppropagation) {\n    e.stoppropagation();\n  } else {\n    // 兼容 ie\n    window.event.cancelbubble = true;\n  }\n}\nfunction stopdefault (e) { // 阻止默认事件\n  if (e && e.preventdefault) {\n    e.preventdefault();\n  } else {\n    // 兼容 ie\n    window.event.returnvalue = false;\n    return false;\n  }\n}\n\n\n\n# 22 所有的事件都有冒泡吗？\n\n并不是所有的事件都有冒泡的，例如以下事件就没有：\n\n * onblur\n\n * onfocus\n\n * onmouseenter\n\n * onmouseleave\n\n\n# 23 拖拽有哪些知识点\n\n 1. 可以通过给标签设置draggable属性来实现元素的拖拽，img和a标签默认是可以拖拽的\n\n 2. 拖拽者身上的三个事件：ondragstart、ondrag、ondragend\n\n 3. 拖拽要放到的元素：ondragenter、ondragover、ondragleave、ondrap\n\n\n# 24 offset、scroll、client的区别\n\nclient:\n\n * oevent.clientx是指鼠标到可视区左边框的距离。\n\n * oevent.clienty是指鼠标到可视区上边框的距离。\n\n * clientwidth是指可视区的宽度。\n\n * clientheight是指可视区的高度。\n\n * clientleft获取左边框的宽度。\n\n * clienttop获取上边框的宽度。\n\noffset:\n\n * offsetwidth是指div的宽度（包括div的边框）\n\n * offsetheight是指div的高度（包括div的边框）\n\n * offsetleft是指div到整个页面左边框的距离（不包括div的边框）\n\n * offsettop是指div到整个页面上边框的距离（不包括div的边框）\n\nscroll:\n\n * scrolltop是指可视区顶部边框与整个页面上部边框的看不到的区域。\n\n * scrollleft是指可视区左边边框与整个页面左边边框的看不到的区域。\n\n * scrollwidth是指左边看不到的区域加可视区加右边看不到的区域即整个页面的宽度（包括边框）\n\n * scrollheight是指上边看不到的区域加可视区加右边看不到的区域即整个页面的高度（包括边框）\n\n\n# 25 target=\"_blank\"有哪些问题？\n\n存在问题：\n\n 1. 安全隐患：新打开的窗口可以通过window.opener获取到来源页面的window对象即使跨域也可以。某些属性的访问被拦截，是因为跨域安全策略的限制。 但是，比如修改window.opener.location的值，指向另外一个地址，这样新窗口有可能会把原来的网页地址改了并进行页面伪装来欺骗用户。\n\n 2. 新打开的窗口与原页面窗口共用一个进程，若是新页面有性能不好的代码也会影响原页面\n\n解决方案：\n\n 1. 尽量不用target=\"_blank\"\n\n 2. 如果一定要用，需要加上rel=\"noopener\"或者rel=\"noreferrer\"。这样新窗口的window.openner就是null了，而且会让新窗口运行在独立的进程里，不会拖累原来页面的进程。(不过，有些浏览器对性能做了优化，即使不加这个属性，新窗口也会在独立进程打开。不过为了安全考虑，还是加上吧。)\n\n\n# 26 children以及childnodes的区别\n\n * children和只获取该节点下的所有element节点\n\n * childnodes不仅仅获取element节点还会获取元素标签中的空白节点\n\n * firstelementchild只获取该节点下的第一个element节点\n\n * firstchild会获取空白节点",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "支持",
      "frontmatter": {
        "title": "支持",
        "date": "2020-05-12T15:09:57.000Z",
        "permalink": "/pages/support",
        "article": false,
        "sidebar": false
      },
      "regularPath": "/70.%E6%94%AF%E6%8C%81/10.%E6%94%AF%E6%8C%81/10.%E6%94%AF%E6%8C%81.html",
      "relativePath": "70.支持/10.支持/10.支持.md",
      "key": "v-811c539e",
      "path": "/pages/support/",
      "headers": [
        {
          "level": 2,
          "title": "Star",
          "slug": "star",
          "normalizedTitle": "star",
          "charIndex": 40
        },
        {
          "level": 2,
          "title": "Issue",
          "slug": "issue",
          "normalizedTitle": "issue",
          "charIndex": 77
        },
        {
          "level": 2,
          "title": "程序百科",
          "slug": "程序百科",
          "normalizedTitle": "程序百科",
          "charIndex": 155
        }
      ],
      "headersStr": "Star Issue 程序百科",
      "content": "如果项目对你有帮助，或者是想支持继续开发维护，可以通过如下任意方式支持\n\n\n# Star\n\n如果本项目对您有所帮助，请点个 Star Gitee\n\n\n# Issue\n\n使用时有任何问题或者建议，请提个 Issue ，一部分问题根据个人的环境和使用有区别，我也不一定能够解决，但是会想办法。 Gitee\n\n\n# 程序百科\n\n程序百科是我个人开发的一款微信小程序，里面有网上收集的很多面试题，企业真题，复习、预习、面试，都非常有用，大家有兴趣可以简单看一下，觉得好用可以收藏一下~\n\n感谢给予支持的程序猿们，您的支持是我前进的动力 🎉",
      "normalizedContent": "如果项目对你有帮助，或者是想支持继续开发维护，可以通过如下任意方式支持\n\n\n# star\n\n如果本项目对您有所帮助，请点个 star gitee\n\n\n# issue\n\n使用时有任何问题或者建议，请提个 issue ，一部分问题根据个人的环境和使用有区别，我也不一定能够解决，但是会想办法。 gitee\n\n\n# 程序百科\n\n程序百科是我个人开发的一款微信小程序，里面有网上收集的很多面试题，企业真题，复习、预习、面试，都非常有用，大家有兴趣可以简单看一下，觉得好用可以收藏一下~\n\n感谢给予支持的程序猿们，您的支持是我前进的动力 🎉",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "CSS模块",
      "frontmatter": {
        "title": "CSS模块",
        "date": "2022-08-08T13:36:45.000Z",
        "permalink": "/pages/fineCss/",
        "article": false
      },
      "regularPath": "/60.%E7%B2%BE%E9%80%89%E7%AF%87/10.%E7%B2%BE%E9%80%89%E6%8C%87%E5%8D%97/20.CSS%E6%A8%A1%E5%9D%97.html",
      "relativePath": "60.精选篇/10.精选指南/20.CSS模块.md",
      "key": "v-2d95b49b",
      "path": "/pages/fineCss/",
      "headers": [
        {
          "level": 2,
          "title": "1 盒模型",
          "slug": "_1-盒模型",
          "normalizedTitle": "1 盒模型",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "2 BFC",
          "slug": "_2-bfc",
          "normalizedTitle": "2 bfc",
          "charIndex": 619
        },
        {
          "level": 2,
          "title": "3 层叠上下文",
          "slug": "_3-层叠上下文",
          "normalizedTitle": "3 层叠上下文",
          "charIndex": 1184
        },
        {
          "level": 2,
          "title": "4 居中布局",
          "slug": "_4-居中布局",
          "normalizedTitle": "4 居中布局",
          "charIndex": 1466
        },
        {
          "level": 3,
          "title": "水平垂直居中多种实现方式",
          "slug": "水平垂直居中多种实现方式",
          "normalizedTitle": "水平垂直居中多种实现方式",
          "charIndex": 1477
        },
        {
          "level": 3,
          "title": "左右居中",
          "slug": "左右居中",
          "normalizedTitle": "左右居中",
          "charIndex": 2357
        },
        {
          "level": 3,
          "title": "上下垂直居中",
          "slug": "上下垂直居中",
          "normalizedTitle": "上下垂直居中",
          "charIndex": 2759
        },
        {
          "level": 2,
          "title": "5 选择器权重计算方式",
          "slug": "_5-选择器权重计算方式",
          "normalizedTitle": "5 选择器权重计算方式",
          "charIndex": 3474
        },
        {
          "level": 2,
          "title": "6 清除浮动",
          "slug": "_6-清除浮动",
          "normalizedTitle": "6 清除浮动",
          "charIndex": 3778
        },
        {
          "level": 2,
          "title": "7 link 与 @import 的区别",
          "slug": "_7-link-与-import-的区别",
          "normalizedTitle": "7 link 与 @import 的区别",
          "charIndex": 4525
        },
        {
          "level": 2,
          "title": "8 CSS3的新特性",
          "slug": "_8-css3的新特性",
          "normalizedTitle": "8 css3的新特性",
          "charIndex": 4717
        },
        {
          "level": 2,
          "title": "9 CSS动画和过渡",
          "slug": "_9-css动画和过渡",
          "normalizedTitle": "9 css动画和过渡",
          "charIndex": 5288
        },
        {
          "level": 3,
          "title": "animation / keyframes",
          "slug": "animation-keyframes",
          "normalizedTitle": "animation / keyframes",
          "charIndex": 5303
        },
        {
          "level": 3,
          "title": "transform",
          "slug": "transform",
          "normalizedTitle": "transform",
          "charIndex": 1302
        },
        {
          "level": 3,
          "title": "transition",
          "slug": "transition",
          "normalizedTitle": "transition",
          "charIndex": 4732
        },
        {
          "level": 3,
          "title": "关键帧动画animation",
          "slug": "关键帧动画animation",
          "normalizedTitle": "关键帧动画animation",
          "charIndex": 6176
        },
        {
          "level": 3,
          "title": "用css3动画使一个图片旋转",
          "slug": "用css3动画使一个图片旋转",
          "normalizedTitle": "用css3动画使一个图片旋转",
          "charIndex": 6867
        },
        {
          "level": 2,
          "title": "10 有哪些方式（CSS）可以隐藏页面元素",
          "slug": "_10-有哪些方式-css-可以隐藏页面元素",
          "normalizedTitle": "10 有哪些方式（css）可以隐藏页面元素",
          "charIndex": 7614
        },
        {
          "level": 2,
          "title": "11 em、px、rem区别",
          "slug": "_11-em、px、rem区别",
          "normalizedTitle": "11 em、px、rem区别",
          "charIndex": 7943
        },
        {
          "level": 2,
          "title": "12 flex布局",
          "slug": "_12-flex布局",
          "normalizedTitle": "12 flex布局",
          "charIndex": 8142
        },
        {
          "level": 2,
          "title": "13 关于伪类 LVHA 的解释",
          "slug": "_13-关于伪类-lvha-的解释",
          "normalizedTitle": "13 关于伪类 lvha 的解释",
          "charIndex": 8477
        },
        {
          "level": 2,
          "title": "14 calc函数",
          "slug": "_14-calc函数",
          "normalizedTitle": "14 calc函数",
          "charIndex": 8879
        },
        {
          "level": 2,
          "title": "15 伪类和伪元素",
          "slug": "_15-伪类和伪元素",
          "normalizedTitle": "15 伪类和伪元素",
          "charIndex": 9365
        },
        {
          "level": 2,
          "title": "16 浏览器是怎样解析 CSS 选择器的",
          "slug": "_16-浏览器是怎样解析-css-选择器的",
          "normalizedTitle": "16 浏览器是怎样解析 css 选择器的",
          "charIndex": 10482
        },
        {
          "level": 2,
          "title": "17 浏览器如何判断是否支持 webp 格式图片",
          "slug": "_17-浏览器如何判断是否支持-webp-格式图片",
          "normalizedTitle": "17 浏览器如何判断是否支持 webp 格式图片",
          "charIndex": 10714
        },
        {
          "level": 2,
          "title": "18 CSS加载问题",
          "slug": "_18-css加载问题",
          "normalizedTitle": "18 css加载问题",
          "charIndex": 10984
        },
        {
          "level": 2,
          "title": "19 文字单超出显示省略号",
          "slug": "_19-文字单超出显示省略号",
          "normalizedTitle": "19 文字单超出显示省略号",
          "charIndex": 11078
        },
        {
          "level": 2,
          "title": "20 页面变灰",
          "slug": "_20-页面变灰",
          "normalizedTitle": "20 页面变灰",
          "charIndex": 11632
        },
        {
          "level": 2,
          "title": "21 CSS中可继承的属性",
          "slug": "_21-css中可继承的属性",
          "normalizedTitle": "21 css中可继承的属性",
          "charIndex": 11697
        },
        {
          "level": 2,
          "title": "22 常规流(文档流)是个怎样的排列关系",
          "slug": "_22-常规流-文档流-是个怎样的排列关系",
          "normalizedTitle": "22 常规流(文档流)是个怎样的排列关系",
          "charIndex": 12133
        },
        {
          "level": 2,
          "title": "23 inline-block的使用场景",
          "slug": "_23-inline-block的使用场景",
          "normalizedTitle": "23 inline-block的使用场景",
          "charIndex": 12192
        },
        {
          "level": 2,
          "title": "24 position: fixed什么时候会失效？",
          "slug": "_24-position-fixed什么时候会失效",
          "normalizedTitle": "24 position: fixed什么时候会失效？",
          "charIndex": 12497
        },
        {
          "level": 2,
          "title": "25 回流（reflow）和重绘（repaint）的理解",
          "slug": "_25-回流-reflow-和重绘-repaint-的理解",
          "normalizedTitle": "25 回流（reflow）和重绘（repaint）的理解",
          "charIndex": 12870
        },
        {
          "level": 2,
          "title": "26 GPU加速的原因",
          "slug": "_26-gpu加速的原因",
          "normalizedTitle": "26 gpu加速的原因",
          "charIndex": 14047
        },
        {
          "level": 2,
          "title": "27 说说will-change",
          "slug": "_27-说说will-change",
          "normalizedTitle": "27 说说will-change",
          "charIndex": 14233
        },
        {
          "level": 2,
          "title": "28 z-index和background的覆盖关系",
          "slug": "_28-z-index和background的覆盖关系",
          "normalizedTitle": "28 z-index和background的覆盖关系",
          "charIndex": 14802
        },
        {
          "level": 2,
          "title": "29 移动端中css你是使用什么单位",
          "slug": "_29-移动端中css你是使用什么单位",
          "normalizedTitle": "29 移动端中css你是使用什么单位",
          "charIndex": 14835
        },
        {
          "level": 2,
          "title": "30 rem和em的区别",
          "slug": "_30-rem和em的区别",
          "normalizedTitle": "30 rem和em的区别",
          "charIndex": 15602
        },
        {
          "level": 2,
          "title": "31 在移动端中怎样初始化根元素的字体大小",
          "slug": "_31-在移动端中怎样初始化根元素的字体大小",
          "normalizedTitle": "31 在移动端中怎样初始化根元素的字体大小",
          "charIndex": 15828
        },
        {
          "level": 2,
          "title": "32 移动端中不同手机html默认的字体大小都是一样的吗",
          "slug": "_32-移动端中不同手机html默认的字体大小都是一样的吗",
          "normalizedTitle": "32 移动端中不同手机html默认的字体大小都是一样的吗",
          "charIndex": 16439
        },
        {
          "level": 2,
          "title": "33 line-height 如何继承",
          "slug": "_33-line-height-如何继承",
          "normalizedTitle": "33 line-height 如何继承",
          "charIndex": 16526
        },
        {
          "level": 2,
          "title": "34 css 怎么开启硬件加速(GPU 加速)",
          "slug": "_34-css-怎么开启硬件加速-gpu-加速",
          "normalizedTitle": "34 css 怎么开启硬件加速(gpu 加速)",
          "charIndex": 16755
        },
        {
          "level": 2,
          "title": "35 flex:1 是哪些属性组成的",
          "slug": "_35-flex-1-是哪些属性组成的",
          "normalizedTitle": "35 flex:1 是哪些属性组成的",
          "charIndex": 17301
        },
        {
          "level": 2,
          "title": "36 编程题",
          "slug": "_36-编程题",
          "normalizedTitle": "36 编程题",
          "charIndex": 17848
        },
        {
          "level": 3,
          "title": "画一条 0.5px 的线",
          "slug": "画一条-0-5px-的线",
          "normalizedTitle": "画一条 0.5px 的线",
          "charIndex": 17859
        },
        {
          "level": 3,
          "title": "如何画一个三角形",
          "slug": "如何画一个三角形",
          "normalizedTitle": "如何画一个三角形",
          "charIndex": 18045
        },
        {
          "level": 3,
          "title": "圆？半圆？椭圆？",
          "slug": "圆-半圆-椭圆",
          "normalizedTitle": "圆？半圆？椭圆？",
          "charIndex": 18259
        },
        {
          "level": 3,
          "title": "左边定宽，右边自适应方案",
          "slug": "左边定宽-右边自适应方案",
          "normalizedTitle": "左边定宽，右边自适应方案",
          "charIndex": 18571
        },
        {
          "level": 3,
          "title": "左右两边定宽，中间自适应",
          "slug": "左右两边定宽-中间自适应",
          "normalizedTitle": "左右两边定宽，中间自适应",
          "charIndex": 18813
        },
        {
          "level": 3,
          "title": "如何实现左侧宽度固定，右侧宽度自适应的布局",
          "slug": "如何实现左侧宽度固定-右侧宽度自适应的布局",
          "normalizedTitle": "如何实现左侧宽度固定，右侧宽度自适应的布局",
          "charIndex": 19352
        },
        {
          "level": 3,
          "title": "利用float + margin实现",
          "slug": "利用float-margin实现",
          "normalizedTitle": "利用float + margin实现",
          "charIndex": 19468
        },
        {
          "level": 3,
          "title": "两边宽度固定中间自适应的三栏布局",
          "slug": "两边宽度固定中间自适应的三栏布局",
          "normalizedTitle": "两边宽度固定中间自适应的三栏布局",
          "charIndex": 20368
        },
        {
          "level": 3,
          "title": "CSS画圆半圆扇形三角梯形",
          "slug": "css画圆半圆扇形三角梯形",
          "normalizedTitle": "css画圆半圆扇形三角梯形",
          "charIndex": 21408
        }
      ],
      "headersStr": "1 盒模型 2 BFC 3 层叠上下文 4 居中布局 水平垂直居中多种实现方式 左右居中 上下垂直居中 5 选择器权重计算方式 6 清除浮动 7 link 与 @import 的区别 8 CSS3的新特性 9 CSS动画和过渡 animation / keyframes transform transition 关键帧动画animation 用css3动画使一个图片旋转 10 有哪些方式（CSS）可以隐藏页面元素 11 em、px、rem区别 12 flex布局 13 关于伪类 LVHA 的解释 14 calc函数 15 伪类和伪元素 16 浏览器是怎样解析 CSS 选择器的 17 浏览器如何判断是否支持 webp 格式图片 18 CSS加载问题 19 文字单超出显示省略号 20 页面变灰 21 CSS中可继承的属性 22 常规流(文档流)是个怎样的排列关系 23 inline-block的使用场景 24 position: fixed什么时候会失效？ 25 回流（reflow）和重绘（repaint）的理解 26 GPU加速的原因 27 说说will-change 28 z-index和background的覆盖关系 29 移动端中css你是使用什么单位 30 rem和em的区别 31 在移动端中怎样初始化根元素的字体大小 32 移动端中不同手机html默认的字体大小都是一样的吗 33 line-height 如何继承 34 css 怎么开启硬件加速(GPU 加速) 35 flex:1 是哪些属性组成的 36 编程题 画一条 0.5px 的线 如何画一个三角形 圆？半圆？椭圆？ 左边定宽，右边自适应方案 左右两边定宽，中间自适应 如何实现左侧宽度固定，右侧宽度自适应的布局 利用float + margin实现 两边宽度固定中间自适应的三栏布局 CSS画圆半圆扇形三角梯形",
      "content": "# 1 盒模型\n\n * 有两种， IE盒子模型、W3C盒子模型；\n\n * 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；\n\n * 区 别： IE的content部分把 border 和 padding计算了进去;\n\n * 盒子模型构成：内容(content)、内填充(padding)、 边框(border)、外边距(margin)\n\n * IE8及其以下版本浏览器，未声明 DOCTYPE，内容宽高会包含内填充和边框，称为怪异盒模型(IE盒模型)\n\n * 标准(W3C)盒模型：元素宽度 = width + padding + border + margin\n\n * 怪异(IE)盒模型：元素宽度 = width + margin\n\n * 标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高\n\n> 页面渲染时，dom 元素所采用的 布局模型。可通过box-sizing进行设置\n\n通过 box-sizing 来改变元素的盒模型\n\n * box-sizing: content-box; 默认的标准(W3C)盒模型元素效果\n\n * box-sizing: border-box; 触发怪异(IE)盒模型元素的效果\n\n * box-sizing: inherit; 继承父元素 box-sizing 属性的值\n\n\n# 2 BFC\n\n> 块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。 IE下为 Layout，可通过 zoom:1 触发\n\n触发条件:\n\n * 绝对定位元素 position: absolute/fixed\n\n * 行内块元素 display: inline-block / table\n\n * float 元素\n\n * ovevflow !== visible\n\n规则:\n\n 1. 属于同一个 BFC 的两个相邻 Box 垂直排列\n\n 2. 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠\n\n 3. BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box的左边相接触 (子元素 absolute 除外)\n\n 4. BFC 的区域不会与 float 的元素区域重叠\n\n 5. 计算 BFC 的高度时，浮动子元素也参与计算\n\n 6. 文字层不会被浮动层覆盖，环绕于周围\n\n应用:\n\n * 利用2：阻止margin重叠\n\n * 利用4：自适应两栏布局\n\n * 利用 5 ，可以避免高度塌陷\n\n * 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个div都位于同一个 BFC 区域之中)\n\n\n# 3 层叠上下文\n\n> 元素提升为一个比较特殊的图层，在三维空间中 (z轴) 高出普通元素一等。\n\n触发条件\n\n * 根层叠上下文(html)\n\n * position\n\n * css3属性\n   \n   * flex\n   \n   * transform\n   \n   * opacity\n   \n   * filter\n   \n   * will-change\n   \n   * webkit-overflow-scrolling\n\n层叠等级：层叠上下文在z轴上的排序\n\n * 在同一层叠上下文中，层叠等级才有意义\n * z-index的优先级最高\n\n\n\n\n# 4 居中布局\n\n\n# 水平垂直居中多种实现方式\n\n 1. 利用绝对定位，设置 left: 50% 和 top: 50% 现将子元素左上角移到父元素中心位置，然后再通过 translate 来调整子元素的中心点到父元素的中心。该方法可以不定宽高\n\n.father {\n  position: relative;\n}\n.son {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n}\n\n\n 1. 利用绝对定位，子元素所有方向都为 0 ，将 margin 设置为 auto ，由于宽高固定，对应方向实现平分，该方法必须盒子有宽高\n\n.father {\n  position: relative;\n}\n.son {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0px;\n  margin: auto;\n  height: 100px;\n  width: 100px;\n}\n\n\n 1. 利用绝对定位，设置 left: 50% 和 top: 50% 现将子元素左上角移到父元素中心位置，然后再通过 margin-left 和 margin-top 以子元素自己的一半宽高进行负值赋值。该方法必须定宽高\n\n.father {\n  position: relative;\n}\n.son {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  width: 200px;\n  height: 200px;\n  margin-left: -100px;\n  margin-top: -100px;\n}\n\n\n 1. 利用 flex ，最经典最方便的一种了，不用解释，定不定宽高无所谓\n\n.father {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n\n\n# 左右居中\n\n * 行内元素: text-align: center\n\n * 定宽块状元素: 左右 margin 值为 auto\n\n * 不定宽块状元素: table布局，position + transform\n\n/* 方案1 */\n.wrap {\n  text-align: center\n}\n.center {\n  display: inline;\n  /* or */\n  /* display: inline-block; */\n}\n/* 方案2 */\n.center {\n  width: 100px;\n  margin: 0 auto;\n}\n/* 方案2 */\n.wrap {\n  position: relative;\n}\n.center {\n  position: absulote;\n  left: 50%;\n  transform: translateX(-50%);\n}\n\n\n\n# 上下垂直居中\n\n * 定高：margin，position + margin(负值)\n\n * 不定高：position + transform，flex，IFC + vertical-align:middle\n\n/* 定高方案1 */\n.center {\n  height: 100px;\n  margin: 50px 0;   \n}\n/* 定高方案2 */\n.center {\n  height: 100px;\n  position: absolute;\n  top: 50%;\n  margin-top: -25px;\n}\n/* 不定高方案1 */\n.center {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n/* 不定高方案2 */\n.wrap {\n  display: flex;\n  align-items: center;\n}\n.center {\n  width: 100%;\n}\n/* 不定高方案3 */\n/* 设置 inline-block 则会在外层产生 IFC，高度设为 100% 撑开 wrap 的高度 */\n.wrap::before {\n  content: '';\n  height: 100%;\n  display: inline-block;\n  vertical-align: middle;\n}\n.wrap {\n  text-align: center;\n}\n.center {\n  display: inline-block;  \n  vertical-align: middle;\n}\n\n\n\n# 5 选择器权重计算方式\n\n> !important > 内联样式 = 外联样式 > ID选择器 > 类选择器 = 伪类选择器 = 属性选择器 > 元素选择器 = 伪元素选择器 > 通配选择器 = 后代选择器 = 兄弟选择器\n\n 1. 属性后面加!import会覆盖页面内任何位置定义的元素样式\n 2. 作为style属性写在元素内的样式\n 3. id选择器\n 4. 类选择器\n 5. 标签选择器\n 6. 通配符选择器（*）\n 7. 浏览器自定义或继承\n\n同一级别：后写的会覆盖先写的\n\n> css选择器的解析原则：选择器定位DOM元素是从右往左的方向，这样可以尽早的过滤掉一些不必要的样式规则和元素\n\n\n# 6 清除浮动\n\n 1. 在浮动元素后面添加 clear:both的空 div 元素\n\n<div class=\"container\">\n    <div class=\"left\"></div>\n    <div class=\"right\"></div>\n    <div style=\"clear:both\"></div>\n</div>\n\n\n 1. 给父元素添加 overflow:hidden 或者 auto 样式，触发BFC\n\n<div class=\"container\">\n    <div class=\"left\"></div>\n    <div class=\"right\"></div>\n</div>\n\n\n.container{\n    width: 300px;\n    background-color: #aaa;\n    overflow:hidden;\n    zoom:1;   /*IE6*/\n}\n\n\n 1. 使用伪元素，也是在元素末尾添加一个点并带有 clear: both 属性的元素实现的。\n\n<div class=\"container clearfix\">\n    <div class=\"left\"></div>\n    <div class=\"right\"></div>\n</div>\n\n\n.clearfix{\n    zoom: 1; /*IE6*/\n}\n.clearfix:after{\n    content: \".\";\n    height: 0;\n    clear: both;\n    display: block;\n    visibility: hidden;\n}\n\n\n> 推荐使用第三种方法，不会在页面新增div，文档结构更加清晰\n\n\n# 7 link 与 @import 的区别\n\n * link功能较多，可以定义 RSS，定义 Rel 等作用，而@import只能用于加载 css\n\n * 当解析到link时，页面会同步加载所引的 css，而@import所引用的 css 会等到页面加载完才被加载\n\n * @import需要 IE5 以上才能使用\n\n * link可以使用 js 动态引入，@import不行\n\n\n# 8 CSS3的新特性\n\n * transition：过渡\n\n * transform: 旋转、缩放、移动或倾斜\n\n * animation: 动画\n\n * gradient: 渐变\n\n * box-shadow: 阴影\n\n * border-radius: 圆角\n\n * word-break: normal|break-all|keep-all; 文字换行(默认规则|单词也可以换行|只在半角空格或连字符换行)\n\n * text-overflow: 文字超出部分处理\n\n * text-shadow: 水平阴影，垂直阴影，模糊的距离，以及阴影的颜色。\n\n * box-sizing: content-box|border-box 盒模型\n\n * 媒体查询 @media screen and (max-width: 960px) {}还有打印print\n\ntransition和animation的区别\n\n> Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的\n\n\n# 9 CSS动画和过渡\n\n\n# animation / keyframes\n\n * animation-name: 动画名称，对应@keyframes\n\n * animation-duration: 间隔\n\n * animation-timing-function: 曲线\n\n * animation-delay: 延迟\n\n * animation-iteration-count: 次数\n   \n   * infinite: 循环动画\n\n * animation-direction: 方向\n   \n   * alternate: 反向播放\n\n * animation-fill-mode: 静止模式\n   \n   * forwards: 停止时，保留最后一帧\n   \n   * backwards: 停止时，回到第一帧\n   \n   * both: 同时运用 forwards / backwards\n\n * 常用钩子: animationend\n\n> 动画属性: 尽量使用动画属性进行动画，能拥有较好的性能表现\n\n * translate\n\n * scale\n\n * rotate\n\n * skew\n\n * opacity\n\n * color\n\n\n# transform\n\n * 位移属性 translate( x , y )\n * 旋转属性 rotate()\n * 缩放属性 scale()\n * 倾斜属性 skew()\n\n\n# transition\n\n * transition-property（过渡的属性的名称）。\n\n * transition-duration（定义过渡效果花费的时间,默认是 0）。\n\n * transition-timing-function:linear(匀速) ease(慢速开始，然后变快，然后慢速结束)（规定过渡效果的时间曲线，最常用的是这两个）。\n\n * transition-delay（规定过渡效果何时开始。默认是 0）\n\n> 般情况下，我们都是写一起的，比如：transition： width 2s ease 1s\n\n\n# 关键帧动画animation\n\n> 一个关键帧动画，最少包含两部分，animation 属性及属性值（动画的名称和运行方式运行时间等）。@keyframes（规定动画的具体实现过程）\n\nanimation 属性可以拆分为\n\n * animation-name 规定@keyframes 动画的名称。\n\n * animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。\n\n * animation-timing-function 规定动画的速度曲线。默认是 “ease”，常用的还有linear，同transtion 。\n\n * animation-delay 规定动画何时开始。默认是 0。\n\n * animation-iteration-count 规定动画被播放的次数。默认是 1，但我们一般用infinite，一直播放\n\n> 而@keyframes的使用方法，可以是from->to（等同于0%和100%），也可以是从0%->100%之间任意个的分层设置。我们通过下面一个稍微复杂点的demo来看一下，基本上用到了上面说到的大部分知识\n\neg:\n   @keyframes mymove\n  {\n      from {top:0px;}\n      to {top:200px;}\n  }\n \n等同于：\n \n@keyframes mymove\n{\n 0%   {top:0px;}\n 25%  {top:200px;}\n 50%  {top:100px;}\n 75%  {top:200px;}\n 100% {top:0px;}\n}\n\n\n\n# 用css3动画使一个图片旋转\n\n#loader {\n    display: block;\n    position: relative;\n    -webkit-animation: spin 2s linear infinite;\n    animation: spin 2s linear infinite;\n}\n\n@-webkit-keyframes spin {\n\n    0%   {\n        -webkit-transform: rotate(0deg);\n        -ms-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n\n    100% {\n        -webkit-transform: rotate(360deg);\n        -ms-transform: rotate(360deg);\n        transform: rotate(360deg);\n    }\n\n}\n\n@keyframes spin {\n\n    0%   {\n        -webkit-transform: rotate(0deg);\n        -ms-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n\n    100% {\n        -webkit-transform: rotate(360deg);\n        -ms-transform: rotate(360deg);\n        transform: rotate(360deg);\n    }\n\n}\n \n\n\n\n# 10 有哪些方式（CSS）可以隐藏页面元素\n\n * opacity:0：本质上是将元素的透明度将为0，就看起来隐藏了，但是依然占据空间且可以交互\n\n * visibility:hidden: 与上一个方法类似的效果，占据空间，但是不可以交互了\n\n * overflow:hidden: 这个只隐藏元素溢出的部分，但是占据空间且不可交互\n\n * display:none: 这个是彻底隐藏了元素，元素从文档流中消失，既不占据空间也不交互，也不影响布局\n\n * z-index:-9999: 原理是将层级放到底部，这样就被覆盖了，看起来隐藏了\n\n * transform: scale(0,0): 平面变换，将元素缩放为0，但是依然占据空间，但不可交互\n\n\n# 11 em、px、rem区别\n\n * px：绝对单位，页面按精确像素展示。\n\n * em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。\n\n * rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持\n\n\n# 12 flex布局\n\n很多时候我们会用到 flex: 1 ，它具体包含了以下的意思\n\n * flex-grow: 1 ：该属性默认为 0 ，如果存在剩余空间，元素也不放大。设置为 1 代表会放大。\n\n * flex-shrink: 1 ：该属性默认为 `1 ，如果空间不足，元素缩小。\n\n * flex-basis: 0% ：该属性定义在分配多余空间之前，元素占据的主轴空间。浏览器就是根据这个属性来计算是否有多余空间的。默认值为 auto ，即项目本身大小。设置为 0% 之后，因为有 flex-grow 和 flex-shrink 的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 flex-basis 设为auto 的话，其本身大小将会是 0\n\n\n# 13 关于伪类 LVHA 的解释\n\n> a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；\n\n当链接未访问过时：\n\n * 当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪 类后面声明；\n * 当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active）， 必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。\n * 当链接访问过时，情况基本同上，只不过需要将:link换成:visited。\n\n> 这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。\n\n\n# 14 calc函数\n\n> calc函数是css3新增的功能，可以使用calc()计算border、margin、pading、font-size和width等属性设置动态值\n\n#div1 {\n    position: absolute;\n    left: 50px;\n    width: calc( 100% / (100px * 2) );\n    /* 兼容写法 */\n    width: -moz-calc( 100% / (100px * 2) );\n    width: -webkit-calc( 100% / (100px * 2) );\n    border: 1px solid black;\n}\n\n\n注意点：\n\n * 需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px);\n\n * calc()函数支持 \"+\", \"-\", \"*\", \"/\" 运算;\n\n * 对于不支持 calc()的浏览器，整个属性值表达式将被忽略。不过我们可以对那些不支持calc()的浏览器，使用一个固定值作为回退。\n\n\n# 15 伪类和伪元素\n\n> css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素都是用来修饰不在文档树中的部分\n\n伪类\n\n> 伪类存在的意义是为了通过选择器找到那些不存在DOM树中的信息以及不能被常规CSS选择器获取到的信息\n\n 1. 获取不存在与DOM树中的信息。比如a标签的:link、visited等，这些信息不存在与DOM树结构中，只能通过CSS选择器来获取；\n\n 2. 获取不能被常规CSS选择器获取的信息。比如：要获取第一个子元素，我们无法用常规的CSS选择器获取，但可以通过 :first-child 来获取到。\n\n伪元素\n\n> 伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：::before，::after，::first-line，::first-letter，::selection、::placeholder等\n\n> 因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素\n\n::after和:after的区别\n\n * 在实际的开发工作中，我们会看到有人把伪元素写成:after，这实际是 CSS2 与CSS3新旧标准的规定不同而导致的。\n\n * CSS2 中的伪元素使用1个冒号，在 CSS3 中，为了区分伪类和伪元素，规定伪元素使用2个冒号。所以，对于 CSS2 标准的老伪元素，比如:first-line，:first-letter，:before，:after，写一个冒号浏览器也能识别，但对于 CSS3 标准的新伪元素，比如::selection，就必须写2个冒号了\n\nCSS3新增伪类有那些？\n\n * p:first-of-type 选择属于其父元素的首个<p>元素的每个<p> 元素。\n\n * p:last-of-type 选择属于其父元素的最后 <p> 元素的每个<p> 元素。\n\n * p:only-of-type 选择属于其父元素唯一的 <p>元素的每个 <p> 元素。\n\n * p:only-child 选择属于其父元素的唯一子元素的每个 <p> 元素。\n\n * p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n * :after 在元素之前添加内容,也可以用来做清除浮动。\n\n * :before 在元素之后添加内容\n\n * :enabled\n\n * :disabled 控制表单控件的禁用状态。\n\n * :checked 单选框或复选框被选中\n\n\n# 16 浏览器是怎样解析 CSS 选择器的\n\n * 样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。\n * 试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能， 最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。\n\n\n# 17 浏览器如何判断是否支持 webp 格式图片\n\n * 宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如 果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格 式的图片\n\n * canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断 返回值中是否含有image/webp字段，如果包含则说明支持WebP，反之则不支持\n\n\n# 18 CSS加载问题\n\n根据页面渲染流程可得知：\n\n * css加载不会阻塞DOM树的解析;\n\n * css加载会阻塞DOM树的渲染；\n\n * css加载会阻塞后面js语句的执行\n\n\n# 19 文字单超出显示省略号\n\ndiv {\n\twidth: 200px;\n\toverflow: hidden;\n\twhite-space: nowrap;\n\ttext-overflow: ellipsis;\n}\n\n\n文字多行超出显示省略号\n\ndiv {\n\twidth: 200px;\n\tdisplay: -webkit-box;\n\t-webkit-box-orient: vertical;\n\t-webkit-line-clamp: 3;\n\toverflow: hidden;\n}\n\n\n该方法适用于WebKit浏览器及移动端。\n\n跨浏览器兼容方案：\n\np {\n    position:relative;\n    line-height:1.4em;\n    /* 3 times the line-height to show 3 lines */\n    height:4.2em;\n    overflow:hidden;\n}\np::after {\n    content:\"...\";\n    font-weight:bold;\n    position:absolute;\n    bottom:0;\n    right:0;\n    padding:0 20px 1px 45px;\n}\n\n\n\n# 20 页面变灰\n\nbody {\n\tfilter: grayscale(100%); /* 百分比或者 0~1 */\n}\n\n\n\n# 21 CSS中可继承的属性\n\n> 可继承的只有：颜色、文字、字体间距、行高对齐方式，列表样式。\n\n所有元素可继承：visibility和cursor。\n\n * 内联元素可继承：\n   \n   * letter-spacing\n   * word-spacing\n   * white-space\n   * line-height\n   * color\n   * font\n   * font-family\n   * font-size\n   * font-style\n   * font-variant\n   * font-weight\n   * text-decoration\n   * text-transform\n   * direction\n\n * 块状：text-indent和text-align。\n\n * 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image\n\n\n# 22 常规流(文档流)是个怎样的排列关系\n\n将窗体自上而下分成一行一行,并在每行中按从左至右的挨次排放元素。\n\n\n# 23 inline-block的使用场景\n\n 1. 要设置某些子元素在一行或者多行内显示，尤其是排列方向一致的情况下，应尽量用inline-block。\n\n 2. 希望若干个元素平行排列，且在父元素中居中排列，此时可以用inline-block，且给父元素设text-align: center。\n\n 3. inline-block可以用一排a {display: inline-block}实现横向导航栏，无论是居左的导航栏还是居右的都适用。\n\n对于第一种和第三种情况虽然都可以使用float来实现，不过inline-block会比它好一些，原因如下：\n\n * 浮动会脱离文档流，导致父元素高度塌陷\n\n\n# 24 position: fixed什么时候会失效？\n\n我们知道，设置了position: fixed固定定位属性的元素会脱离文档流，达到“超然脱俗”的境界。\n\n> 也就是说此时给这种元素设置top, left, right, bottom等属性是根据浏览器窗口定位的，与其上级元素的位置无关。\n\n但是有一种情况例外：\n\n * 若是设置了position: fixed属性的元素，它的祖先元素设置了transform属性则会导致固定定位属性失效。\n\n * 只要你的transform设置的不是none，都会影响到position: fixed，因为此时就会相对于祖先元素指定坐标，而不是浏览器窗口。\n\n注意，这个特性表现，目前只在Chrome浏览器/FireFox浏览器下有。IE浏览器，包括IE11, fixed还是fixed的表现。\n\n\n# 25 回流（reflow）和重绘（repaint）的理解\n\n回流：\n\n> 无论通过什么方式影响了元素的几何信息(元素在视口内的位置和尺寸大小)，浏览器需要重新计算元素在视口内的几何属性，这个过程叫做回流\n\n触发条件：当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生回流的过程。\n\n例如以下操作会触发回流：\n\n1.一个 DOM 元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border 等等, 这个很好理解 2. 使 DOM 节点发生增减或者移动 3. 读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作 4. 调用 window.getComputedStyle 方法\n\n> 回流过程：由于DOM的结构发生了改变，所以需要从生成DOM这一步开始，重新经过样式计算、生成布局树、建立图层树、再到生成绘制列表以及之后的显示器显示这整一个渲染过程走一遍，开销是非常大的\n\n重绘：\n\n> 通过构造渲染树和重排（回流）阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(元素在视口内的位置和尺寸大小)，接下来就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘\n\n触发条件：\n\n * 当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致重绘(repaint)。\n\n * 重绘过程：由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，所以当发生重绘的时候，会跳过生存布局树和建立图层树的阶段，直接到生成绘制列表，然后继续进行分块、生成位图等后面一系列操作。\n\n如何避免触发回流和重绘：\n\n 1. 避免频繁使用 style，而是采用修改class的方式。\n\n 2. 将动画效果应用到position属性为absolute或fixed的元素上。\n\n 3. 批量操作 DOM，比如读取某元素 offsetWidth 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 document.createDocumentFragment() 来添加要被添加的节点，处理完之后再插入到实际 DOM 中\n\n 4. 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘\n\n 5. 对于 resize、scroll 等进行防抖/节流处理。\n\n 6. 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。\n\n 7. 利用 CSS3 的transform、opacity、filter这些属性可以实现合成的效果，也就是CPU加速。\n\n\n# 26 GPU加速的原因\n\n> 在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理。交给它处理有两大好处:\n\n 1. 能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成，而 GPU 是擅长处理位图数据的。\n 2. 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。\n\n\n# 27 说说will-change\n\n> will-change是CSS3新增的标准属性，它的作用很单纯，就是\"增强页面渲染性能\"，当我们在通过某些行为触发页面进行大面积绘制的时候，浏览器往往是没有准备，只能被动的使用CUP去计算和重绘，由于事先没有准备，对于一些复杂的渲染可能会出现掉帧、卡顿等情况。而will-change则是在真正的行为触发之前告诉浏览器可能要进行重绘了，相当于浏览器把CUP拉上了，能从容的面对接下来的变形。\n\n常用的语法主要有：\n\n * whil-change: scroll-position; 即将开始滚动\n\n * will-change: contents; 内容要动画或者变化了\n\n * will-transform; transform相关的属性要变化了(常用)\n\n注意：\n\n * will-change虽然可以开启加速，但是一定要适度使用\n\n * 开启加速的代价为手机的耗电量会增加\n\n * 使用时遵循最小化影响原则，可以对伪元素开启加速，独立渲染\n\n * 可以写在伪类中，例如hover中，这样移出元素的时候就会自动remove掉will-change了\n\n * 如果使用JS添加了will-change，注意要及时remove掉，方式就是style.willChange = 'auto'\n\n\n# 28 z-index和background的覆盖关系\n\n\n\n\n# 29 移动端中css你是使用什么单位\n\n比较常用的：\n\n * em：定义字体大小时以父级的字体大小为基准；定义长度单位时以当前字体大小为基准。例父级font-size: 14px，则子级font-size: 1em;为font-size: 14px;；若定义长度时，子级的字体大小如果为14px，则子级width: 2em;为width: 24px。\n\n * rem：以根元素的字体大小为基准。例如html的font-size: 14px，则子级1rem = 14px。\n\n * %：以父级的宽度为基准。例父级width: 200px，则子级width: 50%;height:50%;为width: 100px;height: 100px;\n\n * vw和vh：基于视口的宽度和高度(视口不包括浏览器的地址栏工具栏和状态栏)。例如视口宽度为1000px，则60vw = 600px;\n\n * vmin和vmax：vmin为当前vw 和vh中较小的一个值；vmax为较大的一个值。例如视口宽度375px，视口高度812px，则100vmin = 375px;，100vmax = 812px;\n\n不常用的：\n\n * ex和ch：ex以字符\"x\"的高度为基准；例如1ex表示和字符\"x\"一样长。ch以数字\"0\"的宽度为基准；例如2ch表示和2个数字\"0\"一样长。\n\n移动端布局总结：\n\n 1. 移动端布局的方式主要使用rem和flex，可以结合各自的优点，比如flex布局很灵活，但是字体的大小不好控制，我们可以使用rem和媒体查询控制字体的大小，媒体查询视口的大小，然后不同的上视口大小下设置设置html的font-size。\n\n 2. 可单独制作移动端页面也可响应式pc端移动端共用一个页面。没有好坏，视情况而定，因势利导\n\n\n# 30 rem和em的区别\n\nem:\n\n> 定义字体大小时以父级的字体大小为基准；定义长度单位时以当前字体大小为基准。例父级font-size: 14px，则子级font-size: 1em;为font-size: 14px;；若定义长度时，子级的字体大小如果为14px，则子级width: 2em;为width: 24px。\n\nrem:\n\n以根元素的字体大小为基准。例如html的font-size: 14px，则子级1rem = 14px。\n\n\n# 31 在移动端中怎样初始化根元素的字体大小\n\n一个简易版的初始化根元素字体大小。\n\n页面开头处引入下面这段代码，用于动态计算font-size：\n\n(假设你需要的1rem = 20px)\n\n(function () {\n  var html = document.documentElement;\n  function onWindowResize() {\n    html.style.fontSize = html.getBoundingClientRect().width / 20 + 'px';\n  }\n  window.addEventListener('resize', onWindowResize);\n  onWindowResize();\n})();\n\n\n * document.documentElement：获取document的根元素\n\n * html.getBoundingClientRect().width：获取html的宽度(窗口的宽度)\n\n * 监听window的resize事件\n\n一般还需要配合一个meta头：\n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-sacle=1.0, maximum-scale=1.0, user-scalable=no\" />\n\n\n\n# 32 移动端中不同手机html默认的字体大小都是一样的吗\n\n> 如果没有人为取改变根元素字体大小的话，默认是1rem = 16px；根元素默认的字体大小是16px。\n\n\n# 33 line-height 如何继承\n\n * 父元素的 line-height 写了具体数值，比如 30px，则子元素 line-height 继承该值。\n\n * 父元素的 line-height 写了比例，比如 1.5或 2，则子元素 line-height 也是继承该比例。\n\n * 父元素的 line-height 写了百分比，比如 200%，则子元素 line-height 继承的是父元素 font-size * 200% 计算出来的值\n\n\n# 34 css 怎么开启硬件加速(GPU 加速)\n\n浏览器在处理下面的 css 的时候，会使用 GPU 渲染\n\n * transform（当 3D 变换的样式出现时会使用 GPU 加速）\n\n * opacity\n\n * filter\n\n * will-change\n\n * 采用 transform: translateZ(0)\n\n * 采用 transform: translate3d(0, 0, 0)\n\n * 使用 CSS 的 will-change属性。 will-change 可以设置为opacity、transform、top、left、bottom、right`\n\n注意！层爆炸，由于某些原因可能导致产生大量不在预期内的合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象（简单理解就是，很多不需要提升为合成层的元素因为某些不当操作成为了合成层）。解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。简单直接的方式：使用 3D 硬件加速提升动画性能时，最好给元素增加一个 z-index 属性，人为干扰合成的排序，可以有效减少创建不必要的合成层，提升渲染性能，移动端优化效果尤为明显。\n\n\n# 35 flex:1 是哪些属性组成的\n\n * flex 实际上是 flex-grow、flex-shrink 和 flex-basis 三个属性的缩写。\n\n * flex-grow：定义项目的的放大比例；\n   \n   * 默认为0，即 即使存在剩余空间，也不会放大；\n   \n   * 所有项目的flex-grow为1：等分剩余空间（自动放大占位）；\n   \n   * flex-grow为n的项目，占据的空间（放大的比例）是flex-grow为1的n倍\n\n * flex-shrink：定义项目的缩小比例；\n   \n   * 默认为1，即 如果空间不足，该项目将缩小；\n   \n   * 所有项目的flex-shrink为1：当空间不足时，缩小的比例相同；\n   \n   * flex-shrink为0：空间不足时，该项目不会缩小；\n   \n   * flex-shrink为n的项目，空间不足时缩小的比例是flex-shrink为1的n倍。\n\n * flex-basis：定义在分配多余空间之前，项目占据的主轴空间（main size），浏览器根据此属性计算主轴是否有多余空间\n   \n   * 默认值为auto，即 项目原本大小；\n   \n   * 设置后项目将占据固定空间。\n\n\n# 36 编程题\n\n\n# 画一条 0.5px 的线\n\n * 采用 meta viewport 的方式 <meta name=\"viewport\" content=\"initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" />\n\n * 采用 border-image 的方式\n\n * 采用 transform: scale() 的方式\n\n\n# 如何画一个三角形\n\n三角形原理:边框的均分原理\n\ndiv {\n  width:0px;\n  height:0px;\n  border-top:10px solid red; \n  border-right:10px solid transparent; \n  border-bottom:10px solid transparent; \n  border-left:10px solid transparent;\n}\n\n\n\n# 圆？半圆？椭圆？\n\ndiv {\n  width: 100px;\n  height: 100px;\n  background-color: red;\n  margin-top: 20px;\n}\n.box1 { /* 圆 */\n  /* border-radius: 50%; */\n  border-radius: 50px;\n}\n.box2 { /* 半圆 */\n  height: 50px;\n  border-radius: 50px 50px 0 0;\n}\n.box3 { /* 椭圆 */\n  height: 50px;\n  border-radius: 50px/25px; /* x轴/y轴 */\n}\n\n\n\n# 左边定宽，右边自适应方案\n\n> float + margin，float + calc\n\n/* 方案1 */ \n.left {\n  width: 120px;\n  float: left;\n}\n.right {\n  margin-left: 120px;\n}\n/* 方案2 */ \n.left {\n  width: 120px;\n  float: left;\n}\n.right {\n  width: calc(100% - 120px);\n  float: left;\n}\n\n\n\n# 左右两边定宽，中间自适应\n\n> float，float + calc, 圣杯布局（设置BFC，margin负值法），flex\n\n.wrap {\n  width: 100%;\n  height: 200px;\n}\n.wrap > div {\n  height: 100%;\n}\n/* 方案1 */\n.left {\n  width: 120px;\n  float: left;\n}\n.right {\n  float: right;\n  width: 120px;\n}\n.center {\n  margin: 0 120px; \n}\n/* 方案2 */\n.left {\n  width: 120px;\n  float: left;\n}\n.right {\n  float: right;\n  width: 120px;\n}\n.center {\n  width: calc(100% - 240px);\n  margin-left: 120px;\n}\n/* 方案3 */\n.wrap {\n  display: flex;\n}\n.left {\n  width: 120px;\n}\n.right {\n  width: 120px;\n}\n.center {\n  flex: 1;\n}\n\n\n\n# 如何实现左侧宽度固定，右侧宽度自适应的布局\n\n<div class=\"box\">\n  <div class=\"box-left\"></div>\n  <div class=\"box-right\"></div>\n</div>\n\n\n\n# 利用float + margin实现\n\n.box {\n height: 200px;\n}\n\n.box > div {\n  height: 100%;\n}\n\n.box-left {\n  width: 200px;\n  float: left;\n  background-color: blue;\n}\n\n.box-right {\n  margin-left: 200px;\n  background-color: red;\n}\n\n\n利用calc计算宽度\n\n.box {\n height: 200px;\n}\n\n.box > div {\n  height: 100%;\n}\n\n.box-left {\n  width: 200px;\n  float: left;\n  background-color: blue;\n}\n\n.box-right {\n  width: calc(100% - 200px);\n  float: right;\n  background-color: red;\n}\n\n\n利用float + overflow实现\n\n.box {\n height: 200px;\n}\n\n.box > div {\n  height: 100%;\n}\n\n.box-left {\n  width: 200px;\n  float: left;\n  background-color: blue;\n}\n\n.box-right {\n  overflow: hidden;\n  background-color: red;\n}\n\n\n利用flex实现\n\n.box {\n  height: 200px;\n  display: flex;\n}\n\n.box > div {\n  height: 100%;\n}\n\n.box-left {\n  width: 200px;\n  background-color: blue;\n}\n\n.box-right {\n  flex: 1; // 设置flex-grow属性为1，默认为0\n  overflow: hidden;\n  background-color: red;\n}\n\n\n\n# 两边宽度固定中间自适应的三栏布局\n\n> 圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。\n\n圣杯布局\n\n<style>\nbody{\n    min-width: 550px;\n}\n#container{\n    padding-left: 200px;\n    padding-right: 150px;\n}\n#container .column{\n    float: left;\n}\n#center{\n    width: 100%;\n}\n#left{\n    width: 200px;\n    margin-left: -100%;\n    position: relative;\n    right: 200px;\n}\n#right{\n    width: 150px;\n    margin-right: -150px;\n}\n</style>\n<div id=\"container\">\n    <div id=\"center\" class=\"column\">center</div>\n    <div id=\"left\" class=\"column\">left</div>\n    <div id=\"right\" class=\"column\">right</div>\n</div>\n\n\n双飞翼布局\n\n<style>\nbody {\n    min-width: 500px;\n}\n#container {\n    width: 100%;\n}\n.column {\n    float: left;\n}\n#center {\n    margin-left: 200px;\n    margin-right: 150px;\n}\n#left {\n    width: 200px;\n    margin-left: -100%;\n}\n#right {\n    width: 150px;\n    margin-left: -150px;\n}\n</style>\n<div id=\"container\" class=\"column\">\n    <div id=\"center\">center</div>\n</div>\n<div id=\"left\" class=\"column\">left</div>\n<div id=\"right\" class=\"column\">right</div>\n\n\n\n# CSS画圆半圆扇形三角梯形\n\ndiv{\n    margin: 50px;\n    width: 100px;\n    height: 100px;\n    background: red;\n}\n/* 半圆 */\n.half-circle{\n    height: 50px;\n    border-radius: 50px 50px 0 0;\n}\n/* 扇形 */\n.sector{\n    border-radius: 100px 0 0;\n}\n/* 三角 */\n.triangle{\n    width: 0px;\n    height: 0px;\n    background: none;\n    border: 50px solid red;\n    border-color: red transparent transparent transparent;\n}\n/* 梯形 */\n.ladder{\n    width: 50px;\n    height: 0px;\n    background: none;\n    border: 50px solid red;\n    border-color: red transparent transparent transparent;\n}\n",
      "normalizedContent": "# 1 盒模型\n\n * 有两种， ie盒子模型、w3c盒子模型；\n\n * 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；\n\n * 区 别： ie的content部分把 border 和 padding计算了进去;\n\n * 盒子模型构成：内容(content)、内填充(padding)、 边框(border)、外边距(margin)\n\n * ie8及其以下版本浏览器，未声明 doctype，内容宽高会包含内填充和边框，称为怪异盒模型(ie盒模型)\n\n * 标准(w3c)盒模型：元素宽度 = width + padding + border + margin\n\n * 怪异(ie)盒模型：元素宽度 = width + margin\n\n * 标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高\n\n> 页面渲染时，dom 元素所采用的 布局模型。可通过box-sizing进行设置\n\n通过 box-sizing 来改变元素的盒模型\n\n * box-sizing: content-box; 默认的标准(w3c)盒模型元素效果\n\n * box-sizing: border-box; 触发怪异(ie)盒模型元素的效果\n\n * box-sizing: inherit; 继承父元素 box-sizing 属性的值\n\n\n# 2 bfc\n\n> 块级格式化上下文，是一个独立的渲染区域，让处于 bfc 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。 ie下为 layout，可通过 zoom:1 触发\n\n触发条件:\n\n * 绝对定位元素 position: absolute/fixed\n\n * 行内块元素 display: inline-block / table\n\n * float 元素\n\n * ovevflow !== visible\n\n规则:\n\n 1. 属于同一个 bfc 的两个相邻 box 垂直排列\n\n 2. 属于同一个 bfc 的两个相邻 box 的 margin 会发生重叠\n\n 3. bfc 中子元素的 margin box 的左边， 与包含块 (bfc) border box的左边相接触 (子元素 absolute 除外)\n\n 4. bfc 的区域不会与 float 的元素区域重叠\n\n 5. 计算 bfc 的高度时，浮动子元素也参与计算\n\n 6. 文字层不会被浮动层覆盖，环绕于周围\n\n应用:\n\n * 利用2：阻止margin重叠\n\n * 利用4：自适应两栏布局\n\n * 利用 5 ，可以避免高度塌陷\n\n * 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个div都位于同一个 bfc 区域之中)\n\n\n# 3 层叠上下文\n\n> 元素提升为一个比较特殊的图层，在三维空间中 (z轴) 高出普通元素一等。\n\n触发条件\n\n * 根层叠上下文(html)\n\n * position\n\n * css3属性\n   \n   * flex\n   \n   * transform\n   \n   * opacity\n   \n   * filter\n   \n   * will-change\n   \n   * webkit-overflow-scrolling\n\n层叠等级：层叠上下文在z轴上的排序\n\n * 在同一层叠上下文中，层叠等级才有意义\n * z-index的优先级最高\n\n\n\n\n# 4 居中布局\n\n\n# 水平垂直居中多种实现方式\n\n 1. 利用绝对定位，设置 left: 50% 和 top: 50% 现将子元素左上角移到父元素中心位置，然后再通过 translate 来调整子元素的中心点到父元素的中心。该方法可以不定宽高\n\n.father {\n  position: relative;\n}\n.son {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n}\n\n\n 1. 利用绝对定位，子元素所有方向都为 0 ，将 margin 设置为 auto ，由于宽高固定，对应方向实现平分，该方法必须盒子有宽高\n\n.father {\n  position: relative;\n}\n.son {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0px;\n  margin: auto;\n  height: 100px;\n  width: 100px;\n}\n\n\n 1. 利用绝对定位，设置 left: 50% 和 top: 50% 现将子元素左上角移到父元素中心位置，然后再通过 margin-left 和 margin-top 以子元素自己的一半宽高进行负值赋值。该方法必须定宽高\n\n.father {\n  position: relative;\n}\n.son {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  width: 200px;\n  height: 200px;\n  margin-left: -100px;\n  margin-top: -100px;\n}\n\n\n 1. 利用 flex ，最经典最方便的一种了，不用解释，定不定宽高无所谓\n\n.father {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n\n\n# 左右居中\n\n * 行内元素: text-align: center\n\n * 定宽块状元素: 左右 margin 值为 auto\n\n * 不定宽块状元素: table布局，position + transform\n\n/* 方案1 */\n.wrap {\n  text-align: center\n}\n.center {\n  display: inline;\n  /* or */\n  /* display: inline-block; */\n}\n/* 方案2 */\n.center {\n  width: 100px;\n  margin: 0 auto;\n}\n/* 方案2 */\n.wrap {\n  position: relative;\n}\n.center {\n  position: absulote;\n  left: 50%;\n  transform: translatex(-50%);\n}\n\n\n\n# 上下垂直居中\n\n * 定高：margin，position + margin(负值)\n\n * 不定高：position + transform，flex，ifc + vertical-align:middle\n\n/* 定高方案1 */\n.center {\n  height: 100px;\n  margin: 50px 0;   \n}\n/* 定高方案2 */\n.center {\n  height: 100px;\n  position: absolute;\n  top: 50%;\n  margin-top: -25px;\n}\n/* 不定高方案1 */\n.center {\n  position: absolute;\n  top: 50%;\n  transform: translatey(-50%);\n}\n/* 不定高方案2 */\n.wrap {\n  display: flex;\n  align-items: center;\n}\n.center {\n  width: 100%;\n}\n/* 不定高方案3 */\n/* 设置 inline-block 则会在外层产生 ifc，高度设为 100% 撑开 wrap 的高度 */\n.wrap::before {\n  content: '';\n  height: 100%;\n  display: inline-block;\n  vertical-align: middle;\n}\n.wrap {\n  text-align: center;\n}\n.center {\n  display: inline-block;  \n  vertical-align: middle;\n}\n\n\n\n# 5 选择器权重计算方式\n\n> !important > 内联样式 = 外联样式 > id选择器 > 类选择器 = 伪类选择器 = 属性选择器 > 元素选择器 = 伪元素选择器 > 通配选择器 = 后代选择器 = 兄弟选择器\n\n 1. 属性后面加!import会覆盖页面内任何位置定义的元素样式\n 2. 作为style属性写在元素内的样式\n 3. id选择器\n 4. 类选择器\n 5. 标签选择器\n 6. 通配符选择器（*）\n 7. 浏览器自定义或继承\n\n同一级别：后写的会覆盖先写的\n\n> css选择器的解析原则：选择器定位dom元素是从右往左的方向，这样可以尽早的过滤掉一些不必要的样式规则和元素\n\n\n# 6 清除浮动\n\n 1. 在浮动元素后面添加 clear:both的空 div 元素\n\n<div class=\"container\">\n    <div class=\"left\"></div>\n    <div class=\"right\"></div>\n    <div style=\"clear:both\"></div>\n</div>\n\n\n 1. 给父元素添加 overflow:hidden 或者 auto 样式，触发bfc\n\n<div class=\"container\">\n    <div class=\"left\"></div>\n    <div class=\"right\"></div>\n</div>\n\n\n.container{\n    width: 300px;\n    background-color: #aaa;\n    overflow:hidden;\n    zoom:1;   /*ie6*/\n}\n\n\n 1. 使用伪元素，也是在元素末尾添加一个点并带有 clear: both 属性的元素实现的。\n\n<div class=\"container clearfix\">\n    <div class=\"left\"></div>\n    <div class=\"right\"></div>\n</div>\n\n\n.clearfix{\n    zoom: 1; /*ie6*/\n}\n.clearfix:after{\n    content: \".\";\n    height: 0;\n    clear: both;\n    display: block;\n    visibility: hidden;\n}\n\n\n> 推荐使用第三种方法，不会在页面新增div，文档结构更加清晰\n\n\n# 7 link 与 @import 的区别\n\n * link功能较多，可以定义 rss，定义 rel 等作用，而@import只能用于加载 css\n\n * 当解析到link时，页面会同步加载所引的 css，而@import所引用的 css 会等到页面加载完才被加载\n\n * @import需要 ie5 以上才能使用\n\n * link可以使用 js 动态引入，@import不行\n\n\n# 8 css3的新特性\n\n * transition：过渡\n\n * transform: 旋转、缩放、移动或倾斜\n\n * animation: 动画\n\n * gradient: 渐变\n\n * box-shadow: 阴影\n\n * border-radius: 圆角\n\n * word-break: normal|break-all|keep-all; 文字换行(默认规则|单词也可以换行|只在半角空格或连字符换行)\n\n * text-overflow: 文字超出部分处理\n\n * text-shadow: 水平阴影，垂直阴影，模糊的距离，以及阴影的颜色。\n\n * box-sizing: content-box|border-box 盒模型\n\n * 媒体查询 @media screen and (max-width: 960px) {}还有打印print\n\ntransition和animation的区别\n\n> animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的\n\n\n# 9 css动画和过渡\n\n\n# animation / keyframes\n\n * animation-name: 动画名称，对应@keyframes\n\n * animation-duration: 间隔\n\n * animation-timing-function: 曲线\n\n * animation-delay: 延迟\n\n * animation-iteration-count: 次数\n   \n   * infinite: 循环动画\n\n * animation-direction: 方向\n   \n   * alternate: 反向播放\n\n * animation-fill-mode: 静止模式\n   \n   * forwards: 停止时，保留最后一帧\n   \n   * backwards: 停止时，回到第一帧\n   \n   * both: 同时运用 forwards / backwards\n\n * 常用钩子: animationend\n\n> 动画属性: 尽量使用动画属性进行动画，能拥有较好的性能表现\n\n * translate\n\n * scale\n\n * rotate\n\n * skew\n\n * opacity\n\n * color\n\n\n# transform\n\n * 位移属性 translate( x , y )\n * 旋转属性 rotate()\n * 缩放属性 scale()\n * 倾斜属性 skew()\n\n\n# transition\n\n * transition-property（过渡的属性的名称）。\n\n * transition-duration（定义过渡效果花费的时间,默认是 0）。\n\n * transition-timing-function:linear(匀速) ease(慢速开始，然后变快，然后慢速结束)（规定过渡效果的时间曲线，最常用的是这两个）。\n\n * transition-delay（规定过渡效果何时开始。默认是 0）\n\n> 般情况下，我们都是写一起的，比如：transition： width 2s ease 1s\n\n\n# 关键帧动画animation\n\n> 一个关键帧动画，最少包含两部分，animation 属性及属性值（动画的名称和运行方式运行时间等）。@keyframes（规定动画的具体实现过程）\n\nanimation 属性可以拆分为\n\n * animation-name 规定@keyframes 动画的名称。\n\n * animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。\n\n * animation-timing-function 规定动画的速度曲线。默认是 “ease”，常用的还有linear，同transtion 。\n\n * animation-delay 规定动画何时开始。默认是 0。\n\n * animation-iteration-count 规定动画被播放的次数。默认是 1，但我们一般用infinite，一直播放\n\n> 而@keyframes的使用方法，可以是from->to（等同于0%和100%），也可以是从0%->100%之间任意个的分层设置。我们通过下面一个稍微复杂点的demo来看一下，基本上用到了上面说到的大部分知识\n\neg:\n   @keyframes mymove\n  {\n      from {top:0px;}\n      to {top:200px;}\n  }\n \n等同于：\n \n@keyframes mymove\n{\n 0%   {top:0px;}\n 25%  {top:200px;}\n 50%  {top:100px;}\n 75%  {top:200px;}\n 100% {top:0px;}\n}\n\n\n\n# 用css3动画使一个图片旋转\n\n#loader {\n    display: block;\n    position: relative;\n    -webkit-animation: spin 2s linear infinite;\n    animation: spin 2s linear infinite;\n}\n\n@-webkit-keyframes spin {\n\n    0%   {\n        -webkit-transform: rotate(0deg);\n        -ms-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n\n    100% {\n        -webkit-transform: rotate(360deg);\n        -ms-transform: rotate(360deg);\n        transform: rotate(360deg);\n    }\n\n}\n\n@keyframes spin {\n\n    0%   {\n        -webkit-transform: rotate(0deg);\n        -ms-transform: rotate(0deg);\n        transform: rotate(0deg);\n    }\n\n    100% {\n        -webkit-transform: rotate(360deg);\n        -ms-transform: rotate(360deg);\n        transform: rotate(360deg);\n    }\n\n}\n \n\n\n\n# 10 有哪些方式（css）可以隐藏页面元素\n\n * opacity:0：本质上是将元素的透明度将为0，就看起来隐藏了，但是依然占据空间且可以交互\n\n * visibility:hidden: 与上一个方法类似的效果，占据空间，但是不可以交互了\n\n * overflow:hidden: 这个只隐藏元素溢出的部分，但是占据空间且不可交互\n\n * display:none: 这个是彻底隐藏了元素，元素从文档流中消失，既不占据空间也不交互，也不影响布局\n\n * z-index:-9999: 原理是将层级放到底部，这样就被覆盖了，看起来隐藏了\n\n * transform: scale(0,0): 平面变换，将元素缩放为0，但是依然占据空间，但不可交互\n\n\n# 11 em、px、rem区别\n\n * px：绝对单位，页面按精确像素展示。\n\n * em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。\n\n * rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，css3新加属性，chrome/firefox/ie9+支持\n\n\n# 12 flex布局\n\n很多时候我们会用到 flex: 1 ，它具体包含了以下的意思\n\n * flex-grow: 1 ：该属性默认为 0 ，如果存在剩余空间，元素也不放大。设置为 1 代表会放大。\n\n * flex-shrink: 1 ：该属性默认为 `1 ，如果空间不足，元素缩小。\n\n * flex-basis: 0% ：该属性定义在分配多余空间之前，元素占据的主轴空间。浏览器就是根据这个属性来计算是否有多余空间的。默认值为 auto ，即项目本身大小。设置为 0% 之后，因为有 flex-grow 和 flex-shrink 的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 flex-basis 设为auto 的话，其本身大小将会是 0\n\n\n# 13 关于伪类 lvha 的解释\n\n> a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；\n\n当链接未访问过时：\n\n * 当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪 类后面声明；\n * 当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active）， 必须将:active声明放到:link和:hover之后。因此得出lvha这个顺序。\n * 当链接访问过时，情况基本同上，只不过需要将:link换成:visited。\n\n> 这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。\n\n\n# 14 calc函数\n\n> calc函数是css3新增的功能，可以使用calc()计算border、margin、pading、font-size和width等属性设置动态值\n\n#div1 {\n    position: absolute;\n    left: 50px;\n    width: calc( 100% / (100px * 2) );\n    /* 兼容写法 */\n    width: -moz-calc( 100% / (100px * 2) );\n    width: -webkit-calc( 100% / (100px * 2) );\n    border: 1px solid black;\n}\n\n\n注意点：\n\n * 需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px);\n\n * calc()函数支持 \"+\", \"-\", \"*\", \"/\" 运算;\n\n * 对于不支持 calc()的浏览器，整个属性值表达式将被忽略。不过我们可以对那些不支持calc()的浏览器，使用一个固定值作为回退。\n\n\n# 15 伪类和伪元素\n\n> css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素都是用来修饰不在文档树中的部分\n\n伪类\n\n> 伪类存在的意义是为了通过选择器找到那些不存在dom树中的信息以及不能被常规css选择器获取到的信息\n\n 1. 获取不存在与dom树中的信息。比如a标签的:link、visited等，这些信息不存在与dom树结构中，只能通过css选择器来获取；\n\n 2. 获取不能被常规css选择器获取的信息。比如：要获取第一个子元素，我们无法用常规的css选择器获取，但可以通过 :first-child 来获取到。\n\n伪元素\n\n> 伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：::before，::after，::first-line，::first-letter，::selection、::placeholder等\n\n> 因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素\n\n::after和:after的区别\n\n * 在实际的开发工作中，我们会看到有人把伪元素写成:after，这实际是 css2 与css3新旧标准的规定不同而导致的。\n\n * css2 中的伪元素使用1个冒号，在 css3 中，为了区分伪类和伪元素，规定伪元素使用2个冒号。所以，对于 css2 标准的老伪元素，比如:first-line，:first-letter，:before，:after，写一个冒号浏览器也能识别，但对于 css3 标准的新伪元素，比如::selection，就必须写2个冒号了\n\ncss3新增伪类有那些？\n\n * p:first-of-type 选择属于其父元素的首个<p>元素的每个<p> 元素。\n\n * p:last-of-type 选择属于其父元素的最后 <p> 元素的每个<p> 元素。\n\n * p:only-of-type 选择属于其父元素唯一的 <p>元素的每个 <p> 元素。\n\n * p:only-child 选择属于其父元素的唯一子元素的每个 <p> 元素。\n\n * p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n * :after 在元素之前添加内容,也可以用来做清除浮动。\n\n * :before 在元素之后添加内容\n\n * :enabled\n\n * :disabled 控制表单控件的禁用状态。\n\n * :checked 单选框或复选框被选中\n\n\n# 16 浏览器是怎样解析 css 选择器的\n\n * 样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。\n * 试想一下，如果采用从左至右的方式读取css规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能， 最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。\n\n\n# 17 浏览器如何判断是否支持 webp 格式图片\n\n * 宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如 果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格 式的图片\n\n * canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的todataurl将设置为webp格式，然后判断 返回值中是否含有image/webp字段，如果包含则说明支持webp，反之则不支持\n\n\n# 18 css加载问题\n\n根据页面渲染流程可得知：\n\n * css加载不会阻塞dom树的解析;\n\n * css加载会阻塞dom树的渲染；\n\n * css加载会阻塞后面js语句的执行\n\n\n# 19 文字单超出显示省略号\n\ndiv {\n\twidth: 200px;\n\toverflow: hidden;\n\twhite-space: nowrap;\n\ttext-overflow: ellipsis;\n}\n\n\n文字多行超出显示省略号\n\ndiv {\n\twidth: 200px;\n\tdisplay: -webkit-box;\n\t-webkit-box-orient: vertical;\n\t-webkit-line-clamp: 3;\n\toverflow: hidden;\n}\n\n\n该方法适用于webkit浏览器及移动端。\n\n跨浏览器兼容方案：\n\np {\n    position:relative;\n    line-height:1.4em;\n    /* 3 times the line-height to show 3 lines */\n    height:4.2em;\n    overflow:hidden;\n}\np::after {\n    content:\"...\";\n    font-weight:bold;\n    position:absolute;\n    bottom:0;\n    right:0;\n    padding:0 20px 1px 45px;\n}\n\n\n\n# 20 页面变灰\n\nbody {\n\tfilter: grayscale(100%); /* 百分比或者 0~1 */\n}\n\n\n\n# 21 css中可继承的属性\n\n> 可继承的只有：颜色、文字、字体间距、行高对齐方式，列表样式。\n\n所有元素可继承：visibility和cursor。\n\n * 内联元素可继承：\n   \n   * letter-spacing\n   * word-spacing\n   * white-space\n   * line-height\n   * color\n   * font\n   * font-family\n   * font-size\n   * font-style\n   * font-variant\n   * font-weight\n   * text-decoration\n   * text-transform\n   * direction\n\n * 块状：text-indent和text-align。\n\n * 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image\n\n\n# 22 常规流(文档流)是个怎样的排列关系\n\n将窗体自上而下分成一行一行,并在每行中按从左至右的挨次排放元素。\n\n\n# 23 inline-block的使用场景\n\n 1. 要设置某些子元素在一行或者多行内显示，尤其是排列方向一致的情况下，应尽量用inline-block。\n\n 2. 希望若干个元素平行排列，且在父元素中居中排列，此时可以用inline-block，且给父元素设text-align: center。\n\n 3. inline-block可以用一排a {display: inline-block}实现横向导航栏，无论是居左的导航栏还是居右的都适用。\n\n对于第一种和第三种情况虽然都可以使用float来实现，不过inline-block会比它好一些，原因如下：\n\n * 浮动会脱离文档流，导致父元素高度塌陷\n\n\n# 24 position: fixed什么时候会失效？\n\n我们知道，设置了position: fixed固定定位属性的元素会脱离文档流，达到“超然脱俗”的境界。\n\n> 也就是说此时给这种元素设置top, left, right, bottom等属性是根据浏览器窗口定位的，与其上级元素的位置无关。\n\n但是有一种情况例外：\n\n * 若是设置了position: fixed属性的元素，它的祖先元素设置了transform属性则会导致固定定位属性失效。\n\n * 只要你的transform设置的不是none，都会影响到position: fixed，因为此时就会相对于祖先元素指定坐标，而不是浏览器窗口。\n\n注意，这个特性表现，目前只在chrome浏览器/firefox浏览器下有。ie浏览器，包括ie11, fixed还是fixed的表现。\n\n\n# 25 回流（reflow）和重绘（repaint）的理解\n\n回流：\n\n> 无论通过什么方式影响了元素的几何信息(元素在视口内的位置和尺寸大小)，浏览器需要重新计算元素在视口内的几何属性，这个过程叫做回流\n\n触发条件：当我们对 dom 结构的修改引发 dom 几何尺寸变化的时候，会发生回流的过程。\n\n例如以下操作会触发回流：\n\n1.一个 dom 元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border 等等, 这个很好理解 2. 使 dom 节点发生增减或者移动 3. 读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作 4. 调用 window.getcomputedstyle 方法\n\n> 回流过程：由于dom的结构发生了改变，所以需要从生成dom这一步开始，重新经过样式计算、生成布局树、建立图层树、再到生成绘制列表以及之后的显示器显示这整一个渲染过程走一遍，开销是非常大的\n\n重绘：\n\n> 通过构造渲染树和重排（回流）阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(元素在视口内的位置和尺寸大小)，接下来就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘\n\n触发条件：\n\n * 当 dom 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致重绘(repaint)。\n\n * 重绘过程：由于没有导致 dom 几何属性的变化，因此元素的位置信息不需要更新，所以当发生重绘的时候，会跳过生存布局树和建立图层树的阶段，直接到生成绘制列表，然后继续进行分块、生成位图等后面一系列操作。\n\n如何避免触发回流和重绘：\n\n 1. 避免频繁使用 style，而是采用修改class的方式。\n\n 2. 将动画效果应用到position属性为absolute或fixed的元素上。\n\n 3. 批量操作 dom，比如读取某元素 offsetwidth 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 document.createdocumentfragment() 来添加要被添加的节点，处理完之后再插入到实际 dom 中\n\n 4. 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的dom操作不会引发回流和重绘\n\n 5. 对于 resize、scroll 等进行防抖/节流处理。\n\n 6. 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。\n\n 7. 利用 css3 的transform、opacity、filter这些属性可以实现合成的效果，也就是cpu加速。\n\n\n# 26 gpu加速的原因\n\n> 在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理。交给它处理有两大好处:\n\n 1. 能够充分发挥gpu的优势。合成线程生成位图的过程中会调用线程池，并在其中使用gpu进行加速生成，而 gpu 是擅长处理位图数据的。\n 2. 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。\n\n\n# 27 说说will-change\n\n> will-change是css3新增的标准属性，它的作用很单纯，就是\"增强页面渲染性能\"，当我们在通过某些行为触发页面进行大面积绘制的时候，浏览器往往是没有准备，只能被动的使用cup去计算和重绘，由于事先没有准备，对于一些复杂的渲染可能会出现掉帧、卡顿等情况。而will-change则是在真正的行为触发之前告诉浏览器可能要进行重绘了，相当于浏览器把cup拉上了，能从容的面对接下来的变形。\n\n常用的语法主要有：\n\n * whil-change: scroll-position; 即将开始滚动\n\n * will-change: contents; 内容要动画或者变化了\n\n * will-transform; transform相关的属性要变化了(常用)\n\n注意：\n\n * will-change虽然可以开启加速，但是一定要适度使用\n\n * 开启加速的代价为手机的耗电量会增加\n\n * 使用时遵循最小化影响原则，可以对伪元素开启加速，独立渲染\n\n * 可以写在伪类中，例如hover中，这样移出元素的时候就会自动remove掉will-change了\n\n * 如果使用js添加了will-change，注意要及时remove掉，方式就是style.willchange = 'auto'\n\n\n# 28 z-index和background的覆盖关系\n\n\n\n\n# 29 移动端中css你是使用什么单位\n\n比较常用的：\n\n * em：定义字体大小时以父级的字体大小为基准；定义长度单位时以当前字体大小为基准。例父级font-size: 14px，则子级font-size: 1em;为font-size: 14px;；若定义长度时，子级的字体大小如果为14px，则子级width: 2em;为width: 24px。\n\n * rem：以根元素的字体大小为基准。例如html的font-size: 14px，则子级1rem = 14px。\n\n * %：以父级的宽度为基准。例父级width: 200px，则子级width: 50%;height:50%;为width: 100px;height: 100px;\n\n * vw和vh：基于视口的宽度和高度(视口不包括浏览器的地址栏工具栏和状态栏)。例如视口宽度为1000px，则60vw = 600px;\n\n * vmin和vmax：vmin为当前vw 和vh中较小的一个值；vmax为较大的一个值。例如视口宽度375px，视口高度812px，则100vmin = 375px;，100vmax = 812px;\n\n不常用的：\n\n * ex和ch：ex以字符\"x\"的高度为基准；例如1ex表示和字符\"x\"一样长。ch以数字\"0\"的宽度为基准；例如2ch表示和2个数字\"0\"一样长。\n\n移动端布局总结：\n\n 1. 移动端布局的方式主要使用rem和flex，可以结合各自的优点，比如flex布局很灵活，但是字体的大小不好控制，我们可以使用rem和媒体查询控制字体的大小，媒体查询视口的大小，然后不同的上视口大小下设置设置html的font-size。\n\n 2. 可单独制作移动端页面也可响应式pc端移动端共用一个页面。没有好坏，视情况而定，因势利导\n\n\n# 30 rem和em的区别\n\nem:\n\n> 定义字体大小时以父级的字体大小为基准；定义长度单位时以当前字体大小为基准。例父级font-size: 14px，则子级font-size: 1em;为font-size: 14px;；若定义长度时，子级的字体大小如果为14px，则子级width: 2em;为width: 24px。\n\nrem:\n\n以根元素的字体大小为基准。例如html的font-size: 14px，则子级1rem = 14px。\n\n\n# 31 在移动端中怎样初始化根元素的字体大小\n\n一个简易版的初始化根元素字体大小。\n\n页面开头处引入下面这段代码，用于动态计算font-size：\n\n(假设你需要的1rem = 20px)\n\n(function () {\n  var html = document.documentelement;\n  function onwindowresize() {\n    html.style.fontsize = html.getboundingclientrect().width / 20 + 'px';\n  }\n  window.addeventlistener('resize', onwindowresize);\n  onwindowresize();\n})();\n\n\n * document.documentelement：获取document的根元素\n\n * html.getboundingclientrect().width：获取html的宽度(窗口的宽度)\n\n * 监听window的resize事件\n\n一般还需要配合一个meta头：\n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-sacle=1.0, maximum-scale=1.0, user-scalable=no\" />\n\n\n\n# 32 移动端中不同手机html默认的字体大小都是一样的吗\n\n> 如果没有人为取改变根元素字体大小的话，默认是1rem = 16px；根元素默认的字体大小是16px。\n\n\n# 33 line-height 如何继承\n\n * 父元素的 line-height 写了具体数值，比如 30px，则子元素 line-height 继承该值。\n\n * 父元素的 line-height 写了比例，比如 1.5或 2，则子元素 line-height 也是继承该比例。\n\n * 父元素的 line-height 写了百分比，比如 200%，则子元素 line-height 继承的是父元素 font-size * 200% 计算出来的值\n\n\n# 34 css 怎么开启硬件加速(gpu 加速)\n\n浏览器在处理下面的 css 的时候，会使用 gpu 渲染\n\n * transform（当 3d 变换的样式出现时会使用 gpu 加速）\n\n * opacity\n\n * filter\n\n * will-change\n\n * 采用 transform: translatez(0)\n\n * 采用 transform: translate3d(0, 0, 0)\n\n * 使用 css 的 will-change属性。 will-change 可以设置为opacity、transform、top、left、bottom、right`\n\n注意！层爆炸，由于某些原因可能导致产生大量不在预期内的合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象（简单理解就是，很多不需要提升为合成层的元素因为某些不当操作成为了合成层）。解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。简单直接的方式：使用 3d 硬件加速提升动画性能时，最好给元素增加一个 z-index 属性，人为干扰合成的排序，可以有效减少创建不必要的合成层，提升渲染性能，移动端优化效果尤为明显。\n\n\n# 35 flex:1 是哪些属性组成的\n\n * flex 实际上是 flex-grow、flex-shrink 和 flex-basis 三个属性的缩写。\n\n * flex-grow：定义项目的的放大比例；\n   \n   * 默认为0，即 即使存在剩余空间，也不会放大；\n   \n   * 所有项目的flex-grow为1：等分剩余空间（自动放大占位）；\n   \n   * flex-grow为n的项目，占据的空间（放大的比例）是flex-grow为1的n倍\n\n * flex-shrink：定义项目的缩小比例；\n   \n   * 默认为1，即 如果空间不足，该项目将缩小；\n   \n   * 所有项目的flex-shrink为1：当空间不足时，缩小的比例相同；\n   \n   * flex-shrink为0：空间不足时，该项目不会缩小；\n   \n   * flex-shrink为n的项目，空间不足时缩小的比例是flex-shrink为1的n倍。\n\n * flex-basis：定义在分配多余空间之前，项目占据的主轴空间（main size），浏览器根据此属性计算主轴是否有多余空间\n   \n   * 默认值为auto，即 项目原本大小；\n   \n   * 设置后项目将占据固定空间。\n\n\n# 36 编程题\n\n\n# 画一条 0.5px 的线\n\n * 采用 meta viewport 的方式 <meta name=\"viewport\" content=\"initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" />\n\n * 采用 border-image 的方式\n\n * 采用 transform: scale() 的方式\n\n\n# 如何画一个三角形\n\n三角形原理:边框的均分原理\n\ndiv {\n  width:0px;\n  height:0px;\n  border-top:10px solid red; \n  border-right:10px solid transparent; \n  border-bottom:10px solid transparent; \n  border-left:10px solid transparent;\n}\n\n\n\n# 圆？半圆？椭圆？\n\ndiv {\n  width: 100px;\n  height: 100px;\n  background-color: red;\n  margin-top: 20px;\n}\n.box1 { /* 圆 */\n  /* border-radius: 50%; */\n  border-radius: 50px;\n}\n.box2 { /* 半圆 */\n  height: 50px;\n  border-radius: 50px 50px 0 0;\n}\n.box3 { /* 椭圆 */\n  height: 50px;\n  border-radius: 50px/25px; /* x轴/y轴 */\n}\n\n\n\n# 左边定宽，右边自适应方案\n\n> float + margin，float + calc\n\n/* 方案1 */ \n.left {\n  width: 120px;\n  float: left;\n}\n.right {\n  margin-left: 120px;\n}\n/* 方案2 */ \n.left {\n  width: 120px;\n  float: left;\n}\n.right {\n  width: calc(100% - 120px);\n  float: left;\n}\n\n\n\n# 左右两边定宽，中间自适应\n\n> float，float + calc, 圣杯布局（设置bfc，margin负值法），flex\n\n.wrap {\n  width: 100%;\n  height: 200px;\n}\n.wrap > div {\n  height: 100%;\n}\n/* 方案1 */\n.left {\n  width: 120px;\n  float: left;\n}\n.right {\n  float: right;\n  width: 120px;\n}\n.center {\n  margin: 0 120px; \n}\n/* 方案2 */\n.left {\n  width: 120px;\n  float: left;\n}\n.right {\n  float: right;\n  width: 120px;\n}\n.center {\n  width: calc(100% - 240px);\n  margin-left: 120px;\n}\n/* 方案3 */\n.wrap {\n  display: flex;\n}\n.left {\n  width: 120px;\n}\n.right {\n  width: 120px;\n}\n.center {\n  flex: 1;\n}\n\n\n\n# 如何实现左侧宽度固定，右侧宽度自适应的布局\n\n<div class=\"box\">\n  <div class=\"box-left\"></div>\n  <div class=\"box-right\"></div>\n</div>\n\n\n\n# 利用float + margin实现\n\n.box {\n height: 200px;\n}\n\n.box > div {\n  height: 100%;\n}\n\n.box-left {\n  width: 200px;\n  float: left;\n  background-color: blue;\n}\n\n.box-right {\n  margin-left: 200px;\n  background-color: red;\n}\n\n\n利用calc计算宽度\n\n.box {\n height: 200px;\n}\n\n.box > div {\n  height: 100%;\n}\n\n.box-left {\n  width: 200px;\n  float: left;\n  background-color: blue;\n}\n\n.box-right {\n  width: calc(100% - 200px);\n  float: right;\n  background-color: red;\n}\n\n\n利用float + overflow实现\n\n.box {\n height: 200px;\n}\n\n.box > div {\n  height: 100%;\n}\n\n.box-left {\n  width: 200px;\n  float: left;\n  background-color: blue;\n}\n\n.box-right {\n  overflow: hidden;\n  background-color: red;\n}\n\n\n利用flex实现\n\n.box {\n  height: 200px;\n  display: flex;\n}\n\n.box > div {\n  height: 100%;\n}\n\n.box-left {\n  width: 200px;\n  background-color: blue;\n}\n\n.box-right {\n  flex: 1; // 设置flex-grow属性为1，默认为0\n  overflow: hidden;\n  background-color: red;\n}\n\n\n\n# 两边宽度固定中间自适应的三栏布局\n\n> 圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。\n\n圣杯布局\n\n<style>\nbody{\n    min-width: 550px;\n}\n#container{\n    padding-left: 200px;\n    padding-right: 150px;\n}\n#container .column{\n    float: left;\n}\n#center{\n    width: 100%;\n}\n#left{\n    width: 200px;\n    margin-left: -100%;\n    position: relative;\n    right: 200px;\n}\n#right{\n    width: 150px;\n    margin-right: -150px;\n}\n</style>\n<div id=\"container\">\n    <div id=\"center\" class=\"column\">center</div>\n    <div id=\"left\" class=\"column\">left</div>\n    <div id=\"right\" class=\"column\">right</div>\n</div>\n\n\n双飞翼布局\n\n<style>\nbody {\n    min-width: 500px;\n}\n#container {\n    width: 100%;\n}\n.column {\n    float: left;\n}\n#center {\n    margin-left: 200px;\n    margin-right: 150px;\n}\n#left {\n    width: 200px;\n    margin-left: -100%;\n}\n#right {\n    width: 150px;\n    margin-left: -150px;\n}\n</style>\n<div id=\"container\" class=\"column\">\n    <div id=\"center\">center</div>\n</div>\n<div id=\"left\" class=\"column\">left</div>\n<div id=\"right\" class=\"column\">right</div>\n\n\n\n# css画圆半圆扇形三角梯形\n\ndiv{\n    margin: 50px;\n    width: 100px;\n    height: 100px;\n    background: red;\n}\n/* 半圆 */\n.half-circle{\n    height: 50px;\n    border-radius: 50px 50px 0 0;\n}\n/* 扇形 */\n.sector{\n    border-radius: 100px 0 0;\n}\n/* 三角 */\n.triangle{\n    width: 0px;\n    height: 0px;\n    background: none;\n    border: 50px solid red;\n    border-color: red transparent transparent transparent;\n}\n/* 梯形 */\n.ladder{\n    width: 50px;\n    height: 0px;\n    background: none;\n    border: 50px solid red;\n    border-color: red transparent transparent transparent;\n}\n",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "JS模块",
      "frontmatter": {
        "title": "JS模块",
        "date": "2022-08-08T14:34:45.000Z",
        "permalink": "/pages/fineJS/",
        "article": false
      },
      "regularPath": "/60.%E7%B2%BE%E9%80%89%E7%AF%87/10.%E7%B2%BE%E9%80%89%E6%8C%87%E5%8D%97/30.JS%E6%A8%A1%E5%9D%97.html",
      "relativePath": "60.精选篇/10.精选指南/30.JS模块.md",
      "key": "v-64dbd551",
      "path": "/pages/fineJS/",
      "headers": [
        {
          "level": 2,
          "title": "1 数据类型基础",
          "slug": "_1-数据类型基础",
          "normalizedTitle": "1 数据类型基础",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "1.1 JS内置类型",
          "slug": "_1-1-js内置类型",
          "normalizedTitle": "1.1 js内置类型",
          "charIndex": 15
        },
        {
          "level": 3,
          "title": "1.2 null和undefined区别",
          "slug": "_1-2-null和undefined区别",
          "normalizedTitle": "1.2 null和undefined区别",
          "charIndex": 1116
        },
        {
          "level": 3,
          "title": "1.3 null是对象吗？为什么？",
          "slug": "_1-3-null是对象吗-为什么",
          "normalizedTitle": "1.3 null是对象吗？为什么？",
          "charIndex": 1434
        },
        {
          "level": 3,
          "title": "1.4 '1'.toString()为什么可以调用？",
          "slug": "_1-4-1-tostring-为什么可以调用",
          "normalizedTitle": "1.4 '1'.tostring()为什么可以调用？",
          "charIndex": 1611
        },
        {
          "level": 3,
          "title": "1.5 0.1+0.2为什么不等于0.3？如何让其相等",
          "slug": "_1-5-0-1-0-2为什么不等于0-3-如何让其相等",
          "normalizedTitle": "1.5 0.1+0.2为什么不等于0.3？如何让其相等",
          "charIndex": 1915
        },
        {
          "level": 3,
          "title": "1.6 如何理解BigInt",
          "slug": "_1-6-如何理解bigint",
          "normalizedTitle": "1.6 如何理解bigint",
          "charIndex": 2630
        },
        {
          "level": 3,
          "title": "1.7 JS 整数是怎么表示的",
          "slug": "_1-7-js-整数是怎么表示的",
          "normalizedTitle": "1.7 js 整数是怎么表示的",
          "charIndex": 4213
        },
        {
          "level": 3,
          "title": "1.8 Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办",
          "slug": "_1-8-number-的存储空间是多大-如果后台发送了一个超过最大自己的数字怎么办",
          "normalizedTitle": "1.8 number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办",
          "charIndex": 4357
        },
        {
          "level": 2,
          "title": "2 数据类型检测",
          "slug": "_2-数据类型检测",
          "normalizedTitle": "2 数据类型检测",
          "charIndex": 4457
        },
        {
          "level": 3,
          "title": "2.1 typeof类型判断",
          "slug": "_2-1-typeof类型判断",
          "normalizedTitle": "2.1 typeof类型判断",
          "charIndex": 4470
        },
        {
          "level": 3,
          "title": "2.2 typeof 于 instanceof 区别",
          "slug": "_2-2-typeof-于-instanceof-区别",
          "normalizedTitle": "2.2 typeof 于 instanceof 区别",
          "charIndex": 7433
        },
        {
          "level": 3,
          "title": "2.3 总结",
          "slug": "_2-3-总结",
          "normalizedTitle": "2.3 总结",
          "charIndex": 8586
        },
        {
          "level": 2,
          "title": "3 数据类型转换",
          "slug": "_3-数据类型转换",
          "normalizedTitle": "3 数据类型转换",
          "charIndex": 9582
        },
        {
          "level": 3,
          "title": "3.1 转化规则",
          "slug": "_3-1-转化规则",
          "normalizedTitle": "3.1 转化规则",
          "charIndex": 9636
        },
        {
          "level": 3,
          "title": "3.2 转Boolean",
          "slug": "_3-2-转boolean",
          "normalizedTitle": "3.2 转boolean",
          "charIndex": 9989
        },
        {
          "level": 3,
          "title": "3.3 比较运算符",
          "slug": "_3-3-比较运算符",
          "normalizedTitle": "3.3 比较运算符",
          "charIndex": 10079
        },
        {
          "level": 3,
          "title": "3.4 [] == ![]结果是什么？为什么？",
          "slug": "_3-4-结果是什么-为什么",
          "normalizedTitle": "3.4 [] == ![]结果是什么？为什么？",
          "charIndex": 10294
        },
        {
          "level": 3,
          "title": "3.5】、 == 和 ===有什么区别",
          "slug": "_3-5】、-和-有什么区别",
          "normalizedTitle": "3.5】、 == 和 ===有什么区别",
          "charIndex": 10456
        },
        {
          "level": 2,
          "title": "4 闭包",
          "slug": "_4-闭包",
          "normalizedTitle": "4 闭包",
          "charIndex": 10860
        },
        {
          "level": 3,
          "title": "4.1 闭包产生的原因",
          "slug": "_4-1-闭包产生的原因",
          "normalizedTitle": "4.1 闭包产生的原因",
          "charIndex": 11026
        },
        {
          "level": 3,
          "title": "4.2 闭包有哪些表现形式",
          "slug": "_4-2-闭包有哪些表现形式",
          "normalizedTitle": "4.2 闭包有哪些表现形式",
          "charIndex": 11954
        },
        {
          "level": 3,
          "title": "4.3 如何解决下面的循环输出问题",
          "slug": "_4-3-如何解决下面的循环输出问题",
          "normalizedTitle": "4.3 如何解决下面的循环输出问题",
          "charIndex": 12566
        },
        {
          "level": 3,
          "title": "4.4 闭包的几种使用场景",
          "slug": "_4-4-闭包的几种使用场景",
          "normalizedTitle": "4.4 闭包的几种使用场景",
          "charIndex": 13486
        },
        {
          "level": 2,
          "title": "5 原型和原型链链",
          "slug": "_5-原型和原型链链",
          "normalizedTitle": "5 原型和原型链链",
          "charIndex": 15486
        },
        {
          "level": 3,
          "title": "5.1 原型/构造函数/实例",
          "slug": "_5-1-原型-构造函数-实例",
          "normalizedTitle": "5.1 原型/构造函数/实例",
          "charIndex": 15500
        },
        {
          "level": 3,
          "title": "5.2 原型对象和构造函数有何关系",
          "slug": "_5-2-原型对象和构造函数有何关系",
          "normalizedTitle": "5.2 原型对象和构造函数有何关系",
          "charIndex": 16259
        },
        {
          "level": 3,
          "title": "5.3 能不能描述一下原型链",
          "slug": "_5-3-能不能描述一下原型链",
          "normalizedTitle": "5.3 能不能描述一下原型链",
          "charIndex": 16433
        },
        {
          "level": 2,
          "title": "6 继承",
          "slug": "_6-继承",
          "normalizedTitle": "6 继承",
          "charIndex": 16616
        },
        {
          "level": 3,
          "title": "6.1 方式1: 借助call",
          "slug": "_6-1-方式1-借助call",
          "normalizedTitle": "6.1 方式1: 借助call",
          "charIndex": 16625
        },
        {
          "level": 3,
          "title": "6.2 方式2: 借助原型链",
          "slug": "_6-2-方式2-借助原型链",
          "normalizedTitle": "6.2 方式2: 借助原型链",
          "charIndex": 16862
        },
        {
          "level": 3,
          "title": "6.3 方式3：将前两种组合",
          "slug": "_6-3-方式3-将前两种组合",
          "normalizedTitle": "6.3 方式3：将前两种组合",
          "charIndex": 17297
        },
        {
          "level": 3,
          "title": "6.4 方式4: 组合继承的优化1",
          "slug": "_6-4-方式4-组合继承的优化1",
          "normalizedTitle": "6.4 方式4: 组合继承的优化1",
          "charIndex": 17734
        },
        {
          "level": 3,
          "title": "6.5 方式5(最推荐使用): 组合继承的优化2",
          "slug": "_6-5-方式5-最推荐使用-组合继承的优化2",
          "normalizedTitle": "6.5 方式5(最推荐使用): 组合继承的优化2",
          "charIndex": 18117
        },
        {
          "level": 3,
          "title": "6.6 ES6的extends被编译后的JavaScript代码",
          "slug": "_6-6-es6的extends被编译后的javascript代码",
          "normalizedTitle": "6.6 es6的extends被编译后的javascript代码",
          "charIndex": 18436
        },
        {
          "level": 3,
          "title": "6.7 从设计思想上谈谈继承本身的问题",
          "slug": "_6-7-从设计思想上谈谈继承本身的问题",
          "normalizedTitle": "6.7 从设计思想上谈谈继承本身的问题",
          "charIndex": 19750
        },
        {
          "level": 3,
          "title": "6.8 继承-简版",
          "slug": "_6-8-继承-简版",
          "normalizedTitle": "6.8 继承-简版",
          "charIndex": 20720
        },
        {
          "level": 2,
          "title": "7 this",
          "slug": "_7-this",
          "normalizedTitle": "7 this",
          "charIndex": 21785
        },
        {
          "level": 2,
          "title": "8 内存机制",
          "slug": "_8-内存机制",
          "normalizedTitle": "8 内存机制",
          "charIndex": 23431
        },
        {
          "level": 2,
          "title": "9 执行上下文",
          "slug": "_9-执行上下文",
          "normalizedTitle": "9 执行上下文",
          "charIndex": 24439
        },
        {
          "level": 2,
          "title": "10 变量提升",
          "slug": "_10-变量提升",
          "normalizedTitle": "10 变量提升",
          "charIndex": 26179
        },
        {
          "level": 2,
          "title": "11 模块化",
          "slug": "_11-模块化",
          "normalizedTitle": "11 模块化",
          "charIndex": 26888
        },
        {
          "level": 2,
          "title": "12 异步编程",
          "slug": "_12-异步编程",
          "normalizedTitle": "12 异步编程",
          "charIndex": 27261
        },
        {
          "level": 3,
          "title": "12.1 浏览器中的Event loop",
          "slug": "_12-1-浏览器中的event-loop",
          "normalizedTitle": "12.1 浏览器中的event loop",
          "charIndex": 27318
        },
        {
          "level": 3,
          "title": "12.2 Node 中的 Event loop",
          "slug": "_12-2-node-中的-event-loop",
          "normalizedTitle": "12.2 node 中的 event loop",
          "charIndex": 29990
        },
        {
          "level": 3,
          "title": "12.3 实现一个Promise A+ 规范",
          "slug": "_12-3-实现一个promise-a-规范",
          "normalizedTitle": "12.3 实现一个promise a+ 规范",
          "charIndex": 40991
        },
        {
          "level": 3,
          "title": "12.4 setTimeout、Promise、Async / Await 的区别",
          "slug": "_12-4-settimeout、promise、async-await-的区别",
          "normalizedTitle": "12.4 settimeout、promise、async / await 的区别",
          "charIndex": 50759
        },
        {
          "level": 3,
          "title": "12.5 setTimeout(fn, 0)多久才执行，Event Loop",
          "slug": "_12-5-settimeout-fn-0-多久才执行-event-loop",
          "normalizedTitle": "12.5 settimeout(fn, 0)多久才执行，event loop",
          "charIndex": 52486
        },
        {
          "level": 3,
          "title": "12.6 async原理",
          "slug": "_12-6-async原理",
          "normalizedTitle": "12.6 async原理",
          "charIndex": 52599
        },
        {
          "level": 2,
          "title": "13 内存泄露",
          "slug": "_13-内存泄露",
          "normalizedTitle": "13 内存泄露",
          "charIndex": 53447
        },
        {
          "level": 3,
          "title": "13.1 Chrome devTools查看内存情况",
          "slug": "_13-1-chrome-devtools查看内存情况",
          "normalizedTitle": "13.1 chrome devtools查看内存情况",
          "charIndex": 53459
        },
        {
          "level": 3,
          "title": "13.2 内存泄漏的场景",
          "slug": "_13-2-内存泄漏的场景",
          "normalizedTitle": "13.2 内存泄漏的场景",
          "charIndex": 54231
        },
        {
          "level": 2,
          "title": "14 垃圾回收机制",
          "slug": "_14-垃圾回收机制",
          "normalizedTitle": "14 垃圾回收机制",
          "charIndex": 59820
        },
        {
          "level": 2,
          "title": "15 深浅拷贝",
          "slug": "_15-深浅拷贝",
          "normalizedTitle": "15 深浅拷贝",
          "charIndex": 60660
        },
        {
          "level": 2,
          "title": "16 对象的几种创建方式",
          "slug": "_16-对象的几种创建方式",
          "normalizedTitle": "16 对象的几种创建方式",
          "charIndex": 67422
        },
        {
          "level": 3,
          "title": "16.1 工厂模式,创建方式",
          "slug": "_16-1-工厂模式-创建方式",
          "normalizedTitle": "16.1 工厂模式,创建方式",
          "charIndex": 67439
        },
        {
          "level": 3,
          "title": "16.2 构造函数模式",
          "slug": "_16-2-构造函数模式",
          "normalizedTitle": "16.2 构造函数模式",
          "charIndex": 67716
        },
        {
          "level": 3,
          "title": "16.3 使用原型模式",
          "slug": "_16-3-使用原型模式",
          "normalizedTitle": "16.3 使用原型模式",
          "charIndex": 67969
        },
        {
          "level": 3,
          "title": "16.4 组合使用构造函数模式和原型模式",
          "slug": "_16-4-组合使用构造函数模式和原型模式",
          "normalizedTitle": "16.4 组合使用构造函数模式和原型模式",
          "charIndex": 68333
        },
        {
          "level": 3,
          "title": "16.5 动态原型模式",
          "slug": "_16-5-动态原型模式",
          "normalizedTitle": "16.5 动态原型模式",
          "charIndex": 68897
        },
        {
          "level": 2,
          "title": "17 数组相关",
          "slug": "_17-数组相关",
          "normalizedTitle": "17 数组相关",
          "charIndex": 69138
        },
        {
          "level": 3,
          "title": "17.1 数组常用方法",
          "slug": "_17-1-数组常用方法",
          "normalizedTitle": "17.1 数组常用方法",
          "charIndex": 69150
        },
        {
          "level": 3,
          "title": "17.2 Array(3)和Array(3, 4)的区别？",
          "slug": "_17-2-array-3-和array-3-4-的区别",
          "normalizedTitle": "17.2 array(3)和array(3, 4)的区别？",
          "charIndex": 69978
        },
        {
          "level": 3,
          "title": "17.3 请创建一个长度为100，值都为1的数组",
          "slug": "_17-3-请创建一个长度为100-值都为1的数组",
          "normalizedTitle": "17.3 请创建一个长度为100，值都为1的数组",
          "charIndex": 70086
        },
        {
          "level": 3,
          "title": "17.4 请创建一个长度为100，值为对应下标的数组",
          "slug": "_17-4-请创建一个长度为100-值为对应下标的数组",
          "normalizedTitle": "17.4 请创建一个长度为100，值为对应下标的数组",
          "charIndex": 70140
        },
        {
          "level": 3,
          "title": "17.5 如何转化类数组成数组",
          "slug": "_17-5-如何转化类数组成数组",
          "normalizedTitle": "17.5 如何转化类数组成数组",
          "charIndex": 70302
        },
        {
          "level": 3,
          "title": "17.6 forEach中return有效果吗？如何中断forEach循环？",
          "slug": "_17-6-foreach中return有效果吗-如何中断foreach循环",
          "normalizedTitle": "17.6 foreach中return有效果吗？如何中断foreach循环？",
          "charIndex": 71295
        },
        {
          "level": 3,
          "title": "17.7 JS判断数组中是否包含某个值",
          "slug": "_17-7-js判断数组中是否包含某个值",
          "normalizedTitle": "17.7 js判断数组中是否包含某个值",
          "charIndex": 71576
        },
        {
          "level": 3,
          "title": "17.8 JS中flat---数组扁平化",
          "slug": "_17-8-js中flat-数组扁平化",
          "normalizedTitle": "17.8 js中flat---数组扁平化",
          "charIndex": 72251
        },
        {
          "level": 2,
          "title": "18 操作DOM",
          "slug": "_18-操作dom",
          "normalizedTitle": "18 操作dom",
          "charIndex": 73230
        },
        {
          "level": 3,
          "title": "18.1 说说有几种类型的DOM节点",
          "slug": "_18-1-说说有几种类型的dom节点",
          "normalizedTitle": "18.1 说说有几种类型的dom节点",
          "charIndex": 73243
        },
        {
          "level": 3,
          "title": "18.2 操作DOM节点方法",
          "slug": "_18-2-操作dom节点方法",
          "normalizedTitle": "18.2 操作dom节点方法",
          "charIndex": 73386
        },
        {
          "level": 2,
          "title": "19 Ajax总结",
          "slug": "_19-ajax总结",
          "normalizedTitle": "19 ajax总结",
          "charIndex": 73745
        },
        {
          "level": 3,
          "title": "19.1 Ajax 有那些优缺点",
          "slug": "_19-1-ajax-有那些优缺点",
          "normalizedTitle": "19.1 ajax 有那些优缺点",
          "charIndex": 73968
        },
        {
          "level": 3,
          "title": "19.2 关于http,XMLHttpRequest,Ajax的关系",
          "slug": "_19-2-关于http-xmlhttprequest-ajax的关系",
          "normalizedTitle": "19.2 关于http,xmlhttprequest,ajax的关系",
          "charIndex": 74182
        },
        {
          "level": 3,
          "title": "19.3 XMLHttpRequest的发展历程是怎样的？",
          "slug": "_19-3-xmlhttprequest的发展历程是怎样的",
          "normalizedTitle": "19.3 xmlhttprequest的发展历程是怎样的？",
          "charIndex": 74418
        },
        {
          "level": 3,
          "title": "19.4 使用XMLHttpRequest封装一个get和post请求",
          "slug": "_19-4-使用xmlhttprequest封装一个get和post请求",
          "normalizedTitle": "19.4 使用xmlhttprequest封装一个get和post请求",
          "charIndex": 74699
        },
        {
          "level": 2,
          "title": "20 定时器",
          "slug": "_20-定时器",
          "normalizedTitle": "20 定时器",
          "charIndex": 76729
        },
        {
          "level": 3,
          "title": "20.1 setInterval存在哪些问题？",
          "slug": "_20-1-setinterval存在哪些问题",
          "normalizedTitle": "20.1 setinterval存在哪些问题？",
          "charIndex": 76740
        },
        {
          "level": 3,
          "title": "20.2 链式调用setTimeout对比setInterval",
          "slug": "_20-2-链式调用settimeout对比setinterval",
          "normalizedTitle": "20.2 链式调用settimeout对比setinterval",
          "charIndex": 77014
        },
        {
          "level": 3,
          "title": "20.3 实现比 setTimeout 快 80 倍的定时器",
          "slug": "_20-3-实现比-settimeout-快-80-倍的定时器",
          "normalizedTitle": "20.3 实现比 settimeout 快 80 倍的定时器",
          "charIndex": 77385
        },
        {
          "level": 3,
          "title": "22.4 说一下requestAnimationFrame",
          "slug": "_22-4-说一下requestanimationframe",
          "normalizedTitle": "22.4 说一下requestanimationframe",
          "charIndex": 80546
        },
        {
          "level": 3,
          "title": "22.5 requestAnimationFrame对比setTimeout",
          "slug": "_22-5-requestanimationframe对比settimeout",
          "normalizedTitle": "22.5 requestanimationframe对比settimeout",
          "charIndex": 81282
        },
        {
          "level": 2,
          "title": "21 谈谈你对for in/for of的理解",
          "slug": "_21-谈谈你对for-in-for-of的理解",
          "normalizedTitle": "21 谈谈你对for in/for of的理解",
          "charIndex": 81704
        },
        {
          "level": 2,
          "title": "22 JavaScript 实现对上传图片的压缩？",
          "slug": "_22-javascript-实现对上传图片的压缩",
          "normalizedTitle": "22 javascript 实现对上传图片的压缩？",
          "charIndex": 82740
        }
      ],
      "headersStr": "1 数据类型基础 1.1 JS内置类型 1.2 null和undefined区别 1.3 null是对象吗？为什么？ 1.4 '1'.toString()为什么可以调用？ 1.5 0.1+0.2为什么不等于0.3？如何让其相等 1.6 如何理解BigInt 1.7 JS 整数是怎么表示的 1.8 Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办 2 数据类型检测 2.1 typeof类型判断 2.2 typeof 于 instanceof 区别 2.3 总结 3 数据类型转换 3.1 转化规则 3.2 转Boolean 3.3 比较运算符 3.4 [] == ![]结果是什么？为什么？ 3.5】、 == 和 ===有什么区别 4 闭包 4.1 闭包产生的原因 4.2 闭包有哪些表现形式 4.3 如何解决下面的循环输出问题 4.4 闭包的几种使用场景 5 原型和原型链链 5.1 原型/构造函数/实例 5.2 原型对象和构造函数有何关系 5.3 能不能描述一下原型链 6 继承 6.1 方式1: 借助call 6.2 方式2: 借助原型链 6.3 方式3：将前两种组合 6.4 方式4: 组合继承的优化1 6.5 方式5(最推荐使用): 组合继承的优化2 6.6 ES6的extends被编译后的JavaScript代码 6.7 从设计思想上谈谈继承本身的问题 6.8 继承-简版 7 this 8 内存机制 9 执行上下文 10 变量提升 11 模块化 12 异步编程 12.1 浏览器中的Event loop 12.2 Node 中的 Event loop 12.3 实现一个Promise A+ 规范 12.4 setTimeout、Promise、Async / Await 的区别 12.5 setTimeout(fn, 0)多久才执行，Event Loop 12.6 async原理 13 内存泄露 13.1 Chrome devTools查看内存情况 13.2 内存泄漏的场景 14 垃圾回收机制 15 深浅拷贝 16 对象的几种创建方式 16.1 工厂模式,创建方式 16.2 构造函数模式 16.3 使用原型模式 16.4 组合使用构造函数模式和原型模式 16.5 动态原型模式 17 数组相关 17.1 数组常用方法 17.2 Array(3)和Array(3, 4)的区别？ 17.3 请创建一个长度为100，值都为1的数组 17.4 请创建一个长度为100，值为对应下标的数组 17.5 如何转化类数组成数组 17.6 forEach中return有效果吗？如何中断forEach循环？ 17.7 JS判断数组中是否包含某个值 17.8 JS中flat---数组扁平化 18 操作DOM 18.1 说说有几种类型的DOM节点 18.2 操作DOM节点方法 19 Ajax总结 19.1 Ajax 有那些优缺点 19.2 关于http,XMLHttpRequest,Ajax的关系 19.3 XMLHttpRequest的发展历程是怎样的？ 19.4 使用XMLHttpRequest封装一个get和post请求 20 定时器 20.1 setInterval存在哪些问题？ 20.2 链式调用setTimeout对比setInterval 20.3 实现比 setTimeout 快 80 倍的定时器 22.4 说一下requestAnimationFrame 22.5 requestAnimationFrame对比setTimeout 21 谈谈你对for in/for of的理解 22 JavaScript 实现对上传图片的压缩？",
      "content": "# 1 数据类型基础\n\n\n# 1.1 JS内置类型\n\n * JS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。\n\n * 基本类型有七种：null，undefined，boolean，number，string，symbol，bigint\n   \n   * 其中 Symbol 和 BigInt 是 ES6 新增的数据类型\n   \n   * Symbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。\n   \n   * BigInt 可以表示任意大小的整数。\n\n * 其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。NaN 也属于 number 类型，并且 NaN 不等于自身。\n\n * 对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型。\n\n引用数据类型：\n\n * 对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function）\n\nlet a = 111 // 这只是字面量，不是 number 类型\na.toString() // 使用时候才会转换为对象类型\n\n\n * 对象（Object）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。\n\nlet a = { name: 'FE' }\nlet b = a\nb.name = 'EF'\nconsole.log(a.name) // EF\n\n\n说出下面运行的结果，解释原因。\n\nfunction test(person) {\n  person.age = 26\n  person = {\n    name: 'hzj',\n    age: 18\n  }\n  return person\n}\nconst p1 = {\n  name: 'fyq',\n  age: 19\n}\nconst p2 = test(p1)\nconsole.log(p1) // -> ?\nconsole.log(p2) // -> ?\n\n\n// 结果:\np1：{name: “fyq”, age: 26}\np2：{name: “hzj”, age: 18}\n\n\n原因: 在函数传参的时候传递的是对象在堆中的内存地址值，test函数中的实参person是p1对象的内存地址，通过调用person.age = 26确实改变了p1的值，但随后person变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2。\n\n\n# 1.2 null和undefined区别\n\nUndefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。用法：\n\n * 变量被声明了，但没有赋值时，就等于undefined。\n\n * 调用函数时，应该提供的参数没有提供，该参数等于undefined。\n\n * 对象没有赋值的属性，该属性的值为undefined。\n\n * 函数没有返回值时，默认返回undefined\n\nNull类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。用法：\n\n * 作为函数的参数，表示该函数的参数不是对象。\n\n * 作为对象原型链的终点\n\n\n# 1.3 null是对象吗？为什么？\n\n结论: null不是对象。\n\n解释: 虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。\n\n\n# 1.4 '1'.toString()为什么可以调用？\n\n其实在这个语句运行的过程中做了这样几件事情：\n\nvar s = new Object('1');\ns.toString();\ns = null;\n\n\n * 第一步: 创建Object类实例。注意为什么不是String ？ 由于Symbol和BigInt的出现，对它们调用new都会报错，目前ES6规范也不建议用new来创建基本类型的包装类。\n * 第二步: 调用实例方法。\n * 第三步: 执行完方法立即销毁这个实例。\n\n整个过程体现了基本包装类型的性质，而基本包装类型恰恰属于基本数据类型，包括Boolean, Number和String。\n\n\n# 1.5 0.1+0.2为什么不等于0.3？如何让其相等\n\n0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004\n\n我们都知道计算机时是通过二进制来进行计算的，即 0 和 1\n\n * 就拿 0.1 + 0.2 来说，0.1表示为0.0001100110011001...，而0.2表示为0.0011001100110011...\n\n * 而在二进制中 1 + 1 = 10，所以 0.1 + 0.2 = 0.0100110011001100...\n\n * 转成10进制就近似表示为 0.30000000000000004\n\n简单来说就是，浮点数转成二进制时丢失了精度，因此在二进制计算完再转回十进制时可能会和理论结果不同\n\n1. ES6提供的Number.EPSILON方法\n\nfunction isEqual(a, b) {\n  return Math.abs(a - b) < Number.EPSILON;\n}\n\nconsole.log(isEqual(0.1 + 0.2, 0.3)); // true\n\n\n> Number.EPSILON 的实质是一个可以接受的最小误差范围，一般来说为 Math.pow(2, -52)\n\n2. 乘以一个10的幂次方\n\n> 把需要计算的数字乘以10的n次方，让数值都变为整数，计算完后再除以10的n次方，这样就不会出现浮点数精度丢失问题\n\n(0.1*10 + 0.2*10) / 10 == 0.3 //true\n\n\n\n# 1.6 如何理解BigInt\n\n什么是BigInt?\n\n> BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。\n\n为什么需要BigInt?\n\n * 在JS中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？\n\n * 这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的Number类型只能安全地表示-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。\n\nconsole.log(999999999999999);  //=>10000000000000000\n\n\n同时也会有一定的安全性问题:\n\n9007199254740992 === 9007199254740993;    // → true 居然是true!\n\n\n如何创建并使用BigInt？\n\n要创建BigInt，只需要在数字末尾追加n即可\n\nconsole.log( 9007199254740995n );    // → 9007199254740995n\t\nconsole.log( 9007199254740995 );     // → 9007199254740996\n\n\n另一种创建BigInt的方法是用BigInt()构造函数\n\nBigInt(\"9007199254740995\");    // → 9007199254740995n\n\n\n简单使用如下:\n\n10n + 20n;    // → 30n\t\n10n - 20n;    // → -10n\t\n+10n;         // → TypeError: Cannot convert a BigInt value to a number\t\n-10n;         // → -10n\t\n10n * 20n;    // → 200n\t\n20n / 10n;    // → 2n\t\n23n % 10n;    // → 3n\t\n10n ** 3n;    // → 1000n\t\n\nconst x = 10n;\t\n++x;          // → 11n\t\n--x;          // → 9n\nconsole.log(typeof x);   //\"bigint\"\n\n\n值得警惕的点\n\n> BigInt不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 Number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js 代码。\n\n因为隐式类型转换可能丢失信息，所以不允许在bigint和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。\n\n10 + 10n;    // → TypeError\n\n\n> 不能将BigInt传递给Web api和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报TypeError错误。\n\nMath.max(2n, 4n, 6n);    // → TypeError\n\n\n> 当 Boolean 类型与 BigInt 类型相遇时，BigInt 的处理方式与Number类似，换句话说，只要不是0n，BigInt就被视为truthy的值。\n\nif(0n){//条件判断为false\n}\nif(3n){//条件为true\n}\n\n\n * 元素都为BigInt的数组可以进行sort。\n * BigInt可以正常地进行位运算，如|、&、<<、>>和^\n\n\n# 1.7 JS 整数是怎么表示的\n\n * 通过 Number 类型来表示，遵循 IEEE754 标准，通过 64 位来表示一个数字，（1 + 11 + 52），最大安全数字是 Math.pow(2, 53) - 1，对于 16 位十进制。（符号位 + 指数位 + 小数部分有效位）\n\n\n# 1.8 Number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办\n\n * Math.pow(2, 53) ，53 为有效数字，会发生截断，等于 JS 能支持的最大数字。\n\n\n# 2 数据类型检测\n\n\n# 2.1 typeof类型判断\n\n> 在写业务逻辑的时候，经常要用到JS数据类型的判断，面试常见的案例深浅拷贝也要用到数据类型的判断。\n\ntypeof\n\nconsole.log(typeof 2);               // number\nconsole.log(typeof true);            // boolean\nconsole.log(typeof 'str');           // string\nconsole.log(typeof undefined);       // undefined\nconsole.log(typeof function(){});    // function\nconsole.log(typeof Symbol(\"foo\")); // symbol\nconsole.log(typeof 2172141653n); // bigint\n\n// 不能判别\nconsole.log(typeof []); // object\nconsole.log(typeof {}); // object\nconsole.log(typeof null); // object\n\n\n> 优点：能够快速区分基本数据类型 缺点：不能将Object、Array和Null区分，都返回object\n\ninstanceof\n\nconsole.log(2 instanceof Number);                    // false\nconsole.log(true instanceof Boolean);                // false \nconsole.log('str' instanceof String);                // false  \nconsole.log([] instanceof Array);                    // true\nconsole.log(function(){} instanceof Function);       // true\nconsole.log({} instanceof Object);                   // true\n\n\n * 优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象\n\n * 缺点：Number，Boolean，String基本数据类型不能判断\n\n其内部运行机制是判断在其原型链中能否找到该类型的原型\n\nclass People {}\nclass Student extends People {}\n\nconst stu = new Student();\n\nconsole.log(stu instanceof People); // true\nconsole.log(stu instanceof Student); // true\n\n\n其实现就是顺着原型链去找，如果能找到对应的 Xxxxx.prototype 即为 true 。比如这里的 stu 作为实例，顺着原型链能找到 Student.prototype 及 People.prototype ，所以都为 true\n\nObject.prototype.toString.call()\n\nvar toString = Object.prototype.toString;\n \nconsole.log(toString.call(2));                      //[object Number]\nconsole.log(toString.call(true));                   //[object Boolean]\nconsole.log(toString.call('str'));                  //[object String]\nconsole.log(toString.call([]));                     //[object Array]\nconsole.log(toString.call(function(){}));           //[object Function]\nconsole.log(toString.call({}));                     //[object Object]\nconsole.log(toString.call(undefined));              //[object Undefined]\nconsole.log(toString.call(null));                   //[object Null]\n\n\n * 优点：精准判断数据类型，所有原始数据类型都是能判断的，还有 Error 对象，Date 对象等\n * 缺点：写法繁琐不容易记，推荐进行封装后使用\n\nObject.prototype.toString.call(2); // \"[object Number]\"\nObject.prototype.toString.call(\"\"); // \"[object String]\"\nObject.prototype.toString.call(true); // \"[object Boolean]\"\nObject.prototype.toString.call(undefined); // \"[object Undefined]\"\nObject.prototype.toString.call(null); // \"[object Null]\"\nObject.prototype.toString.call(Math); // \"[object Math]\"\nObject.prototype.toString.call({}); // \"[object Object]\"\nObject.prototype.toString.call([]); // \"[object Array]\"\nObject.prototype.toString.call(function () {}); // \"[object Function]\"\n\n\n在面试中有一个经常被问的问题就是：如何判断变量是否为数组？\n\nArray.isArray(arr); // true\narr.__proto__ === Array.prototype; // true\narr instanceof Array; // true\nObject.prototype.toString.call(arr); // \"[object Array]\"\n\n\n判断是否是promise对象\n\nfunction isPromise (val) {\n    return (\n      typeof val.then === 'function' &&\n      typeof val.catch === 'function'\n    )\n}\n\n\n\n# 2.2 typeof 于 instanceof 区别\n\n * typeof 对于基本类型，除了 null都可以显示正确的类型\n\ntypeof 1 // 'number'\ntypeof '1' // 'string'\ntypeof undefined // 'undefined'\ntypeof true // 'boolean'\ntypeof Symbol() // 'symbol'\ntypeof b // b 没有声明，但是还会显示 undefined\n\n\n * typeof 对于对象，除了函数都会显示 object\n\ntypeof [] // 'object'\ntypeof {} // 'object'\ntypeof console.log // 'function'\n\n\n * 对于 null 来说，虽然它是基本类型，但是会显示 object，这是一个存在很久了的 Bug\n\ntypeof null // 'object'\n\n\n * instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 iprototype\n\n// 我们也可以试着实现一下 instanceof\nfunction _instanceof(left, right) {\n    // 由于instance要检测的是某对象，需要有一个前置判断条件\n    //基本数据类型直接返回false\n    if(typeof left !== 'object' || left === null) return false;\n\n    // 获得类型的原型\n    let prototype = right.prototype\n    // 获得对象的原型\n    left = left.__proto__\n    // 判断对象的类型是否等于类型的原型\n    while (true) {\n    \tif (left === null)\n    \t\treturn false\n    \tif (prototype === left)\n    \t\treturn true\n    \tleft = left.__proto__\n    }\n}\n\nconsole.log('test', _instanceof(null, Array)) // false\nconsole.log('test', _instanceof([], Array)) // true\nconsole.log('test', _instanceof('', Array)) // false\nconsole.log('test', _instanceof({}, Object)) // true\n\n\n\n# 2.3 总结\n\n * typeof\n   \n   * 直接在计算机底层基于数据类型的值（二进制）进行检测\n   \n   * typeof null为object 原因是对象存在在计算机中，都是以000开始的二进制存储，所以检测出来的结果是对象\n   \n   * typeof 普通对象/数组对象/正则对象/日期对象 都是object\n   \n   * typeof NaN === 'number'\n\n * instanceof\n   \n   * 检测当前实例是否属于这个类的\n   * 底层机制：只要当前类出现在实例的原型上，结果都是true\n   * 不能检测基本数据类型\n\n * constructor\n   \n   * 支持基本类型\n   * constructor可以随便改，也不准\n\n * Object.prototype.toString.call([val])\n   \n   * 返回当前实例所属类信息\n\n> 判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:\n\n * 基本类型(null): 使用 String(null)\n\n * 基本类型(string / number / boolean / undefined) + function: - 直接使用 typeof即可\n\n * 其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断\n\n很稳的判断封装:\n\nlet class2type = {}\n'Array Date RegExp Object Error'.split(' ').forEach(e => class2type[ '[object ' + e + ']' ] = e.toLowerCase()) \n\nfunction type(obj) {\n  if (obj == null) return String(obj)\n  return typeof obj === 'object' ? class2type[ Object.prototype.toString.call(obj) ] || 'object' : typeof obj\n}\n\n\n\n# 3 数据类型转换\n\n> 大家都知道 JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:\n\n\n# 3.1 转化规则\n\n * -、*、/、%：一律转换成数值后计算\n\n * +：\n   \n   * 数字 + 字符串 = 字符串， 运算顺序是从左到右\n   \n   * 数字 + 对象， 优先调用对象的valueOf -> toString\n   \n   * 数字 + boolean/null -> 数字\n   \n   * 数字 + undefined -> NaN\n\n * [1].toString() === '1'\n\n * {}.toString() === '[object object]'\n\n * NaN !== NaN 、+undefined 为 NaN\n\n> 首先我们要知道，在 JS 中类型转换只有三种情况，分别是：\n\n * 转换为布尔值\n * 转换为数字\n * 转换为字符串\n\n\n\n\n# 3.2 转Boolean\n\n * 在条件判断时，除了 undefined，null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象\n\n\n# 3.3 比较运算符\n\n * 如果是对象，就通过 toPrimitive 转换对象\n\n * 如果是字符串，就通过 unicode 字符索引来比较\n\nlet a = {\n  valueOf() {\n    return 0\n  },\n  toString() {\n    return '1'\n  }\n}\na > -1 // true\n\n\n在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。\n\n\n# 3.4 [] == ![]结果是什么？为什么？\n\n * == 中，左右两边都需要转换为数字然后进行比较\n\n * []转换为数字为0\n\n * ![] 首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为true\n\n * 因此![]为false，进而在转换成数字，变为0\n\n * 0 == 0 ， 结果为true\n\n\n# 3.5】、 == 和 ===有什么区别\n\n> ===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如'1'===1的结果是false，因为一边是string，另一边是number\n\n==不像===那样严格，对于一般情况，只要值相等，就返回true，但==还涉及一些类型转换，它的转换规则如下\n\n * 两边的类型是否相同，相同的话就比较值的大小，例如1==2，返回false\n\n * 判断的是否是null和undefined，是的话就返回true\n\n * 判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较\n\n * 判断其中一方是否是Boolean，是的话就把Boolean转换成Number`，再进行比较\n\n * 如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较\n\n\n# 4 闭包\n\n> 红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，\n\n> MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。\n> \n>  * （其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）\n\n\n# 4.1 闭包产生的原因\n\n> 首先要明白作用域链的概念，其实很简单，在ES5中只存在两种作用域————全局作用域和函数作用域，当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链，值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。 比如:\n\nvar a = 1;\nfunction f1() {\n  var a = 2\n  function f2() {\n    var a = 3;\n    console.log(a);//3\n  }\n}\n\n\n> 在这段代码中，f1的作用域指向有全局作用域(window)和它本身，而f2的作用域指向全局作用域(window)、f1和它本身。而且作用域是从最底层向上找，直到找到全局作用域window为止，如果全局还没有的话就会报错。就这么简单一件事情\n\n闭包产生的本质就是，当前环境中存在指向父级作用域的引用。还是举上面的例子:\n\nfunction f1() {\n  var a = 2\n  function f2() {\n    console.log(a);//2\n  }\n  return f2;\n}\nvar x = f1();\nx();\n\n\n> 这里x会拿到父级作用域中的变量，输出2。因为在当前环境中，含有对f2的引用，f2恰恰引用了window、f1和f2的作用域。因此f2可以访问到f1的作用域的变量。\n\n * 那是不是只有返回函数才算是产生了闭包呢？\n * 回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：\n\nvar f3;\nfunction f1() {\n  var a = 2\n  f3 = function() {\n    console.log(a);\n  }\n}\nf1();\nf3();\n\n\n * 让f1执行，给f3赋值后，等于说现在f3拥有了window、f1和f3本身这几个作用域的访问权限，还是自底向上查找，最近是在f1中找到了a,因此输出2。\n\n * 在这里是外面的变量f3存在着父级作用域的引用，因此产生了闭包，形式变了，本质没有改变\n\n\n# 4.2 闭包有哪些表现形式\n\n明白了本质之后，我们就来看看，在真实的场景中，究竟在哪些地方能体现闭包的存在？\n\n 1. 返回一个函数。刚刚已经举例。\n 2. 作为函数参数传递\n\nvar a = 1;\nfunction foo(){\n  var a = 2;\n  function baz(){\n    console.log(a);\n  }\n  bar(baz);\n}\nfunction bar(fn){\n  // 这就是闭包\n  fn();\n}\n// 输出2，而不是1\nfoo();\n\n\n 1. 在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包\n\n以下的闭包保存的仅仅是window和当前作用域。\n\n// 定时器\nsetTimeout(function timeHandler(){\n  console.log('111');\n}，100)\n\n// 事件监听\n$('#app').click(function(){\n  console.log('DOM Listener');\n})\n\n\n 1. IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以访问全局的变量\n\nvar a = 2;\n(function IIFE(){\n  // 输出2\n  console.log(a);\n})();\n\n\n\n# 4.3 如何解决下面的循环输出问题\n\nfor(var i = 1; i <= 5; i ++){\n  setTimeout(function timer(){\n    console.log(i)\n  }, 0)\n}\n\n\n为什么会全部输出6？如何改进，让它输出1，2，3，4，5？(方法越多越好) 因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后setTimeout中的回调才依次执行，但输出i的时候当前作用域没有，往上一级再找，发现了i,此时循环已经结束，i变成了6。因此会全部输出6。\n\n解决方法：\n\n 1. 利用IIFE(立即执行函数表达式)当每次for循环时，把此时的i变量传递到定时器中\n\nfor(var i = 1;i <= 5;i++){\n  (function(j){\n    setTimeout(function timer(){\n      console.log(j)\n    }, 0)\n  })(i)\n}\n\n\n 1. 给定时器传入第三个参数, 作为timer函数的第一个函数参数\n\nfor(var i=1;i<=5;i++){\n  setTimeout(function timer(j){\n    console.log(j)\n  }, 0, i)\n}\n\n\n 1. 使用ES6中的let\n\nfor(let i = 1; i <= 5; i++){\n  setTimeout(function timer(){\n    console.log(i)\n  },0)\n}\n\n\n> let使JS发生革命性的变化，让JS有函数作用域变为了块级作用域，用let后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例:\n\n// i = 1\n{\n  setTimeout(function timer(){\n    console.log(1)\n  },0)\n}\n// i = 2\n{\n  setTimeout(function timer(){\n    console.log(2)\n  },0)\n}\n// i = 3\n...\n\n\n\n# 4.4 闭包的几种使用场景\n\n1. 返回值（最常用）\n\n//1.返回值 最常用的\nfunction fn(){\n    var name=\"hello\";\n    return function(){\n        return name;\n    }\n}\nvar fnc = fn();\nconsole.log(fnc())//hello\n\n\n> 这个很好理解就是以闭包的形式将 name 返回\n\n2. 函数赋值\n\nvar fn2;\nfunction fn(){\n    var name=\"hello\";\n    //将函数赋值给fn2\n    fn2 = function(){\n        return name;\n    }\n}\nfn()//要先执行进行赋值，\nconsole.log(fn2())//执行输出fn2\n\n\n> 在闭包里面给fn2函数设置值，闭包的形式把name属性记忆下来，执行会输出 hello。\n\n3. 函数参数\n\nfunction fn(){\n    var name=\"hello\";\n    return function callback(){\n        return name;\n    }\n}\nvar fn1 = fn()//执行函数将返回值（callback函数）赋值给fn1，\n \nfunction fn2(f){\n    //将函数作为参数传入\n    console.log(f());//执行函数，并输出\n}\nfn2(fn1)//执行输出fn2\n\n\n> 用闭包返回一个函数，把此函数作为另一个函数的参数，在另一个函数里面执行这个函数，最终输出 hello\n\n4. IIFE（自执行函数）\n\n(function(){\n    var name=\"hello\";\n    var fn1= function(){\n        return name;\n    }\n    //直接在自执行函数里面调用fn2，将fn1作为参数传入\n    fn2(fn1);\n})()\nfunction fn2(f){\n    //将函数作为参数传入\n    console.log(f());//执行函数，并输出\n}\n\n\n> 直接在自执行函数里面将封装的函数fn1传给fn2，作为参数调用同样可以获得结果 hello\n\n5. 循环赋值\n\n//每秒执行1次，分别输出1-10\nfor(var i=1;i<=10;i++){\n    (function(j){\n        //j来接收\n        setTimeout(function(){\n            console.log(j);\n        },j*1000);\n    })(i)//i作为实参传入\n}\n\n\n> 如果不采用闭包的话，会有不一样的情况\n\n6. getter和setter\n\nfunction fn(){\n    var name='hello'\n    setName=function(n){\n        name = n;\n    }\n    getName=function(){\n        return name;\n    }\n\n    //将setName，getName作为对象的属性返回\n    return {\n        setName:setName,\n        getName:getName\n    }\n}\nvar fn1 = fn();//返回对象，属性setName和getName是两个函数\nconsole.log(fn1.getName());//getter\nfn1.setName('world');//setter修改闭包里面的name\nconsole.log(fn1.getName());//getter\n\n\n> 第一次输出 hello 用setter以后再输出 world ，这样做可以封装成公共方法，防止不想暴露的属性和函数暴露在外部\n\n7. 迭代器（执行一次函数往下取一个值）\n\nvar arr =['aa','bb','cc'];\nfunction incre(arr){\n    var i=0;\n    return function(){\n        //这个函数每次被执行都返回数组arr中 i下标对应的元素\n         return arr[i++] || '数组值已经遍历完';\n    }\n}\nvar next = incre(arr);\nconsole.log(next());//aa\nconsole.log(next());//bb\nconsole.log(next());//cc\nconsole.log(next());//数组值已经遍历完\n\n\n\n# 5 原型和原型链链\n\n\n# 5.1 原型/构造函数/实例\n\n * 原型(prototype): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个JavaScript对象中都包含一个__proto__(非标准)的属性指向它爹(该对象的原型)，可obj.__proto__进行访问。\n\n * 构造函数: 可以通过new来 新建一个对象 的函数。\n\n * 实例: 通过构造函数和new创建出来的对象，便是实例。 实例通过__proto__指向原型，通过constructor指向构造函数。\n\n> 以Object为例，我们常用的Object便是一个构造函数，因此我们可以通过它构建实例。\n\n// 实例\nconst instance = new Object()\n\n\n> 则此时， 实例为instance, 构造函数为Object，我们知道，构造函数拥有一个prototype的属性指向原型，因此原型为:\n\n// 原型\nconst prototype = Object.prototype\n\n\n这里我们可以来看出三者的关系:\n\n * 实例.__proto__ === 原型\n\n * 原型.constructor === 构造函数\n\n * 构造函数.prototype === 原型\n\n// 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线\n// 例如: \n// const o = new Object()\n// o.constructor === Object   --> true\n// o.__proto__ = null;\n// o.constructor === Object   --> false\n实例.constructor === 构造函数\n\n\n\n\n\n# 5.2 原型对象和构造函数有何关系\n\n * 在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性，这个属性指向函数的原型对象。\n\n * 当函数经过new调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个实例对象有一个__proto__属性，指向构造函数的原型对象。\n\n\n\n\n# 5.3 能不能描述一下原型链\n\n> JavaScript对象通过__proto__ 指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条, 即原型链\n\n\n\n * 对象的 hasOwnProperty() 来检查对象自身中是否含有该属性\n\n * 使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true\n\n\n# 6 继承\n\n\n# 6.1 方式1: 借助call\n\n function Parent1(){\n    this.name = 'parent1';\n  }\n  function Child1(){\n    Parent1.call(this);\n    this.type = 'child1'\n  }\n  console.log(new Child1);\n\n\n> 这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。\n\n\n# 6.2 方式2: 借助原型链\n\n function Parent2() {\n    this.name = 'parent2';\n    this.play = [1, 2, 3]\n  }\n  function Child2() {\n    this.type = 'child2';\n  }\n  Child2.prototype = new Parent2();\n\n  console.log(new Child2());\n\n\n看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：\n\nvar s1 = new Child2();\nvar s2 = new Child2();\ns1.play.push(4);\nconsole.log(s1.play, s2.play);\n\n\n可以看到控制台：\n\n\n\n> 明明我只改变了s1的play属性，为什么s2也跟着变了呢？很简单，因为两个实例使用的是同一个原型对象。\n\n那么还有更好的方式么？\n\n\n# 6.3 方式3：将前两种组合\n\n  function Parent3 () {\n    this.name = 'parent3';\n    this.play = [1, 2, 3];\n  }\n  function Child3() {\n    Parent3.call(this);\n    this.type = 'child3';\n  }\n  Child3.prototype = new Parent3();\n  var s3 = new Child3();\n  var s4 = new Child3();\n  s3.play.push(4);\n  console.log(s3.play, s4.play);\n\n\n可以看到控制台：\n\n\n\n> 之前的问题都得以解决。但是这里又徒增了一个新问题，那就是Parent3的构造函数会多执行了一次（Child3.prototype = new Parent3();）。这是我们不愿看到的。那么如何解决这个问题？\n\n\n# 6.4 方式4: 组合继承的优化1\n\n  function Parent4 () {\n    this.name = 'parent4';\n    this.play = [1, 2, 3];\n  }\n  function Child4() {\n    Parent4.call(this);\n    this.type = 'child4';\n  }\n  Child4.prototype = Parent4.prototype;\n\n\n这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下：\n\nvar s3 = new Child4();\nvar s4 = new Child4();\nconsole.log(s3)\n\n\n\n\n> 子类实例的构造函数是Parent4，显然这是不对的，应该是Child4。\n\n\n# 6.5 方式5(最推荐使用): 组合继承的优化2\n\n function Parent5 () {\n    this.name = 'parent5';\n    this.play = [1, 2, 3];\n  }\n  function Child5() {\n    Parent5.call(this);\n    this.type = 'child5';\n  }\n  Child5.prototype = Object.create(Parent5.prototype);\n  Child5.prototype.constructor = Child5;\n\n\n这是最推荐的一种方式，接近完美的继承，它的名字也叫做寄生组合继承。\n\n\n# 6.6 ES6的extends被编译后的JavaScript代码\n\n> ES6的代码最后都是要在浏览器上能够跑起来的，这中间就利用了babel这个编译工具，将ES6的代码编译成ES5让一些不支持新语法的浏览器也能运行。\n\n那最后编译成了什么样子呢？\n\nfunction _possibleConstructorReturn(self, call) {\n    // ...\n    return call && (typeof call === 'object' || typeof call === 'function') ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n    // ...\n    //看到没有\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n\nvar Parent = function Parent() {\n    // 验证是否是 Parent 构造出来的 this\n    _classCallCheck(this, Parent);\n};\n\nvar Child = (function (_Parent) {\n    _inherits(Child, _Parent);\n\n    function Child() {\n        _classCallCheck(this, Child);\n\n        return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).apply(this, arguments));\n    }\n\n    return Child;\n}(Parent));\n\n\n> 核心是_inherits函数，可以看到它采用的依然也是第五种方式————寄生组合继承方式，同时证明了这种方式的成功。不过这里加了一个Object.setPrototypeOf(subClass, superClass)，这是用来干啥的呢？\n\n答案是用来继承父类的静态方法。这也是原来的继承方式疏忽掉的地方。\n\n追问: 面向对象的设计一定是好的设计吗？\n\n> 不一定。从继承的角度说，这一设计是存在巨大隐患的。\n\n\n# 6.7 从设计思想上谈谈继承本身的问题\n\n假如现在有不同品牌的车，每辆车都有drive、music、addOil这三个方法。\n\nclass Car{\n  constructor(id) {\n    this.id = id;\n  }\n  drive(){\n    console.log(\"wuwuwu!\");\n  }\n  music(){\n    console.log(\"lalala!\")\n  }\n  addOil(){\n    console.log(\"哦哟！\")\n  }\n}\nclass otherCar extends Car{}\n\n\n现在可以实现车的功能，并且以此去扩展不同的车。\n\n但是问题来了，新能源汽车也是车，但是它并不需要addOil(加油)。\n\n如果让新能源汽车的类继承Car的话，也是有问题的，俗称\"大猩猩和香蕉\"的问题。大猩猩手里有香蕉，但是我现在明明只需要香蕉，却拿到了一只大猩猩。也就是说加油这个方法，我现在是不需要的，但是由于继承的原因，也给到子类了。\n\n> 继承的最大问题在于：无法决定继承哪些属性，所有属性都得继承。\n\n当然你可能会说，可以再创建一个父类啊，把加油的方法给去掉，但是这也是有问题的，一方面父类是无法描述所有子类的细节情况的，为了不同的子类特性去增加不同的父类，代码势必会大量重复，另一方面一旦子类有所变动，父类也要进行相应的更新，代码的耦合性太高，维护性不好。\n\n那如何来解决继承的诸多问题呢？\n\n> 用组合，这也是当今编程语法发展的趋势，比如golang完全采用的是面向组合的设计方式。\n\n顾名思义，面向组合就是先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类。\n\nfunction drive(){\n  console.log(\"wuwuwu!\");\n}\nfunction music(){\n  console.log(\"lalala!\")\n}\nfunction addOil(){\n  console.log(\"哦哟！\")\n}\n\nlet car = compose(drive, music, addOil);\nlet newEnergyCar = compose(drive, music);\n\n\n> 代码干净，复用性也很好。这就是面向组合的设计方式。\n\n\n# 6.8 继承-简版\n\n> 在 ES5 中，我们可以使用如下方式解决继承的问题\n\nfunction Super() {}\nSuper.prototype.getNumber = function() {\n  return 1\n}\n\nfunction Sub() {}\nlet s = new Sub()\nSub.prototype = Object.create(Super.prototype, {\n  constructor: {\n    value: Sub,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  }\n})\n\n\n * 以上继承实现思路就是将子类的原型设置为父类的原型\n * 在 ES6 中，我们可以通过 class 语法轻松解决这个问题\n\nclass MyDate extends Date {\n  test() {\n    return this.getTime()\n  }\n}\nlet myDate = new MyDate()\nmyDate.test()\n\n\n * 但是 ES6 不是所有浏览器都兼容，所以我们需要使用 Babel 来编译这段代码。\n\n * 如果你使用编译过得代码调用 myDate.test()你会惊奇地发现出现了报错\n\n> 因为在 JS 底层有限制，如果不是由 Date构造出来的实例的话，是不能调用 Date 里的函数的。所以这也侧面的说明了：ES6 中的 class 继承与 ES5 中的一般继承写法是不同的。\n\n * 既然底层限制了实例必须由 Date 构造出来，那么我们可以改变下思路实现继承\n\nfunction MyData() {\n\n}\nMyData.prototype.test = function () {\n  return this.getTime()\n}\nlet d = new Date()\nObject.setPrototypeOf(d, MyData.prototype)\nObject.setPrototypeOf(MyData.prototype, Date.prototype)\n\n\n * 以上继承实现思路：先创建父类实例 => 改变实例原先的 _proto__转而连接到子类的 prototype=> 子类的 prototype 的 __proto__ 改为父类的 prototype。\n\n * 通过以上方法实现的继承就可以完美解决 JS 底层的这个限制\n\n\n# 7 this\n\n> 我们先来看几个函数调用的场景\n\nfunction foo() {\n  console.log(this.a)\n}\nvar a = 1\nfoo()\n\nconst obj = {\n  a: 2,\n  foo: foo\n}\nobj.foo()\n\nconst c = new foo()\n\n\n * 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是window\n\n * 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象\n\n * 对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this\n\n> 说完了以上几种情况，其实很多代码中的 this 应该就没什么问题了，下面让我们看看箭头函数中的 this\n\nfunction a() {\n  return () => {\n    return () => {\n      console.log(this)\n    }\n  }\n}\nconsole.log(a()()())\n\n\n * 首先箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外对箭头函数使用 bind这类函数是无效的。\n\n * 最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。\n\n * 那么说到 bind，不知道大家是否考虑过，如果对一个函数进行多次 bind，那么上下文会是什么呢？\n\nlet a = {}\nlet fn = function () { console.log(this) }\nfn.bind().bind(a)() // => ?\n\n\n> 如果你认为输出结果是 a，那么你就错了，其实我们可以把上述代码转换成另一种形式\n\n// fn.bind().bind(a) 等于\nlet fn2 = function fn1() {\n  return function() {\n    return fn.apply()\n  }.apply(a)\n}\nfn2()\n\n\n> 可以从上述代码中发现，不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window\n\nlet a = { name: 'poetries' }\nfunction foo() {\n  console.log(this.name)\n}\nfoo.bind(a)() // => 'poetries'\n\n\n> 以上就是 this 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 this 最终指向哪里。\n\n> 首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。\n\n\n\n总结\n\n> this执行主体，谁把它执行的和在哪创建的在哪执行的都没有必然的关系\n\n * 函数执行，看方法前面是否有点，没有点this是window(严格模式下是undefined)，有点，点前面是谁·this·就是谁\n\n * 给当前元素的某个事件行为绑定方法，当事件行为触发，方法中的this是当前元素本身（排除attachEvent）\n\n * 构造函数体中this是当前类的实例\n\n * 箭头函数中没有执行主体，所用到的this都是所处上下文中的this\n\n * 可以基于Function.prototype上的call/apply/bind改变this指向\n\n\n# 8 内存机制\n\n> 网上的资料基本是这样说的: 基本数据类型用栈存储，引用数据类型用堆存储。\n\n看起来没有错误，但实际上是有问题的。可以考虑一下闭包的情况，如果变量存在栈中，那函数调用完栈顶空间销毁，闭包变量不就没了吗？\n\n其实还是需要补充一句:\n\n> 闭包变量是存在堆内存中的。\n\n具体而言，以下数据类型存储在栈中:\n\n * boolean\n\n * null\n\n * undefined\n\n * number\n\n * string\n\n * symbol\n\n * bigint\n\n而所有的对象数据类型存放在堆中。\n\n> 值得注意的是，对于赋值操作，原始类型的数据直接完整地复制变量值，对象数据类型的数据则是复制引用地址。\n\n因此会有下面的情况:\n\nlet obj = { a: 1 };\nlet newObj = obj;\nnewObj.a = 2;\nconsole.log(obj.a);//变成了2\n\n\n * 之所以会这样，是因为 obj 和 newObj 是同一份堆空间的地址，改变newObj，等于改变了共同的堆内存，这时候通过 obj 来获取这块内存的值当然会改变。 当然，你可能会问: 为什么不全部用栈来保存呢？\n * 首先，对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能。举个例子:\n\n当然，你可能会问: 为什么不全部用栈来保存呢？\n\n首先，对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能。举个例子:\n\nfunction f(a) {\n  console.log(a);\n}\n\nfunction func(a) {\n  f(a);\n}\n\nfunc(1);\n\n\n * 假设用ESP指针来保存当前的执行状态，在系统栈中会产生如下的过程：\n * 调用func, 将 func 函数的上下文压栈，ESP指向栈顶。\n * 执行func，又调用f函数，将 f 函数的上下文压栈，ESP 指针上移。\n * 执行完 f 函数，将ESP 下移，f函数对应的栈顶空间被回收。\n * 执行完 func，ESP 下移，func对应的空间被回收。\n\n图示如下:\n\n\n\n * 因此你也看到了，如果采用栈来存储相对基本类型更加复杂的对象数据，那么切换上下文的开销将变得巨大！\n * 不过堆内存虽然空间大，能存放大量的数据，但与此同时垃圾内存的回收会带来更大的开销\n\n\n# 9 执行上下文\n\n> 当执行 JS 代码时，会产生三种执行上下文\n\n * 全局执行上下文\n * 函数执行上下文\n * eval 执行上下文\n\n> 每个执行上下文中都有三个重要的属性\n\n * 变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问\n\n * 作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定了）\n\n * this\n\nvar a = 10\nfunction foo(i) {\n  var b = 20\n}\nfoo()\n\n\n> 对于上述代码，执行栈中有两个上下文：全局上下文和函数 foo 上下文。\n\nstack = [\n    globalContext,\n    fooContext\n]\n\n\n> 对于全局上下文来说，VO大概是这样的\n\nglobalContext.VO === globe\nglobalContext.VO = {\n    a: undefined,\n\tfoo: <Function>,\n}\n\n\n> 对于函数 foo 来说，VO 不能访问，只能访问到活动对象（AO）\n\nfooContext.VO === foo.AO\nfooContext.AO {\n    i: undefined,\n\tb: undefined,\n    arguments: <>\n}\n// arguments 是函数独有的对象(箭头函数没有)\n// 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素\n// 该对象中的 `callee` 属性代表函数本身\n// `caller` 属性代表函数的调用者\n\n\n> 对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过 [[Scope]]属性查找上级变量\n\nfooContext.[[Scope]] = [\n    globalContext.VO\n]\nfooContext.Scope = fooContext.[[Scope]] + fooContext.VO\nfooContext.Scope = [\n    fooContext.VO,\n    globalContext.VO\n]\n\n\n * 对于非匿名的立即执行函数需要注意以下一点\n\nvar foo = 1\n(function foo() {\n    foo = 10\n    console.log(foo)\n}()) // -> ƒ foo() { foo = 10 ; console.log(foo) }\n\n\n * 因为当 JS 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 foo，但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。\n\nspecialObject = {};\n\nScope = specialObject + Scope;\n\nfoo = new FunctionExpression;\nfoo.[[Scope]] = Scope;\nspecialObject.foo = foo; // {DontDelete}, {ReadOnly}\n\ndelete Scope[0]; // remove specialObject from the front of scope chain\n\n\n小结\n\n> 执行上下文可以简单理解为一个对象:\n\n它包含三个部分:\n\n * 变量对象(VO)\n * 作用域链(词法作用域)\n * this指向\n\n它的类型:\n\n * 全局执行上下文\n * 函数执行上下文\n * eval执行上下文\n\n代码执行过程:\n\n * 创建 全局上下文 (global EC)\n\n * 全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被push到执行栈顶层\n\n * 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起\n\n * 函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行\n\n\n# 10 变量提升\n\n> 当执行 JS 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境。\n\nb() // call b\nconsole.log(a) // undefined\n\nvar a = 'Hello world'\n\nfunction b() {\n    console.log('call b')\n}\n\n\n * 想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用\n\n * 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升\n\nb() // call b second\n\nfunction b() {\n    console.log('call b fist')\n}\nfunction b() {\n    console.log('call b second')\n}\nvar b = 'Hello world'\n\n\n> var 会产生很多错误，所以在 ES6中引入了 let。let不能在声明前使用，但是这并不是常说的 let 不会提升，let提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用\n\n\n# 11 模块化\n\n> 模块化开发在现代开发中已是必不可少的一部分，它大大提高了项目的可维护、可拓展和可协作性。通常，我们 在浏览器中使用 ES6 的模块化支持，在 Node 中使用 commonjs 的模块化支持。\n\n分类:\n\n * es6: import / export\n\n * commonjs: require / module.exports / exports\n\n * amd: require / defined\n\nrequire与import的区别\n\n * require支持 动态导入，import不支持，正在提案 (babel 下可支持)\n\n * require是 同步 导入，import属于 异步 导入\n\n * require是 值拷贝，导出值变化不会影响导入值；import指向 内存地址，导入值会随导出值而变化\n\n\n# 12 异步编程\n\n> 这部分着重要理解 Promise、async awiat、event loop 等\n\n\n# 12.1 浏览器中的Event loop\n\n简版总结\n\nJavaScript 最早是用于写网页交互逻辑的，为了避免多线程同时修改 dom 的同步问题，设计成了单线程，又为了解决单线程的阻塞问题，加了一层调度逻辑，也就是 Loop 循环和 Task 队列，把阻塞的逻辑放到其他线程跑，从而支持了异步。然后为了支持高优先级的任务调度，又引入了微任务队列，这就是浏览器的 Event Loop 机制：每次执行一个宏任务，然后执行所有微任务\n\n\n\n正确的一次 Event loop 顺序是这样的\n\n * 执行同步代码，这属于宏任务\n * 执行栈为空，查询是否有微任务需要执行\n * 执行所有微任务\n * 必要的话渲染 UI\n * 然后开始下一轮 Event loop，执行宏任务中的异步代码\n\n> 通过 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的响应界面响应，我们可以把操作 DOM 放入微任务中\n\n推荐一个可以在线看代码流程的网站：loupe (opens new window)，看一下这个学习视频(opens new window)\n\n> JavaScript 是用于实现网页交互逻辑的，涉及到 dom 操作，如果多个线程同时操作需要做同步互斥的处理，为了简化就设计成了单线程，但是如果单线程的话，遇到定时逻辑、网络请求又会阻塞住。怎么办呢？可以加一层调度逻辑。把 JS 代码封装成一个个的任务，放在一个任务队列中，主线程就不断的取任务执行就好了。\n\n每次取任务执行，都会创建新的调用栈。\n\n\n\n> 其中，定时器、网络请求其实都是在别的线程执行的，执行完了之后在任务队列里放个任务，告诉主线程可以继续往下执行了\n\n\n\n * 因为这些异步任务是在别的线程执行完，然后通过任务队列通知下主线程，是一种事件机制，所以这个循环叫做 Event Loop\n\n * 这些在其他线程执行的异步任务包括定时器（setTimeout、setInterval），UI 渲染、网络请求（XHR 或 fetch）。\n\n * 但是，现在的 Event Loop 有个严重的问题，没有优先级的概念，只是按照先后顺序来执行，那如果有高优先级的任务就得不到及时的执行了。所以，得设计一套插队机制。\n\n * 那就搞一个高优先级的任务队列就好了，每执行完一个普通任务，都去把所有高优先级的任务给执行完，之后再去执行普通任务。\n\n\n\n> 有了插队机制之后，高优任务就能得到及时的执行。这就是现在浏览器的 Event Loop，其中普通任务叫做 MacroTask（宏任务），高优任务叫做 MicroTask（微任务）\n\n * 宏任务包括：setTimeout、setInterval、requestAnimationFrame、Ajax、fetch、script（浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务） 标签的代码\n * 微任务包括：Promise.then、MutationObserver、Object.observe\n\n怎么理解宏微任务的划分呢？\n\n * 定时器、网络请求这种都是在别的线程跑完之后通知主线程的普通异步逻辑，所以都是宏任务\n * 高优任务的这三种也很好理解，MutationObserver 和 Object.observe 都是监听某个对象的变化的，变化是很瞬时的事情，肯定要马上响应，不然可能又变了，Promise 是组织异步流程的，异步结束调用 then 也是很高优的\n\n> 这就是浏览器里的 Event Loop 的设计：设计 Loop 机制和 Task 队列是为了支持异步，解决逻辑执行阻塞主线程的问题，设计 MicroTask 队列的插队机制是为了解决高优任务尽早执行的问题\n\n但是后来，JS 的执行环境不只是浏览器一种了，还有了 Node.js，它同样也要解决这些问题，但是它设计出来的 Event Loop 更细致一些\n\n例子1\n\nsetTimeout(function() {\n  console.log(1)\n}, 0);\nnew Promise(function(resolve, reject) {\n  console.log(2);\n  resolve()\n}).then(function() {\n  console.log(3)\n});\nprocess.nextTick(function () {\n  console.log(4)\n})\nconsole.log(5)\n\n\n * 第一轮：主线程开始执行，遇到setTimeout，将setTimeout的回调函数丢到宏任务队列中，在往下执行new Promise立即执行，输出2，then的回调函数丢到微任务队列中，再继续执行，遇到process.nextTick，同样将回调函数扔到微任务队列，再继续执行，输出5，当所有同步任务执行完成后看有没有可以执行的微任务，发现有then函数和nextTick两个微任务，先执行哪个呢？process.nextTick指定的异步任务总是发生在所有异步任务之前，因此先执行process.nextTick输出4然后执行then函数输出3，第一轮执行结束。\n\n * 第二轮：从宏任务队列开始，发现setTimeout回调，输出1执行完毕，因此结果是25431\n\n例子2\n\nconsole.log('script start');\n\nsetTimeout(function() {\n  console.log('setTimeout');\n}, 0);\n\nnew Promise((resolve) => {\n    console.log('Promise')\n    resolve()\n}).then(function() {\n  console.log('promise1');\n}).then(function() {\n  console.log('promise2');\n});\n\nconsole.log('script end');\n// script start => Promise => script end => promise1 => promise2 => setTimeout\n\n\n> 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务\n\n\n# 12.2 Node 中的 Event loop\n\n首先从优先级出发理解Node EventLoop\n\n> Node.js 是一个新的 JS 运行环境，它同样要支持异步逻辑，包括定时器、IO、网络请求，很明显，也可以用 Event Loop 那一套来跑\n\n但是呢，浏览器那套 ·Event Loop· 就是为浏览器设计的，对于做高性能服务器来说，那种设计还是有点粗糙了\n\n哪里粗糙呢？\n\n * 浏览器的 Event Loop 只分了两层优先级，一层是宏任务，一层是微任务。但是宏任务之间没有再划分优先级，微任务之间也没有再划分优先级。\n\n * 而 Node.js 任务宏任务之间也是有优先级的，比如定时器 Timer 的逻辑就比 IO 的逻辑优先级高，因为涉及到时间，越早越准确；而 close 资源的处理逻辑优先级就很低，因为不 close 最多多占点内存等资源，影响不大。\n\n * 于是就把宏任务队列拆成了五个优先级：Timers、Pending、Poll、Check、Close\n\n\n\n解释一下这五种宏任务：\n\n * Timers Callback： 涉及到时间，肯定越早执行越准确，所以这个优先级最高很容易理解。\n\n * Pending Callback：处理网络、IO 等异常时的回调，有的 *niux 系统会等待发生错误的上报，所以得处理下。\n\n * Poll Callback：处理 IO 的 data，网络的 connection，服务器主要处理的就是这个。\n\n * Check Callback：执行 setImmediate 的回调，特点是刚执行完 IO 之后就能回调这个。\n\n * Close Callback：关闭资源的回调，晚点执行影响也不到，优先级最低。\n\n所以呢，Node.js 的 Event Loop 就是这样跑的了：\n\n\n\n还有一点不同要特别注意：\n\n> Node.js 的 Event Loop 并不是浏览器那种一次执行一个宏任务，然后执行所有的微任务，而是执行完一定数量的 Timers 宏任务，再去执行所有微任务，然后再执行一定数量的 Pending 的宏任务，然后再去执行所有微任务，剩余的 Poll、Check、Close 的宏任务也是这样。（订正：node 11 之前是这样，node 11 之后改为了每个宏任务都执行所有微任务了）\n\n为什么这样呢？\n\n> 其实按照优先级来看很容易理解：假设浏览器里面的宏任务优先级是 1，所以是按照先后顺序依次执行，也就是一个宏任务，所有的微任务，再一个宏任务，再所有的微任务。而 Node.js 的 宏任务之间也是有优先级的，所以 Node.js 的 Event Loop 每次都是把当前优先级的所有宏任务跑完再去跑微任务，然后再跑下一个优先级的宏任务\n\n\n\n * 也就是是一定数量的 Timers 宏任务，再所有微任务，再一定数量的 Pending Callback 宏任务，再所有微任务这样。\n\n * 为什么说是一定数量呢？因为如果某个阶段宏任务太多，下个阶段就一直执行不到了，所以有个上限的限制，剩余的下个 Event Loop 再继续执行。 除了宏任务有优先级，微任务也划分了优先级，多了一个 process.nextTick 的高优先级微任务，在所有的普通微任务之前来跑。\n\n\n\nNode.js 的 Event Loop 的完整流程就是这样的\n\n * Timers 阶段：执行一定数量的定时器，也就是 setTimeout、setInterval 的 callback，太多的话留到下次执行\n\n * Pending 阶段：执行一定数量的 IO 和网络的异常回调，太多的话留到下次执行\n\n * Idle/Prepare 阶段：内部用的一个阶段\n\n * Poll 阶段：执行一定数量的文件的 data 回调、网络的 connection 回调，太多的话留到下次执行。如果没有 IO 回调并且也没有 timers、check 阶段的回调要处理，就阻塞在这里等待 IO 事件\n\n * Check 阶段：执行一定数量的 setImmediate 的 callback，太多的话留到下次执行。\n\n * Close 阶段：执行一定数量的 close 事件的 callback，太多的话留到下次执行。\n\n比起浏览器里的 Event Loop，明显复杂了很多\n\n> Node.js 对宏任务做了优先级划分，从高到低分别是 Timers、Pending、Poll、Check、Close 这 5 种，也对微任务做了划分，也就是 nextTick 的微任务和其他微任务。执行流程是先执行完当前优先级的一定数量的宏任务（剩下的留到下次循环），然后执行 process.nextTick 的微任务，再执行普通微任务，之后再执行下个优先级的一定数量的宏任务。这样不断循环。其中还有一个 Idle/Prepare 阶段是给 Node.js 内部逻辑用的，不需要关心\n\n * 改变了浏览器 Event Loop 里那种一次执行一个宏任务的方式，可以让高优先级的宏任务更早的得到执行，但是也设置了个上限，避免下个阶段一直得不到执行。\n\n * 还有一个特别要注意的点，就是 poll 阶段：如果执行到 poll 阶段，发现 poll 队列为空并且 timers 队列、check 队列都没有任务要执行，那么就阻塞的等在这里等 IO 事件，而不是空转。 这点设计也是因为服务器主要是处理 IO 的，阻塞在这里可以更早的响应 IO。\n\n完整的 Node.js 的 Event Loop 是这样的\n\n\n\n对比下浏览器的 Event Loop\n\n\n\n两个 JS 运行环境的 Event Loop 整体设计思路是差不多的，只不过 Node.js 的 Event Loop 对宏任务和微任务做了更细粒度的划分，也很容易理解，毕竟 Node.js 面向的环境和浏览器不同，更重要的是服务端对性能的要求会更高\n\n总结\n\n * Node.js也是一个 JS 运行环境，想支持异步同样要用 Event Loop，只不过服务端环境更复杂，对性能要求更高，所以 Node.js 对宏微任务都做了更细粒度的优先级划分\n\n * Node.js 里划分了 5 种宏任务，分别是 Timers、Pending、Poll、Check、Close。又划分了 2 种微任务，分别是 process.nextTick 的微任务和其他的微任务。\n\n * Node.js 的 Event Loop 流程是执行当前阶段的一定数量的宏任务（剩余的到下个循环执行），然后执行所有微任务，一共有 Timers、Pending、Idle/Prepare、Poll、Check、Close 6 个阶段。（订正：node 11 之前是这样，node 11 之后改为了每个宏任务都执行所有微任务了）其中 Idle/Prepare 阶段是 Node.js 内部用的，不用关心。\n\n * 特别要注意的是 Poll 阶段，如果执行到这里，poll 队列为空并且 timers、check 队列也为空，就一直阻塞在这里等待 IO，直到 timers、check 队列有回调再继续 loop。\n\n * Event Loop 是 JS 为了支持异步和任务优先级而设计的一套调度逻辑，针对浏览器、Node.js 等不同环境有不同的设计（主要是任务优先级的划分粒度不同），Node.js 面对的环境更复杂、对性能要求更高，所以 Event Loop 设计的更复杂一些。\n\n> 当 Node.js 开始启动时，会初始化一个 Eventloop，处理输入的代码脚本，这些脚本会进行 API 异步调用，process.nextTick() 方法会开始处理事件循环。下面就是 Node.js 官网提供的 Eventloop 事件循环参考流程\n\n * Node 中的 Event loop 和浏览器中的不相同。\n\n * Node 的 Event loop 分为6个阶段，它们会按照顺序反复运行\n\n\n\n * 每次执行执行一个宏任务后会清空微任务（执行顺序和浏览器一致，在node11版本以上）\n\n * process.nextTick node中的微任务，当前执行栈的底部，优先级比promise要高\n\n> 整个流程分为六个阶段，当这六个阶段执行完一次之后，才可以算得上执行了一次 Eventloop 的循环过程。我们来分别看下这六个阶段都做了哪些事情。\n\n * Timers 阶段：这个阶段执行 setTimeout 和 setInterval的回调函数，简单理解就是由这两个函数启动的回调函数。\n\n * I/O callbacks 阶段：这个阶段主要执行系统级别的回调函数，比如 TCP 连接失败的回调。\n\n * idle，prepare 阶段：仅系统内部使用，你只需要知道有这 2 个阶段就可以。\n\n * poll 阶段：poll 阶段是一个重要且复杂的阶段，几乎所有 I/O 相关的回调，都在这个阶段执行（除了setTimeout、setInterval、setImmediate 以及一些因为 exception 意外关闭产生的回调）。检索新的 I/O 事件，执行与 I/O 相关的回调，其他情况Node.js` 将在适当的时候在此阻塞。这也是最复杂的一个阶段，所有的事件循环以及回调处理都在这个阶段执行。这个阶段的主要流程如下图所示。\n\n\n\n * check 阶段：setImmediate() 回调函数在这里执行，setImmediate 并不是立马执行，而是当事件循环 poll 中没有新的事件处理时就执行该部分，如下代码所示。\n\nconst fs = require('fs');\nsetTimeout(() => { // 新的事件循环的起点\n    console.log('1'); \n}, 0);\nsetImmediate( () => {\n    console.log('setImmediate 1');\n});\n/// fs.readFile 将会在 poll 阶段执行\nfs.readFile('./test.conf', {encoding: 'utf-8'}, (err, data) => {\n    if (err) throw err;\n    console.log('read file success');\n});\n/// 该部分将会在首次事件循环中执行\nPromise.resolve().then(()=>{\n    console.log('poll callback');\n});\n// 首次事件循环执行\nconsole.log('2');\n\n\n在这一代码中有一个非常奇特的地方，就是 setImmediate 会在 setTimeout 之后输出。有以下几点原因：\n\n * setTimeout 如果不设置时间或者设置时间为 0，则会默认为 1ms\n\n * 主流程执行完成后，超过 1ms 时，会将 setTimeout 回调函数逻辑插入到待执行回调函数 poll 队列中；\n\n * 由于当前 poll 队列中存在可执行回调函数，因此需要先执行完，待完全执行完成后，才会执行check：setImmediate。\n\n * 因此这也验证了这句话，先执行回调函数，再执行 setImmediate\n\n * close callbacks 阶段：执行一些关闭的回调函数，如 socket.on('close', ...)\n\n> 除了把 Eventloop 的宏任务细分到不同阶段外。node 还引入了一个新的任务队列 Process.nextTick()\n\n可以认为，Process.nextTick() 会在上述各个阶段结束时，在进入下一个阶段之前立即执行（优先级甚至超过 microtask 队列）\n\n事件循环的主要包含微任务和宏任务。具体是怎么进行循环的呢\n\n\n\n * 微任务：在 Node.js 中微任务包含 2 种——process.nextTick 和 Promise。微任务在事件循环中优先级是最高的，因此在同一个事件循环中有其他任务存在时，优先执行微任务队列。并且process.nextTick 和 Promise也存在优先级，process.nextTick 高于 Promise\n\n * 宏任务：在 Node.js 中宏任务包含 4 种——setTimeout、setInterval、setImmediate 和 I/O。宏任务在微任务执行之后执行，因此在同一个事件循环周期内，如果既存在微任务队列又存在宏任务队列，那么优先将微任务队列清空，再执行宏任务队列\n\n我们可以看到有一个核心的主线程，它的执行阶段主要处理三个核心逻辑。\n\n * 同步代码。\n * 将异步任务插入到微任务队列或者宏任务队列中。\n * 执行微任务或者宏任务的回调函数。在主线程处理回调函数的同时，也需要判断是否插入微任务和宏任务。根据优先级，先判断微任务队列是否存在任务，存在则先执行微任务，不存在则判断在宏任务队列是否有任务，有则执行。\n\nconst fs = require('fs');\n// 首次事件循环执行\nconsole.log('start');\n/// 将会在新的事件循环中的阶段执行\nfs.readFile('./test.conf', {encoding: 'utf-8'}, (err, data) => {\n    if (err) throw err;\n    console.log('read file success');\n});\nsetTimeout(() => { // 新的事件循环的起点\n    console.log('setTimeout'); \n}, 0);\n/// 该部分将会在首次事件循环中执行\nPromise.resolve().then(()=>{\n    console.log('Promise callback');\n});\n/// 执行 process.nextTick\nprocess.nextTick(() => {\n    console.log('nextTick callback');\n});\n// 首次事件循环执行\nconsole.log('end');\n\n\n分析下上面代码的执行过程\n\n * 第一个事件循环主线程发起，因此先执行同步代码，所以先输出 start，然后输出 end\n\n * 第一个事件循环主线程发起，因此先执行同步代码，所以先输出 start，然后输出 end；\n\n * 再从上往下分析，遇到微任务，插入微任务队列，遇到宏任务，插入宏任务队列，分析完成后，微任务队列包含：Promise.resolve 和 process.nextTick，宏任务队列包含：fs.readFile 和 setTimeout；\n\n * 先执行微任务队列，但是根据优先级，先执行 process.nextTick 再执行 Promise.resolve，所以先输出 nextTick callback 再输出 Promise callback；\n\n * 再执行宏任务队列，根据宏任务插入先后顺序执行 setTimeout 再执行 fs.readFile，这里需要注意，先执行 setTimeout 由于其回调时间较短，因此回调也先执行，并非是 setTimeout 先执行所以才先执行回调函数，但是它执行需要时间肯定大于 1ms，所以虽然 fs.readFile 先于setTimeout 执行，但是 setTimeout 执行更快，所以先输出 setTimeout ，最后输出 read file success。\n\n// 输出结果\nstart\nend\nnextTick callback\nPromise callback\nsetTimeout\nread file success\n\n\n\n\n> 当微任务和宏任务又产生新的微任务和宏任务时，又应该如何处理呢？如下代码所示：\n\nconst fs = require('fs');\nsetTimeout(() => { // 新的事件循环的起点\n    console.log('1'); \n    fs.readFile('./config/test.conf', {encoding: 'utf-8'}, (err, data) => {\n        if (err) throw err;\n        console.log('read file sync success');\n    });\n}, 0);\n/// 回调将会在新的事件循环之前\nfs.readFile('./config/test.conf', {encoding: 'utf-8'}, (err, data) => {\n    if (err) throw err;\n    console.log('read file success');\n});\n/// 该部分将会在首次事件循环中执行\nPromise.resolve().then(()=>{\n    console.log('poll callback');\n});\n// 首次事件循环执行\nconsole.log('2');\n\n\n在上面代码中，有 2 个宏任务和 1 个微任务，宏任务是 setTimeout 和 fs.readFile，微任务是 Promise.resolve。\n\n * 整个过程优先执行主线程的第一个事件循环过程，所以先执行同步逻辑，先输出 2。\n\n * 接下来执行微任务，输出 poll callback。\n\n * 再执行宏任务中的 fs.readFile 和 setTimeout，由于 fs.readFile 优先级高，先执行 fs.readFile。但是处理时间长于 1ms，因此会先执行 setTimeout 的回调函数，输出 1。这个阶段在执行过程中又会产生新的宏任务 fs.readFile，因此又将该 fs.readFile 插入宏任务队列\n\n * 最后由于只剩下宏任务了 fs.readFile，因此执行该宏任务，并等待处理完成后的回调，输出 read file sync success。\n\n// 结果\n2\npoll callback\n1\nread file success\nread file sync success\n\n\nProcess.nextick() 和 Vue 的 nextick\n\n\n\n> Node.js 和浏览器端宏任务队列的另一个很重要的不同点是，浏览器端任务队列每轮事件循环仅出队一个回调函数接着去执行微任务队列；而 Node.js 端只要轮到执行某个宏任务队列，则会执行完队列中所有的当前任务，但是当前轮次新添加到队尾的任务则会等到下一轮次才会执行。\n\nsetTimeout(() => {\n    console.log('setTimeout');\n}, 0);\nsetImmediate(() => {\n    console.log('setImmediate');\n})\n// 这里可能会输出 setTimeout，setImmediate\n// 可能也会相反的输出，这取决于性能\n// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate\n// 否则会执行 setTimeout\n\n\n> 上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行\n\nsetTimeout(()=>{\n    console.log('timer1')\n\n    Promise.resolve().then(function() {\n        console.log('promise1')\n    })\n}, 0)\n\nsetTimeout(()=>{\n    console.log('timer2')\n\n    Promise.resolve().then(function() {\n        console.log('promise2')\n    })\n}, 0)\n\n// 以上代码在浏览器和 node 中打印情况是不同的\n// 浏览器中一定打印 timer1, promise1, timer2, promise2\n// node 中可能打印 timer1, timer2, promise1, promise2\n// 也可能打印 timer1, promise1, timer2, promise2\n\n\n> Node 中的 process.nextTick 会先于其他 microtask 执行\n\n\n\nsetTimeout(() => {\n console.log(\"timer1\");\n\n Promise.resolve().then(function() {\n   console.log(\"promise1\");\n });\n}, 0);\n\n// poll阶段执行\nfs.readFile('./test',()=>{\n  // 在poll阶段里面 如果有setImmediate优先执行，setTimeout处于事件循环顶端 poll下面就是setImmediate\n  setTimeout(()=>console.log('setTimeout'),0)\n  setImmediate(()=>console.log('setImmediate'),0)\n})\n\nprocess.nextTick(() => {\n console.log(\"nextTick\");\n});\n// nextTick, timer1, promise1,setImmediate,setTimeout\n\n\n> 对于 microtask 来说，它会在以上每个阶段完成前清空 microtask 队列，下图中的 Tick 就代表了 microtask\n\n\n\n谁来启动这个循环过程，循环条件是什么？\n\n> 当 Node.js 启动后，会初始化事件循环，处理已提供的输入脚本，它可能会先调用一些异步的 API、调度定时器，或者 process.nextTick()，然后再开始处理事件循环。因此可以这样理解，Node.js 进程启动后，就发起了一个新的事件循环，也就是事件循环的起点。\n\n总结来说，Node.js 事件循环的发起点有 4 个：\n\n * Node.js 启动后；\n\n * setTimeout 回调函数；\n\n * setInterval 回调函数；\n\n * 也可能是一次 I/O 后的回调函数。\n\n无限循环有没有终点\n\n> 当所有的微任务和宏任务都清空的时候，虽然当前没有任务可执行了，但是也并不能代表循环结束了。因为可能存在当前还未回调的异步 I/O，所以这个循环是没有终点的，只要进程在，并且有新的任务存在，就会去执行\n\nNode.js 是单线程的还是多线程的？\n\n> 主线程是单线程执行的，但是 Node.js 存在多线程执行，多线程包括 setTimeout 和异步 I/O 事件。其实 Node.js 还存在其他的线程，包括垃圾回收、内存优化等\n\nEventLoop 对渲染的影响\n\n * 想必你之前在业务开发中也遇到过 requestIdlecallback 和 requestAnimationFrame，这两个函数在我们之前的内容中没有讲过，但是当你开始考虑它们在 Eventloop 的生命周期的哪一步触发，或者这两个方法的回调会在微任务队列还是宏任务队列执行的时候，才发现好像没有想象中那么简单。这两个方法其实也并不属于 JS 的原生方法，而是浏览器宿主环境提供的方法，因为它们牵扯到另一个问题：渲染。\n\n * 我们知道浏览器作为一个复杂的应用是多线程工作的，除了运行 JS 的线程外，还有渲染线程、定时器触发线程、HTTP 请求线程，等等。JS 线程可以读取并且修改 DOM，而渲染线程也需要读取 DOM，这是一个典型的多线程竞争临界资源的问题。所以浏览器就把这两个线程设计成互斥的，即同时只能有一个线程在执行\n\n * 渲染原本就不应该出现在 Eventloop 相关的知识体系里，但是因为 Eventloop 显然是在讨论 JS 如何运行的问题，而渲染则是浏览器另外一个线程的工作。但是 requestAnimationFrame的出现却把这两件事情给关联起来\n\n * 通过调用requestAnimationFrame我们可以在下次渲染之前执行回调函数。那下次渲染具体是哪个时间点呢？渲染和 Eventloop 有什么关系呢？\n   \n   * 简单来说，就是在每一次 Eventloop 的末尾，判断当前页面是否处于渲染时机，就是重新渲染\n\n * 有屏幕的硬件限制，比如 60Hz 刷新率，简而言之就是 1 秒刷新了 60 次，16.6ms 刷新一次。这个时候浏览器的渲染间隔时间就没必要小于 16.6ms，因为就算渲染了屏幕上也看不到。当然浏览器也不能保证一定会每 16.6ms 会渲染一次，因为还会受到处理器的性能、JavaScript 执行效率等其他因素影响。\n\n * 回到 requestAnimationFrame，这个 API 保证在下次浏览器渲染之前一定会被调用，实际上我们完全可以把它看成是一个高级版的 setInterval。它们都是在一段时间后执行回调，但是前者的间隔时间是由浏览器自己不断调整的，而后者只能由用户指定。这样的特性也决定了 requestAnimationFrame 更适合用来做针对每一帧来修改的动画效果\n\n * 当然 requestAnimationFrame 不是 Eventloop 里的宏任务，或者说它并不在 Eventloop 的生命周期里，只是浏览器又开放的一个在渲染之前发生的新的 hook。另外需要注意的是微任务的认知概念也需要更新，在执行 animation callback 时也有可能产生微任务（比如 promise 的 callback），会放到 animation queue 处理完后再执行。所以微任务并不是像之前说的那样在每一轮 Eventloop 后处理，而是在 JS 的函数调用栈清空后处理\n\n但是 requestIdlecallback 却是一个更好理解的概念。当宏任务队列中没有任务可以处理时，浏览器可能存在“空闲状态”。这段空闲时间可以被 requestIdlecallback 利用起来执行一些优先级不高、不必立即执行的任务，如下图所示：\n\n\n\n\n# 12.3 实现一个Promise A+ 规范\n\n> 最好是实现一遍 Promise A+ 规范，多少有点印象，当然面试官也不会叫你默写一个完整的出来，但是你起码要知道实现原理\n\n/**\n * Promises/A+规范 实现一个promise\n * https://promisesaplus.com/\n*/\n\nconst EMUM = {\n  PENDING: 'PENDING',\n  FULFILLED: 'FULFILLED',\n  REJECTED: 'REJECTED'\n}\n\n// x 返回值\n// promise2 then的时候new的promise\n// promise2的resolve, reject\nconst resolvePromise = (x, promise2, resolve, reject)=>{\n  // 解析promise的值解析promise2是成功还是失败 传递到下层then\n  if(x === promise2) {\n    reject(new TypeError('类型错误'))\n  }\n  // 这里的x如果是一个promise的话 可能是其他的promise，可能调用了成功 又调用了失败\n  // 防止resolve的时候 又throw err抛出异常到reject了\n  let called\n  // 如果x是promise 那么就采用他的状态\n  // 有then方法是promise\n  if(typeof x === 'object' && typeof x!== null || typeof x === 'function') {\n    // x是对象或函数\n    try {\n      let then = x.then // 缓存，不用多次取值\n      if(typeof then === 'function') {\n        // 是promise，调用then方法里面有this，需要传入this为x才能取到then方法里面的值this.value\n        then.call(x, y=>{// 成功\n          // y值可能也是一个promise 如resolve(new Promise()) 此时的y==new Promise()\n          // 递归解析y，直到拿到普通的值resolve(x出去)\n          if(called) return;\n          called = true;\n\n          resolvePromise(y, promise2, resolve, reject)\n        },r=>{// 一旦失败直接失败\n          if(called) return;\n          called = true;\n          reject(r)\n        })\n      } else {\n        // 普通对象不是promise\n        resolve(x)\n      }\n    } catch (e) {\n      // 对象取值可能报错，用defineProperty定义get 抛出异常\n      if(called) return;\n      called = true;\n      reject(e)\n    }\n  } else {\n    // x是普通值\n    resolve(x) // 直接成功\n  }\n  \n}\nclass myPromise {\n  constructor(executor) {\n    this.status = EMUM.PENDING // 当前状态\n    this.value = undefined // resolve接收值\n    this.reason = undefined // reject失败返回值\n\n    /**\n     * 同一个promise可以then多次(发布订阅模式)\n     * 调用then时 当前状态是等待态，需要将当前成功或失败的回调存放起来（订阅）\n     * 调用resolve时 将订阅函数进行执行（发布）\n    */\n    // 成功队列\n    this.onResolvedCallbacks = []\n    // 失败队列\n    this.onRejectedCallbacks = []\n    const resolve = value =>{\n      // 如果value是一个promise，需要递归解析\n      // 如 myPromise.resolve(new myPromise()) 需要解析value\n      if(value instanceof myPromise) {\n        // 不停的解析 直到值不是promise\n        return value.then(resolve,reject)\n      }\n\n      if(this.status === EMUM.PENDING) {\n        this.status = EMUM.FULFILLED\n        this.value = value\n\n        this.onResolvedCallbacks.forEach(fn=>fn())\n      }\n    }\n    const reject = reason =>{\n      if(this.status === EMUM.PENDING) {\n        this.status = EMUM.REJECTED\n        this.reason = reason\n\n        this.onRejectedCallbacks.forEach(fn=>fn())\n      }\n    }\n    try {\n      executor(resolve,reject)\n    } catch(e) {\n      reject(e)\n    }\n  }\n  then(onFulFilled, onRejected) {\n    // 透传 处理默认不传的情况\n    // new Promise((resolve,reject)=>{\n    //   resolve(1)\n    // }).then().then().then(d=>{})\n    // new Promise((resolve,reject)=>{\n    //   resolve(1)\n    // }).then(v=>v).then(v=>v).then(d=>{})\n    // new Promise((resolve,reject)=>{\n    //   reject(1)\n    // }).then().then().then(null, e=>{console.log(e)})\n    // new Promise((resolve,reject)=>{\n    //   reject(1)\n    // }).then(null,e=>{throw e}).then(null,e=>{throw e}).then(null,e=>{console.log(e)})\n    onFulFilled = typeof onFulFilled === 'function' ? onFulFilled : v => v\n    onRejected = typeof onRejected === 'function' ? onRejected : err => {throw err}\n\n    // 调用then 创建一个新的promise\n    let promise2 = new myPromise((resolve,reject)=>{\n      // 根据value判断是resolve 还是reject value也可能是promise\n      if(this.status === EMUM.FULFILLED) {\n        setTimeout(() => {\n          try {\n            // 成功回调结果\n            let x = onFulFilled(this.value)\n            // 解析promise\n            resolvePromise(x, promise2,resolve,reject)\n          } catch (error) {\n            reject(error)\n          }\n        }, 0);\n      }\n      if(this.status === EMUM.REJECTED) {\n        setTimeout(() => {\n          try {\n            let x = onRejected(this.reason)\n            // 解析promise\n            resolvePromise(x, promise2,resolve,reject)\n          } catch (error) {\n            reject(error)\n          }\n        }, 0);\n      }\n      // 用户还未调用resolve或reject方法\n      if(this.status === EMUM.PENDING) {\n        this.onResolvedCallbacks.push(()=>{\n          try {\n            let x = onFulFilled(this.value)\n            // 解析promise\n            resolvePromise(x, promise2,resolve,reject)\n          } catch (error) {\n            reject(error)\n          }\n        })\n        this.onRejectedCallbacks.push(()=>{\n          try {\n            let x = onRejected(this.reason)\n            // 解析promise\n            resolvePromise(x, promise2,resolve,reject)\n          } catch (error) {\n            reject(error)\n          }\n        })\n      }\n    })\n    \n    return promise2\n  }\n  catch(errCallback) {\n    // 等同于没有成功，把失败放进去而已\n    return this.then(null, errCallback)\n  }\n  // myPromise.resolve 具备等待功能的 如果参数的promise会等待promise解析完毕在向下执行\n  static resolve(val) {\n    return new myPromise((resolve,reject)=>{\n      resolve(val)\n    })\n  }\n  // myPromise.reject 直接将值返回\n  static reject(reason) {\n    return new myPromise((resolve,reject)=>{\n      reject(reason)\n    })\n  }\n  // finally传入的函数 无论成功或失败都执行\n  // Promise.reject(100).finally(()=>{console.log(1)}).then(d=>console.log('success',d)).catch(er=>console.log('faild',er))\n  // Promise.reject(100).finally(()=>new Promise()).then(d=>console.log(d)).catch(er=>)\n  finally(callback) {\n    return this.then((val)=>{\n      return myPromise.resolve(callback()).then(()=>val)\n    },(err)=>{\n      return myPromise.resolve(callback()).then(()=>{throw err})\n    })\n  }\n  // Promise.all\n  static all(values) {\n    return new myPromise((resolve,reject)=>{\n      let resultArr = []\n      let orderIndex = 0\n      const processResultByKey = (value,index)=>{\n        resultArr[index] = value \n        // 处理完全部\n        if(++orderIndex === values.length) {\n          resolve(resultArr) // 处理完成的结果返回去\n        }\n      }\n      for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        // 是promise\n        if(value && typeof value.then === 'function') {\n          value.then((val)=>{\n            processResultByKey(val,i)\n          },reject)\n        } else {\n          // 不是promise情况\n          processResultByKey(value,i)\n        }\n      }\n    })\n  }\n  static race(promises) {\n    // 采用最新成功或失败的作为结果\n    return new myPromise((resolve,reject)=>{\n      for (let i = 0; i < promises.length; i++) {\n        let val = promises[i]\n        if(val && typeof val.then === 'function') {\n          // 任何一个promise先调用resolve或reject就返回结果了 也就是返回执行最快的那个promise的结果\n          val.then(resolve,reject)\n        }else{\n          // 普通值\n          resolve(val)\n        }\n      }\n    })\n  }\n}\n\nmodule.exports = myPromise\n\n\n测试\n\n/**\n * =====测试用例-====\n */\n// let promise1 = new myPromise((resolve,reject)=>{\n//   setTimeout(() => {\n//     resolve('成功')\n//   }, 900);\n// })\n\n// promise1.then(val=>{\n//   console.log('success', val)\n// },reason=>{\n//   console.log('fail', reason)\n// })\n\n/**\n * then的使用方式 普通值意味不是promise\n * \n * 1、then中的回调有两个方法 成功或失败 他们的结果返回（普通值）会传递给外层的下一个then中\n * 2、可以在成功或失败中抛出异常，走到下一次then的失败中\n * 3、返回的是一个promsie，那么会用这个promise的状态作为结果，会用promise的结果向下传递\n * 4、错误处理，会默认先找离自己最新的错误处理，找不到就向下查找，找打了就执行\n */\n\n// read('./name.txt').then(data=>{\n//   return '123'\n// }).then(data=>{\n  \n// }).then(null,err=>{\n\n// })\n// // .catch(err=>{ // catch就是没有成功的promise\n\n// // })\n\n/**\n * promise.then实现原理：通过每次返回一个新的promise来实现（promise一旦成功就不能失败，失败就不能成功）\n * \n */\n\n// function read(data) {\n//   return new myPromise((resolve,reject)=>{\n//     setTimeout(() => {\n//       resolve(new myPromise((resolve,reject)=>resolve(data)))\n//     }, 1000);\n//   })\n// }\n\n// let promise2 = read({name: 'poetry'}).then(data=>{\n//   return data\n// }).then().then().then(data=>{\n//   console.log(data,'-data-')\n// },(err)=>{\n//   console.log(err,'-err-')\n// })\n\n// finally测试\n// myPromise\n//   .resolve(100)\n//   .finally(()=>{\n//     return new myPromise((resolve,reject)=>setTimeout(() => {\n//       resolve(100)\n//     }, 100))\n//   })\n//   .then(d=>console.log('finally success',d))\n//   .catch(er=>console.log(er, 'finally err'))\n\n\n/**\n * promise.all 测试\n * \n * myPromise.all 解决并发问题 多个异步并发获取最终的结果\n*/\n\n// myPromise.all([1,2,3,4,new myPromise((resolve,reject)=>{\n//   setTimeout(() => {\n//     resolve('ok1')\n//   }, 1000);\n// }),new myPromise((resolve,reject)=>{\n//   setTimeout(() => {\n//     resolve('ok2')\n//   }, 1000);\n// })]).then(d=>{\n//   console.log(d,'myPromise.all.resolve')\n// }).catch(err=>{\n//   console.log(err,'myPromise.all.reject')\n// })\n\n\n// 实现promise中断请求\nlet promise = new Promise((resolve,reject)=>{\n  setTimeout(() => {\n    // 模拟接口调用 ajax调用超时\n    resolve('成功') \n  }, 10000);\n})\n\nfunction promiseWrap(promise) {\n  // 包装一个promise 可以控制原来的promise是成功 还是失败\n  let abort\n  let newPromsie = new myPromise((resolve,reject)=>{\n    abort = reject\n  })\n  // 只要控制newPromsie失败，就可以控制被包装的promise走向失败\n  // Promise.race 任何一个先成功或者失败 就可以获得结果\n  let p = myPromise.race([promise, newPromsie])\n  p.abort = abort\n\n  return p\n}\n\nlet newPromise = promiseWrap(promise)\n\nsetTimeout(() => {\n  // 超过3秒超时\n  newPromise.abort('请求超时')\n}, 3000);\n\nnewPromise.then(d=>{\n  console.log('d',d)\n}).catch(err=>{\n  console.log('err',err)\n})\n\n\n// 使用promises-aplus-tests 测试写的promise是否规范\n// 全局安装 cnpm i -g promises-aplus-tests\n// 命令行执行 promises-aplus-tests promise.js\n// 测试入口 产生延迟对象\nmyPromise.defer = myPromise.deferred = function () {\n  let dfd = {}\n  dfd.promise = new myPromise((resolve,reject)=>{\n    dfd.resolve = resolve\n    dfd.reject = reject\n  })\n  return dfd\n}\n\n// 延迟对象用户\n// ![](http://img-repo.poetries.top/images/20210509172817.png)\n// promise解决嵌套问题\n// function readData(url) {\n//   let dfd = myPromise.defer()\n//   fs.readFile(url, 'utf8', function (err,data) {\n//     if(err) {\n//       dfd.reject()\n//     }\n//     dfd.resolve(data)\n//   })\n//   return dfd.promise\n// }\n// readData().then(d=>{\n//   return d\n// })\n\n\n\n# 12.4 setTimeout、Promise、Async / Await 的区别\n\n * 首先，我们先来了解一下基本概念：\n   \n   * js EventLoop 事件循环机制:\n   \n   * JavaScript的事件分两种，宏任务(macro-task)和微任务(micro-task)\n\n * 宏任务：包括整体代码script，setTimeout，setInterval\n\n * 微任务：Promise.then(非new Promise)，process.nextTick(node中)\n\n * 事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。\n\n * 注意： setTimeOut并不是直接的把你的回掉函数放进上述的异步队列中去，而是在定时器的时间到了之后，把回掉函数放到执行异步队列中去。如果此时这个队列已经有很多任务了，那就排在他们的后面。这也就解释了为什么setTimeOut为什么不能精准的执行的问题了。\n\n * setTimeout 执行需要满足两个条件：\n   \n   * 主进程必须是空闲的状态，如果到时间了，主进程不空闲也不会执行你的回掉函数\n   * 这个回掉函数需要等到插入异步队列时前面的异步函数都执行完了，才会执行\n\n * 上面是比较官方的解释，说一下自己的理解吧：\n   \n   * 了解了什么是宏任务和微任务，就好理解多了，首先执行 宏任务 => 微任务的Event Queue => 宏任务的Event Queue\n\n * promise、async/await\n   \n   * 首先，new Promise是同步的任务，会被放到主进程中去立即执行。而.then()函数是异步任务会放到异步队列中去，那什么时候放到异步队列中去呢？当你的promise状态结束的时候，就会立即放进异步队列中去了。\n   \n   * 带async关键字的函数会返回一个promise对象，如果里面没有await，执行起来等同于普通函数；如果没有await，async函数并没有很厉害是不是\n   \n   * await 关键字要在 async 关键字函数的内部，await 写在外面会报错；await如同他的语意，就是在等待，等待右侧的表达式完成。此时的await会让出线程，阻塞async内后续的代码，先去执行async外的代码。等外面的同步代码执行完毕，才会执行里面的后续代码。就算await的不是promise对象，是一个同步函数，也会等这样操作\n\n\n\n根据图片显示我们来整理一下流程：\n\n * 执行console.log('script start')，输出script start；\n\n * 执行setTimeout，是一个异步动作，放入宏任务异步队列中；\n\n * 执行async1()，输出async1 start，继续向下执行；\n\n * 执行async2()，输出async2，并返回了一个promise对象，await让出了线程，把返回的promise加入了微任务异步队列，所以async1()下面的代码也要等待上面完成后继续执行;\n\n * 执行 new Promise，输出promise1，然后将resolve放入微任务异步队列；\n\n * 执行console.log('script end')，输出script end；\n\n * 到此同步的代码就都执行完成了，然后去微任务异步队列里去获取任务\n\n * 接下来执行resolve（async2返回的promise返回的），输出了async1 end。\n\n * 然后执行resolve（new Promise的），输出了promise2\n\n * 最后执行setTimeout，输出了settimeout\n\n\n# 12.5 setTimeout(fn, 0)多久才执行，Event Loop\n\n> setTimeout 按照顺序放到队列里面，然后等待函数调用栈清空之后才开始执行，而这些操作进入队列的顺序，则由设定的延迟时间来决定\n\n\n# 12.6 async原理\n\n> async/await语法糖就是使用Generator函数+自动执行器来运作的\n\n// 定义了一个promise，用来模拟异步请求，作用是传入参数++\nfunction getNum(num){\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(num+1)\n        }, 1000)\n    })\n}\n\n//自动执行器，如果一个Generator函数没有执行完，则递归调用\nfunction asyncFun(func){\n  var gen = func();\n\n  function next(data){\n    var result = gen.next(data);\n    if (result.done) return result.value;\n    result.value.then(function(data){\n      next(data);\n    });\n  }\n\n  next();\n}\n\n// 所需要执行的Generator函数，内部的数据在执行完成一步的promise之后，再调用下一步\nvar func = function* (){\n  var f1 = yield getNum(1);\n  var f2 = yield getNum(f1);\n  console.log(f2) ;\n};\nasyncFun(func);\n\n\n * 在执行的过程中，判断一个函数的promise是否完成，如果已经完成，将结果传入下一个函数，继续重复此步骤\n * 每一个 next() 方法返回值的 value 属性为一个 Promise 对象，所以我们为其添加 then 方法， 在 then 方法里面接着运行 next 方法挪移遍历器指针，直到 Generator函数运行完成\n\n\n# 13 内存泄露\n\n\n# 13.1 Chrome devTools查看内存情况\n\n>  * 打开Chrome的无痕模式，这样做的目的是为了屏蔽掉Chrome插件对我们之后测试内存占用情况的影响\n>  * 打开开发者工具，找到Performance这一栏，可以看到其内部带着一些功能按钮，例如：开始录制按钮；刷新页面按钮；清空记录按钮；记录并可视化js内存、节点、事件监听器按钮；触发垃圾回收机制按钮等\n\n\n\n简单录制一下百度页面，看看我们能获得什么，如下动图所示：\n\n\n\n> 从上图中我们可以看到，在页面从零到加载完成这个过程中JS Heap（js堆内存）、documents（文档）、Nodes（DOM节点）、Listeners（监听器）、GPU memory（GPU内存）的最低值、最高值以及随时间的走势曲线，这也是我们主要关注的点\n\n看看开发者工具中的Memory一栏，其主要是用于记录页面堆内存的具体情况以及js堆内存随加载时间线动态的分配情况\n\n\n\n堆快照就像照相机一样，能记录你当前页面的堆内存情况，每快照一次就会产生一条快照记录\n\n\n\n> 如上图所示，刚开始执行了一次快照，记录了当时堆内存空间占用为33.7MB，然后我们点击了页面中某些按钮，又执行一次快照，记录了当时堆内存空间占用为32.5MB。并且点击对应的快照记录，能看到当时所有内存中的变量情况（结构、占总占用内存的百分比...）\n\n\n\n> 在开始记录后，我们可以看到图中右上角有起伏的蓝色与灰色的柱形图，其中蓝色表示当前时间线下占用着的内存；灰色表示之前占用的内存空间已被清除释放\n\n在得知有内存泄漏的情况存在时，我们可以改用Memory来更明确得确认问题和定位问题\n\n首先可以用Allocation instrumentation on timeline来确认问题，如下图所示：\n\n\n\n\n# 13.2 内存泄漏的场景\n\n * 闭包使用不当引起内存泄漏\n * 全局变量\n * 分离的DOM节点\n * 控制台的打印\n * 遗忘的定时器\n\n1. 闭包使用不当引起内存泄漏\n\n使用Performance和Memory来查看一下闭包导致的内存泄漏问题\n\n<button onclick=\"myClick()\">执行fn1函数</button>\n<script>\n    function fn1 () {\n        let a = new Array(10000)  // 这里设置了一个很大的数组对象\n\n        let b = 3\n\n        function fn2() {\n            let c = [1, 2, 3]\n        }\n\n        fn2()\n\n        return a\n    }\n\n    let res = []  \n\n    function myClick() {\n        res.push(fn1())\n    }\n</script>\n\n\n> 在退出fn1函数执行上下文后，该上下文中的变量a本应被当作垃圾数据给回收掉，但因fn1函数最终将变量a返回并赋值给全局变量res，其产生了对变量a的引用，所以变量a被标记为活动变量并一直占用着相应的内存，假设变量res后续用不到，这就算是一种闭包使用不当的例子\n\n设置了一个按钮，每次执行就会将fn1函数的返回值添加到全局数组变量res中，是为了能在performacne的曲线图中看出效果，如图所示：\n\n\n\n * 在每次录制开始时手动触发一次垃圾回收机制，这是为了确认一个初始的堆内存基准线，便于后面的对比，然后我们点击了几次按钮，即往全局数组变量res中添加了几个比较大的数组对象，最后再触发一次垃圾回收，发现录制结果的JS Heap曲线刚开始成阶梯式上升的，最后的曲线的高度比基准线要高，说明可能是存在内存泄漏的问题\n * 在得知有内存泄漏的情况存在时，我们可以改用Memory来更明确得确认问题和定位问题\n * 首先可以用Allocation instrumentation on timeline来确认问题，如下图所示：\n\n\n\n * 在我们每次点击按钮后，动态内存分配情况图上都会出现一个蓝色的柱形，并且在我们触发垃圾回收后，蓝色柱形都没变成灰色柱形，即之前分配的内存并未被清除\n * 所以此时我们就可以更明确得确认内存泄漏的问题是存在的了，接下来就精准定位问题，可以利用Heap snapshot来定位问题，如图所示：\n\n\n\n * 第一次先点击快照记录初始的内存情况，然后我们多次点击按钮后再次点击快照，记录此时的内存情况，发现从原来的1.1M内存空间变成了1.4M内存空间，然后我们选中第二条快照记录，可以看到右上角有个All objects的字段，其表示展示的是当前选中的快照记录所有对象的分配情况，而我们想要知道的是第二条快照与第一条快照的区别在哪，所以选择Object allocated between Snapshot1 and Snapshot2即展示第一条快照和第二条快照存在差异的内存对象分配情况，此时可以看到Array的百分比很高，初步可以判断是该变量存在问题，点击查看详情后就能查看到该变量对应的具体数据了\n\n以上就是一个判断闭包带来内存泄漏问题并简单定位的方法了\n\n2. 全局变量\n\n全局的变量一般是不会被垃圾回收掉的当然这并不是说变量都不能存在全局，只是有时候会因为疏忽而导致某些变量流失到全局，例如未声明变量，却直接对某变量进行赋值，就会导致该变量在全局创建，如下所示：\n\nfunction fn1() {\n    // 此处变量name未被声明\n    name = new Array(99999999)\n}\n\nfn1()\n\n\n * 此时这种情况就会在全局自动创建一个变量name，并将一个很大的数组赋值给name，又因为是全局变量，所以该内存空间就一直不会被释放\n * 解决办法的话，自己平时要多加注意，不要在变量未声明前赋值，或者也可以开启严格模式，这样就会在不知情犯错时，收到报错警告，例如\n\nfunction fn1() {\n    'use strict';\n    name = new Array(99999999)\n}\n\nfn1()\n\n\n3. 分离的DOM节点\n\n假设你手动移除了某个dom节点，本应释放该dom节点所占用的内存，但却因为疏忽导致某处代码仍对该被移除节点有引用，最终导致该节点所占内存无法被释放，例如这种情况\n\n<div id=\"root\">\n    <div class=\"child\">我是子元素</div>\n    <button>移除</button>\n</div>\n<script>\n  let btn = document.querySelector('button')\n  let child = document.querySelector('.child')\n  let root = document.querySelector('#root')\n  \n  btn.addEventListener('click', function() {\n      root.removeChild(child)\n  })\n</script>\n\n\n> 该代码所做的操作就是点击按钮后移除.child的节点，虽然点击后，该节点确实从dom被移除了，但全局变量child仍对该节点有引用，所以导致该节点的内存一直无法被释放，可以尝试用Memory的快照功能来检测一下，如图所示\n\n\n\n> 同样的先记录一下初始状态的快照，然后点击移除按钮后，再点击一次快照，此时内存大小我们看不出什么变化，因为移除的节点占用的内存实在太小了可以忽略不计，但我们可以点击第二条快照记录，在筛选框里输入detached，于是就会展示所有脱离了却又未被清除的节点对象\n\n解决办法如下图所示：\n\n<div id=\"root\">\n    <div class=\"child\">我是子元素</div>\n    <button>移除</button>\n</div>\n<script>\n    let btn = document.querySelector('button')\n\n    btn.addEventListener('click', function() {  \n        let child = document.querySelector('.child')\n        let root = document.querySelector('#root')\n\n        root.removeChild(child)\n    })\n\n</script>\n\n\n> 改动很简单，就是将对.child节点的引用移动到了click事件的回调函数中，那么当移除节点并退出回调函数的执行上文后就会自动清除对该节点的引用，那么自然就不会存在内存泄漏的情况了，我们来验证一下，如下图所示：\n\n\n\n结果很明显，这样处理过后就不存在内存泄漏的情况了\n\n4. 控制台的打印\n\n<button>按钮</button>\n<script>\n    document.querySelector('button').addEventListener('click', function() {\n        let obj = new Array(1000000)\n\n        console.log(obj);\n    })\n</script>\n\n\n我们在按钮的点击回调事件中创建了一个很大的数组对象并打印，用performance来验证一下\n\n\n\n> 开始录制，先触发一次垃圾回收清除初始的内存，然后点击三次按钮，即执行了三次点击事件，最后再触发一次垃圾回收。查看录制结果发现JS Heap曲线成阶梯上升，并且最终保持的高度比初始基准线高很多，这说明每次执行点击事件创建的很大的数组对象obj都因为console.log被浏览器保存了下来并且无法被回收\n\n接下来注释掉console.log，再来看一下结果：\n\n<button>按钮</button>\n<script>\n    document.querySelector('button').addEventListener('click', function() {\n        let obj = new Array(1000000)\n\n        // console.log(obj);\n    })\n</script>\n\n\n\n\n可以看到没有打印以后，每次创建的obj都立马被销毁了，并且最终触发垃圾回收机制后跟初始的基准线同样高，说明已经不存在内存泄漏的现象了\n\n其实同理 console.log也可以用Memory来进一步验证\n\n未注释 console.log\n\n\n\n注释掉了console.log\n\n\n\n> 最后简单总结一下：在开发环境下，可以使用控制台打印便于调试，但是在生产环境下，尽可能得不要在控制台打印数据。所以我们经常会在代码中看到类似如下的操作：\n\n// 如果在开发环境下，打印变量obj\nif(isDev) {\n    console.log(obj)\n}\n\n\n> 这样就避免了生产环境下无用的变量打印占用一定的内存空间，同样的除了console.log之外，console.error、console.info、console.dir等等都不要在生产环境下使用\n\n5. 遗忘的定时器\n\n> 定时器也是平时很多人会忽略的一个问题，比如定义了定时器后就再也不去考虑清除定时器了，这样其实也会造成一定的内存泄漏。来看一个代码示例：\n\n<button>开启定时器</button>\n<script>\n\n    function fn1() {\n        let largeObj = new Array(100000)\n\n        setInterval(() => {\n            let myObj = largeObj\n        }, 1000)\n    }\n\n    document.querySelector('button').addEventListener('click', function() {\n        fn1()\n    })\n</script>\n\n\n这段代码是在点击按钮后执行fn1函数，fn1函数内创建了一个很大的数组对象largeObj，同时创建了一个setInterval定时器，定时器的回调函数只是简单的引用了一下变量largeObj，我们来看看其整体的内存分配情况吧：\n\n\n\n按道理来说点击按钮执行fn1函数后会退出该函数的执行上下文，紧跟着函数体内的局部变量应该被清除，但图中performance的录制结果显示似乎是存在内存泄漏问题的，即最终曲线高度比基准线高度要高，那么再用Memory来确认一次：\n\n\n\n * 在我们点击按钮后，从动态内存分配的图上看到出现一个蓝色柱形，说明浏览器为变量largeObj分配了一段内存，但是之后这段内存并没有被释放掉，说明的确存在内存泄漏的问题，原因其实就是因为setInterval的回调函数内对变量largeObj有一个引用关系，而定时器一直未被清除，所以变量largeObj的内存也自然不会被释放\n * 那么我们如何来解决这个问题呢，假设我们只需要让定时器执行三次就可以了，那么我们可以改动一下代码：\n\n<button>开启定时器</button>\n<script>\n    function fn1() {\n        let largeObj = new Array(100000)\n        let index = 0\n\n        let timer = setInterval(() => {\n            if(index === 3) clearInterval(timer);\n            let myObj = largeObj\n            index ++\n        }, 1000)\n    }\n\n    document.querySelector('button').addEventListener('click', function() {\n        fn1()\n    })\n</script>\n\n\n现在我们再通过performance和memory来看看还不会存在内存泄漏的问题\n\n * performance\n\n\n\n> 这次的录制结果就能看出，最后的曲线高度和初始基准线的高度一样，说明并没有内存泄漏的情况\n\n * memory\n\n\n\n这里做一个解释，图中刚开始出现的蓝色柱形是因为我在录制后刷新了页面，可以忽略；然后我们点击了按钮，看到又出现了一个蓝色柱形，此时就是为fn1函数中的变量largeObj分配了内存，3s后该内存又被释放了，即变成了灰色柱形。所以我们可以得出结论，这段代码不存在内存泄漏的问题\n\n> 简单总结一下： 大家在平时用到了定时器，如果在用不到定时器后一定要清除掉，否则就会出现本例中的情况。除了setTimeout和setInterval，其实浏览器还提供了一个API也可能就存在这样的问题，那就是requestAnimationFrame\n\n\n# 14 垃圾回收机制\n\n * 对于在JavaScript中的字符串，对象，数组是没有固定大小的，只有当对他们进行动态分配存储时，解释器就会分配内存来存储这些数据，当JavaScript的解释器消耗完系统中所有可用的内存时，就会造成系统崩溃。\n * 内存泄漏，在某些情况下，不再使用到的变量所占用内存没有及时释放，导致程序运行中，内存越占越大，极端情况下可以导致系统崩溃，服务器宕机。\n * JavaScript有自己的一套垃圾回收机制，JavaScript的解释器可以检测到什么时候程序不再使用这个对象了（数据），就会把它所占用的内存释放掉。\n * 针对JavaScript的来及回收机制有以下两种方法（常用）：标记清除，引用计数\n\n有两种垃圾回收策略：\n\n * 标记清除：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。\n * 引用计数：它把对象是否不再需要简化定义为对象有没有其他对象引用到它。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收\n\n标记清除的缺点：\n\n * 内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。\n * 分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。\n\n> 解决以上的缺点可以使用 标记整理（Mark-Compact）算法 标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）\n\n\n\n引用计数的缺点：\n\n * 需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。\n * 解决不了循环引用导致的无法回收问题\n\n> V8 的垃圾回收机制也是基于标记清除算法，不过对其做了一些优化。\n\n * 针对新生区采用并行回收。\n * 针对老生区采用增量标记与惰性回收\n\n\n# 15 深浅拷贝\n\n\n\n1. 浅拷贝的原理和实现\n\n> 自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象\n\n方法一：object.assign\n\n> object.assign是 ES6 中 object 的一个方法，该方法可以用于 JS 对象的合并等多个用途，其中一个用途就是可以进行浅拷贝。该方法的第一个参数是拷贝的目标对象，后面的参数是拷贝的来源对象（也可以是多个来源）。\n\nobject.assign 的语法为：Object.assign(target, ...sources)\n\n\nobject.assign 的示例代码如下：\n\nlet target = {};\nlet source = { a: { b: 1 } };\nObject.assign(target, source);\nconsole.log(target); // { a: { b: 1 } };\n\n\n但是使用 object.assign 方法有几点需要注意\n\n * 它不会拷贝对象的继承属性；\n * 它不会拷贝对象的不可枚举的属性；\n * 可以拷贝 Symbol 类型的属性。\n\nlet obj1 = { a:{ b:1 }, sym:Symbol(1)}; \nObject.defineProperty(obj1, 'innumerable' ,{\n    value:'不可枚举属性',\n    enumerable:false\n});\nlet obj2 = {};\nObject.assign(obj2,obj1)\nobj1.a.b = 2;\nconsole.log('obj1',obj1);\nconsole.log('obj2',obj2);\n\n\n\n\n> 从上面的样例代码中可以看到，利用 object.assign 也可以拷贝 Symbol 类型的对象，但是如果到了对象的第二层属性 obj1.a.b 这里的时候，前者值的改变也会影响后者的第二层属性的值，说明其中依旧存在着访问共同堆内存的问题，也就是说这种方法还不能进一步复制，而只是完成了浅拷贝的功能\n\n方法二：扩展运算符方式\n\n * 我们也可以利用 JS 的扩展运算符，在构造对象的同时完成浅拷贝的功能。\n * 扩展运算符的语法为：let cloneObj = { ...obj };\n\n/* 对象的拷贝 */\nlet obj = {a:1,b:{c:1}}\nlet obj2 = {...obj}\nobj.a = 2\nconsole.log(obj)  //{a:2,b:{c:1}} console.log(obj2); //{a:1,b:{c:1}}\nobj.b.c = 2\nconsole.log(obj)  //{a:2,b:{c:2}} console.log(obj2); //{a:1,b:{c:2}}\n/* 数组的拷贝 */\nlet arr = [1, 2, 3];\nlet newArr = [...arr]; //跟arr.slice()是一样的效果\n\n\n> 扩展运算符 和 object.assign 有同样的缺陷，也就是实现的浅拷贝的功能差不多，但是如果属性都是基本类型的值，使用扩展运算符进行浅拷贝会更加方便\n\n方法三：concat 拷贝数组\n\n> 数组的 concat 方法其实也是浅拷贝，所以连接一个含有引用类型的数组时，需要注意修改原数组中的元素的属性，因为它会影响拷贝之后连接的数组。不过 concat 只能用于数组的浅拷贝，使用场景比较局限。代码如下所示。\n\nlet arr = [1, 2, 3];\nlet newArr = arr.concat();\nnewArr[1] = 100;\nconsole.log(arr);  // [ 1, 2, 3 ]\nconsole.log(newArr); // [ 1, 100, 3 ]\n\n\n方法四：slice 拷贝数组\n\n> slice 方法也比较有局限性，因为它仅仅针对数组类型。slice方法会返回一个新的数组对象，这一对象由该方法的前两个参数来决定原数组截取的开始和结束时间，是不会影响和改变原始数组的。\n\n// slice 的语法为：arr.slice(begin, end);\nlet arr = [1, 2, {val: 4}];\nlet newArr = arr.slice();\nnewArr[2].val = 1000;\nconsole.log(arr);  //[ 1, 2, { val: 1000 } ]\n\n\n> 从上面的代码中可以看出，这就是浅拷贝的限制所在了——它只能拷贝一层对象。如果存在对象的嵌套，那么浅拷贝将无能为力。因此深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝\n\n手工实现一个浅拷贝\n\n根据以上对浅拷贝的理解，如果让你自己实现一个浅拷贝，大致的思路分为两点：\n\n * 对基础类型做一个最基本的一个拷贝；\n * 对引用类型开辟一个新的存储，并且拷贝一层对象属性。\n\nconst shallowClone = (target) => {\n  if (typeof target === 'object' && target !== null) {\n    const cloneTarget = Array.isArray(target) ? []: {};\n    for (let prop in target) {\n      if (target.hasOwnProperty(prop)) {\n          cloneTarget[prop] = target[prop];\n      }\n    }\n    return cloneTarget;\n  } else {\n    return target;\n  }\n}\n\n\n> 利用类型判断，针对引用类型的对象进行 for 循环遍历对象属性赋值给目标对象的属性，基本就可以手工实现一个浅拷贝的代码了\n\n2. 深拷贝的原理和实现\n\n浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值，而引用数据类型只拷贝了一层属性，再深层的还是无法进行拷贝。深拷贝则不同，对于复杂引用数据类型，其在堆内存中完全开辟了一块内存地址，并将原有的对象完全复制过来存放。\n\n这两个对象是相互独立、不受影响的，彻底实现了内存上的分离。总的来说，深拷贝的原理可以总结如下：\n\n> 将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。\n\n方法一：乞丐版（JSON.stringify）\n\n> JSON.stringify() 是目前开发过程中最简单的深拷贝方法，其实就是把一个对象序列化成为 JSON 的字符串，并将对象里面的内容转换成字符串，最后再用 JSON.parse() 的方法将 JSON 字符串生成一个新的对象\n\nlet a = {\n    age: 1,\n    jobs: {\n        first: 'FE'\n    }\n}\nlet b = JSON.parse(JSON.stringify(a))\na.jobs.first = 'native'\nconsole.log(b.jobs.first) // FE\n\n\n但是该方法也是有局限性的：\n\n * 会忽略 undefined\n * 会忽略 symbol\n * 不能序列化函数\n * 无法拷贝不可枚举的属性\n * 无法拷贝对象的原型链\n * 拷贝 RegExp 引用类型会变成空对象\n * 拷贝 Date 引用类型会变成字符串\n * 对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null\n * 不能解决循环引用的对象，即对象成环 (obj[key] = obj)。\n\nfunction Obj() { \n  this.func = function () { alert(1) }; \n  this.obj = {a:1};\n  this.arr = [1,2,3];\n  this.und = undefined; \n  this.reg = /123/; \n  this.date = new Date(0); \n  this.NaN = NaN;\n  this.infinity = Infinity;\n  this.sym = Symbol(1);\n} \nlet obj1 = new Obj();\nObject.defineProperty(obj1,'innumerable',{ \n  enumerable:false,\n  value:'innumerable'\n});\nconsole.log('obj1',obj1);\nlet str = JSON.stringify(obj1);\nlet obj2 = JSON.parse(str);\nconsole.log('obj2',obj2);\n\n\n\n\n> 使用 JSON.stringify 方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。而对于其他的也要实现深拷贝的，比较麻烦的属性对应的数据类型，JSON.stringify 暂时还是无法满足的，那么就需要下面的几种方法了\n\n方法二：基础版（手写递归实现）\n\n> 下面是一个实现 deepClone 函数封装的例子，通过 for in 遍历传入参数的属性值，如果值是引用类型则再次递归调用该函数，如果是基础数据类型就直接复制\n\nlet obj1 = {\n  a:{\n    b:1\n  }\n}\nfunction deepClone(obj) { \n  let cloneObj = {}\n  for(let key in obj) {                 //遍历\n    if(typeof obj[key] ==='object') { \n      cloneObj[key] = deepClone(obj[key])  //是对象就再次调用该函数递归\n    } else {\n      cloneObj[key] = obj[key]  //基本类型的话直接复制值\n    }\n  }\n  return cloneObj\n}\nlet obj2 = deepClone(obj1);\nobj1.a.b = 2;\nconsole.log(obj2);   //  {a:{b:1}}\n\n\n虽然利用递归能实现一个深拷贝，但是同上面的 JSON.stringify 一样，还是有一些问题没有完全解决，例如：\n\n * 这个深拷贝函数并不能复制不可枚举的属性以及 Symbol 类型；\n * 这种方法只是针对普通的引用类型的值做递归复制，而对于 Array、Date、RegExp、Error、Function 这样的引用类型并不能正确地拷贝；\n * 对象的属性里面成环，即循环引用没有解决。\n\n这种基础版本的写法也比较简单，可以应对大部分的应用情况。但是你在面试的过程中，如果只能写出这样的一个有缺陷的深拷贝方法，有可能不会通过。\n\n所以为了“拯救”这些缺陷，下面我带你一起看看改进的版本，以便于你可以在面试种呈现出更好的深拷贝方法，赢得面试官的青睐。\n\n方法三：改进版（改进后递归实现）\n\n> 针对上面几个待解决问题，我先通过四点相关的理论告诉你分别应该怎么做。\n\n * 针对能够遍历对象的不可枚举属性以及 Symbol 类型，我们可以使用 Reflect.ownKeys 方法；\n * 当参数为 Date、RegExp 类型，则直接生成一个新的实例返回；\n * 利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性，以及对应的特性，顺便结合 Object.create 方法创建一个新对象，并继承传入原对象的原型链；\n * 利用 WeakMap 类型作为 Hash 表，因为 WeakMap 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 Map 和 weakMap 的关键区别，这里要用 weakMap），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 WeakMap 存储的值\n\n如果你在考虑到循环引用的问题之后，还能用 WeakMap 来很好地解决，并且向面试官解释这样做的目的，那么你所展示的代码，以及你对问题思考的全面性，在面试官眼中应该算是合格的了\n\n实现深拷贝\n\nconst isComplexDataType = obj => (typeof obj === 'object' || typeof obj === 'function') && (obj !== null)\n\nconst deepClone = function (obj, hash = new WeakMap()) {\n  if (obj.constructor === Date) {\n    return new Date(obj)       // 日期对象直接返回一个新的日期对象\n  }\n  \n  if (obj.constructor === RegExp){\n    return new RegExp(obj)     //正则对象直接返回一个新的正则对象\n  }\n  \n  //如果循环引用了就用 weakMap 来解决\n  if (hash.has(obj)) {\n    return hash.get(obj)\n  }\n  let allDesc = Object.getOwnPropertyDescriptors(obj)\n\n  //遍历传入参数所有键的特性\n  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc)\n\n  // 把cloneObj原型复制到obj上\n  hash.set(obj, cloneObj)\n\n  for (let key of Reflect.ownKeys(obj)) { \n    cloneObj[key] = (isComplexDataType(obj[key]) && typeof obj[key] !== 'function') ? deepClone(obj[key], hash) : obj[key]\n  }\n  return cloneObj\n}\n\n\n// 下面是验证代码\nlet obj = {\n  num: 0,\n  str: '',\n  boolean: true,\n  unf: undefined,\n  nul: null,\n  obj: { name: '我是一个对象', id: 1 },\n  arr: [0, 1, 2],\n  func: function () { console.log('我是一个函数') },\n  date: new Date(0),\n  reg: new RegExp('/我是一个正则/ig'),\n  [Symbol('1')]: 1,\n};\nObject.defineProperty(obj, 'innumerable', {\n  enumerable: false, value: '不可枚举属性' }\n);\nobj = Object.create(obj, Object.getOwnPropertyDescriptors(obj))\nobj.loop = obj    // 设置loop成循环引用的属性\nlet cloneObj = deepClone(obj)\ncloneObj.arr.push(4)\nconsole.log('obj', obj)\nconsole.log('cloneObj', cloneObj)\n\n\n我们看一下结果，cloneObj 在 obj 的基础上进行了一次深拷贝，cloneObj 里的 arr 数组进行了修改，并未影响到 obj.arr 的变化，如下图所示\n\n\n\n\n# 16 对象的几种创建方式\n\n\n# 16.1 工厂模式,创建方式\n\nfunction createPerson(name,age,job){\n    var o = new Object();\n    o.name=name;\n    o.age=age;\n    o.job=job;\n    o.sayName = function(){\n        alert(this.name);\n    }\n}\nvar person1 = createPerson(\"da\",1,\"it\");\nvar person2 = createPerson(\"dada\",2,\"it\");\n\n\n\n# 16.2 构造函数模式\n\nfunction Person(name,age,ob){\n    this.name=name;\n    this.age=age;\n    this.job=job;\n    this.sayName = function(){\n        alert(this.name);\n    }\nvar person1 = new Person(\"dada\",1,\"web\");\nvar person2 = new Person(\"dada\",2,\"web\");\n}\n\n\n\n# 16.3 使用原型模式\n\nfunction Person(){\n}\nPerson.prototype.name = \"da\";\nPerson.prototype.age = 1;\nPerson.prototype.job = \"web\";\nPerson.prototype.sayName = function(){\n    alert(this.name);\n}\n \nvar person1 = new Person();\nperson1.sayName();    //\"dada\"\n \nvar person2 = new Person();\nperson2.sayName();    //\"dada\"\n \nalert(person1.sayName == person2.sayName);   //true\n\n\n\n# 16.4 组合使用构造函数模式和原型模式\n\nfunction Person(name,age){\n    this.name = name;\n    this.age = age;\n    this.friends = [\"da\",\"dada\"];\n}\nPerson.prototype = {\n    constructor:Person,\n    sayName:function(){\n        alert(this.name);\n    }\n}\nvar person1 = new Person(\"da1\",1);\nvar person2 = new Person(\"da2\",2);\nperson1.friends.push(\"dadada\");\nconsole.log(person1.friends);    //[\"da\",\"dada\",\"dadada\"]\nconsole.log(person2.friends);    //[\"da\",\"dada\"]\nconsole.log(person1.friends === person2.friends);    //false\nconsole.log(person1.sayName === person2.sayName);   //true\n\n\n\n# 16.5 动态原型模式\n\nfunction Person(name,age,job){\n    this.name=name;\n    this.age=age;\n    this.job=job;\n\n    if(typeof this.sayName!=\"function\"){\n        Person.prototype.sayName=function(){\n            alert(this.name);\n        };\n    }\n}\n\n\n\n# 17 数组相关\n\n\n# 17.1 数组常用方法\n\n * map: 遍历数组，返回回调返回值组成的新数组\n * forEach: 无法break，可以用try/catch中throw new Error来停止\n * filter: 过滤\n * some: 有一项返回true，则整体为true\n * every: 有一项返回false，则整体为false\n * join: 通过指定连接符生成字符串\n * push / pop: 末尾推入和弹出，改变原数组， 返回推入/弹出项\n * unshift / shift: 头部推入和弹出，改变原数组，返回操作项\n * sort(fn) / reverse: 排序与反转，改变原数组\n * concat: 连接数组，不影响原数组， 浅拷贝\n * slice(start, end): 返回截断后的新数组，不改变原数组\n * splice(start, number, value...): 返回删除元素组成的数组，value为插入项，改变原数组\n * indexOf / lastIndexOf(value, fromIndex): 查找数组项，返回对应的下标\n * reduce / reduceRight(fn(prev, cur)， defaultPrev): 两两执行，prev 为上次化简函数的return值，cur为当前值(从第二项开始)\n\n数组乱序：\n\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\narr.sort(function () {\n    return Math.random() - 0.5;\n});\n\n\n数组拆解: flat: [1,[2,3]] --> [1, 2, 3]\n\nArray.prototype.flat = function() {\n    this.toString().split(',').map(item => +item )\n}\n\n\n\n# 17.2 Array(3)和Array(3, 4)的区别？\n\nconsole.log(Array(3)) // [empty x 3]\nconsole.log(Array(3, 4)) // [3, 4]\n\n\n\n# 17.3 请创建一个长度为100，值都为1的数组\n\nnew Array(100).fill(1)\n\n\n\n# 17.4 请创建一个长度为100，值为对应下标的数组\n\n// cool的写法：\n[...Array(100).keys()]\n\n// 其他方法：\nArray(100).join(\",\").split(\",\").map((v, i) => i)\nArray(100).fill().map((v, i) => i)\n\n\n\n# 17.5 如何转化类数组成数组\n\n> 因为arguments本身并不能调用数组方法，它是一个另外一种对象类型，只不过属性从0开始排，依次为0，1，2...最后还有callee和length属性。我们也把这样的对象称为类数组\n\n常见的类数组还有：\n\n * 用getElementsByTagName/ClassName()获得的HTMLCollection\n\n * 用querySelector获得的nodeList\n\n> 那这导致很多数组的方法就不能用了，必要时需要我们将它们转换成数组，有哪些方法呢？\n\n1. Array.prototype.slice.call()\n\nfunction sum(a, b) {\n  let args = Array.prototype.slice.call(arguments);\n  console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦\n}\nsum(1, 2);//3\n\n\n2. Array.from()\n\nfunction sum(a, b) {\n  let args = Array.from(arguments);\n  console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦\n}\nsum(1, 2);//3\n\n\n这种方法也可以用来转换Set和Map哦！\n\n3. ES6展开运算符\n\nfunction sum(a, b) {\n  let args = [...arguments];\n  console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦\n}\nsum(1, 2);//3\n\n\n4. 利用concat+apply\n\nfunction sum(a, b) {\n  let args = Array.prototype.concat.apply([], arguments);//apply方法会把第二个参数展开\n  console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦\n}\nsum(1, 2);//3\n\n\n\n# 17.6 forEach中return有效果吗？如何中断forEach循环？\n\n> 在forEach中用return不会返回，函数会继续执行。\n\nlet nums = [1, 2, 3];\nnums.forEach((item, index) => {\n  return;//无效\n})\n\n\n中断方法：\n\n * 使用try监视代码块，在需要中断的地方抛出异常。\n\n * 官方推荐方法（替换方法）：用every和some替代forEach函数。every在碰到return false的时候，中止循环。some在碰到return true的时候，中止循环\n\n\n# 17.7 JS判断数组中是否包含某个值\n\n方法一：array.indexOf\n\n> 此方法判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回-1。\n\nvar arr=[1,2,3,4];\nvar index=arr.indexOf(3);\nconsole.log(index);\n\n\n方法二：array.includes(searcElement[,fromIndex])\n\n> 此方法判断数组中是否存在某个值，如果存在返回true，否则返回false\n\nvar arr=[1,2,3,4];\nif(arr.includes(3))\n  console.log(\"存在\");\nelse\n  console.log(\"不存在\");\n\n\n方法三：array.find(callback[,thisArg])\n\n返回数组中满足条件的第一个元素的值，如果没有，返回undefined\n\nvar arr=[1,2,3,4];\nvar result = arr.find(item =>{\n    return item > 3\n});\nconsole.log(result);\n\n\n方法四：array.findeIndex(callback[,thisArg])\n\n> 返回数组中满足条件的第一个元素的下标，如果没有找到，返回-1\n\nvar arr=[1,2,3,4];\nvar result = arr.findIndex(item =>{\n    return item > 3\n});\nconsole.log(result);\n\n\n\n# 17.8 JS中flat---数组扁平化\n\n> 对于前端项目开发过程中，偶尔会出现层叠数据结构的数组，我们需要将多层级数组转化为一级数组（即提取嵌套数组元素最终合并为一个数组），使其内容合并且展开。那么该如何去实现呢？\n\n需求:多维数组=>一维数组\n\nlet ary = [1, [2, [3, [4, 5]]], 6];// -> [1, 2, 3, 4, 5, 6]\nlet str = JSON.stringify(ary);\n\n\n1. 调用ES6中的flat方法\n\nary = ary.flat(Infinity);\n\n\n2. replace + split\n\nary = str.replace(/(\\[|\\])/g, '').split(',')\n\n\n3. replace + JSON.parse\n\nstr = str.replace(/(\\[|\\])/g, '');\nstr = '[' + str + ']';\nary = JSON.parse(str);\n\n\n4. 普通递归\n\nlet result = [];\nlet fn = function(ary) {\n  for(let i = 0; i < ary.length; i++) {\n    let item = ary[i];\n    if (Array.isArray(ary[i])){\n      fn(item);\n    } else {\n      result.push(item);\n    }\n  }\n}\n\n\n5. 利用reduce函数迭代\n\nfunction flatten(ary) {\n    return ary.reduce((pre, cur) => {\n        return pre.concat(Array.isArray(cur) ? flatten(cur) : cur);\n    }, []);\n}\nlet ary = [1, 2, [3, 4], [5, [6, 7]]]\nconsole.log(flatten(ary))\n\n\n6. 扩展运算符\n\n//只要有一个元素有数组，那么循环继续\nwhile (ary.some(Array.isArray)) {\n  ary = [].concat(...ary);\n}\n\n\n\n# 18 操作DOM\n\n\n# 18.1 说说有几种类型的DOM节点\n\n * Document节点，整个文档是一个文档节点；\n * Element节点，每个HTML标签是一个元素节点；\n * Attribute节点，每一个HTML属性是一个属性节点；\n * Text节点，包含在HTML元素中的文本是文本节点\n\n\n# 18.2 操作DOM节点方法\n\n创建新节点\n\ncreateDocumentFragment()    //创建一个DOM片段\ncreateElement()   //创建一个具体的元素\ncreateTextNode()   //创建一个文本节点\n\n\n添加、移除、替换、插入\n\nappendChild()      //添加\nremoveChild()      //移除\nreplaceChild()      //替换\ninsertBefore()      //插入\n\n\n查找\n\ngetElementsByTagName()    //通过标签名称\ngetElementsByName()     //通过元素的Name属性的值\ngetElementById()        //通过元素Id，唯一性\n\n\n\n# 19 Ajax总结\n\n * Ajax的原理简单来说是在用户和服务器之间加了—个中间层(AJAX引擎)，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据\n * Ajax的过程只涉及JavaScript、XMLHttpRequest和DOM。XMLHttpRequest是ajax的核心机制\n\n\n# 19.1 Ajax 有那些优缺点\n\n优点：\n\n * 通过异步模式，提升了用户体验.\n * 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.\n * Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。\n * Ajax可以实现动态不刷新（局部刷新）\n\n缺点：\n\n * 安全问题 AJAX暴露了与服务器交互的细节。\n * 对搜索引擎的支持比较弱。\n * 不容易调试。\n\n\n# 19.2 关于http,XMLHttpRequest,Ajax的关系\n\n * http是浏览器和web服务器交换数据的协议,规范\n * XMLHttpRequest是一个JS对象，是浏览器实现的一组api函数，使用这些函数，浏览器再通过http协议请求和发送数据。\n * Ajax是一种技术方案，但并不是一种新技术，它最核心的就是依赖浏览器提供的XMLHttpRequest对象。用一句话来概括就是我们使用XMLHttpRequest对象来发送一个Ajax请求。\n\n\n# 19.3 XMLHttpRequest的发展历程是怎样的？\n\n它最开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了XMLHttpRequest标准。标准又分为Level 1和Level 2。\n\nLevel 2相对于Level 1做了很大的改进，具体来说是：\n\n * 可以设置HTTP请求的超时时间。\n * 可以使用FormData对象管理表单数据。\n * 可以上传文件。\n * 可以请求不同域名下的数据（跨域请求）。\n * 可以获取服务器端的二进制数据。\n * 可以获得数据传输的进度信息。\n\n\n# 19.4 使用XMLHttpRequest封装一个get和post请求\n\nget请求：\n\n核心就四步：\n\n 1. var xhr = new XMLHttpRequest()\n 2. xhr.open('GET', 'http://www.example.com/api/getname', true)\n 3. xhr.onreadystatechange = function () {}\n 4. xhr.send()\n\n让我们来封装一个简易版的：\n\n/*\n* xhr的get请求\n* @param url: 请求地址\n* @param params: 请求参数\n* @param onSuccess: 成功回调函数\n* @param onError: 失败回调函数\n*/\nfunction xhrGet (url, params = {}, onSuccess, onError) {\n  // 兼容IE6\n  var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');\n  let paramString = formatParams(params);\n  // xhr.open的第三个参数isAsync：是否异步 \n  xhr.open('GET', `${url}${paramString}`, true);\n  xhr.onreadystatechange = function () {\n    // console.log(e);\n    console.log(this);\n    if (this.readyState === 4) {\n      if (this.status >= 200 && this.status < 300) {\n        onSuccess(this.response);\n      } else {\n        onError(this.response)\n      }\n    }\n  }\n  xhr.send();\n}\n// 处理参数：如将{name: 'lindaidai'}转为'?name=lindaidai'\nfunction formatParams (params) {\n  var paramString = Object.keys(params).map(key => {\n    return `${key}=${encodeURIComponent(params[key])}`\n  }).join('&');\n  return paramString ? `?${paramString}` : ''\n}\n\n\n（当然上面的兼容IE6估计现在考的不多了，而且我这种写法其实也没啥用，因为如果真是在IE6下的话，后面的Object.keys()等方法也用不了了）\n\n需要注意的是两种状态，一个是readyState，一个是status。\n\n> readyState请求状态：\n\n * 0（未初始化）：还没有调用 open() 方法。\n * 1（载入）：已调用 send() 方法，正在发送请求。\n * 2（载入完成）：send() 方法完成，已收到全部响应内容。\n * 3（解析）：正在解析响应内容。\n * 4（完成）：响应内容解析完成，可以在客户端调用。\n\n> status结果状态码：\n\n * 0 ：如果状态是 UNSENT 或 OPENED；或者如果错误标签被设置(例如跨域时)\n * 200 成功\n * 其它HTTP状态码\n\npost请求：\n\nfunction xhrPost (url, params, onSuccess, onError) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('POST', url, true);\n  // ajax的默认请求ContentType:text/plain(纯文本)\n  xhr.setRequestHeader(\"Content-Type\", \"application-x-www-form-urlencode\");\n  xhr.onreadystatechange = function () {\n    if (this.readyState === 4) {\n      if (this.status >= 200 && this.status < 300) {\n        onSuccess(this.response);\n      } else {\n        onError(this.response);\n      }\n    }\n  }\n  xhr.send(params);\n}\n\n\n\n# 20 定时器\n\n\n# 20.1 setInterval存在哪些问题？\n\n> JavaScript中使用 setInterval 开启轮询。定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。而javascript引擎对这个问题的解决是：当使用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。\n\n但是，这样会导致两个问题：\n\n * 某些间隔被跳过；\n * 多个定时器的代码执行之间的间隔可能比预期的小\n\n\n# 20.2 链式调用setTimeout对比setInterval\n\nsetInterval本身是会存在一些问题的。而使用链式调用setTimeout这种方式会比它好一些：\n\nsetTimeout(function fn(){\n    console.log('我是setTimeout');\n    setTimeout(fn, 1000);\n},1000);\n\n\n这个模式链式调用了setTimeout()，每次函数执行的时候都会创建一个新的定时器。第二个setTimeout()调用当前执行的函数，并为其设置另外一个定时器。这样做的好处是：\n\n * 在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。\n * 而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。\n\n\n# 20.3 实现比 setTimeout 快 80 倍的定时器\n\n> 在浏览器中，setTimeout()/setInterval() 的每调用一次定时器的最小间隔是 4ms，这通常是由于函数嵌套导致（嵌套层级达到一定深度）\n\n简单来说，5 层以上的定时器嵌套会导致至少 4ms 的延迟。\n\n用如下代码做个测试：\n\nlet a = performance.now();\nsetTimeout(() => {\n  let b = performance.now();\n  console.log(b - a);\n  setTimeout(() => {\n    let c = performance.now();\n    console.log(c - b);\n    setTimeout(() => {\n      let d = performance.now();\n      console.log(d - c);\n      setTimeout(() => {\n        let e = performance.now();\n        console.log(e - d);\n        setTimeout(() => {\n          let f = performance.now();\n          console.log(f - e);\n          setTimeout(() => {\n            let g = performance.now();\n            console.log(g - f);\n          }, 0);\n        }, 0);\n      }, 0);\n    }, 0);\n  }, 0);\n}, 0);\n\n\n> 在浏览器中的打印结果大概是这样的，和规范一致，第五次执行的时候延迟来到了 4ms 以上\n\n// 结果是\n1.2999999970197678\n1.5\n1.2999999970197678\n1.9000000059604645\n4.5\n4.5999999940395355\n\n\n> 如果想在浏览器中实现 0ms 延时的定时器，可以用 window.postMessage 来实现真正 0 延迟的定时器\n\n(function () {\n  var timeouts = [];\n  var messageName = 'zero-timeout-message';\n\n  // 保持 setTimeout 的形态，只接受单个函数的参数，延迟始终为 0。\n  function setZeroTimeout(fn) {\n    timeouts.push(fn);\n    window.postMessage(messageName, '*');\n  }\n\n  function handleMessage(event) {\n    if (event.source == window && event.data == messageName) {\n      event.stopPropagation();\n      if (timeouts.length > 0) {\n        var fn = timeouts.shift();\n        fn();\n      }\n    }\n  }\n\n  window.addEventListener('message', handleMessage, true);\n\n  // 把 API 添加到 window 对象上\n  window.setZeroTimeout = setZeroTimeout;\n})();\n\n\n由于 postMessage 的回调函数的执行时机和 setTimeout 类似，都属于宏任务，所以可以简单利用 postMessage 和 addEventListener('message') 的消息通知组合，来实现模拟定时器的功能。\n\n这样，执行时机类似，但是延迟更小的定时器就完成了。\n\n再利用下面的嵌套定时器的例子来跑一下测试：\n\nvar a = performance.now();\nsetZeroTimeout(() => {\n  let b = performance.now();\n  console.log(b - a);\n  setZeroTimeout(() => {\n    let c = performance.now();\n    console.log(c - b);\n    setZeroTimeout(() => {\n      let d = performance.now();\n      console.log(d - c);\n      setZeroTimeout(() => {\n        let e = performance.now();\n        console.log(e - d);\n        setZeroTimeout(() => {\n          let f = performance.now();\n          console.log(f - e);\n          setZeroTimeout(() => {\n            let g = performance.now();\n            console.log(g - f);\n          }, 0);\n        }, 0);\n      }, 0);\n    }, 0);\n  }, 0);\n}, 0);\n    \n// 结果\n0.30000000447034836\n0.19999999552965164\n0.10000000149011612\n0.10000000149011612\n0.10000000149011612\n0.10000000149011612\n\n\n全部在 0.1 ~ 0.3 毫秒级别，而且不会随着嵌套层数的增多而增加延迟\n\n有什么场景需要无延迟的定时器？其实在 React 的源码中，做时间切片的部分就用到了\n\n// 伪代码\n\nconst channel = new MessageChannel();\nconst port = channel.port2;\n\n// 每次 port.postMessage() 调用就会添加一个宏任务\n// 该宏任务为调用 scheduler.scheduleTask 方法\nchannel.port1.onmessage = scheduler.scheduleTask;\n\nconst scheduler = {\n  scheduleTask() {\n    // 挑选一个任务并执行\n    const task = pickTask();\n    const continuousTask = task();\n\n    // 如果当前任务未完成，则在下个宏任务继续执行\n    if (continuousTask) {\n      port.postMessage(null);\n    }\n  },\n};\n\n\n> React 把任务切分成很多片段，这样就可以通过把任务交给 postMessage 的回调函数，来让浏览器主线程拿回控制权，进行一些更优先的渲染任务（比如用户输入）\n\n为什么不用执行时机更靠前的微任务呢？关键的原因在于微任务会在渲染之前执行，这样就算浏览器有紧急的渲染任务，也得等微任务执行完才能渲染\n\n\n# 22.4 说一下requestAnimationFrame\n\n简介：\n\n显示器都有自己固有的刷新频率(60HZ或者75HZ)，也就是说每秒最多重绘60次或者75次。而requestAnimationFrame的基本思想就是与这个刷新频率保持同步，利用这个刷新频率进行重绘。\n\n特点：\n\n * 使用这个API时，一旦页面不处于浏览器的当前标签，就会自动停止刷新，这样就节省了CPU、GPU、电力。\n * 由于它时在主线程上完成的，所以若是主线程非常忙时它的动画也会收到影响\n * 它使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。\n\n使用：\n\n正常使用：\n\nconst requestID = window.requestAnimationFrame(callback);\n\n\n兼容版本：\n\n// 给 window 下挂载一个兼容版本的 requestAniFrame\nwindow.requestAniFrame = (function () {\n  return  window.requestAnimationFrame || \n    window.webkitRequestAnimationFrame || \n    window.mozRequestAnimationFrame    || \n    window.oRequestAnimationFrame      || \n    window.msRequestAnimationFrame     || \n    function( callback ){\n      window.setTimeout(callback, 1000 / 60);\n    };\n})();\n\n\n\n# 22.5 requestAnimationFrame对比setTimeout\n\n * 屏幕刷新频率 屏幕每秒出现图像的次数。普通笔记本为60Hz\n * 动画原理 计算机每16.7ms刷新一次，由于人眼的视觉停留，所以看起来是流畅的移动。\n * setTimeout 通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿抖动的现象；原因是：\n\n 1. settimeout 任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；\n 2. settimeout 的固定时间间隔不一定与屏幕刷新时间相同，会引起丢帧。\n\n> requestAnimationFrame 优势：由系统决定回调函数的执行时机。60Hz的刷新频率，那么每次刷新的间隔中会执行一次回调函数，不会引起丢帧，不会卡顿。且由于一旦页面不处于浏览器的当前标签，就会自动停止刷新，这样就节省了CPU、GPU、电力。\n\n\n# 21 谈谈你对for in/for of的理解\n\n> for in性能很差，迭代当前对象中可枚举的属性，并且一直查找到原型上去。\n\n * 问题1：遍历顺序数字优先\n * 问题2：无法遍历symbol属性\n * 问题3：可以遍历到原型属性中可枚举的\n\nlet obj = {\n  name: 'poetry',\n  age: 22,\n  [Symbol('aa')]: 100,\n  0: 200,\n  1: 300\n}\n\n\n\n\nfor(let key in obj) {\n  // 不遍历原型上的属性\n  if(!obj.hasOwnProperty(key)) {\n    break;\n  }\n}\n\n\n遍历obj的私有属性拼接\n\nlet keys = Object.keys(obj)\nkeys = keys.concat(Object.getOwnPropertySymbols(obj1))\nkeys.forEach(v=>{\n  console.log(v)\n})\n\n\nfor of\n\n * 部分数据结构实现了迭代器规范\n   * Symbol.itertor\n   * 数组/set/map\n   * 对象没有实现，for of不能遍历对象\n\n// 数组具备迭代器规范，模拟实现\nvar arr = [1,2,3,4,5]\n\narr[Symbol.iterator] = function() {\n  let self = this, index = 0;\n\n  return {\n    next() {\n      if(index > self.length - 1) {\n        return {\n          done: true,\n          value: undefined\n        }\n      }\n      return {\n        done: false,\n        value: self[index++]\n      }\n    }\n  }\n}\n    \n// 使对象具备可迭代特性\nlet obj = {\n  0: 100,\n  1: 200,\n  length: 2\n}\n\nobj[Symbol.iterator] = Array.prototype[Symbol.iterator]\n\nfor(var val of obj) {\n  console.log(val)\n}\n\n\n\n# 22 JavaScript 实现对上传图片的压缩？\n\n> 答：读取用户上传的 File 对象，读写到画布（canvas）上，利用 Canvas 的 API 进行压缩，完成压缩之后再转成 File（Blob） 对象，上传到远程图片服务器；不过有时候我们也需要将一个 base64 字符串压缩之后再变为 base64 字符串传入到远程数据库或者再转成 File（Blob） 对象。\n\n思路就是 File + Canvas 的 drawImage",
      "normalizedContent": "# 1 数据类型基础\n\n\n# 1.1 js内置类型\n\n * js 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（object）。\n\n * 基本类型有七种：null，undefined，boolean，number，string，symbol，bigint\n   \n   * 其中 symbol 和 bigint 是 es6 新增的数据类型\n   \n   * symbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。\n   \n   * bigint 可以表示任意大小的整数。\n\n * 其中 js 的数字类型是浮点类型的，没有整型。并且浮点类型基于 ieee 754标准实现，在使用中会遇到某些 bug。nan 也属于 number 类型，并且 nan 不等于自身。\n\n * 对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型。\n\n引用数据类型：\n\n * 对象object（包含普通对象-object，数组对象-array，正则对象-regexp，日期对象-date，数学函数-math，函数对象-function）\n\nlet a = 111 // 这只是字面量，不是 number 类型\na.tostring() // 使用时候才会转换为对象类型\n\n\n * 对象（object）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。\n\nlet a = { name: 'fe' }\nlet b = a\nb.name = 'ef'\nconsole.log(a.name) // ef\n\n\n说出下面运行的结果，解释原因。\n\nfunction test(person) {\n  person.age = 26\n  person = {\n    name: 'hzj',\n    age: 18\n  }\n  return person\n}\nconst p1 = {\n  name: 'fyq',\n  age: 19\n}\nconst p2 = test(p1)\nconsole.log(p1) // -> ?\nconsole.log(p2) // -> ?\n\n\n// 结果:\np1：{name: “fyq”, age: 26}\np2：{name: “hzj”, age: 18}\n\n\n原因: 在函数传参的时候传递的是对象在堆中的内存地址值，test函数中的实参person是p1对象的内存地址，通过调用person.age = 26确实改变了p1的值，但随后person变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2。\n\n\n# 1.2 null和undefined区别\n\nundefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。用法：\n\n * 变量被声明了，但没有赋值时，就等于undefined。\n\n * 调用函数时，应该提供的参数没有提供，该参数等于undefined。\n\n * 对象没有赋值的属性，该属性的值为undefined。\n\n * 函数没有返回值时，默认返回undefined\n\nnull类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。用法：\n\n * 作为函数的参数，表示该函数的参数不是对象。\n\n * 作为对象原型链的终点\n\n\n# 1.3 null是对象吗？为什么？\n\n结论: null不是对象。\n\n解释: 虽然 typeof null 会输出 object，但是这只是 js 存在的一个悠久 bug。在 js 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。\n\n\n# 1.4 '1'.tostring()为什么可以调用？\n\n其实在这个语句运行的过程中做了这样几件事情：\n\nvar s = new object('1');\ns.tostring();\ns = null;\n\n\n * 第一步: 创建object类实例。注意为什么不是string ？ 由于symbol和bigint的出现，对它们调用new都会报错，目前es6规范也不建议用new来创建基本类型的包装类。\n * 第二步: 调用实例方法。\n * 第三步: 执行完方法立即销毁这个实例。\n\n整个过程体现了基本包装类型的性质，而基本包装类型恰恰属于基本数据类型，包括boolean, number和string。\n\n\n# 1.5 0.1+0.2为什么不等于0.3？如何让其相等\n\n0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004\n\n我们都知道计算机时是通过二进制来进行计算的，即 0 和 1\n\n * 就拿 0.1 + 0.2 来说，0.1表示为0.0001100110011001...，而0.2表示为0.0011001100110011...\n\n * 而在二进制中 1 + 1 = 10，所以 0.1 + 0.2 = 0.0100110011001100...\n\n * 转成10进制就近似表示为 0.30000000000000004\n\n简单来说就是，浮点数转成二进制时丢失了精度，因此在二进制计算完再转回十进制时可能会和理论结果不同\n\n1. es6提供的number.epsilon方法\n\nfunction isequal(a, b) {\n  return math.abs(a - b) < number.epsilon;\n}\n\nconsole.log(isequal(0.1 + 0.2, 0.3)); // true\n\n\n> number.epsilon 的实质是一个可以接受的最小误差范围，一般来说为 math.pow(2, -52)\n\n2. 乘以一个10的幂次方\n\n> 把需要计算的数字乘以10的n次方，让数值都变为整数，计算完后再除以10的n次方，这样就不会出现浮点数精度丢失问题\n\n(0.1*10 + 0.2*10) / 10 == 0.3 //true\n\n\n\n# 1.6 如何理解bigint\n\n什么是bigint?\n\n> bigint是一种新的数据类型，用于当整数值大于number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。\n\n为什么需要bigint?\n\n * 在js中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？\n\n * 这导致js中的number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，js中的number类型只能安全地表示-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。\n\nconsole.log(999999999999999);  //=>10000000000000000\n\n\n同时也会有一定的安全性问题:\n\n9007199254740992 === 9007199254740993;    // → true 居然是true!\n\n\n如何创建并使用bigint？\n\n要创建bigint，只需要在数字末尾追加n即可\n\nconsole.log( 9007199254740995n );    // → 9007199254740995n\t\nconsole.log( 9007199254740995 );     // → 9007199254740996\n\n\n另一种创建bigint的方法是用bigint()构造函数\n\nbigint(\"9007199254740995\");    // → 9007199254740995n\n\n\n简单使用如下:\n\n10n + 20n;    // → 30n\t\n10n - 20n;    // → -10n\t\n+10n;         // → typeerror: cannot convert a bigint value to a number\t\n-10n;         // → -10n\t\n10n * 20n;    // → 200n\t\n20n / 10n;    // → 2n\t\n23n % 10n;    // → 3n\t\n10n ** 3n;    // → 1000n\t\n\nconst x = 10n;\t\n++x;          // → 11n\t\n--x;          // → 9n\nconsole.log(typeof x);   //\"bigint\"\n\n\n值得警惕的点\n\n> bigint不支持一元加号运算符, 这可能是某些程序可能依赖于 + 始终生成 number 的不变量，或者抛出异常。另外，更改 + 的行为也会破坏 asm.js 代码。\n\n因为隐式类型转换可能丢失信息，所以不允许在bigint和 number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由bigint或number精确表示。\n\n10 + 10n;    // → typeerror\n\n\n> 不能将bigint传递给web api和内置的 js 函数，这些函数需要一个 number 类型的数字。尝试这样做会报typeerror错误。\n\nmath.max(2n, 4n, 6n);    // → typeerror\n\n\n> 当 boolean 类型与 bigint 类型相遇时，bigint 的处理方式与number类似，换句话说，只要不是0n，bigint就被视为truthy的值。\n\nif(0n){//条件判断为false\n}\nif(3n){//条件为true\n}\n\n\n * 元素都为bigint的数组可以进行sort。\n * bigint可以正常地进行位运算，如|、&、<<、>>和^\n\n\n# 1.7 js 整数是怎么表示的\n\n * 通过 number 类型来表示，遵循 ieee754 标准，通过 64 位来表示一个数字，（1 + 11 + 52），最大安全数字是 math.pow(2, 53) - 1，对于 16 位十进制。（符号位 + 指数位 + 小数部分有效位）\n\n\n# 1.8 number() 的存储空间是多大？如果后台发送了一个超过最大自己的数字怎么办\n\n * math.pow(2, 53) ，53 为有效数字，会发生截断，等于 js 能支持的最大数字。\n\n\n# 2 数据类型检测\n\n\n# 2.1 typeof类型判断\n\n> 在写业务逻辑的时候，经常要用到js数据类型的判断，面试常见的案例深浅拷贝也要用到数据类型的判断。\n\ntypeof\n\nconsole.log(typeof 2);               // number\nconsole.log(typeof true);            // boolean\nconsole.log(typeof 'str');           // string\nconsole.log(typeof undefined);       // undefined\nconsole.log(typeof function(){});    // function\nconsole.log(typeof symbol(\"foo\")); // symbol\nconsole.log(typeof 2172141653n); // bigint\n\n// 不能判别\nconsole.log(typeof []); // object\nconsole.log(typeof {}); // object\nconsole.log(typeof null); // object\n\n\n> 优点：能够快速区分基本数据类型 缺点：不能将object、array和null区分，都返回object\n\ninstanceof\n\nconsole.log(2 instanceof number);                    // false\nconsole.log(true instanceof boolean);                // false \nconsole.log('str' instanceof string);                // false  \nconsole.log([] instanceof array);                    // true\nconsole.log(function(){} instanceof function);       // true\nconsole.log({} instanceof object);                   // true\n\n\n * 优点：能够区分array、object和function，适合用于判断自定义的类实例对象\n\n * 缺点：number，boolean，string基本数据类型不能判断\n\n其内部运行机制是判断在其原型链中能否找到该类型的原型\n\nclass people {}\nclass student extends people {}\n\nconst stu = new student();\n\nconsole.log(stu instanceof people); // true\nconsole.log(stu instanceof student); // true\n\n\n其实现就是顺着原型链去找，如果能找到对应的 xxxxx.prototype 即为 true 。比如这里的 stu 作为实例，顺着原型链能找到 student.prototype 及 people.prototype ，所以都为 true\n\nobject.prototype.tostring.call()\n\nvar tostring = object.prototype.tostring;\n \nconsole.log(tostring.call(2));                      //[object number]\nconsole.log(tostring.call(true));                   //[object boolean]\nconsole.log(tostring.call('str'));                  //[object string]\nconsole.log(tostring.call([]));                     //[object array]\nconsole.log(tostring.call(function(){}));           //[object function]\nconsole.log(tostring.call({}));                     //[object object]\nconsole.log(tostring.call(undefined));              //[object undefined]\nconsole.log(tostring.call(null));                   //[object null]\n\n\n * 优点：精准判断数据类型，所有原始数据类型都是能判断的，还有 error 对象，date 对象等\n * 缺点：写法繁琐不容易记，推荐进行封装后使用\n\nobject.prototype.tostring.call(2); // \"[object number]\"\nobject.prototype.tostring.call(\"\"); // \"[object string]\"\nobject.prototype.tostring.call(true); // \"[object boolean]\"\nobject.prototype.tostring.call(undefined); // \"[object undefined]\"\nobject.prototype.tostring.call(null); // \"[object null]\"\nobject.prototype.tostring.call(math); // \"[object math]\"\nobject.prototype.tostring.call({}); // \"[object object]\"\nobject.prototype.tostring.call([]); // \"[object array]\"\nobject.prototype.tostring.call(function () {}); // \"[object function]\"\n\n\n在面试中有一个经常被问的问题就是：如何判断变量是否为数组？\n\narray.isarray(arr); // true\narr.__proto__ === array.prototype; // true\narr instanceof array; // true\nobject.prototype.tostring.call(arr); // \"[object array]\"\n\n\n判断是否是promise对象\n\nfunction ispromise (val) {\n    return (\n      typeof val.then === 'function' &&\n      typeof val.catch === 'function'\n    )\n}\n\n\n\n# 2.2 typeof 于 instanceof 区别\n\n * typeof 对于基本类型，除了 null都可以显示正确的类型\n\ntypeof 1 // 'number'\ntypeof '1' // 'string'\ntypeof undefined // 'undefined'\ntypeof true // 'boolean'\ntypeof symbol() // 'symbol'\ntypeof b // b 没有声明，但是还会显示 undefined\n\n\n * typeof 对于对象，除了函数都会显示 object\n\ntypeof [] // 'object'\ntypeof {} // 'object'\ntypeof console.log // 'function'\n\n\n * 对于 null 来说，虽然它是基本类型，但是会显示 object，这是一个存在很久了的 bug\n\ntypeof null // 'object'\n\n\n * instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 iprototype\n\n// 我们也可以试着实现一下 instanceof\nfunction _instanceof(left, right) {\n    // 由于instance要检测的是某对象，需要有一个前置判断条件\n    //基本数据类型直接返回false\n    if(typeof left !== 'object' || left === null) return false;\n\n    // 获得类型的原型\n    let prototype = right.prototype\n    // 获得对象的原型\n    left = left.__proto__\n    // 判断对象的类型是否等于类型的原型\n    while (true) {\n    \tif (left === null)\n    \t\treturn false\n    \tif (prototype === left)\n    \t\treturn true\n    \tleft = left.__proto__\n    }\n}\n\nconsole.log('test', _instanceof(null, array)) // false\nconsole.log('test', _instanceof([], array)) // true\nconsole.log('test', _instanceof('', array)) // false\nconsole.log('test', _instanceof({}, object)) // true\n\n\n\n# 2.3 总结\n\n * typeof\n   \n   * 直接在计算机底层基于数据类型的值（二进制）进行检测\n   \n   * typeof null为object 原因是对象存在在计算机中，都是以000开始的二进制存储，所以检测出来的结果是对象\n   \n   * typeof 普通对象/数组对象/正则对象/日期对象 都是object\n   \n   * typeof nan === 'number'\n\n * instanceof\n   \n   * 检测当前实例是否属于这个类的\n   * 底层机制：只要当前类出现在实例的原型上，结果都是true\n   * 不能检测基本数据类型\n\n * constructor\n   \n   * 支持基本类型\n   * constructor可以随便改，也不准\n\n * object.prototype.tostring.call([val])\n   \n   * 返回当前实例所属类信息\n\n> 判断 target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 js 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:\n\n * 基本类型(null): 使用 string(null)\n\n * 基本类型(string / number / boolean / undefined) + function: - 直接使用 typeof即可\n\n * 其余引用类型(array / date / regexp error): 调用tostring后根据[object xxx]进行判断\n\n很稳的判断封装:\n\nlet class2type = {}\n'array date regexp object error'.split(' ').foreach(e => class2type[ '[object ' + e + ']' ] = e.tolowercase()) \n\nfunction type(obj) {\n  if (obj == null) return string(obj)\n  return typeof obj === 'object' ? class2type[ object.prototype.tostring.call(obj) ] || 'object' : typeof obj\n}\n\n\n\n# 3 数据类型转换\n\n> 大家都知道 js 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:\n\n\n# 3.1 转化规则\n\n * -、*、/、%：一律转换成数值后计算\n\n * +：\n   \n   * 数字 + 字符串 = 字符串， 运算顺序是从左到右\n   \n   * 数字 + 对象， 优先调用对象的valueof -> tostring\n   \n   * 数字 + boolean/null -> 数字\n   \n   * 数字 + undefined -> nan\n\n * [1].tostring() === '1'\n\n * {}.tostring() === '[object object]'\n\n * nan !== nan 、+undefined 为 nan\n\n> 首先我们要知道，在 js 中类型转换只有三种情况，分别是：\n\n * 转换为布尔值\n * 转换为数字\n * 转换为字符串\n\n\n\n\n# 3.2 转boolean\n\n * 在条件判断时，除了 undefined，null， false， nan， ''， 0， -0，其他所有值都转为 true，包括所有对象\n\n\n# 3.3 比较运算符\n\n * 如果是对象，就通过 toprimitive 转换对象\n\n * 如果是字符串，就通过 unicode 字符索引来比较\n\nlet a = {\n  valueof() {\n    return 0\n  },\n  tostring() {\n    return '1'\n  }\n}\na > -1 // true\n\n\n在以上代码中，因为 a 是对象，所以会通过 valueof 转换为原始类型再比较值。\n\n\n# 3.4 [] == ![]结果是什么？为什么？\n\n * == 中，左右两边都需要转换为数字然后进行比较\n\n * []转换为数字为0\n\n * ![] 首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为true\n\n * 因此![]为false，进而在转换成数字，变为0\n\n * 0 == 0 ， 结果为true\n\n\n# 3.5】、 == 和 ===有什么区别\n\n> ===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如'1'===1的结果是false，因为一边是string，另一边是number\n\n==不像===那样严格，对于一般情况，只要值相等，就返回true，但==还涉及一些类型转换，它的转换规则如下\n\n * 两边的类型是否相同，相同的话就比较值的大小，例如1==2，返回false\n\n * 判断的是否是null和undefined，是的话就返回true\n\n * 判断的类型是否是string和number，是的话，把string类型转换成number，再进行比较\n\n * 判断其中一方是否是boolean，是的话就把boolean转换成number`，再进行比较\n\n * 如果其中一方为object，且另一方为string、number或者symbol，会将object转换成字符串，再进行比较\n\n\n# 4 闭包\n\n> 红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数，\n\n> mdn 对闭包的定义为：闭包是指那些能够访问自由变量的函数。\n> \n>  * （其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量。）\n\n\n# 4.1 闭包产生的原因\n\n> 首先要明白作用域链的概念，其实很简单，在es5中只存在两种作用域————全局作用域和函数作用域，当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链，值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。 比如:\n\nvar a = 1;\nfunction f1() {\n  var a = 2\n  function f2() {\n    var a = 3;\n    console.log(a);//3\n  }\n}\n\n\n> 在这段代码中，f1的作用域指向有全局作用域(window)和它本身，而f2的作用域指向全局作用域(window)、f1和它本身。而且作用域是从最底层向上找，直到找到全局作用域window为止，如果全局还没有的话就会报错。就这么简单一件事情\n\n闭包产生的本质就是，当前环境中存在指向父级作用域的引用。还是举上面的例子:\n\nfunction f1() {\n  var a = 2\n  function f2() {\n    console.log(a);//2\n  }\n  return f2;\n}\nvar x = f1();\nx();\n\n\n> 这里x会拿到父级作用域中的变量，输出2。因为在当前环境中，含有对f2的引用，f2恰恰引用了window、f1和f2的作用域。因此f2可以访问到f1的作用域的变量。\n\n * 那是不是只有返回函数才算是产生了闭包呢？\n * 回到闭包的本质，我们只需要让父级作用域的引用存在即可，因此我们还可以这么做：\n\nvar f3;\nfunction f1() {\n  var a = 2\n  f3 = function() {\n    console.log(a);\n  }\n}\nf1();\nf3();\n\n\n * 让f1执行，给f3赋值后，等于说现在f3拥有了window、f1和f3本身这几个作用域的访问权限，还是自底向上查找，最近是在f1中找到了a,因此输出2。\n\n * 在这里是外面的变量f3存在着父级作用域的引用，因此产生了闭包，形式变了，本质没有改变\n\n\n# 4.2 闭包有哪些表现形式\n\n明白了本质之后，我们就来看看，在真实的场景中，究竟在哪些地方能体现闭包的存在？\n\n 1. 返回一个函数。刚刚已经举例。\n 2. 作为函数参数传递\n\nvar a = 1;\nfunction foo(){\n  var a = 2;\n  function baz(){\n    console.log(a);\n  }\n  bar(baz);\n}\nfunction bar(fn){\n  // 这就是闭包\n  fn();\n}\n// 输出2，而不是1\nfoo();\n\n\n 1. 在定时器、事件监听、ajax请求、跨窗口通信、web workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包\n\n以下的闭包保存的仅仅是window和当前作用域。\n\n// 定时器\nsettimeout(function timehandler(){\n  console.log('111');\n}，100)\n\n// 事件监听\n$('#app').click(function(){\n  console.log('dom listener');\n})\n\n\n 1. iife(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以访问全局的变量\n\nvar a = 2;\n(function iife(){\n  // 输出2\n  console.log(a);\n})();\n\n\n\n# 4.3 如何解决下面的循环输出问题\n\nfor(var i = 1; i <= 5; i ++){\n  settimeout(function timer(){\n    console.log(i)\n  }, 0)\n}\n\n\n为什么会全部输出6？如何改进，让它输出1，2，3，4，5？(方法越多越好) 因为settimeout为宏任务，由于js中单线程eventloop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后settimeout中的回调才依次执行，但输出i的时候当前作用域没有，往上一级再找，发现了i,此时循环已经结束，i变成了6。因此会全部输出6。\n\n解决方法：\n\n 1. 利用iife(立即执行函数表达式)当每次for循环时，把此时的i变量传递到定时器中\n\nfor(var i = 1;i <= 5;i++){\n  (function(j){\n    settimeout(function timer(){\n      console.log(j)\n    }, 0)\n  })(i)\n}\n\n\n 1. 给定时器传入第三个参数, 作为timer函数的第一个函数参数\n\nfor(var i=1;i<=5;i++){\n  settimeout(function timer(j){\n    console.log(j)\n  }, 0, i)\n}\n\n\n 1. 使用es6中的let\n\nfor(let i = 1; i <= 5; i++){\n  settimeout(function timer(){\n    console.log(i)\n  },0)\n}\n\n\n> let使js发生革命性的变化，让js有函数作用域变为了块级作用域，用let后作用域链不复存在。代码的作用域以块级为单位，以上面代码为例:\n\n// i = 1\n{\n  settimeout(function timer(){\n    console.log(1)\n  },0)\n}\n// i = 2\n{\n  settimeout(function timer(){\n    console.log(2)\n  },0)\n}\n// i = 3\n...\n\n\n\n# 4.4 闭包的几种使用场景\n\n1. 返回值（最常用）\n\n//1.返回值 最常用的\nfunction fn(){\n    var name=\"hello\";\n    return function(){\n        return name;\n    }\n}\nvar fnc = fn();\nconsole.log(fnc())//hello\n\n\n> 这个很好理解就是以闭包的形式将 name 返回\n\n2. 函数赋值\n\nvar fn2;\nfunction fn(){\n    var name=\"hello\";\n    //将函数赋值给fn2\n    fn2 = function(){\n        return name;\n    }\n}\nfn()//要先执行进行赋值，\nconsole.log(fn2())//执行输出fn2\n\n\n> 在闭包里面给fn2函数设置值，闭包的形式把name属性记忆下来，执行会输出 hello。\n\n3. 函数参数\n\nfunction fn(){\n    var name=\"hello\";\n    return function callback(){\n        return name;\n    }\n}\nvar fn1 = fn()//执行函数将返回值（callback函数）赋值给fn1，\n \nfunction fn2(f){\n    //将函数作为参数传入\n    console.log(f());//执行函数，并输出\n}\nfn2(fn1)//执行输出fn2\n\n\n> 用闭包返回一个函数，把此函数作为另一个函数的参数，在另一个函数里面执行这个函数，最终输出 hello\n\n4. iife（自执行函数）\n\n(function(){\n    var name=\"hello\";\n    var fn1= function(){\n        return name;\n    }\n    //直接在自执行函数里面调用fn2，将fn1作为参数传入\n    fn2(fn1);\n})()\nfunction fn2(f){\n    //将函数作为参数传入\n    console.log(f());//执行函数，并输出\n}\n\n\n> 直接在自执行函数里面将封装的函数fn1传给fn2，作为参数调用同样可以获得结果 hello\n\n5. 循环赋值\n\n//每秒执行1次，分别输出1-10\nfor(var i=1;i<=10;i++){\n    (function(j){\n        //j来接收\n        settimeout(function(){\n            console.log(j);\n        },j*1000);\n    })(i)//i作为实参传入\n}\n\n\n> 如果不采用闭包的话，会有不一样的情况\n\n6. getter和setter\n\nfunction fn(){\n    var name='hello'\n    setname=function(n){\n        name = n;\n    }\n    getname=function(){\n        return name;\n    }\n\n    //将setname，getname作为对象的属性返回\n    return {\n        setname:setname,\n        getname:getname\n    }\n}\nvar fn1 = fn();//返回对象，属性setname和getname是两个函数\nconsole.log(fn1.getname());//getter\nfn1.setname('world');//setter修改闭包里面的name\nconsole.log(fn1.getname());//getter\n\n\n> 第一次输出 hello 用setter以后再输出 world ，这样做可以封装成公共方法，防止不想暴露的属性和函数暴露在外部\n\n7. 迭代器（执行一次函数往下取一个值）\n\nvar arr =['aa','bb','cc'];\nfunction incre(arr){\n    var i=0;\n    return function(){\n        //这个函数每次被执行都返回数组arr中 i下标对应的元素\n         return arr[i++] || '数组值已经遍历完';\n    }\n}\nvar next = incre(arr);\nconsole.log(next());//aa\nconsole.log(next());//bb\nconsole.log(next());//cc\nconsole.log(next());//数组值已经遍历完\n\n\n\n# 5 原型和原型链链\n\n\n# 5.1 原型/构造函数/实例\n\n * 原型(prototype): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 firefox 和 chrome 中，每个javascript对象中都包含一个__proto__(非标准)的属性指向它爹(该对象的原型)，可obj.__proto__进行访问。\n\n * 构造函数: 可以通过new来 新建一个对象 的函数。\n\n * 实例: 通过构造函数和new创建出来的对象，便是实例。 实例通过__proto__指向原型，通过constructor指向构造函数。\n\n> 以object为例，我们常用的object便是一个构造函数，因此我们可以通过它构建实例。\n\n// 实例\nconst instance = new object()\n\n\n> 则此时， 实例为instance, 构造函数为object，我们知道，构造函数拥有一个prototype的属性指向原型，因此原型为:\n\n// 原型\nconst prototype = object.prototype\n\n\n这里我们可以来看出三者的关系:\n\n * 实例.__proto__ === 原型\n\n * 原型.constructor === 构造函数\n\n * 构造函数.prototype === 原型\n\n// 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线\n// 例如: \n// const o = new object()\n// o.constructor === object   --> true\n// o.__proto__ = null;\n// o.constructor === object   --> false\n实例.constructor === 构造函数\n\n\n\n\n\n# 5.2 原型对象和构造函数有何关系\n\n * 在javascript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性，这个属性指向函数的原型对象。\n\n * 当函数经过new调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个实例对象有一个__proto__属性，指向构造函数的原型对象。\n\n\n\n\n# 5.3 能不能描述一下原型链\n\n> javascript对象通过__proto__ 指向父类对象，直到指向object对象为止，这样就形成了一个原型指向的链条, 即原型链\n\n\n\n * 对象的 hasownproperty() 来检查对象自身中是否含有该属性\n\n * 使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true\n\n\n# 6 继承\n\n\n# 6.1 方式1: 借助call\n\n function parent1(){\n    this.name = 'parent1';\n  }\n  function child1(){\n    parent1.call(this);\n    this.type = 'child1'\n  }\n  console.log(new child1);\n\n\n> 这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。\n\n\n# 6.2 方式2: 借助原型链\n\n function parent2() {\n    this.name = 'parent2';\n    this.play = [1, 2, 3]\n  }\n  function child2() {\n    this.type = 'child2';\n  }\n  child2.prototype = new parent2();\n\n  console.log(new child2());\n\n\n看似没有问题，父类的方法和属性都能够访问，但实际上有一个潜在的不足。举个例子：\n\nvar s1 = new child2();\nvar s2 = new child2();\ns1.play.push(4);\nconsole.log(s1.play, s2.play);\n\n\n可以看到控制台：\n\n\n\n> 明明我只改变了s1的play属性，为什么s2也跟着变了呢？很简单，因为两个实例使用的是同一个原型对象。\n\n那么还有更好的方式么？\n\n\n# 6.3 方式3：将前两种组合\n\n  function parent3 () {\n    this.name = 'parent3';\n    this.play = [1, 2, 3];\n  }\n  function child3() {\n    parent3.call(this);\n    this.type = 'child3';\n  }\n  child3.prototype = new parent3();\n  var s3 = new child3();\n  var s4 = new child3();\n  s3.play.push(4);\n  console.log(s3.play, s4.play);\n\n\n可以看到控制台：\n\n\n\n> 之前的问题都得以解决。但是这里又徒增了一个新问题，那就是parent3的构造函数会多执行了一次（child3.prototype = new parent3();）。这是我们不愿看到的。那么如何解决这个问题？\n\n\n# 6.4 方式4: 组合继承的优化1\n\n  function parent4 () {\n    this.name = 'parent4';\n    this.play = [1, 2, 3];\n  }\n  function child4() {\n    parent4.call(this);\n    this.type = 'child4';\n  }\n  child4.prototype = parent4.prototype;\n\n\n这里让将父类原型对象直接给到子类，父类构造函数只执行一次，而且父类属性和方法均能访问，但是我们来测试一下：\n\nvar s3 = new child4();\nvar s4 = new child4();\nconsole.log(s3)\n\n\n\n\n> 子类实例的构造函数是parent4，显然这是不对的，应该是child4。\n\n\n# 6.5 方式5(最推荐使用): 组合继承的优化2\n\n function parent5 () {\n    this.name = 'parent5';\n    this.play = [1, 2, 3];\n  }\n  function child5() {\n    parent5.call(this);\n    this.type = 'child5';\n  }\n  child5.prototype = object.create(parent5.prototype);\n  child5.prototype.constructor = child5;\n\n\n这是最推荐的一种方式，接近完美的继承，它的名字也叫做寄生组合继承。\n\n\n# 6.6 es6的extends被编译后的javascript代码\n\n> es6的代码最后都是要在浏览器上能够跑起来的，这中间就利用了babel这个编译工具，将es6的代码编译成es5让一些不支持新语法的浏览器也能运行。\n\n那最后编译成了什么样子呢？\n\nfunction _possibleconstructorreturn(self, call) {\n    // ...\n    return call && (typeof call === 'object' || typeof call === 'function') ? call : self;\n}\n\nfunction _inherits(subclass, superclass) {\n    // ...\n    //看到没有\n    subclass.prototype = object.create(superclass && superclass.prototype, {\n        constructor: {\n            value: subclass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superclass) object.setprototypeof ? object.setprototypeof(subclass, superclass) : subclass.__proto__ = superclass;\n}\n\n\nvar parent = function parent() {\n    // 验证是否是 parent 构造出来的 this\n    _classcallcheck(this, parent);\n};\n\nvar child = (function (_parent) {\n    _inherits(child, _parent);\n\n    function child() {\n        _classcallcheck(this, child);\n\n        return _possibleconstructorreturn(this, (child.__proto__ || object.getprototypeof(child)).apply(this, arguments));\n    }\n\n    return child;\n}(parent));\n\n\n> 核心是_inherits函数，可以看到它采用的依然也是第五种方式————寄生组合继承方式，同时证明了这种方式的成功。不过这里加了一个object.setprototypeof(subclass, superclass)，这是用来干啥的呢？\n\n答案是用来继承父类的静态方法。这也是原来的继承方式疏忽掉的地方。\n\n追问: 面向对象的设计一定是好的设计吗？\n\n> 不一定。从继承的角度说，这一设计是存在巨大隐患的。\n\n\n# 6.7 从设计思想上谈谈继承本身的问题\n\n假如现在有不同品牌的车，每辆车都有drive、music、addoil这三个方法。\n\nclass car{\n  constructor(id) {\n    this.id = id;\n  }\n  drive(){\n    console.log(\"wuwuwu!\");\n  }\n  music(){\n    console.log(\"lalala!\")\n  }\n  addoil(){\n    console.log(\"哦哟！\")\n  }\n}\nclass othercar extends car{}\n\n\n现在可以实现车的功能，并且以此去扩展不同的车。\n\n但是问题来了，新能源汽车也是车，但是它并不需要addoil(加油)。\n\n如果让新能源汽车的类继承car的话，也是有问题的，俗称\"大猩猩和香蕉\"的问题。大猩猩手里有香蕉，但是我现在明明只需要香蕉，却拿到了一只大猩猩。也就是说加油这个方法，我现在是不需要的，但是由于继承的原因，也给到子类了。\n\n> 继承的最大问题在于：无法决定继承哪些属性，所有属性都得继承。\n\n当然你可能会说，可以再创建一个父类啊，把加油的方法给去掉，但是这也是有问题的，一方面父类是无法描述所有子类的细节情况的，为了不同的子类特性去增加不同的父类，代码势必会大量重复，另一方面一旦子类有所变动，父类也要进行相应的更新，代码的耦合性太高，维护性不好。\n\n那如何来解决继承的诸多问题呢？\n\n> 用组合，这也是当今编程语法发展的趋势，比如golang完全采用的是面向组合的设计方式。\n\n顾名思义，面向组合就是先设计一系列零件，然后将这些零件进行拼装，来形成不同的实例或者类。\n\nfunction drive(){\n  console.log(\"wuwuwu!\");\n}\nfunction music(){\n  console.log(\"lalala!\")\n}\nfunction addoil(){\n  console.log(\"哦哟！\")\n}\n\nlet car = compose(drive, music, addoil);\nlet newenergycar = compose(drive, music);\n\n\n> 代码干净，复用性也很好。这就是面向组合的设计方式。\n\n\n# 6.8 继承-简版\n\n> 在 es5 中，我们可以使用如下方式解决继承的问题\n\nfunction super() {}\nsuper.prototype.getnumber = function() {\n  return 1\n}\n\nfunction sub() {}\nlet s = new sub()\nsub.prototype = object.create(super.prototype, {\n  constructor: {\n    value: sub,\n    enumerable: false,\n    writable: true,\n    configurable: true\n  }\n})\n\n\n * 以上继承实现思路就是将子类的原型设置为父类的原型\n * 在 es6 中，我们可以通过 class 语法轻松解决这个问题\n\nclass mydate extends date {\n  test() {\n    return this.gettime()\n  }\n}\nlet mydate = new mydate()\nmydate.test()\n\n\n * 但是 es6 不是所有浏览器都兼容，所以我们需要使用 babel 来编译这段代码。\n\n * 如果你使用编译过得代码调用 mydate.test()你会惊奇地发现出现了报错\n\n> 因为在 js 底层有限制，如果不是由 date构造出来的实例的话，是不能调用 date 里的函数的。所以这也侧面的说明了：es6 中的 class 继承与 es5 中的一般继承写法是不同的。\n\n * 既然底层限制了实例必须由 date 构造出来，那么我们可以改变下思路实现继承\n\nfunction mydata() {\n\n}\nmydata.prototype.test = function () {\n  return this.gettime()\n}\nlet d = new date()\nobject.setprototypeof(d, mydata.prototype)\nobject.setprototypeof(mydata.prototype, date.prototype)\n\n\n * 以上继承实现思路：先创建父类实例 => 改变实例原先的 _proto__转而连接到子类的 prototype=> 子类的 prototype 的 __proto__ 改为父类的 prototype。\n\n * 通过以上方法实现的继承就可以完美解决 js 底层的这个限制\n\n\n# 7 this\n\n> 我们先来看几个函数调用的场景\n\nfunction foo() {\n  console.log(this.a)\n}\nvar a = 1\nfoo()\n\nconst obj = {\n  a: 2,\n  foo: foo\n}\nobj.foo()\n\nconst c = new foo()\n\n\n * 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是window\n\n * 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象\n\n * 对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this\n\n> 说完了以上几种情况，其实很多代码中的 this 应该就没什么问题了，下面让我们看看箭头函数中的 this\n\nfunction a() {\n  return () => {\n    return () => {\n      console.log(this)\n    }\n  }\n}\nconsole.log(a()()())\n\n\n * 首先箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外对箭头函数使用 bind这类函数是无效的。\n\n * 最后种情况也就是 bind 这些改变上下文的 api 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。\n\n * 那么说到 bind，不知道大家是否考虑过，如果对一个函数进行多次 bind，那么上下文会是什么呢？\n\nlet a = {}\nlet fn = function () { console.log(this) }\nfn.bind().bind(a)() // => ?\n\n\n> 如果你认为输出结果是 a，那么你就错了，其实我们可以把上述代码转换成另一种形式\n\n// fn.bind().bind(a) 等于\nlet fn2 = function fn1() {\n  return function() {\n    return fn.apply()\n  }.apply(a)\n}\nfn2()\n\n\n> 可以从上述代码中发现，不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window\n\nlet a = { name: 'poetries' }\nfunction foo() {\n  console.log(this.name)\n}\nfoo.bind(a)() // => 'poetries'\n\n\n> 以上就是 this 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 this 最终指向哪里。\n\n> 首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。\n\n\n\n总结\n\n> this执行主体，谁把它执行的和在哪创建的在哪执行的都没有必然的关系\n\n * 函数执行，看方法前面是否有点，没有点this是window(严格模式下是undefined)，有点，点前面是谁·this·就是谁\n\n * 给当前元素的某个事件行为绑定方法，当事件行为触发，方法中的this是当前元素本身（排除attachevent）\n\n * 构造函数体中this是当前类的实例\n\n * 箭头函数中没有执行主体，所用到的this都是所处上下文中的this\n\n * 可以基于function.prototype上的call/apply/bind改变this指向\n\n\n# 8 内存机制\n\n> 网上的资料基本是这样说的: 基本数据类型用栈存储，引用数据类型用堆存储。\n\n看起来没有错误，但实际上是有问题的。可以考虑一下闭包的情况，如果变量存在栈中，那函数调用完栈顶空间销毁，闭包变量不就没了吗？\n\n其实还是需要补充一句:\n\n> 闭包变量是存在堆内存中的。\n\n具体而言，以下数据类型存储在栈中:\n\n * boolean\n\n * null\n\n * undefined\n\n * number\n\n * string\n\n * symbol\n\n * bigint\n\n而所有的对象数据类型存放在堆中。\n\n> 值得注意的是，对于赋值操作，原始类型的数据直接完整地复制变量值，对象数据类型的数据则是复制引用地址。\n\n因此会有下面的情况:\n\nlet obj = { a: 1 };\nlet newobj = obj;\nnewobj.a = 2;\nconsole.log(obj.a);//变成了2\n\n\n * 之所以会这样，是因为 obj 和 newobj 是同一份堆空间的地址，改变newobj，等于改变了共同的堆内存，这时候通过 obj 来获取这块内存的值当然会改变。 当然，你可能会问: 为什么不全部用栈来保存呢？\n * 首先，对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能。举个例子:\n\n当然，你可能会问: 为什么不全部用栈来保存呢？\n\n首先，对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能。举个例子:\n\nfunction f(a) {\n  console.log(a);\n}\n\nfunction func(a) {\n  f(a);\n}\n\nfunc(1);\n\n\n * 假设用esp指针来保存当前的执行状态，在系统栈中会产生如下的过程：\n * 调用func, 将 func 函数的上下文压栈，esp指向栈顶。\n * 执行func，又调用f函数，将 f 函数的上下文压栈，esp 指针上移。\n * 执行完 f 函数，将esp 下移，f函数对应的栈顶空间被回收。\n * 执行完 func，esp 下移，func对应的空间被回收。\n\n图示如下:\n\n\n\n * 因此你也看到了，如果采用栈来存储相对基本类型更加复杂的对象数据，那么切换上下文的开销将变得巨大！\n * 不过堆内存虽然空间大，能存放大量的数据，但与此同时垃圾内存的回收会带来更大的开销\n\n\n# 9 执行上下文\n\n> 当执行 js 代码时，会产生三种执行上下文\n\n * 全局执行上下文\n * 函数执行上下文\n * eval 执行上下文\n\n> 每个执行上下文中都有三个重要的属性\n\n * 变量对象（vo），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问\n\n * 作用域链（js 采用词法作用域，也就是说变量的作用域是在定义时就决定了）\n\n * this\n\nvar a = 10\nfunction foo(i) {\n  var b = 20\n}\nfoo()\n\n\n> 对于上述代码，执行栈中有两个上下文：全局上下文和函数 foo 上下文。\n\nstack = [\n    globalcontext,\n    foocontext\n]\n\n\n> 对于全局上下文来说，vo大概是这样的\n\nglobalcontext.vo === globe\nglobalcontext.vo = {\n    a: undefined,\n\tfoo: <function>,\n}\n\n\n> 对于函数 foo 来说，vo 不能访问，只能访问到活动对象（ao）\n\nfoocontext.vo === foo.ao\nfoocontext.ao {\n    i: undefined,\n\tb: undefined,\n    arguments: <>\n}\n// arguments 是函数独有的对象(箭头函数没有)\n// 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素\n// 该对象中的 `callee` 属性代表函数本身\n// `caller` 属性代表函数的调用者\n\n\n> 对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过 [[scope]]属性查找上级变量\n\nfoocontext.[[scope]] = [\n    globalcontext.vo\n]\nfoocontext.scope = foocontext.[[scope]] + foocontext.vo\nfoocontext.scope = [\n    foocontext.vo,\n    globalcontext.vo\n]\n\n\n * 对于非匿名的立即执行函数需要注意以下一点\n\nvar foo = 1\n(function foo() {\n    foo = 10\n    console.log(foo)\n}()) // -> ƒ foo() { foo = 10 ; console.log(foo) }\n\n\n * 因为当 js 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 foo，但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。\n\nspecialobject = {};\n\nscope = specialobject + scope;\n\nfoo = new functionexpression;\nfoo.[[scope]] = scope;\nspecialobject.foo = foo; // {dontdelete}, {readonly}\n\ndelete scope[0]; // remove specialobject from the front of scope chain\n\n\n小结\n\n> 执行上下文可以简单理解为一个对象:\n\n它包含三个部分:\n\n * 变量对象(vo)\n * 作用域链(词法作用域)\n * this指向\n\n它的类型:\n\n * 全局执行上下文\n * 函数执行上下文\n * eval执行上下文\n\n代码执行过程:\n\n * 创建 全局上下文 (global ec)\n\n * 全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被push到执行栈顶层\n\n * 函数执行上下文被激活，成为 active ec, 开始执行函数中的代码，caller 被挂起\n\n * 函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行\n\n\n# 10 变量提升\n\n> 当执行 js 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境。\n\nb() // call b\nconsole.log(a) // undefined\n\nvar a = 'hello world'\n\nfunction b() {\n    console.log('call b')\n}\n\n\n * 想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，js 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用\n\n * 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升\n\nb() // call b second\n\nfunction b() {\n    console.log('call b fist')\n}\nfunction b() {\n    console.log('call b second')\n}\nvar b = 'hello world'\n\n\n> var 会产生很多错误，所以在 es6中引入了 let。let不能在声明前使用，但是这并不是常说的 let 不会提升，let提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用\n\n\n# 11 模块化\n\n> 模块化开发在现代开发中已是必不可少的一部分，它大大提高了项目的可维护、可拓展和可协作性。通常，我们 在浏览器中使用 es6 的模块化支持，在 node 中使用 commonjs 的模块化支持。\n\n分类:\n\n * es6: import / export\n\n * commonjs: require / module.exports / exports\n\n * amd: require / defined\n\nrequire与import的区别\n\n * require支持 动态导入，import不支持，正在提案 (babel 下可支持)\n\n * require是 同步 导入，import属于 异步 导入\n\n * require是 值拷贝，导出值变化不会影响导入值；import指向 内存地址，导入值会随导出值而变化\n\n\n# 12 异步编程\n\n> 这部分着重要理解 promise、async awiat、event loop 等\n\n\n# 12.1 浏览器中的event loop\n\n简版总结\n\njavascript 最早是用于写网页交互逻辑的，为了避免多线程同时修改 dom 的同步问题，设计成了单线程，又为了解决单线程的阻塞问题，加了一层调度逻辑，也就是 loop 循环和 task 队列，把阻塞的逻辑放到其他线程跑，从而支持了异步。然后为了支持高优先级的任务调度，又引入了微任务队列，这就是浏览器的 event loop 机制：每次执行一个宏任务，然后执行所有微任务\n\n\n\n正确的一次 event loop 顺序是这样的\n\n * 执行同步代码，这属于宏任务\n * 执行栈为空，查询是否有微任务需要执行\n * 执行所有微任务\n * 必要的话渲染 ui\n * 然后开始下一轮 event loop，执行宏任务中的异步代码\n\n> 通过 event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 dom 的话，为了更快的响应界面响应，我们可以把操作 dom 放入微任务中\n\n推荐一个可以在线看代码流程的网站：loupe (opens new window)，看一下这个学习视频(opens new window)\n\n> javascript 是用于实现网页交互逻辑的，涉及到 dom 操作，如果多个线程同时操作需要做同步互斥的处理，为了简化就设计成了单线程，但是如果单线程的话，遇到定时逻辑、网络请求又会阻塞住。怎么办呢？可以加一层调度逻辑。把 js 代码封装成一个个的任务，放在一个任务队列中，主线程就不断的取任务执行就好了。\n\n每次取任务执行，都会创建新的调用栈。\n\n\n\n> 其中，定时器、网络请求其实都是在别的线程执行的，执行完了之后在任务队列里放个任务，告诉主线程可以继续往下执行了\n\n\n\n * 因为这些异步任务是在别的线程执行完，然后通过任务队列通知下主线程，是一种事件机制，所以这个循环叫做 event loop\n\n * 这些在其他线程执行的异步任务包括定时器（settimeout、setinterval），ui 渲染、网络请求（xhr 或 fetch）。\n\n * 但是，现在的 event loop 有个严重的问题，没有优先级的概念，只是按照先后顺序来执行，那如果有高优先级的任务就得不到及时的执行了。所以，得设计一套插队机制。\n\n * 那就搞一个高优先级的任务队列就好了，每执行完一个普通任务，都去把所有高优先级的任务给执行完，之后再去执行普通任务。\n\n\n\n> 有了插队机制之后，高优任务就能得到及时的执行。这就是现在浏览器的 event loop，其中普通任务叫做 macrotask（宏任务），高优任务叫做 microtask（微任务）\n\n * 宏任务包括：settimeout、setinterval、requestanimationframe、ajax、fetch、script（浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务） 标签的代码\n * 微任务包括：promise.then、mutationobserver、object.observe\n\n怎么理解宏微任务的划分呢？\n\n * 定时器、网络请求这种都是在别的线程跑完之后通知主线程的普通异步逻辑，所以都是宏任务\n * 高优任务的这三种也很好理解，mutationobserver 和 object.observe 都是监听某个对象的变化的，变化是很瞬时的事情，肯定要马上响应，不然可能又变了，promise 是组织异步流程的，异步结束调用 then 也是很高优的\n\n> 这就是浏览器里的 event loop 的设计：设计 loop 机制和 task 队列是为了支持异步，解决逻辑执行阻塞主线程的问题，设计 microtask 队列的插队机制是为了解决高优任务尽早执行的问题\n\n但是后来，js 的执行环境不只是浏览器一种了，还有了 node.js，它同样也要解决这些问题，但是它设计出来的 event loop 更细致一些\n\n例子1\n\nsettimeout(function() {\n  console.log(1)\n}, 0);\nnew promise(function(resolve, reject) {\n  console.log(2);\n  resolve()\n}).then(function() {\n  console.log(3)\n});\nprocess.nexttick(function () {\n  console.log(4)\n})\nconsole.log(5)\n\n\n * 第一轮：主线程开始执行，遇到settimeout，将settimeout的回调函数丢到宏任务队列中，在往下执行new promise立即执行，输出2，then的回调函数丢到微任务队列中，再继续执行，遇到process.nexttick，同样将回调函数扔到微任务队列，再继续执行，输出5，当所有同步任务执行完成后看有没有可以执行的微任务，发现有then函数和nexttick两个微任务，先执行哪个呢？process.nexttick指定的异步任务总是发生在所有异步任务之前，因此先执行process.nexttick输出4然后执行then函数输出3，第一轮执行结束。\n\n * 第二轮：从宏任务队列开始，发现settimeout回调，输出1执行完毕，因此结果是25431\n\n例子2\n\nconsole.log('script start');\n\nsettimeout(function() {\n  console.log('settimeout');\n}, 0);\n\nnew promise((resolve) => {\n    console.log('promise')\n    resolve()\n}).then(function() {\n  console.log('promise1');\n}).then(function() {\n  console.log('promise2');\n});\n\nconsole.log('script end');\n// script start => promise => script end => promise1 => promise2 => settimeout\n\n\n> 以上代码虽然 settimeout 写在 promise 之前，但是因为 promise 属于微任务而 settimeout 属于宏任务\n\n\n# 12.2 node 中的 event loop\n\n首先从优先级出发理解node eventloop\n\n> node.js 是一个新的 js 运行环境，它同样要支持异步逻辑，包括定时器、io、网络请求，很明显，也可以用 event loop 那一套来跑\n\n但是呢，浏览器那套 ·event loop· 就是为浏览器设计的，对于做高性能服务器来说，那种设计还是有点粗糙了\n\n哪里粗糙呢？\n\n * 浏览器的 event loop 只分了两层优先级，一层是宏任务，一层是微任务。但是宏任务之间没有再划分优先级，微任务之间也没有再划分优先级。\n\n * 而 node.js 任务宏任务之间也是有优先级的，比如定时器 timer 的逻辑就比 io 的逻辑优先级高，因为涉及到时间，越早越准确；而 close 资源的处理逻辑优先级就很低，因为不 close 最多多占点内存等资源，影响不大。\n\n * 于是就把宏任务队列拆成了五个优先级：timers、pending、poll、check、close\n\n\n\n解释一下这五种宏任务：\n\n * timers callback： 涉及到时间，肯定越早执行越准确，所以这个优先级最高很容易理解。\n\n * pending callback：处理网络、io 等异常时的回调，有的 *niux 系统会等待发生错误的上报，所以得处理下。\n\n * poll callback：处理 io 的 data，网络的 connection，服务器主要处理的就是这个。\n\n * check callback：执行 setimmediate 的回调，特点是刚执行完 io 之后就能回调这个。\n\n * close callback：关闭资源的回调，晚点执行影响也不到，优先级最低。\n\n所以呢，node.js 的 event loop 就是这样跑的了：\n\n\n\n还有一点不同要特别注意：\n\n> node.js 的 event loop 并不是浏览器那种一次执行一个宏任务，然后执行所有的微任务，而是执行完一定数量的 timers 宏任务，再去执行所有微任务，然后再执行一定数量的 pending 的宏任务，然后再去执行所有微任务，剩余的 poll、check、close 的宏任务也是这样。（订正：node 11 之前是这样，node 11 之后改为了每个宏任务都执行所有微任务了）\n\n为什么这样呢？\n\n> 其实按照优先级来看很容易理解：假设浏览器里面的宏任务优先级是 1，所以是按照先后顺序依次执行，也就是一个宏任务，所有的微任务，再一个宏任务，再所有的微任务。而 node.js 的 宏任务之间也是有优先级的，所以 node.js 的 event loop 每次都是把当前优先级的所有宏任务跑完再去跑微任务，然后再跑下一个优先级的宏任务\n\n\n\n * 也就是是一定数量的 timers 宏任务，再所有微任务，再一定数量的 pending callback 宏任务，再所有微任务这样。\n\n * 为什么说是一定数量呢？因为如果某个阶段宏任务太多，下个阶段就一直执行不到了，所以有个上限的限制，剩余的下个 event loop 再继续执行。 除了宏任务有优先级，微任务也划分了优先级，多了一个 process.nexttick 的高优先级微任务，在所有的普通微任务之前来跑。\n\n\n\nnode.js 的 event loop 的完整流程就是这样的\n\n * timers 阶段：执行一定数量的定时器，也就是 settimeout、setinterval 的 callback，太多的话留到下次执行\n\n * pending 阶段：执行一定数量的 io 和网络的异常回调，太多的话留到下次执行\n\n * idle/prepare 阶段：内部用的一个阶段\n\n * poll 阶段：执行一定数量的文件的 data 回调、网络的 connection 回调，太多的话留到下次执行。如果没有 io 回调并且也没有 timers、check 阶段的回调要处理，就阻塞在这里等待 io 事件\n\n * check 阶段：执行一定数量的 setimmediate 的 callback，太多的话留到下次执行。\n\n * close 阶段：执行一定数量的 close 事件的 callback，太多的话留到下次执行。\n\n比起浏览器里的 event loop，明显复杂了很多\n\n> node.js 对宏任务做了优先级划分，从高到低分别是 timers、pending、poll、check、close 这 5 种，也对微任务做了划分，也就是 nexttick 的微任务和其他微任务。执行流程是先执行完当前优先级的一定数量的宏任务（剩下的留到下次循环），然后执行 process.nexttick 的微任务，再执行普通微任务，之后再执行下个优先级的一定数量的宏任务。这样不断循环。其中还有一个 idle/prepare 阶段是给 node.js 内部逻辑用的，不需要关心\n\n * 改变了浏览器 event loop 里那种一次执行一个宏任务的方式，可以让高优先级的宏任务更早的得到执行，但是也设置了个上限，避免下个阶段一直得不到执行。\n\n * 还有一个特别要注意的点，就是 poll 阶段：如果执行到 poll 阶段，发现 poll 队列为空并且 timers 队列、check 队列都没有任务要执行，那么就阻塞的等在这里等 io 事件，而不是空转。 这点设计也是因为服务器主要是处理 io 的，阻塞在这里可以更早的响应 io。\n\n完整的 node.js 的 event loop 是这样的\n\n\n\n对比下浏览器的 event loop\n\n\n\n两个 js 运行环境的 event loop 整体设计思路是差不多的，只不过 node.js 的 event loop 对宏任务和微任务做了更细粒度的划分，也很容易理解，毕竟 node.js 面向的环境和浏览器不同，更重要的是服务端对性能的要求会更高\n\n总结\n\n * node.js也是一个 js 运行环境，想支持异步同样要用 event loop，只不过服务端环境更复杂，对性能要求更高，所以 node.js 对宏微任务都做了更细粒度的优先级划分\n\n * node.js 里划分了 5 种宏任务，分别是 timers、pending、poll、check、close。又划分了 2 种微任务，分别是 process.nexttick 的微任务和其他的微任务。\n\n * node.js 的 event loop 流程是执行当前阶段的一定数量的宏任务（剩余的到下个循环执行），然后执行所有微任务，一共有 timers、pending、idle/prepare、poll、check、close 6 个阶段。（订正：node 11 之前是这样，node 11 之后改为了每个宏任务都执行所有微任务了）其中 idle/prepare 阶段是 node.js 内部用的，不用关心。\n\n * 特别要注意的是 poll 阶段，如果执行到这里，poll 队列为空并且 timers、check 队列也为空，就一直阻塞在这里等待 io，直到 timers、check 队列有回调再继续 loop。\n\n * event loop 是 js 为了支持异步和任务优先级而设计的一套调度逻辑，针对浏览器、node.js 等不同环境有不同的设计（主要是任务优先级的划分粒度不同），node.js 面对的环境更复杂、对性能要求更高，所以 event loop 设计的更复杂一些。\n\n> 当 node.js 开始启动时，会初始化一个 eventloop，处理输入的代码脚本，这些脚本会进行 api 异步调用，process.nexttick() 方法会开始处理事件循环。下面就是 node.js 官网提供的 eventloop 事件循环参考流程\n\n * node 中的 event loop 和浏览器中的不相同。\n\n * node 的 event loop 分为6个阶段，它们会按照顺序反复运行\n\n\n\n * 每次执行执行一个宏任务后会清空微任务（执行顺序和浏览器一致，在node11版本以上）\n\n * process.nexttick node中的微任务，当前执行栈的底部，优先级比promise要高\n\n> 整个流程分为六个阶段，当这六个阶段执行完一次之后，才可以算得上执行了一次 eventloop 的循环过程。我们来分别看下这六个阶段都做了哪些事情。\n\n * timers 阶段：这个阶段执行 settimeout 和 setinterval的回调函数，简单理解就是由这两个函数启动的回调函数。\n\n * i/o callbacks 阶段：这个阶段主要执行系统级别的回调函数，比如 tcp 连接失败的回调。\n\n * idle，prepare 阶段：仅系统内部使用，你只需要知道有这 2 个阶段就可以。\n\n * poll 阶段：poll 阶段是一个重要且复杂的阶段，几乎所有 i/o 相关的回调，都在这个阶段执行（除了settimeout、setinterval、setimmediate 以及一些因为 exception 意外关闭产生的回调）。检索新的 i/o 事件，执行与 i/o 相关的回调，其他情况node.js` 将在适当的时候在此阻塞。这也是最复杂的一个阶段，所有的事件循环以及回调处理都在这个阶段执行。这个阶段的主要流程如下图所示。\n\n\n\n * check 阶段：setimmediate() 回调函数在这里执行，setimmediate 并不是立马执行，而是当事件循环 poll 中没有新的事件处理时就执行该部分，如下代码所示。\n\nconst fs = require('fs');\nsettimeout(() => { // 新的事件循环的起点\n    console.log('1'); \n}, 0);\nsetimmediate( () => {\n    console.log('setimmediate 1');\n});\n/// fs.readfile 将会在 poll 阶段执行\nfs.readfile('./test.conf', {encoding: 'utf-8'}, (err, data) => {\n    if (err) throw err;\n    console.log('read file success');\n});\n/// 该部分将会在首次事件循环中执行\npromise.resolve().then(()=>{\n    console.log('poll callback');\n});\n// 首次事件循环执行\nconsole.log('2');\n\n\n在这一代码中有一个非常奇特的地方，就是 setimmediate 会在 settimeout 之后输出。有以下几点原因：\n\n * settimeout 如果不设置时间或者设置时间为 0，则会默认为 1ms\n\n * 主流程执行完成后，超过 1ms 时，会将 settimeout 回调函数逻辑插入到待执行回调函数 poll 队列中；\n\n * 由于当前 poll 队列中存在可执行回调函数，因此需要先执行完，待完全执行完成后，才会执行check：setimmediate。\n\n * 因此这也验证了这句话，先执行回调函数，再执行 setimmediate\n\n * close callbacks 阶段：执行一些关闭的回调函数，如 socket.on('close', ...)\n\n> 除了把 eventloop 的宏任务细分到不同阶段外。node 还引入了一个新的任务队列 process.nexttick()\n\n可以认为，process.nexttick() 会在上述各个阶段结束时，在进入下一个阶段之前立即执行（优先级甚至超过 microtask 队列）\n\n事件循环的主要包含微任务和宏任务。具体是怎么进行循环的呢\n\n\n\n * 微任务：在 node.js 中微任务包含 2 种——process.nexttick 和 promise。微任务在事件循环中优先级是最高的，因此在同一个事件循环中有其他任务存在时，优先执行微任务队列。并且process.nexttick 和 promise也存在优先级，process.nexttick 高于 promise\n\n * 宏任务：在 node.js 中宏任务包含 4 种——settimeout、setinterval、setimmediate 和 i/o。宏任务在微任务执行之后执行，因此在同一个事件循环周期内，如果既存在微任务队列又存在宏任务队列，那么优先将微任务队列清空，再执行宏任务队列\n\n我们可以看到有一个核心的主线程，它的执行阶段主要处理三个核心逻辑。\n\n * 同步代码。\n * 将异步任务插入到微任务队列或者宏任务队列中。\n * 执行微任务或者宏任务的回调函数。在主线程处理回调函数的同时，也需要判断是否插入微任务和宏任务。根据优先级，先判断微任务队列是否存在任务，存在则先执行微任务，不存在则判断在宏任务队列是否有任务，有则执行。\n\nconst fs = require('fs');\n// 首次事件循环执行\nconsole.log('start');\n/// 将会在新的事件循环中的阶段执行\nfs.readfile('./test.conf', {encoding: 'utf-8'}, (err, data) => {\n    if (err) throw err;\n    console.log('read file success');\n});\nsettimeout(() => { // 新的事件循环的起点\n    console.log('settimeout'); \n}, 0);\n/// 该部分将会在首次事件循环中执行\npromise.resolve().then(()=>{\n    console.log('promise callback');\n});\n/// 执行 process.nexttick\nprocess.nexttick(() => {\n    console.log('nexttick callback');\n});\n// 首次事件循环执行\nconsole.log('end');\n\n\n分析下上面代码的执行过程\n\n * 第一个事件循环主线程发起，因此先执行同步代码，所以先输出 start，然后输出 end\n\n * 第一个事件循环主线程发起，因此先执行同步代码，所以先输出 start，然后输出 end；\n\n * 再从上往下分析，遇到微任务，插入微任务队列，遇到宏任务，插入宏任务队列，分析完成后，微任务队列包含：promise.resolve 和 process.nexttick，宏任务队列包含：fs.readfile 和 settimeout；\n\n * 先执行微任务队列，但是根据优先级，先执行 process.nexttick 再执行 promise.resolve，所以先输出 nexttick callback 再输出 promise callback；\n\n * 再执行宏任务队列，根据宏任务插入先后顺序执行 settimeout 再执行 fs.readfile，这里需要注意，先执行 settimeout 由于其回调时间较短，因此回调也先执行，并非是 settimeout 先执行所以才先执行回调函数，但是它执行需要时间肯定大于 1ms，所以虽然 fs.readfile 先于settimeout 执行，但是 settimeout 执行更快，所以先输出 settimeout ，最后输出 read file success。\n\n// 输出结果\nstart\nend\nnexttick callback\npromise callback\nsettimeout\nread file success\n\n\n\n\n> 当微任务和宏任务又产生新的微任务和宏任务时，又应该如何处理呢？如下代码所示：\n\nconst fs = require('fs');\nsettimeout(() => { // 新的事件循环的起点\n    console.log('1'); \n    fs.readfile('./config/test.conf', {encoding: 'utf-8'}, (err, data) => {\n        if (err) throw err;\n        console.log('read file sync success');\n    });\n}, 0);\n/// 回调将会在新的事件循环之前\nfs.readfile('./config/test.conf', {encoding: 'utf-8'}, (err, data) => {\n    if (err) throw err;\n    console.log('read file success');\n});\n/// 该部分将会在首次事件循环中执行\npromise.resolve().then(()=>{\n    console.log('poll callback');\n});\n// 首次事件循环执行\nconsole.log('2');\n\n\n在上面代码中，有 2 个宏任务和 1 个微任务，宏任务是 settimeout 和 fs.readfile，微任务是 promise.resolve。\n\n * 整个过程优先执行主线程的第一个事件循环过程，所以先执行同步逻辑，先输出 2。\n\n * 接下来执行微任务，输出 poll callback。\n\n * 再执行宏任务中的 fs.readfile 和 settimeout，由于 fs.readfile 优先级高，先执行 fs.readfile。但是处理时间长于 1ms，因此会先执行 settimeout 的回调函数，输出 1。这个阶段在执行过程中又会产生新的宏任务 fs.readfile，因此又将该 fs.readfile 插入宏任务队列\n\n * 最后由于只剩下宏任务了 fs.readfile，因此执行该宏任务，并等待处理完成后的回调，输出 read file sync success。\n\n// 结果\n2\npoll callback\n1\nread file success\nread file sync success\n\n\nprocess.nextick() 和 vue 的 nextick\n\n\n\n> node.js 和浏览器端宏任务队列的另一个很重要的不同点是，浏览器端任务队列每轮事件循环仅出队一个回调函数接着去执行微任务队列；而 node.js 端只要轮到执行某个宏任务队列，则会执行完队列中所有的当前任务，但是当前轮次新添加到队尾的任务则会等到下一轮次才会执行。\n\nsettimeout(() => {\n    console.log('settimeout');\n}, 0);\nsetimmediate(() => {\n    console.log('setimmediate');\n})\n// 这里可能会输出 settimeout，setimmediate\n// 可能也会相反的输出，这取决于性能\n// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setimmediate\n// 否则会执行 settimeout\n\n\n> 上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行\n\nsettimeout(()=>{\n    console.log('timer1')\n\n    promise.resolve().then(function() {\n        console.log('promise1')\n    })\n}, 0)\n\nsettimeout(()=>{\n    console.log('timer2')\n\n    promise.resolve().then(function() {\n        console.log('promise2')\n    })\n}, 0)\n\n// 以上代码在浏览器和 node 中打印情况是不同的\n// 浏览器中一定打印 timer1, promise1, timer2, promise2\n// node 中可能打印 timer1, timer2, promise1, promise2\n// 也可能打印 timer1, promise1, timer2, promise2\n\n\n> node 中的 process.nexttick 会先于其他 microtask 执行\n\n\n\nsettimeout(() => {\n console.log(\"timer1\");\n\n promise.resolve().then(function() {\n   console.log(\"promise1\");\n });\n}, 0);\n\n// poll阶段执行\nfs.readfile('./test',()=>{\n  // 在poll阶段里面 如果有setimmediate优先执行，settimeout处于事件循环顶端 poll下面就是setimmediate\n  settimeout(()=>console.log('settimeout'),0)\n  setimmediate(()=>console.log('setimmediate'),0)\n})\n\nprocess.nexttick(() => {\n console.log(\"nexttick\");\n});\n// nexttick, timer1, promise1,setimmediate,settimeout\n\n\n> 对于 microtask 来说，它会在以上每个阶段完成前清空 microtask 队列，下图中的 tick 就代表了 microtask\n\n\n\n谁来启动这个循环过程，循环条件是什么？\n\n> 当 node.js 启动后，会初始化事件循环，处理已提供的输入脚本，它可能会先调用一些异步的 api、调度定时器，或者 process.nexttick()，然后再开始处理事件循环。因此可以这样理解，node.js 进程启动后，就发起了一个新的事件循环，也就是事件循环的起点。\n\n总结来说，node.js 事件循环的发起点有 4 个：\n\n * node.js 启动后；\n\n * settimeout 回调函数；\n\n * setinterval 回调函数；\n\n * 也可能是一次 i/o 后的回调函数。\n\n无限循环有没有终点\n\n> 当所有的微任务和宏任务都清空的时候，虽然当前没有任务可执行了，但是也并不能代表循环结束了。因为可能存在当前还未回调的异步 i/o，所以这个循环是没有终点的，只要进程在，并且有新的任务存在，就会去执行\n\nnode.js 是单线程的还是多线程的？\n\n> 主线程是单线程执行的，但是 node.js 存在多线程执行，多线程包括 settimeout 和异步 i/o 事件。其实 node.js 还存在其他的线程，包括垃圾回收、内存优化等\n\neventloop 对渲染的影响\n\n * 想必你之前在业务开发中也遇到过 requestidlecallback 和 requestanimationframe，这两个函数在我们之前的内容中没有讲过，但是当你开始考虑它们在 eventloop 的生命周期的哪一步触发，或者这两个方法的回调会在微任务队列还是宏任务队列执行的时候，才发现好像没有想象中那么简单。这两个方法其实也并不属于 js 的原生方法，而是浏览器宿主环境提供的方法，因为它们牵扯到另一个问题：渲染。\n\n * 我们知道浏览器作为一个复杂的应用是多线程工作的，除了运行 js 的线程外，还有渲染线程、定时器触发线程、http 请求线程，等等。js 线程可以读取并且修改 dom，而渲染线程也需要读取 dom，这是一个典型的多线程竞争临界资源的问题。所以浏览器就把这两个线程设计成互斥的，即同时只能有一个线程在执行\n\n * 渲染原本就不应该出现在 eventloop 相关的知识体系里，但是因为 eventloop 显然是在讨论 js 如何运行的问题，而渲染则是浏览器另外一个线程的工作。但是 requestanimationframe的出现却把这两件事情给关联起来\n\n * 通过调用requestanimationframe我们可以在下次渲染之前执行回调函数。那下次渲染具体是哪个时间点呢？渲染和 eventloop 有什么关系呢？\n   \n   * 简单来说，就是在每一次 eventloop 的末尾，判断当前页面是否处于渲染时机，就是重新渲染\n\n * 有屏幕的硬件限制，比如 60hz 刷新率，简而言之就是 1 秒刷新了 60 次，16.6ms 刷新一次。这个时候浏览器的渲染间隔时间就没必要小于 16.6ms，因为就算渲染了屏幕上也看不到。当然浏览器也不能保证一定会每 16.6ms 会渲染一次，因为还会受到处理器的性能、javascript 执行效率等其他因素影响。\n\n * 回到 requestanimationframe，这个 api 保证在下次浏览器渲染之前一定会被调用，实际上我们完全可以把它看成是一个高级版的 setinterval。它们都是在一段时间后执行回调，但是前者的间隔时间是由浏览器自己不断调整的，而后者只能由用户指定。这样的特性也决定了 requestanimationframe 更适合用来做针对每一帧来修改的动画效果\n\n * 当然 requestanimationframe 不是 eventloop 里的宏任务，或者说它并不在 eventloop 的生命周期里，只是浏览器又开放的一个在渲染之前发生的新的 hook。另外需要注意的是微任务的认知概念也需要更新，在执行 animation callback 时也有可能产生微任务（比如 promise 的 callback），会放到 animation queue 处理完后再执行。所以微任务并不是像之前说的那样在每一轮 eventloop 后处理，而是在 js 的函数调用栈清空后处理\n\n但是 requestidlecallback 却是一个更好理解的概念。当宏任务队列中没有任务可以处理时，浏览器可能存在“空闲状态”。这段空闲时间可以被 requestidlecallback 利用起来执行一些优先级不高、不必立即执行的任务，如下图所示：\n\n\n\n\n# 12.3 实现一个promise a+ 规范\n\n> 最好是实现一遍 promise a+ 规范，多少有点印象，当然面试官也不会叫你默写一个完整的出来，但是你起码要知道实现原理\n\n/**\n * promises/a+规范 实现一个promise\n * https://promisesaplus.com/\n*/\n\nconst emum = {\n  pending: 'pending',\n  fulfilled: 'fulfilled',\n  rejected: 'rejected'\n}\n\n// x 返回值\n// promise2 then的时候new的promise\n// promise2的resolve, reject\nconst resolvepromise = (x, promise2, resolve, reject)=>{\n  // 解析promise的值解析promise2是成功还是失败 传递到下层then\n  if(x === promise2) {\n    reject(new typeerror('类型错误'))\n  }\n  // 这里的x如果是一个promise的话 可能是其他的promise，可能调用了成功 又调用了失败\n  // 防止resolve的时候 又throw err抛出异常到reject了\n  let called\n  // 如果x是promise 那么就采用他的状态\n  // 有then方法是promise\n  if(typeof x === 'object' && typeof x!== null || typeof x === 'function') {\n    // x是对象或函数\n    try {\n      let then = x.then // 缓存，不用多次取值\n      if(typeof then === 'function') {\n        // 是promise，调用then方法里面有this，需要传入this为x才能取到then方法里面的值this.value\n        then.call(x, y=>{// 成功\n          // y值可能也是一个promise 如resolve(new promise()) 此时的y==new promise()\n          // 递归解析y，直到拿到普通的值resolve(x出去)\n          if(called) return;\n          called = true;\n\n          resolvepromise(y, promise2, resolve, reject)\n        },r=>{// 一旦失败直接失败\n          if(called) return;\n          called = true;\n          reject(r)\n        })\n      } else {\n        // 普通对象不是promise\n        resolve(x)\n      }\n    } catch (e) {\n      // 对象取值可能报错，用defineproperty定义get 抛出异常\n      if(called) return;\n      called = true;\n      reject(e)\n    }\n  } else {\n    // x是普通值\n    resolve(x) // 直接成功\n  }\n  \n}\nclass mypromise {\n  constructor(executor) {\n    this.status = emum.pending // 当前状态\n    this.value = undefined // resolve接收值\n    this.reason = undefined // reject失败返回值\n\n    /**\n     * 同一个promise可以then多次(发布订阅模式)\n     * 调用then时 当前状态是等待态，需要将当前成功或失败的回调存放起来（订阅）\n     * 调用resolve时 将订阅函数进行执行（发布）\n    */\n    // 成功队列\n    this.onresolvedcallbacks = []\n    // 失败队列\n    this.onrejectedcallbacks = []\n    const resolve = value =>{\n      // 如果value是一个promise，需要递归解析\n      // 如 mypromise.resolve(new mypromise()) 需要解析value\n      if(value instanceof mypromise) {\n        // 不停的解析 直到值不是promise\n        return value.then(resolve,reject)\n      }\n\n      if(this.status === emum.pending) {\n        this.status = emum.fulfilled\n        this.value = value\n\n        this.onresolvedcallbacks.foreach(fn=>fn())\n      }\n    }\n    const reject = reason =>{\n      if(this.status === emum.pending) {\n        this.status = emum.rejected\n        this.reason = reason\n\n        this.onrejectedcallbacks.foreach(fn=>fn())\n      }\n    }\n    try {\n      executor(resolve,reject)\n    } catch(e) {\n      reject(e)\n    }\n  }\n  then(onfulfilled, onrejected) {\n    // 透传 处理默认不传的情况\n    // new promise((resolve,reject)=>{\n    //   resolve(1)\n    // }).then().then().then(d=>{})\n    // new promise((resolve,reject)=>{\n    //   resolve(1)\n    // }).then(v=>v).then(v=>v).then(d=>{})\n    // new promise((resolve,reject)=>{\n    //   reject(1)\n    // }).then().then().then(null, e=>{console.log(e)})\n    // new promise((resolve,reject)=>{\n    //   reject(1)\n    // }).then(null,e=>{throw e}).then(null,e=>{throw e}).then(null,e=>{console.log(e)})\n    onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : v => v\n    onrejected = typeof onrejected === 'function' ? onrejected : err => {throw err}\n\n    // 调用then 创建一个新的promise\n    let promise2 = new mypromise((resolve,reject)=>{\n      // 根据value判断是resolve 还是reject value也可能是promise\n      if(this.status === emum.fulfilled) {\n        settimeout(() => {\n          try {\n            // 成功回调结果\n            let x = onfulfilled(this.value)\n            // 解析promise\n            resolvepromise(x, promise2,resolve,reject)\n          } catch (error) {\n            reject(error)\n          }\n        }, 0);\n      }\n      if(this.status === emum.rejected) {\n        settimeout(() => {\n          try {\n            let x = onrejected(this.reason)\n            // 解析promise\n            resolvepromise(x, promise2,resolve,reject)\n          } catch (error) {\n            reject(error)\n          }\n        }, 0);\n      }\n      // 用户还未调用resolve或reject方法\n      if(this.status === emum.pending) {\n        this.onresolvedcallbacks.push(()=>{\n          try {\n            let x = onfulfilled(this.value)\n            // 解析promise\n            resolvepromise(x, promise2,resolve,reject)\n          } catch (error) {\n            reject(error)\n          }\n        })\n        this.onrejectedcallbacks.push(()=>{\n          try {\n            let x = onrejected(this.reason)\n            // 解析promise\n            resolvepromise(x, promise2,resolve,reject)\n          } catch (error) {\n            reject(error)\n          }\n        })\n      }\n    })\n    \n    return promise2\n  }\n  catch(errcallback) {\n    // 等同于没有成功，把失败放进去而已\n    return this.then(null, errcallback)\n  }\n  // mypromise.resolve 具备等待功能的 如果参数的promise会等待promise解析完毕在向下执行\n  static resolve(val) {\n    return new mypromise((resolve,reject)=>{\n      resolve(val)\n    })\n  }\n  // mypromise.reject 直接将值返回\n  static reject(reason) {\n    return new mypromise((resolve,reject)=>{\n      reject(reason)\n    })\n  }\n  // finally传入的函数 无论成功或失败都执行\n  // promise.reject(100).finally(()=>{console.log(1)}).then(d=>console.log('success',d)).catch(er=>console.log('faild',er))\n  // promise.reject(100).finally(()=>new promise()).then(d=>console.log(d)).catch(er=>)\n  finally(callback) {\n    return this.then((val)=>{\n      return mypromise.resolve(callback()).then(()=>val)\n    },(err)=>{\n      return mypromise.resolve(callback()).then(()=>{throw err})\n    })\n  }\n  // promise.all\n  static all(values) {\n    return new mypromise((resolve,reject)=>{\n      let resultarr = []\n      let orderindex = 0\n      const processresultbykey = (value,index)=>{\n        resultarr[index] = value \n        // 处理完全部\n        if(++orderindex === values.length) {\n          resolve(resultarr) // 处理完成的结果返回去\n        }\n      }\n      for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        // 是promise\n        if(value && typeof value.then === 'function') {\n          value.then((val)=>{\n            processresultbykey(val,i)\n          },reject)\n        } else {\n          // 不是promise情况\n          processresultbykey(value,i)\n        }\n      }\n    })\n  }\n  static race(promises) {\n    // 采用最新成功或失败的作为结果\n    return new mypromise((resolve,reject)=>{\n      for (let i = 0; i < promises.length; i++) {\n        let val = promises[i]\n        if(val && typeof val.then === 'function') {\n          // 任何一个promise先调用resolve或reject就返回结果了 也就是返回执行最快的那个promise的结果\n          val.then(resolve,reject)\n        }else{\n          // 普通值\n          resolve(val)\n        }\n      }\n    })\n  }\n}\n\nmodule.exports = mypromise\n\n\n测试\n\n/**\n * =====测试用例-====\n */\n// let promise1 = new mypromise((resolve,reject)=>{\n//   settimeout(() => {\n//     resolve('成功')\n//   }, 900);\n// })\n\n// promise1.then(val=>{\n//   console.log('success', val)\n// },reason=>{\n//   console.log('fail', reason)\n// })\n\n/**\n * then的使用方式 普通值意味不是promise\n * \n * 1、then中的回调有两个方法 成功或失败 他们的结果返回（普通值）会传递给外层的下一个then中\n * 2、可以在成功或失败中抛出异常，走到下一次then的失败中\n * 3、返回的是一个promsie，那么会用这个promise的状态作为结果，会用promise的结果向下传递\n * 4、错误处理，会默认先找离自己最新的错误处理，找不到就向下查找，找打了就执行\n */\n\n// read('./name.txt').then(data=>{\n//   return '123'\n// }).then(data=>{\n  \n// }).then(null,err=>{\n\n// })\n// // .catch(err=>{ // catch就是没有成功的promise\n\n// // })\n\n/**\n * promise.then实现原理：通过每次返回一个新的promise来实现（promise一旦成功就不能失败，失败就不能成功）\n * \n */\n\n// function read(data) {\n//   return new mypromise((resolve,reject)=>{\n//     settimeout(() => {\n//       resolve(new mypromise((resolve,reject)=>resolve(data)))\n//     }, 1000);\n//   })\n// }\n\n// let promise2 = read({name: 'poetry'}).then(data=>{\n//   return data\n// }).then().then().then(data=>{\n//   console.log(data,'-data-')\n// },(err)=>{\n//   console.log(err,'-err-')\n// })\n\n// finally测试\n// mypromise\n//   .resolve(100)\n//   .finally(()=>{\n//     return new mypromise((resolve,reject)=>settimeout(() => {\n//       resolve(100)\n//     }, 100))\n//   })\n//   .then(d=>console.log('finally success',d))\n//   .catch(er=>console.log(er, 'finally err'))\n\n\n/**\n * promise.all 测试\n * \n * mypromise.all 解决并发问题 多个异步并发获取最终的结果\n*/\n\n// mypromise.all([1,2,3,4,new mypromise((resolve,reject)=>{\n//   settimeout(() => {\n//     resolve('ok1')\n//   }, 1000);\n// }),new mypromise((resolve,reject)=>{\n//   settimeout(() => {\n//     resolve('ok2')\n//   }, 1000);\n// })]).then(d=>{\n//   console.log(d,'mypromise.all.resolve')\n// }).catch(err=>{\n//   console.log(err,'mypromise.all.reject')\n// })\n\n\n// 实现promise中断请求\nlet promise = new promise((resolve,reject)=>{\n  settimeout(() => {\n    // 模拟接口调用 ajax调用超时\n    resolve('成功') \n  }, 10000);\n})\n\nfunction promisewrap(promise) {\n  // 包装一个promise 可以控制原来的promise是成功 还是失败\n  let abort\n  let newpromsie = new mypromise((resolve,reject)=>{\n    abort = reject\n  })\n  // 只要控制newpromsie失败，就可以控制被包装的promise走向失败\n  // promise.race 任何一个先成功或者失败 就可以获得结果\n  let p = mypromise.race([promise, newpromsie])\n  p.abort = abort\n\n  return p\n}\n\nlet newpromise = promisewrap(promise)\n\nsettimeout(() => {\n  // 超过3秒超时\n  newpromise.abort('请求超时')\n}, 3000);\n\nnewpromise.then(d=>{\n  console.log('d',d)\n}).catch(err=>{\n  console.log('err',err)\n})\n\n\n// 使用promises-aplus-tests 测试写的promise是否规范\n// 全局安装 cnpm i -g promises-aplus-tests\n// 命令行执行 promises-aplus-tests promise.js\n// 测试入口 产生延迟对象\nmypromise.defer = mypromise.deferred = function () {\n  let dfd = {}\n  dfd.promise = new mypromise((resolve,reject)=>{\n    dfd.resolve = resolve\n    dfd.reject = reject\n  })\n  return dfd\n}\n\n// 延迟对象用户\n// ![](http://img-repo.poetries.top/images/20210509172817.png)\n// promise解决嵌套问题\n// function readdata(url) {\n//   let dfd = mypromise.defer()\n//   fs.readfile(url, 'utf8', function (err,data) {\n//     if(err) {\n//       dfd.reject()\n//     }\n//     dfd.resolve(data)\n//   })\n//   return dfd.promise\n// }\n// readdata().then(d=>{\n//   return d\n// })\n\n\n\n# 12.4 settimeout、promise、async / await 的区别\n\n * 首先，我们先来了解一下基本概念：\n   \n   * js eventloop 事件循环机制:\n   \n   * javascript的事件分两种，宏任务(macro-task)和微任务(micro-task)\n\n * 宏任务：包括整体代码script，settimeout，setinterval\n\n * 微任务：promise.then(非new promise)，process.nexttick(node中)\n\n * 事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入event table并注册函数，异步事件完成后，会将回调函数放入event queue中(宏任务和微任务是不同的event queue)，同步任务执行完成后，会从event queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。\n\n * 注意： settimeout并不是直接的把你的回掉函数放进上述的异步队列中去，而是在定时器的时间到了之后，把回掉函数放到执行异步队列中去。如果此时这个队列已经有很多任务了，那就排在他们的后面。这也就解释了为什么settimeout为什么不能精准的执行的问题了。\n\n * settimeout 执行需要满足两个条件：\n   \n   * 主进程必须是空闲的状态，如果到时间了，主进程不空闲也不会执行你的回掉函数\n   * 这个回掉函数需要等到插入异步队列时前面的异步函数都执行完了，才会执行\n\n * 上面是比较官方的解释，说一下自己的理解吧：\n   \n   * 了解了什么是宏任务和微任务，就好理解多了，首先执行 宏任务 => 微任务的event queue => 宏任务的event queue\n\n * promise、async/await\n   \n   * 首先，new promise是同步的任务，会被放到主进程中去立即执行。而.then()函数是异步任务会放到异步队列中去，那什么时候放到异步队列中去呢？当你的promise状态结束的时候，就会立即放进异步队列中去了。\n   \n   * 带async关键字的函数会返回一个promise对象，如果里面没有await，执行起来等同于普通函数；如果没有await，async函数并没有很厉害是不是\n   \n   * await 关键字要在 async 关键字函数的内部，await 写在外面会报错；await如同他的语意，就是在等待，等待右侧的表达式完成。此时的await会让出线程，阻塞async内后续的代码，先去执行async外的代码。等外面的同步代码执行完毕，才会执行里面的后续代码。就算await的不是promise对象，是一个同步函数，也会等这样操作\n\n\n\n根据图片显示我们来整理一下流程：\n\n * 执行console.log('script start')，输出script start；\n\n * 执行settimeout，是一个异步动作，放入宏任务异步队列中；\n\n * 执行async1()，输出async1 start，继续向下执行；\n\n * 执行async2()，输出async2，并返回了一个promise对象，await让出了线程，把返回的promise加入了微任务异步队列，所以async1()下面的代码也要等待上面完成后继续执行;\n\n * 执行 new promise，输出promise1，然后将resolve放入微任务异步队列；\n\n * 执行console.log('script end')，输出script end；\n\n * 到此同步的代码就都执行完成了，然后去微任务异步队列里去获取任务\n\n * 接下来执行resolve（async2返回的promise返回的），输出了async1 end。\n\n * 然后执行resolve（new promise的），输出了promise2\n\n * 最后执行settimeout，输出了settimeout\n\n\n# 12.5 settimeout(fn, 0)多久才执行，event loop\n\n> settimeout 按照顺序放到队列里面，然后等待函数调用栈清空之后才开始执行，而这些操作进入队列的顺序，则由设定的延迟时间来决定\n\n\n# 12.6 async原理\n\n> async/await语法糖就是使用generator函数+自动执行器来运作的\n\n// 定义了一个promise，用来模拟异步请求，作用是传入参数++\nfunction getnum(num){\n    return new promise((resolve, reject) => {\n        settimeout(() => {\n            resolve(num+1)\n        }, 1000)\n    })\n}\n\n//自动执行器，如果一个generator函数没有执行完，则递归调用\nfunction asyncfun(func){\n  var gen = func();\n\n  function next(data){\n    var result = gen.next(data);\n    if (result.done) return result.value;\n    result.value.then(function(data){\n      next(data);\n    });\n  }\n\n  next();\n}\n\n// 所需要执行的generator函数，内部的数据在执行完成一步的promise之后，再调用下一步\nvar func = function* (){\n  var f1 = yield getnum(1);\n  var f2 = yield getnum(f1);\n  console.log(f2) ;\n};\nasyncfun(func);\n\n\n * 在执行的过程中，判断一个函数的promise是否完成，如果已经完成，将结果传入下一个函数，继续重复此步骤\n * 每一个 next() 方法返回值的 value 属性为一个 promise 对象，所以我们为其添加 then 方法， 在 then 方法里面接着运行 next 方法挪移遍历器指针，直到 generator函数运行完成\n\n\n# 13 内存泄露\n\n\n# 13.1 chrome devtools查看内存情况\n\n>  * 打开chrome的无痕模式，这样做的目的是为了屏蔽掉chrome插件对我们之后测试内存占用情况的影响\n>  * 打开开发者工具，找到performance这一栏，可以看到其内部带着一些功能按钮，例如：开始录制按钮；刷新页面按钮；清空记录按钮；记录并可视化js内存、节点、事件监听器按钮；触发垃圾回收机制按钮等\n\n\n\n简单录制一下百度页面，看看我们能获得什么，如下动图所示：\n\n\n\n> 从上图中我们可以看到，在页面从零到加载完成这个过程中js heap（js堆内存）、documents（文档）、nodes（dom节点）、listeners（监听器）、gpu memory（gpu内存）的最低值、最高值以及随时间的走势曲线，这也是我们主要关注的点\n\n看看开发者工具中的memory一栏，其主要是用于记录页面堆内存的具体情况以及js堆内存随加载时间线动态的分配情况\n\n\n\n堆快照就像照相机一样，能记录你当前页面的堆内存情况，每快照一次就会产生一条快照记录\n\n\n\n> 如上图所示，刚开始执行了一次快照，记录了当时堆内存空间占用为33.7mb，然后我们点击了页面中某些按钮，又执行一次快照，记录了当时堆内存空间占用为32.5mb。并且点击对应的快照记录，能看到当时所有内存中的变量情况（结构、占总占用内存的百分比...）\n\n\n\n> 在开始记录后，我们可以看到图中右上角有起伏的蓝色与灰色的柱形图，其中蓝色表示当前时间线下占用着的内存；灰色表示之前占用的内存空间已被清除释放\n\n在得知有内存泄漏的情况存在时，我们可以改用memory来更明确得确认问题和定位问题\n\n首先可以用allocation instrumentation on timeline来确认问题，如下图所示：\n\n\n\n\n# 13.2 内存泄漏的场景\n\n * 闭包使用不当引起内存泄漏\n * 全局变量\n * 分离的dom节点\n * 控制台的打印\n * 遗忘的定时器\n\n1. 闭包使用不当引起内存泄漏\n\n使用performance和memory来查看一下闭包导致的内存泄漏问题\n\n<button onclick=\"myclick()\">执行fn1函数</button>\n<script>\n    function fn1 () {\n        let a = new array(10000)  // 这里设置了一个很大的数组对象\n\n        let b = 3\n\n        function fn2() {\n            let c = [1, 2, 3]\n        }\n\n        fn2()\n\n        return a\n    }\n\n    let res = []  \n\n    function myclick() {\n        res.push(fn1())\n    }\n</script>\n\n\n> 在退出fn1函数执行上下文后，该上下文中的变量a本应被当作垃圾数据给回收掉，但因fn1函数最终将变量a返回并赋值给全局变量res，其产生了对变量a的引用，所以变量a被标记为活动变量并一直占用着相应的内存，假设变量res后续用不到，这就算是一种闭包使用不当的例子\n\n设置了一个按钮，每次执行就会将fn1函数的返回值添加到全局数组变量res中，是为了能在performacne的曲线图中看出效果，如图所示：\n\n\n\n * 在每次录制开始时手动触发一次垃圾回收机制，这是为了确认一个初始的堆内存基准线，便于后面的对比，然后我们点击了几次按钮，即往全局数组变量res中添加了几个比较大的数组对象，最后再触发一次垃圾回收，发现录制结果的js heap曲线刚开始成阶梯式上升的，最后的曲线的高度比基准线要高，说明可能是存在内存泄漏的问题\n * 在得知有内存泄漏的情况存在时，我们可以改用memory来更明确得确认问题和定位问题\n * 首先可以用allocation instrumentation on timeline来确认问题，如下图所示：\n\n\n\n * 在我们每次点击按钮后，动态内存分配情况图上都会出现一个蓝色的柱形，并且在我们触发垃圾回收后，蓝色柱形都没变成灰色柱形，即之前分配的内存并未被清除\n * 所以此时我们就可以更明确得确认内存泄漏的问题是存在的了，接下来就精准定位问题，可以利用heap snapshot来定位问题，如图所示：\n\n\n\n * 第一次先点击快照记录初始的内存情况，然后我们多次点击按钮后再次点击快照，记录此时的内存情况，发现从原来的1.1m内存空间变成了1.4m内存空间，然后我们选中第二条快照记录，可以看到右上角有个all objects的字段，其表示展示的是当前选中的快照记录所有对象的分配情况，而我们想要知道的是第二条快照与第一条快照的区别在哪，所以选择object allocated between snapshot1 and snapshot2即展示第一条快照和第二条快照存在差异的内存对象分配情况，此时可以看到array的百分比很高，初步可以判断是该变量存在问题，点击查看详情后就能查看到该变量对应的具体数据了\n\n以上就是一个判断闭包带来内存泄漏问题并简单定位的方法了\n\n2. 全局变量\n\n全局的变量一般是不会被垃圾回收掉的当然这并不是说变量都不能存在全局，只是有时候会因为疏忽而导致某些变量流失到全局，例如未声明变量，却直接对某变量进行赋值，就会导致该变量在全局创建，如下所示：\n\nfunction fn1() {\n    // 此处变量name未被声明\n    name = new array(99999999)\n}\n\nfn1()\n\n\n * 此时这种情况就会在全局自动创建一个变量name，并将一个很大的数组赋值给name，又因为是全局变量，所以该内存空间就一直不会被释放\n * 解决办法的话，自己平时要多加注意，不要在变量未声明前赋值，或者也可以开启严格模式，这样就会在不知情犯错时，收到报错警告，例如\n\nfunction fn1() {\n    'use strict';\n    name = new array(99999999)\n}\n\nfn1()\n\n\n3. 分离的dom节点\n\n假设你手动移除了某个dom节点，本应释放该dom节点所占用的内存，但却因为疏忽导致某处代码仍对该被移除节点有引用，最终导致该节点所占内存无法被释放，例如这种情况\n\n<div id=\"root\">\n    <div class=\"child\">我是子元素</div>\n    <button>移除</button>\n</div>\n<script>\n  let btn = document.queryselector('button')\n  let child = document.queryselector('.child')\n  let root = document.queryselector('#root')\n  \n  btn.addeventlistener('click', function() {\n      root.removechild(child)\n  })\n</script>\n\n\n> 该代码所做的操作就是点击按钮后移除.child的节点，虽然点击后，该节点确实从dom被移除了，但全局变量child仍对该节点有引用，所以导致该节点的内存一直无法被释放，可以尝试用memory的快照功能来检测一下，如图所示\n\n\n\n> 同样的先记录一下初始状态的快照，然后点击移除按钮后，再点击一次快照，此时内存大小我们看不出什么变化，因为移除的节点占用的内存实在太小了可以忽略不计，但我们可以点击第二条快照记录，在筛选框里输入detached，于是就会展示所有脱离了却又未被清除的节点对象\n\n解决办法如下图所示：\n\n<div id=\"root\">\n    <div class=\"child\">我是子元素</div>\n    <button>移除</button>\n</div>\n<script>\n    let btn = document.queryselector('button')\n\n    btn.addeventlistener('click', function() {  \n        let child = document.queryselector('.child')\n        let root = document.queryselector('#root')\n\n        root.removechild(child)\n    })\n\n</script>\n\n\n> 改动很简单，就是将对.child节点的引用移动到了click事件的回调函数中，那么当移除节点并退出回调函数的执行上文后就会自动清除对该节点的引用，那么自然就不会存在内存泄漏的情况了，我们来验证一下，如下图所示：\n\n\n\n结果很明显，这样处理过后就不存在内存泄漏的情况了\n\n4. 控制台的打印\n\n<button>按钮</button>\n<script>\n    document.queryselector('button').addeventlistener('click', function() {\n        let obj = new array(1000000)\n\n        console.log(obj);\n    })\n</script>\n\n\n我们在按钮的点击回调事件中创建了一个很大的数组对象并打印，用performance来验证一下\n\n\n\n> 开始录制，先触发一次垃圾回收清除初始的内存，然后点击三次按钮，即执行了三次点击事件，最后再触发一次垃圾回收。查看录制结果发现js heap曲线成阶梯上升，并且最终保持的高度比初始基准线高很多，这说明每次执行点击事件创建的很大的数组对象obj都因为console.log被浏览器保存了下来并且无法被回收\n\n接下来注释掉console.log，再来看一下结果：\n\n<button>按钮</button>\n<script>\n    document.queryselector('button').addeventlistener('click', function() {\n        let obj = new array(1000000)\n\n        // console.log(obj);\n    })\n</script>\n\n\n\n\n可以看到没有打印以后，每次创建的obj都立马被销毁了，并且最终触发垃圾回收机制后跟初始的基准线同样高，说明已经不存在内存泄漏的现象了\n\n其实同理 console.log也可以用memory来进一步验证\n\n未注释 console.log\n\n\n\n注释掉了console.log\n\n\n\n> 最后简单总结一下：在开发环境下，可以使用控制台打印便于调试，但是在生产环境下，尽可能得不要在控制台打印数据。所以我们经常会在代码中看到类似如下的操作：\n\n// 如果在开发环境下，打印变量obj\nif(isdev) {\n    console.log(obj)\n}\n\n\n> 这样就避免了生产环境下无用的变量打印占用一定的内存空间，同样的除了console.log之外，console.error、console.info、console.dir等等都不要在生产环境下使用\n\n5. 遗忘的定时器\n\n> 定时器也是平时很多人会忽略的一个问题，比如定义了定时器后就再也不去考虑清除定时器了，这样其实也会造成一定的内存泄漏。来看一个代码示例：\n\n<button>开启定时器</button>\n<script>\n\n    function fn1() {\n        let largeobj = new array(100000)\n\n        setinterval(() => {\n            let myobj = largeobj\n        }, 1000)\n    }\n\n    document.queryselector('button').addeventlistener('click', function() {\n        fn1()\n    })\n</script>\n\n\n这段代码是在点击按钮后执行fn1函数，fn1函数内创建了一个很大的数组对象largeobj，同时创建了一个setinterval定时器，定时器的回调函数只是简单的引用了一下变量largeobj，我们来看看其整体的内存分配情况吧：\n\n\n\n按道理来说点击按钮执行fn1函数后会退出该函数的执行上下文，紧跟着函数体内的局部变量应该被清除，但图中performance的录制结果显示似乎是存在内存泄漏问题的，即最终曲线高度比基准线高度要高，那么再用memory来确认一次：\n\n\n\n * 在我们点击按钮后，从动态内存分配的图上看到出现一个蓝色柱形，说明浏览器为变量largeobj分配了一段内存，但是之后这段内存并没有被释放掉，说明的确存在内存泄漏的问题，原因其实就是因为setinterval的回调函数内对变量largeobj有一个引用关系，而定时器一直未被清除，所以变量largeobj的内存也自然不会被释放\n * 那么我们如何来解决这个问题呢，假设我们只需要让定时器执行三次就可以了，那么我们可以改动一下代码：\n\n<button>开启定时器</button>\n<script>\n    function fn1() {\n        let largeobj = new array(100000)\n        let index = 0\n\n        let timer = setinterval(() => {\n            if(index === 3) clearinterval(timer);\n            let myobj = largeobj\n            index ++\n        }, 1000)\n    }\n\n    document.queryselector('button').addeventlistener('click', function() {\n        fn1()\n    })\n</script>\n\n\n现在我们再通过performance和memory来看看还不会存在内存泄漏的问题\n\n * performance\n\n\n\n> 这次的录制结果就能看出，最后的曲线高度和初始基准线的高度一样，说明并没有内存泄漏的情况\n\n * memory\n\n\n\n这里做一个解释，图中刚开始出现的蓝色柱形是因为我在录制后刷新了页面，可以忽略；然后我们点击了按钮，看到又出现了一个蓝色柱形，此时就是为fn1函数中的变量largeobj分配了内存，3s后该内存又被释放了，即变成了灰色柱形。所以我们可以得出结论，这段代码不存在内存泄漏的问题\n\n> 简单总结一下： 大家在平时用到了定时器，如果在用不到定时器后一定要清除掉，否则就会出现本例中的情况。除了settimeout和setinterval，其实浏览器还提供了一个api也可能就存在这样的问题，那就是requestanimationframe\n\n\n# 14 垃圾回收机制\n\n * 对于在javascript中的字符串，对象，数组是没有固定大小的，只有当对他们进行动态分配存储时，解释器就会分配内存来存储这些数据，当javascript的解释器消耗完系统中所有可用的内存时，就会造成系统崩溃。\n * 内存泄漏，在某些情况下，不再使用到的变量所占用内存没有及时释放，导致程序运行中，内存越占越大，极端情况下可以导致系统崩溃，服务器宕机。\n * javascript有自己的一套垃圾回收机制，javascript的解释器可以检测到什么时候程序不再使用这个对象了（数据），就会把它所占用的内存释放掉。\n * 针对javascript的来及回收机制有以下两种方法（常用）：标记清除，引用计数\n\n有两种垃圾回收策略：\n\n * 标记清除：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。\n * 引用计数：它把对象是否不再需要简化定义为对象有没有其他对象引用到它。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收\n\n标记清除的缺点：\n\n * 内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。\n * 分配速度慢，因为即便是使用 first-fit 策略，其操作仍是一个 o(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。\n\n> 解决以上的缺点可以使用 标记整理（mark-compact）算法 标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）\n\n\n\n引用计数的缺点：\n\n * 需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。\n * 解决不了循环引用导致的无法回收问题\n\n> v8 的垃圾回收机制也是基于标记清除算法，不过对其做了一些优化。\n\n * 针对新生区采用并行回收。\n * 针对老生区采用增量标记与惰性回收\n\n\n# 15 深浅拷贝\n\n\n\n1. 浅拷贝的原理和实现\n\n> 自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象\n\n方法一：object.assign\n\n> object.assign是 es6 中 object 的一个方法，该方法可以用于 js 对象的合并等多个用途，其中一个用途就是可以进行浅拷贝。该方法的第一个参数是拷贝的目标对象，后面的参数是拷贝的来源对象（也可以是多个来源）。\n\nobject.assign 的语法为：object.assign(target, ...sources)\n\n\nobject.assign 的示例代码如下：\n\nlet target = {};\nlet source = { a: { b: 1 } };\nobject.assign(target, source);\nconsole.log(target); // { a: { b: 1 } };\n\n\n但是使用 object.assign 方法有几点需要注意\n\n * 它不会拷贝对象的继承属性；\n * 它不会拷贝对象的不可枚举的属性；\n * 可以拷贝 symbol 类型的属性。\n\nlet obj1 = { a:{ b:1 }, sym:symbol(1)}; \nobject.defineproperty(obj1, 'innumerable' ,{\n    value:'不可枚举属性',\n    enumerable:false\n});\nlet obj2 = {};\nobject.assign(obj2,obj1)\nobj1.a.b = 2;\nconsole.log('obj1',obj1);\nconsole.log('obj2',obj2);\n\n\n\n\n> 从上面的样例代码中可以看到，利用 object.assign 也可以拷贝 symbol 类型的对象，但是如果到了对象的第二层属性 obj1.a.b 这里的时候，前者值的改变也会影响后者的第二层属性的值，说明其中依旧存在着访问共同堆内存的问题，也就是说这种方法还不能进一步复制，而只是完成了浅拷贝的功能\n\n方法二：扩展运算符方式\n\n * 我们也可以利用 js 的扩展运算符，在构造对象的同时完成浅拷贝的功能。\n * 扩展运算符的语法为：let cloneobj = { ...obj };\n\n/* 对象的拷贝 */\nlet obj = {a:1,b:{c:1}}\nlet obj2 = {...obj}\nobj.a = 2\nconsole.log(obj)  //{a:2,b:{c:1}} console.log(obj2); //{a:1,b:{c:1}}\nobj.b.c = 2\nconsole.log(obj)  //{a:2,b:{c:2}} console.log(obj2); //{a:1,b:{c:2}}\n/* 数组的拷贝 */\nlet arr = [1, 2, 3];\nlet newarr = [...arr]; //跟arr.slice()是一样的效果\n\n\n> 扩展运算符 和 object.assign 有同样的缺陷，也就是实现的浅拷贝的功能差不多，但是如果属性都是基本类型的值，使用扩展运算符进行浅拷贝会更加方便\n\n方法三：concat 拷贝数组\n\n> 数组的 concat 方法其实也是浅拷贝，所以连接一个含有引用类型的数组时，需要注意修改原数组中的元素的属性，因为它会影响拷贝之后连接的数组。不过 concat 只能用于数组的浅拷贝，使用场景比较局限。代码如下所示。\n\nlet arr = [1, 2, 3];\nlet newarr = arr.concat();\nnewarr[1] = 100;\nconsole.log(arr);  // [ 1, 2, 3 ]\nconsole.log(newarr); // [ 1, 100, 3 ]\n\n\n方法四：slice 拷贝数组\n\n> slice 方法也比较有局限性，因为它仅仅针对数组类型。slice方法会返回一个新的数组对象，这一对象由该方法的前两个参数来决定原数组截取的开始和结束时间，是不会影响和改变原始数组的。\n\n// slice 的语法为：arr.slice(begin, end);\nlet arr = [1, 2, {val: 4}];\nlet newarr = arr.slice();\nnewarr[2].val = 1000;\nconsole.log(arr);  //[ 1, 2, { val: 1000 } ]\n\n\n> 从上面的代码中可以看出，这就是浅拷贝的限制所在了——它只能拷贝一层对象。如果存在对象的嵌套，那么浅拷贝将无能为力。因此深拷贝就是为了解决这个问题而生的，它能解决多层对象嵌套问题，彻底实现拷贝\n\n手工实现一个浅拷贝\n\n根据以上对浅拷贝的理解，如果让你自己实现一个浅拷贝，大致的思路分为两点：\n\n * 对基础类型做一个最基本的一个拷贝；\n * 对引用类型开辟一个新的存储，并且拷贝一层对象属性。\n\nconst shallowclone = (target) => {\n  if (typeof target === 'object' && target !== null) {\n    const clonetarget = array.isarray(target) ? []: {};\n    for (let prop in target) {\n      if (target.hasownproperty(prop)) {\n          clonetarget[prop] = target[prop];\n      }\n    }\n    return clonetarget;\n  } else {\n    return target;\n  }\n}\n\n\n> 利用类型判断，针对引用类型的对象进行 for 循环遍历对象属性赋值给目标对象的属性，基本就可以手工实现一个浅拷贝的代码了\n\n2. 深拷贝的原理和实现\n\n浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值，而引用数据类型只拷贝了一层属性，再深层的还是无法进行拷贝。深拷贝则不同，对于复杂引用数据类型，其在堆内存中完全开辟了一块内存地址，并将原有的对象完全复制过来存放。\n\n这两个对象是相互独立、不受影响的，彻底实现了内存上的分离。总的来说，深拷贝的原理可以总结如下：\n\n> 将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。\n\n方法一：乞丐版（json.stringify）\n\n> json.stringify() 是目前开发过程中最简单的深拷贝方法，其实就是把一个对象序列化成为 json 的字符串，并将对象里面的内容转换成字符串，最后再用 json.parse() 的方法将 json 字符串生成一个新的对象\n\nlet a = {\n    age: 1,\n    jobs: {\n        first: 'fe'\n    }\n}\nlet b = json.parse(json.stringify(a))\na.jobs.first = 'native'\nconsole.log(b.jobs.first) // fe\n\n\n但是该方法也是有局限性的：\n\n * 会忽略 undefined\n * 会忽略 symbol\n * 不能序列化函数\n * 无法拷贝不可枚举的属性\n * 无法拷贝对象的原型链\n * 拷贝 regexp 引用类型会变成空对象\n * 拷贝 date 引用类型会变成字符串\n * 对象中含有 nan、infinity 以及 -infinity，json 序列化的结果会变成 null\n * 不能解决循环引用的对象，即对象成环 (obj[key] = obj)。\n\nfunction obj() { \n  this.func = function () { alert(1) }; \n  this.obj = {a:1};\n  this.arr = [1,2,3];\n  this.und = undefined; \n  this.reg = /123/; \n  this.date = new date(0); \n  this.nan = nan;\n  this.infinity = infinity;\n  this.sym = symbol(1);\n} \nlet obj1 = new obj();\nobject.defineproperty(obj1,'innumerable',{ \n  enumerable:false,\n  value:'innumerable'\n});\nconsole.log('obj1',obj1);\nlet str = json.stringify(obj1);\nlet obj2 = json.parse(str);\nconsole.log('obj2',obj2);\n\n\n\n\n> 使用 json.stringify 方法实现深拷贝对象，虽然到目前为止还有很多无法实现的功能，但是这种方法足以满足日常的开发需求，并且是最简单和快捷的。而对于其他的也要实现深拷贝的，比较麻烦的属性对应的数据类型，json.stringify 暂时还是无法满足的，那么就需要下面的几种方法了\n\n方法二：基础版（手写递归实现）\n\n> 下面是一个实现 deepclone 函数封装的例子，通过 for in 遍历传入参数的属性值，如果值是引用类型则再次递归调用该函数，如果是基础数据类型就直接复制\n\nlet obj1 = {\n  a:{\n    b:1\n  }\n}\nfunction deepclone(obj) { \n  let cloneobj = {}\n  for(let key in obj) {                 //遍历\n    if(typeof obj[key] ==='object') { \n      cloneobj[key] = deepclone(obj[key])  //是对象就再次调用该函数递归\n    } else {\n      cloneobj[key] = obj[key]  //基本类型的话直接复制值\n    }\n  }\n  return cloneobj\n}\nlet obj2 = deepclone(obj1);\nobj1.a.b = 2;\nconsole.log(obj2);   //  {a:{b:1}}\n\n\n虽然利用递归能实现一个深拷贝，但是同上面的 json.stringify 一样，还是有一些问题没有完全解决，例如：\n\n * 这个深拷贝函数并不能复制不可枚举的属性以及 symbol 类型；\n * 这种方法只是针对普通的引用类型的值做递归复制，而对于 array、date、regexp、error、function 这样的引用类型并不能正确地拷贝；\n * 对象的属性里面成环，即循环引用没有解决。\n\n这种基础版本的写法也比较简单，可以应对大部分的应用情况。但是你在面试的过程中，如果只能写出这样的一个有缺陷的深拷贝方法，有可能不会通过。\n\n所以为了“拯救”这些缺陷，下面我带你一起看看改进的版本，以便于你可以在面试种呈现出更好的深拷贝方法，赢得面试官的青睐。\n\n方法三：改进版（改进后递归实现）\n\n> 针对上面几个待解决问题，我先通过四点相关的理论告诉你分别应该怎么做。\n\n * 针对能够遍历对象的不可枚举属性以及 symbol 类型，我们可以使用 reflect.ownkeys 方法；\n * 当参数为 date、regexp 类型，则直接生成一个新的实例返回；\n * 利用 object 的 getownpropertydescriptors 方法可以获得对象的所有属性，以及对应的特性，顺便结合 object.create 方法创建一个新对象，并继承传入原对象的原型链；\n * 利用 weakmap 类型作为 hash 表，因为 weakmap 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 map 和 weakmap 的关键区别，这里要用 weakmap），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 weakmap 存储的值\n\n如果你在考虑到循环引用的问题之后，还能用 weakmap 来很好地解决，并且向面试官解释这样做的目的，那么你所展示的代码，以及你对问题思考的全面性，在面试官眼中应该算是合格的了\n\n实现深拷贝\n\nconst iscomplexdatatype = obj => (typeof obj === 'object' || typeof obj === 'function') && (obj !== null)\n\nconst deepclone = function (obj, hash = new weakmap()) {\n  if (obj.constructor === date) {\n    return new date(obj)       // 日期对象直接返回一个新的日期对象\n  }\n  \n  if (obj.constructor === regexp){\n    return new regexp(obj)     //正则对象直接返回一个新的正则对象\n  }\n  \n  //如果循环引用了就用 weakmap 来解决\n  if (hash.has(obj)) {\n    return hash.get(obj)\n  }\n  let alldesc = object.getownpropertydescriptors(obj)\n\n  //遍历传入参数所有键的特性\n  let cloneobj = object.create(object.getprototypeof(obj), alldesc)\n\n  // 把cloneobj原型复制到obj上\n  hash.set(obj, cloneobj)\n\n  for (let key of reflect.ownkeys(obj)) { \n    cloneobj[key] = (iscomplexdatatype(obj[key]) && typeof obj[key] !== 'function') ? deepclone(obj[key], hash) : obj[key]\n  }\n  return cloneobj\n}\n\n\n// 下面是验证代码\nlet obj = {\n  num: 0,\n  str: '',\n  boolean: true,\n  unf: undefined,\n  nul: null,\n  obj: { name: '我是一个对象', id: 1 },\n  arr: [0, 1, 2],\n  func: function () { console.log('我是一个函数') },\n  date: new date(0),\n  reg: new regexp('/我是一个正则/ig'),\n  [symbol('1')]: 1,\n};\nobject.defineproperty(obj, 'innumerable', {\n  enumerable: false, value: '不可枚举属性' }\n);\nobj = object.create(obj, object.getownpropertydescriptors(obj))\nobj.loop = obj    // 设置loop成循环引用的属性\nlet cloneobj = deepclone(obj)\ncloneobj.arr.push(4)\nconsole.log('obj', obj)\nconsole.log('cloneobj', cloneobj)\n\n\n我们看一下结果，cloneobj 在 obj 的基础上进行了一次深拷贝，cloneobj 里的 arr 数组进行了修改，并未影响到 obj.arr 的变化，如下图所示\n\n\n\n\n# 16 对象的几种创建方式\n\n\n# 16.1 工厂模式,创建方式\n\nfunction createperson(name,age,job){\n    var o = new object();\n    o.name=name;\n    o.age=age;\n    o.job=job;\n    o.sayname = function(){\n        alert(this.name);\n    }\n}\nvar person1 = createperson(\"da\",1,\"it\");\nvar person2 = createperson(\"dada\",2,\"it\");\n\n\n\n# 16.2 构造函数模式\n\nfunction person(name,age,ob){\n    this.name=name;\n    this.age=age;\n    this.job=job;\n    this.sayname = function(){\n        alert(this.name);\n    }\nvar person1 = new person(\"dada\",1,\"web\");\nvar person2 = new person(\"dada\",2,\"web\");\n}\n\n\n\n# 16.3 使用原型模式\n\nfunction person(){\n}\nperson.prototype.name = \"da\";\nperson.prototype.age = 1;\nperson.prototype.job = \"web\";\nperson.prototype.sayname = function(){\n    alert(this.name);\n}\n \nvar person1 = new person();\nperson1.sayname();    //\"dada\"\n \nvar person2 = new person();\nperson2.sayname();    //\"dada\"\n \nalert(person1.sayname == person2.sayname);   //true\n\n\n\n# 16.4 组合使用构造函数模式和原型模式\n\nfunction person(name,age){\n    this.name = name;\n    this.age = age;\n    this.friends = [\"da\",\"dada\"];\n}\nperson.prototype = {\n    constructor:person,\n    sayname:function(){\n        alert(this.name);\n    }\n}\nvar person1 = new person(\"da1\",1);\nvar person2 = new person(\"da2\",2);\nperson1.friends.push(\"dadada\");\nconsole.log(person1.friends);    //[\"da\",\"dada\",\"dadada\"]\nconsole.log(person2.friends);    //[\"da\",\"dada\"]\nconsole.log(person1.friends === person2.friends);    //false\nconsole.log(person1.sayname === person2.sayname);   //true\n\n\n\n# 16.5 动态原型模式\n\nfunction person(name,age,job){\n    this.name=name;\n    this.age=age;\n    this.job=job;\n\n    if(typeof this.sayname!=\"function\"){\n        person.prototype.sayname=function(){\n            alert(this.name);\n        };\n    }\n}\n\n\n\n# 17 数组相关\n\n\n# 17.1 数组常用方法\n\n * map: 遍历数组，返回回调返回值组成的新数组\n * foreach: 无法break，可以用try/catch中throw new error来停止\n * filter: 过滤\n * some: 有一项返回true，则整体为true\n * every: 有一项返回false，则整体为false\n * join: 通过指定连接符生成字符串\n * push / pop: 末尾推入和弹出，改变原数组， 返回推入/弹出项\n * unshift / shift: 头部推入和弹出，改变原数组，返回操作项\n * sort(fn) / reverse: 排序与反转，改变原数组\n * concat: 连接数组，不影响原数组， 浅拷贝\n * slice(start, end): 返回截断后的新数组，不改变原数组\n * splice(start, number, value...): 返回删除元素组成的数组，value为插入项，改变原数组\n * indexof / lastindexof(value, fromindex): 查找数组项，返回对应的下标\n * reduce / reduceright(fn(prev, cur)， defaultprev): 两两执行，prev 为上次化简函数的return值，cur为当前值(从第二项开始)\n\n数组乱序：\n\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\narr.sort(function () {\n    return math.random() - 0.5;\n});\n\n\n数组拆解: flat: [1,[2,3]] --> [1, 2, 3]\n\narray.prototype.flat = function() {\n    this.tostring().split(',').map(item => +item )\n}\n\n\n\n# 17.2 array(3)和array(3, 4)的区别？\n\nconsole.log(array(3)) // [empty x 3]\nconsole.log(array(3, 4)) // [3, 4]\n\n\n\n# 17.3 请创建一个长度为100，值都为1的数组\n\nnew array(100).fill(1)\n\n\n\n# 17.4 请创建一个长度为100，值为对应下标的数组\n\n// cool的写法：\n[...array(100).keys()]\n\n// 其他方法：\narray(100).join(\",\").split(\",\").map((v, i) => i)\narray(100).fill().map((v, i) => i)\n\n\n\n# 17.5 如何转化类数组成数组\n\n> 因为arguments本身并不能调用数组方法，它是一个另外一种对象类型，只不过属性从0开始排，依次为0，1，2...最后还有callee和length属性。我们也把这样的对象称为类数组\n\n常见的类数组还有：\n\n * 用getelementsbytagname/classname()获得的htmlcollection\n\n * 用queryselector获得的nodelist\n\n> 那这导致很多数组的方法就不能用了，必要时需要我们将它们转换成数组，有哪些方法呢？\n\n1. array.prototype.slice.call()\n\nfunction sum(a, b) {\n  let args = array.prototype.slice.call(arguments);\n  console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦\n}\nsum(1, 2);//3\n\n\n2. array.from()\n\nfunction sum(a, b) {\n  let args = array.from(arguments);\n  console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦\n}\nsum(1, 2);//3\n\n\n这种方法也可以用来转换set和map哦！\n\n3. es6展开运算符\n\nfunction sum(a, b) {\n  let args = [...arguments];\n  console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦\n}\nsum(1, 2);//3\n\n\n4. 利用concat+apply\n\nfunction sum(a, b) {\n  let args = array.prototype.concat.apply([], arguments);//apply方法会把第二个参数展开\n  console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦\n}\nsum(1, 2);//3\n\n\n\n# 17.6 foreach中return有效果吗？如何中断foreach循环？\n\n> 在foreach中用return不会返回，函数会继续执行。\n\nlet nums = [1, 2, 3];\nnums.foreach((item, index) => {\n  return;//无效\n})\n\n\n中断方法：\n\n * 使用try监视代码块，在需要中断的地方抛出异常。\n\n * 官方推荐方法（替换方法）：用every和some替代foreach函数。every在碰到return false的时候，中止循环。some在碰到return true的时候，中止循环\n\n\n# 17.7 js判断数组中是否包含某个值\n\n方法一：array.indexof\n\n> 此方法判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回-1。\n\nvar arr=[1,2,3,4];\nvar index=arr.indexof(3);\nconsole.log(index);\n\n\n方法二：array.includes(searcelement[,fromindex])\n\n> 此方法判断数组中是否存在某个值，如果存在返回true，否则返回false\n\nvar arr=[1,2,3,4];\nif(arr.includes(3))\n  console.log(\"存在\");\nelse\n  console.log(\"不存在\");\n\n\n方法三：array.find(callback[,thisarg])\n\n返回数组中满足条件的第一个元素的值，如果没有，返回undefined\n\nvar arr=[1,2,3,4];\nvar result = arr.find(item =>{\n    return item > 3\n});\nconsole.log(result);\n\n\n方法四：array.findeindex(callback[,thisarg])\n\n> 返回数组中满足条件的第一个元素的下标，如果没有找到，返回-1\n\nvar arr=[1,2,3,4];\nvar result = arr.findindex(item =>{\n    return item > 3\n});\nconsole.log(result);\n\n\n\n# 17.8 js中flat---数组扁平化\n\n> 对于前端项目开发过程中，偶尔会出现层叠数据结构的数组，我们需要将多层级数组转化为一级数组（即提取嵌套数组元素最终合并为一个数组），使其内容合并且展开。那么该如何去实现呢？\n\n需求:多维数组=>一维数组\n\nlet ary = [1, [2, [3, [4, 5]]], 6];// -> [1, 2, 3, 4, 5, 6]\nlet str = json.stringify(ary);\n\n\n1. 调用es6中的flat方法\n\nary = ary.flat(infinity);\n\n\n2. replace + split\n\nary = str.replace(/(\\[|\\])/g, '').split(',')\n\n\n3. replace + json.parse\n\nstr = str.replace(/(\\[|\\])/g, '');\nstr = '[' + str + ']';\nary = json.parse(str);\n\n\n4. 普通递归\n\nlet result = [];\nlet fn = function(ary) {\n  for(let i = 0; i < ary.length; i++) {\n    let item = ary[i];\n    if (array.isarray(ary[i])){\n      fn(item);\n    } else {\n      result.push(item);\n    }\n  }\n}\n\n\n5. 利用reduce函数迭代\n\nfunction flatten(ary) {\n    return ary.reduce((pre, cur) => {\n        return pre.concat(array.isarray(cur) ? flatten(cur) : cur);\n    }, []);\n}\nlet ary = [1, 2, [3, 4], [5, [6, 7]]]\nconsole.log(flatten(ary))\n\n\n6. 扩展运算符\n\n//只要有一个元素有数组，那么循环继续\nwhile (ary.some(array.isarray)) {\n  ary = [].concat(...ary);\n}\n\n\n\n# 18 操作dom\n\n\n# 18.1 说说有几种类型的dom节点\n\n * document节点，整个文档是一个文档节点；\n * element节点，每个html标签是一个元素节点；\n * attribute节点，每一个html属性是一个属性节点；\n * text节点，包含在html元素中的文本是文本节点\n\n\n# 18.2 操作dom节点方法\n\n创建新节点\n\ncreatedocumentfragment()    //创建一个dom片段\ncreateelement()   //创建一个具体的元素\ncreatetextnode()   //创建一个文本节点\n\n\n添加、移除、替换、插入\n\nappendchild()      //添加\nremovechild()      //移除\nreplacechild()      //替换\ninsertbefore()      //插入\n\n\n查找\n\ngetelementsbytagname()    //通过标签名称\ngetelementsbyname()     //通过元素的name属性的值\ngetelementbyid()        //通过元素id，唯一性\n\n\n\n# 19 ajax总结\n\n * ajax的原理简单来说是在用户和服务器之间加了—个中间层(ajax引擎)，通过xmlhttprequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作dom而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据\n * ajax的过程只涉及javascript、xmlhttprequest和dom。xmlhttprequest是ajax的核心机制\n\n\n# 19.1 ajax 有那些优缺点\n\n优点：\n\n * 通过异步模式，提升了用户体验.\n * 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.\n * ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。\n * ajax可以实现动态不刷新（局部刷新）\n\n缺点：\n\n * 安全问题 ajax暴露了与服务器交互的细节。\n * 对搜索引擎的支持比较弱。\n * 不容易调试。\n\n\n# 19.2 关于http,xmlhttprequest,ajax的关系\n\n * http是浏览器和web服务器交换数据的协议,规范\n * xmlhttprequest是一个js对象，是浏览器实现的一组api函数，使用这些函数，浏览器再通过http协议请求和发送数据。\n * ajax是一种技术方案，但并不是一种新技术，它最核心的就是依赖浏览器提供的xmlhttprequest对象。用一句话来概括就是我们使用xmlhttprequest对象来发送一个ajax请求。\n\n\n# 19.3 xmlhttprequest的发展历程是怎样的？\n\n它最开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来w3c对它进行了标准化，提出了xmlhttprequest标准。标准又分为level 1和level 2。\n\nlevel 2相对于level 1做了很大的改进，具体来说是：\n\n * 可以设置http请求的超时时间。\n * 可以使用formdata对象管理表单数据。\n * 可以上传文件。\n * 可以请求不同域名下的数据（跨域请求）。\n * 可以获取服务器端的二进制数据。\n * 可以获得数据传输的进度信息。\n\n\n# 19.4 使用xmlhttprequest封装一个get和post请求\n\nget请求：\n\n核心就四步：\n\n 1. var xhr = new xmlhttprequest()\n 2. xhr.open('get', 'http://www.example.com/api/getname', true)\n 3. xhr.onreadystatechange = function () {}\n 4. xhr.send()\n\n让我们来封装一个简易版的：\n\n/*\n* xhr的get请求\n* @param url: 请求地址\n* @param params: 请求参数\n* @param onsuccess: 成功回调函数\n* @param onerror: 失败回调函数\n*/\nfunction xhrget (url, params = {}, onsuccess, onerror) {\n  // 兼容ie6\n  var xhr = window.xmlhttprequest ? new xmlhttprequest() : new activexobject('microsoft.xmlhttp');\n  let paramstring = formatparams(params);\n  // xhr.open的第三个参数isasync：是否异步 \n  xhr.open('get', `${url}${paramstring}`, true);\n  xhr.onreadystatechange = function () {\n    // console.log(e);\n    console.log(this);\n    if (this.readystate === 4) {\n      if (this.status >= 200 && this.status < 300) {\n        onsuccess(this.response);\n      } else {\n        onerror(this.response)\n      }\n    }\n  }\n  xhr.send();\n}\n// 处理参数：如将{name: 'lindaidai'}转为'?name=lindaidai'\nfunction formatparams (params) {\n  var paramstring = object.keys(params).map(key => {\n    return `${key}=${encodeuricomponent(params[key])}`\n  }).join('&');\n  return paramstring ? `?${paramstring}` : ''\n}\n\n\n（当然上面的兼容ie6估计现在考的不多了，而且我这种写法其实也没啥用，因为如果真是在ie6下的话，后面的object.keys()等方法也用不了了）\n\n需要注意的是两种状态，一个是readystate，一个是status。\n\n> readystate请求状态：\n\n * 0（未初始化）：还没有调用 open() 方法。\n * 1（载入）：已调用 send() 方法，正在发送请求。\n * 2（载入完成）：send() 方法完成，已收到全部响应内容。\n * 3（解析）：正在解析响应内容。\n * 4（完成）：响应内容解析完成，可以在客户端调用。\n\n> status结果状态码：\n\n * 0 ：如果状态是 unsent 或 opened；或者如果错误标签被设置(例如跨域时)\n * 200 成功\n * 其它http状态码\n\npost请求：\n\nfunction xhrpost (url, params, onsuccess, onerror) {\n  var xhr = new xmlhttprequest();\n  xhr.open('post', url, true);\n  // ajax的默认请求contenttype:text/plain(纯文本)\n  xhr.setrequestheader(\"content-type\", \"application-x-www-form-urlencode\");\n  xhr.onreadystatechange = function () {\n    if (this.readystate === 4) {\n      if (this.status >= 200 && this.status < 300) {\n        onsuccess(this.response);\n      } else {\n        onerror(this.response);\n      }\n    }\n  }\n  xhr.send(params);\n}\n\n\n\n# 20 定时器\n\n\n# 20.1 setinterval存在哪些问题？\n\n> javascript中使用 setinterval 开启轮询。定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。而javascript引擎对这个问题的解决是：当使用setinterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。\n\n但是，这样会导致两个问题：\n\n * 某些间隔被跳过；\n * 多个定时器的代码执行之间的间隔可能比预期的小\n\n\n# 20.2 链式调用settimeout对比setinterval\n\nsetinterval本身是会存在一些问题的。而使用链式调用settimeout这种方式会比它好一些：\n\nsettimeout(function fn(){\n    console.log('我是settimeout');\n    settimeout(fn, 1000);\n},1000);\n\n\n这个模式链式调用了settimeout()，每次函数执行的时候都会创建一个新的定时器。第二个settimeout()调用当前执行的函数，并为其设置另外一个定时器。这样做的好处是：\n\n * 在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。\n * 而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。\n\n\n# 20.3 实现比 settimeout 快 80 倍的定时器\n\n> 在浏览器中，settimeout()/setinterval() 的每调用一次定时器的最小间隔是 4ms，这通常是由于函数嵌套导致（嵌套层级达到一定深度）\n\n简单来说，5 层以上的定时器嵌套会导致至少 4ms 的延迟。\n\n用如下代码做个测试：\n\nlet a = performance.now();\nsettimeout(() => {\n  let b = performance.now();\n  console.log(b - a);\n  settimeout(() => {\n    let c = performance.now();\n    console.log(c - b);\n    settimeout(() => {\n      let d = performance.now();\n      console.log(d - c);\n      settimeout(() => {\n        let e = performance.now();\n        console.log(e - d);\n        settimeout(() => {\n          let f = performance.now();\n          console.log(f - e);\n          settimeout(() => {\n            let g = performance.now();\n            console.log(g - f);\n          }, 0);\n        }, 0);\n      }, 0);\n    }, 0);\n  }, 0);\n}, 0);\n\n\n> 在浏览器中的打印结果大概是这样的，和规范一致，第五次执行的时候延迟来到了 4ms 以上\n\n// 结果是\n1.2999999970197678\n1.5\n1.2999999970197678\n1.9000000059604645\n4.5\n4.5999999940395355\n\n\n> 如果想在浏览器中实现 0ms 延时的定时器，可以用 window.postmessage 来实现真正 0 延迟的定时器\n\n(function () {\n  var timeouts = [];\n  var messagename = 'zero-timeout-message';\n\n  // 保持 settimeout 的形态，只接受单个函数的参数，延迟始终为 0。\n  function setzerotimeout(fn) {\n    timeouts.push(fn);\n    window.postmessage(messagename, '*');\n  }\n\n  function handlemessage(event) {\n    if (event.source == window && event.data == messagename) {\n      event.stoppropagation();\n      if (timeouts.length > 0) {\n        var fn = timeouts.shift();\n        fn();\n      }\n    }\n  }\n\n  window.addeventlistener('message', handlemessage, true);\n\n  // 把 api 添加到 window 对象上\n  window.setzerotimeout = setzerotimeout;\n})();\n\n\n由于 postmessage 的回调函数的执行时机和 settimeout 类似，都属于宏任务，所以可以简单利用 postmessage 和 addeventlistener('message') 的消息通知组合，来实现模拟定时器的功能。\n\n这样，执行时机类似，但是延迟更小的定时器就完成了。\n\n再利用下面的嵌套定时器的例子来跑一下测试：\n\nvar a = performance.now();\nsetzerotimeout(() => {\n  let b = performance.now();\n  console.log(b - a);\n  setzerotimeout(() => {\n    let c = performance.now();\n    console.log(c - b);\n    setzerotimeout(() => {\n      let d = performance.now();\n      console.log(d - c);\n      setzerotimeout(() => {\n        let e = performance.now();\n        console.log(e - d);\n        setzerotimeout(() => {\n          let f = performance.now();\n          console.log(f - e);\n          setzerotimeout(() => {\n            let g = performance.now();\n            console.log(g - f);\n          }, 0);\n        }, 0);\n      }, 0);\n    }, 0);\n  }, 0);\n}, 0);\n    \n// 结果\n0.30000000447034836\n0.19999999552965164\n0.10000000149011612\n0.10000000149011612\n0.10000000149011612\n0.10000000149011612\n\n\n全部在 0.1 ~ 0.3 毫秒级别，而且不会随着嵌套层数的增多而增加延迟\n\n有什么场景需要无延迟的定时器？其实在 react 的源码中，做时间切片的部分就用到了\n\n// 伪代码\n\nconst channel = new messagechannel();\nconst port = channel.port2;\n\n// 每次 port.postmessage() 调用就会添加一个宏任务\n// 该宏任务为调用 scheduler.scheduletask 方法\nchannel.port1.onmessage = scheduler.scheduletask;\n\nconst scheduler = {\n  scheduletask() {\n    // 挑选一个任务并执行\n    const task = picktask();\n    const continuoustask = task();\n\n    // 如果当前任务未完成，则在下个宏任务继续执行\n    if (continuoustask) {\n      port.postmessage(null);\n    }\n  },\n};\n\n\n> react 把任务切分成很多片段，这样就可以通过把任务交给 postmessage 的回调函数，来让浏览器主线程拿回控制权，进行一些更优先的渲染任务（比如用户输入）\n\n为什么不用执行时机更靠前的微任务呢？关键的原因在于微任务会在渲染之前执行，这样就算浏览器有紧急的渲染任务，也得等微任务执行完才能渲染\n\n\n# 22.4 说一下requestanimationframe\n\n简介：\n\n显示器都有自己固有的刷新频率(60hz或者75hz)，也就是说每秒最多重绘60次或者75次。而requestanimationframe的基本思想就是与这个刷新频率保持同步，利用这个刷新频率进行重绘。\n\n特点：\n\n * 使用这个api时，一旦页面不处于浏览器的当前标签，就会自动停止刷新，这样就节省了cpu、gpu、电力。\n * 由于它时在主线程上完成的，所以若是主线程非常忙时它的动画也会收到影响\n * 它使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。\n\n使用：\n\n正常使用：\n\nconst requestid = window.requestanimationframe(callback);\n\n\n兼容版本：\n\n// 给 window 下挂载一个兼容版本的 requestaniframe\nwindow.requestaniframe = (function () {\n  return  window.requestanimationframe || \n    window.webkitrequestanimationframe || \n    window.mozrequestanimationframe    || \n    window.orequestanimationframe      || \n    window.msrequestanimationframe     || \n    function( callback ){\n      window.settimeout(callback, 1000 / 60);\n    };\n})();\n\n\n\n# 22.5 requestanimationframe对比settimeout\n\n * 屏幕刷新频率 屏幕每秒出现图像的次数。普通笔记本为60hz\n * 动画原理 计算机每16.7ms刷新一次，由于人眼的视觉停留，所以看起来是流畅的移动。\n * settimeout 通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿抖动的现象；原因是：\n\n 1. settimeout 任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；\n 2. settimeout 的固定时间间隔不一定与屏幕刷新时间相同，会引起丢帧。\n\n> requestanimationframe 优势：由系统决定回调函数的执行时机。60hz的刷新频率，那么每次刷新的间隔中会执行一次回调函数，不会引起丢帧，不会卡顿。且由于一旦页面不处于浏览器的当前标签，就会自动停止刷新，这样就节省了cpu、gpu、电力。\n\n\n# 21 谈谈你对for in/for of的理解\n\n> for in性能很差，迭代当前对象中可枚举的属性，并且一直查找到原型上去。\n\n * 问题1：遍历顺序数字优先\n * 问题2：无法遍历symbol属性\n * 问题3：可以遍历到原型属性中可枚举的\n\nlet obj = {\n  name: 'poetry',\n  age: 22,\n  [symbol('aa')]: 100,\n  0: 200,\n  1: 300\n}\n\n\n\n\nfor(let key in obj) {\n  // 不遍历原型上的属性\n  if(!obj.hasownproperty(key)) {\n    break;\n  }\n}\n\n\n遍历obj的私有属性拼接\n\nlet keys = object.keys(obj)\nkeys = keys.concat(object.getownpropertysymbols(obj1))\nkeys.foreach(v=>{\n  console.log(v)\n})\n\n\nfor of\n\n * 部分数据结构实现了迭代器规范\n   * symbol.itertor\n   * 数组/set/map\n   * 对象没有实现，for of不能遍历对象\n\n// 数组具备迭代器规范，模拟实现\nvar arr = [1,2,3,4,5]\n\narr[symbol.iterator] = function() {\n  let self = this, index = 0;\n\n  return {\n    next() {\n      if(index > self.length - 1) {\n        return {\n          done: true,\n          value: undefined\n        }\n      }\n      return {\n        done: false,\n        value: self[index++]\n      }\n    }\n  }\n}\n    \n// 使对象具备可迭代特性\nlet obj = {\n  0: 100,\n  1: 200,\n  length: 2\n}\n\nobj[symbol.iterator] = array.prototype[symbol.iterator]\n\nfor(var val of obj) {\n  console.log(val)\n}\n\n\n\n# 22 javascript 实现对上传图片的压缩？\n\n> 答：读取用户上传的 file 对象，读写到画布（canvas）上，利用 canvas 的 api 进行压缩，完成压缩之后再转成 file（blob） 对象，上传到远程图片服务器；不过有时候我们也需要将一个 base64 字符串压缩之后再变为 base64 字符串传入到远程数据库或者再转成 file（blob） 对象。\n\n思路就是 file + canvas 的 drawimage",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "图片优化",
      "frontmatter": {
        "title": "图片优化",
        "date": "2022-10-18T11:31:15.000Z",
        "permalink": "/pages/performance/picture/",
        "article": false
      },
      "regularPath": "/50.%E6%80%A7%E8%83%BD&%E7%BD%91%E7%BB%9C%E7%AF%87/30.%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/50.%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96.html",
      "relativePath": "50.性能&网络篇/30.前端性能优化篇/50.图片优化.md",
      "key": "v-37071c5a",
      "path": "/pages/performance/picture/",
      "headers": [
        {
          "level": 3,
          "title": "1. 如何对项目中的图片进行优化？",
          "slug": "_1-如何对项目中的图片进行优化",
          "normalizedTitle": "1. 如何对项目中的图片进行优化？",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "2. 常见的图片格式及使用场景",
          "slug": "_2-常见的图片格式及使用场景",
          "normalizedTitle": "2. 常见的图片格式及使用场景",
          "charIndex": 370
        }
      ],
      "headersStr": "1. 如何对项目中的图片进行优化？ 2. 常见的图片格式及使用场景",
      "content": "# 1. 如何对项目中的图片进行优化？\n\n 1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。\n 2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。\n 3. 小图使用 base64 格式\n 4. 将多个图标文件整合到一张图片中（雪碧图）\n 5. 选择正确的图片格式：\n    * 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好\n    * 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替\n    * 照片使用 JPEG\n\n\n# 2. 常见的图片格式及使用场景\n\n（1）BMP，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。\n\n（2）GIF是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。\n\n（3）JPEG是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。\n\n（4）PNG-8是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。\n\n（5）PNG-24是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。\n\n（6）SVG是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制Logo、Icon等。\n\n（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。\n\n * 在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；\n * 在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；\n * WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。",
      "normalizedContent": "# 1. 如何对项目中的图片进行优化？\n\n 1. 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 css 去代替。\n 2. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 cdn 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。\n 3. 小图使用 base64 格式\n 4. 将多个图标文件整合到一张图片中（雪碧图）\n 5. 选择正确的图片格式：\n    * 对于能够显示 webp 格式的浏览器尽量使用 webp 格式。因为 webp 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好\n    * 小图使用 png，其实对于大部分图标这类图片，完全可以使用 svg 代替\n    * 照片使用 jpeg\n\n\n# 2. 常见的图片格式及使用场景\n\n（1）bmp，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以bmp格式的图片通常是较大的文件。\n\n（2）gif是无损的、采用索引色的点阵图。采用lzw压缩算法进行编码。文件小，是gif格式的优点，同时，gif格式还具有支持动画以及透明的优点。但是gif格式仅支持8bit的索引色，所以gif格式适用于对色彩要求不高同时需要文件体积较小的场景。\n\n（3）jpeg是有损的、采用直接色的点阵图。jpeg的图片的优点是采用了直接色，得益于更丰富的色彩，jpeg非常适合用来存储照片，与gif相比，jpeg不适合用来存储企业logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较gif更大。\n\n（4）png-8是无损的、使用索引色的点阵图。png是一种比较新的图片格式，png-8是非常好的gif格式替代者，在可能的情况下，应该尽可能的使用png-8而不是gif，因为在相同的图片效果下，png-8具有更小的文件体积。除此之外，png-8还支持透明度的调节，而gif并不支持。除非需要动画的支持，否则没有理由使用gif而不是png-8。\n\n（5）png-24是无损的、使用直接色的点阵图。png-24的优点在于它压缩了图片的数据，使得同样效果的图片，png-24格式的文件大小要比bmp小得多。当然，png24的图片还是要比jpeg、gif、png-8大得多。\n\n（6）svg是无损的矢量图。svg是矢量图意味着svg图片由直线和曲线以及绘制它们的方法组成。当放大svg图片时，看到的还是线和曲线，而不会出现像素点。这意味着svg图片在放大时，不会失真，所以它非常适合用来绘制logo、icon等。\n\n（7）webp是谷歌开发的一种新图片格式，webp是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为web而生的，什么叫为web而生呢？就是说相同质量的图片，webp具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有chrome浏览器和opera浏览器支持webp格式，兼容性不太好。\n\n * 在无损压缩的情况下，相同质量的webp图片，文件大小要比png小26%；\n * 在有损压缩的情况下，具有相同图片精度的webp图片，文件大小要比jpeg小25%~34%；\n * webp图片格式支持图片透明度，一个无损压缩的webp图片，如果要支持透明度只需要22%的格外文件大小。",
      "charsets": {
        "cjk": true
      },
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "归档",
      "frontmatter": {
        "archivesPage": true,
        "title": "归档",
        "permalink": "/archives/",
        "article": false
      },
      "regularPath": "/@pages/archivesPage.html",
      "relativePath": "@pages/archivesPage.md",
      "key": "v-1b8e8447",
      "path": "/archives/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    },
    {
      "title": "Home",
      "frontmatter": {
        "home": true,
        "heroImage": "/img/hero-image.png",
        "heroText": "前端进阶宝典",
        "tagline": "前端系统进阶宝典 & 面试指南",
        "actionText": "快速了解 →",
        "actionLink": "/pages/base/",
        "bannerBg": "none",
        "features": [
          {
            "title": "基础篇",
            "details": "帮你梳理常见的前端基础面试题wqw"
          },
          {
            "title": "进阶篇",
            "details": "提炼分析面试难点，助你快速理解"
          },
          {
            "title": "高频篇",
            "details": "精心整理高频面试题型归类"
          },
          {
            "title": "手写篇",
            "details": "高频常见手写编程题"
          },
          {
            "title": "原理篇",
            "details": "面试题型原理解析"
          },
          {
            "title": "面经篇",
            "details": "大厂面经真题整理"
          }
        ]
      },
      "regularPath": "/",
      "relativePath": "index.md",
      "key": "v-4b36bbe0",
      "path": "/",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {},
      "lastUpdated": "2024/04/25, 14:54:23",
      "lastUpdatedTimestamp": 1714028063000
    }
  ],
  "themeConfig": {
    "nav": [
      {
        "text": "基础篇",
        "link": "/pages/base/"
      },
      {
        "text": "高频篇",
        "link": "/pages/dataType/"
      },
      {
        "text": "框架篇",
        "link": "/pages/frameVue/"
      },
      {
        "text": "代码篇",
        "link": "/pages/writeCode/javaScript/"
      },
      {
        "text": "性能&网络篇",
        "link": "/pages/network/http/"
      },
      {
        "text": "精选篇",
        "link": "/pages/fine/"
      },
      {
        "text": "原理篇",
        "link": "/"
      },
      {
        "text": "面经篇",
        "link": "/"
      },
      {
        "text": "更多面试题",
        "link": "/pages/install-phpStudy/",
        "items": [
          {
            "text": "安装后端",
            "link": "/pages/install-phpStudy/"
          },
          {
            "text": "hosts配置",
            "link": "/pages/install-hosts/"
          },
          {
            "text": "phpStudy中PHP配置",
            "link": "/pages/install-php/"
          }
        ]
      },
      {
        "text": "支持",
        "link": "/pages/support/"
      }
    ],
    "sidebarDepth": 1,
    "logo": "/img/hero-image.png",
    "repo": "",
    "searchMaxSuggestions": 10,
    "lastUpdated": "上次更新",
    "sidebar": {
      "/10.基础篇/": [
        {
          "title": "基础进阶",
          "collapsable": false,
          "children": [
            [
              "10.基础进阶/10.HTML、HTTP、web综合问题.md",
              "HTML、HTTP、web综合问题",
              "/pages/base"
            ],
            [
              "10.基础进阶/20.css部分.md",
              "css 部分",
              "/pages/baseCss"
            ],
            [
              "10.基础进阶/30.JavaScript.md",
              "JavaScript",
              "/pages/baseJavaScript"
            ],
            [
              "10.基础进阶/40.webpack相关.md",
              "webpack相关",
              "/pages/baseWebpack/"
            ],
            [
              "10.基础进阶/50.综合.md",
              "综合",
              "/pages/baseUs/"
            ]
          ]
        }
      ],
      "catalogue": {},
      "/20.高频篇/": [
        {
          "title": "JavaScript篇",
          "collapsable": false,
          "children": [
            [
              "10.JavaScript篇/10.数据类型.md",
              "数据类型",
              "/pages/dataType/"
            ],
            [
              "10.JavaScript篇/20.ES6.md",
              "ES6",
              "/pages/es6/"
            ],
            [
              "10.JavaScript篇/30.JavaScript基础.md",
              "JavaScript基础",
              "/pages/JavaScript/"
            ],
            [
              "10.JavaScript篇/40.原型与原型链.md",
              "JavaScript进阶",
              "/pages/effect/"
            ],
            [
              "10.JavaScript篇/50.执行上下文&作用域链&闭包.md",
              "执行上下文&作用域链&闭包",
              "/pages/context/"
            ],
            [
              "10.JavaScript篇/60.this&call&apply&bind.md",
              "this&call&apply&bind",
              "/pages/thisCall/"
            ],
            [
              "10.JavaScript篇/70.异步编程.md",
              "异步编程",
              "/pages/asynchronous/"
            ],
            [
              "10.JavaScript篇/80.面向对象.md",
              "面向对象",
              "/pages/objectOriented/"
            ],
            [
              "10.JavaScript篇/90.垃圾回收与内存泄漏.md",
              "垃圾回收与内存泄漏",
              "/pages/garbageCollection/"
            ]
          ]
        },
        {
          "title": "HTML篇",
          "collapsable": false,
          "children": [
            [
              "20.HTML篇/10.高频HTML.md",
              "高频HTML",
              "/pages/highHtml/"
            ]
          ]
        },
        {
          "title": "CSS篇",
          "collapsable": false,
          "children": [
            [
              "30.CSS篇/10.css基础.md",
              "css基础",
              "/pages/highCss/"
            ],
            [
              "30.CSS篇/20.页面布局.md",
              "页面布局",
              "/pages/highLayout/"
            ],
            [
              "30.CSS篇/30.定位、浮动与场景应用.md",
              "定位、浮动与场景应用",
              "/pages/highLocation/"
            ]
          ]
        }
      ],
      "/30.框架篇/": [
        {
          "title": "vue篇",
          "collapsable": false,
          "children": [
            [
              "10.vue篇/10.vue基础.md",
              "vue基础",
              "/pages/frameVue/"
            ],
            [
              "10.vue篇/20.生命周期.md",
              "生命周期",
              "/pages/frameLifeCycle/"
            ],
            [
              "10.vue篇/30.组件通信.md",
              "组件通信",
              "/pages/frameComponent/"
            ],
            [
              "10.vue篇/40.路由.md",
              "路由",
              "/pages/frameRoute/"
            ],
            [
              "10.vue篇/50.Vuex.md",
              "Vuex",
              "/pages/frameVuex/"
            ],
            [
              "10.vue篇/60.Vue 3.0.md",
              "Vue3",
              "/pages/frameVue3/"
            ],
            [
              "10.vue篇/70.虚拟DOM.md",
              "虚拟DOM",
              "/pages/frameDom/"
            ]
          ]
        },
        {
          "title": "react篇",
          "collapsable": false,
          "children": [
            [
              "20.react篇/10.组件基础.md",
              "组件基础",
              "/pages/frameReact/"
            ],
            [
              "20.react篇/20.数据管理.md",
              "数据管理",
              "/pages/frameDataManagement/"
            ],
            [
              "20.react篇/30.生命周期.md",
              "生命周期",
              "/pages/frameReactLifeCycle/"
            ],
            [
              "20.react篇/40.组件通信.md",
              "组件通信",
              "/pages/frameReactComponent/"
            ],
            [
              "20.react篇/50.路由.md",
              "路由",
              "/pages/frameReactRoute/"
            ],
            [
              "20.react篇/60.Redux.md",
              "Redux",
              "/pages/frameRedux/"
            ],
            [
              "20.react篇/70.Hooks.md",
              "Hooks",
              "/pages/frameHooks/"
            ],
            [
              "20.react篇/80.虚拟DOM.md",
              "虚拟DOM",
              "/pages/frameReactDom/"
            ],
            [
              "20.react篇/90.其他.md",
              "其它",
              "/pages/frameReactOther/"
            ]
          ]
        }
      ],
      "/40.代码篇/": [
        {
          "title": "手写代码篇",
          "collapsable": false,
          "children": [
            [
              "10.手写代码篇/10.JavaScript 基础.md",
              "JavaScript 基础",
              "/pages/writeCode/javaScript/"
            ],
            [
              "10.手写代码篇/20.数据处理.md",
              "数据处理",
              "/pages/writeCode/dataProcessing/"
            ],
            [
              "10.手写代码篇/30.场景应用.md",
              "场景应用",
              "/pages/writeCode/scenarioApplication/"
            ]
          ]
        },
        {
          "title": "代码输出结果篇",
          "collapsable": false,
          "children": [
            [
              "20.代码输出结果篇/10.异步&事件循环.md",
              "异步&事件循环",
              "/pages/codeOutput/react/"
            ],
            [
              "20.代码输出结果篇/20.this.md",
              "this",
              "/pages/codeOutput/this/"
            ],
            [
              "20.代码输出结果篇/30.作用域&变量提升&闭包.md",
              "作用域&变量提升&闭包",
              "/pages/codeOutput/scope/"
            ],
            [
              "20.代码输出结果篇/40.原型&继承.md",
              "原型&继承",
              "/pages/codeOutput/prototype/"
            ]
          ]
        }
      ],
      "/50.性能&网络篇/": [
        {
          "title": "计算机网络篇",
          "collapsable": false,
          "children": [
            [
              "10.计算机网络篇/10.HTTP协议.md",
              "HTTP协议",
              "/pages/network/http/"
            ],
            [
              "10.计算机网络篇/20.HTTPS协议.md",
              "HTTPS协议",
              "/pages/network/https/"
            ],
            [
              "10.计算机网络篇/30.HTTP状态码.md",
              "HTTPS状态码",
              "/pages/network/httpCode/"
            ],
            [
              "10.计算机网络篇/40.DNS协议介绍.md",
              "DNS协议介绍",
              "/pages/network/dns/"
            ],
            [
              "10.计算机网络篇/50.网络模型.md",
              "网络模型",
              "/pages/network/model/"
            ],
            [
              "10.计算机网络篇/60.TCP与UDP.md",
              "TCP与UDP",
              "/pages/network/tcp/"
            ],
            [
              "10.计算机网络篇/70.WebSocket.md",
              "WebSocket",
              "/pages/network/webSocket/"
            ]
          ]
        },
        {
          "title": "浏览器原理篇",
          "collapsable": false,
          "children": [
            [
              "20.浏览器原理篇/10.浏览器安全.md",
              "浏览器安全",
              "/pages/browser/security/"
            ],
            [
              "20.浏览器原理篇/20.进程与线程.md",
              "进程与线程",
              "/pages/browser/process/"
            ],
            [
              "20.浏览器原理篇/30.浏览器缓存.md",
              "浏览器缓存",
              "/pages/browser/cache/"
            ],
            [
              "20.浏览器原理篇/40.浏览器组成.md",
              "浏览器组成",
              "/pages/browser/form/"
            ],
            [
              "20.浏览器原理篇/50.浏览器渲染原理.md",
              "浏览器渲染原理",
              "/pages/browser/principles/"
            ],
            [
              "20.浏览器原理篇/60.浏览器本地存储.md",
              "浏览器本地存储",
              "/pages/browser/storage/"
            ],
            [
              "20.浏览器原理篇/70.浏览器同源策略.md",
              "浏览器同源策略",
              "/pages/browser/cognate/"
            ],
            [
              "20.浏览器原理篇/80.浏览器事件机制.md",
              "浏览器事件机制",
              "/pages/browser/event/"
            ],
            [
              "20.浏览器原理篇/90.浏览器垃圾回收机制.md",
              "浏览器垃圾回收机制",
              "/pages/browser/recovery/"
            ]
          ]
        },
        {
          "title": "前端性能优化篇",
          "collapsable": false,
          "children": [
            [
              "30.前端性能优化篇/10.CDN.md",
              "CDN",
              "/pages/performance/cdn/"
            ],
            [
              "30.前端性能优化篇/20.懒加载.md",
              "懒加载",
              "/pages/performance/loading/"
            ],
            [
              "30.前端性能优化篇/30.回流与重绘.md",
              "回流与重绘",
              "/pages/performance/redraw/"
            ],
            [
              "30.前端性能优化篇/40.节流与防抖.md",
              "节流与防抖",
              "/pages/performance/shaking/"
            ],
            [
              "30.前端性能优化篇/50.图片优化.md",
              "图片优化",
              "/pages/performance/picture/"
            ],
            [
              "30.前端性能优化篇/60.Webpack优化.md",
              "Webpack优化",
              "/pages/performance/webpack/"
            ]
          ]
        }
      ],
      "/60.精选篇/": [
        {
          "title": "精选指南",
          "collapsable": false,
          "children": [
            [
              "10.精选指南/10.HTML模块.md",
              "HTML模块",
              "/pages/fine/"
            ],
            [
              "10.精选指南/20.CSS模块.md",
              "CSS模块",
              "/pages/fineCss/"
            ],
            [
              "10.精选指南/30.JS模块.md",
              "JS模块",
              "/pages/fineJS/"
            ]
          ]
        }
      ],
      "/70.支持/": [
        {
          "title": "支持",
          "collapsable": false,
          "children": [
            [
              "10.支持/10.支持.md",
              "支持",
              "/pages/support"
            ]
          ]
        }
      ]
    },
    "updateBar": {
      "showToArticle": false
    },
    "category": false,
    "tag": false,
    "author": {
      "name": "lj",
      "href": ""
    },
    "social": {
      "icons": [
        {
          "iconClass": "icon-gitee",
          "title": "Gitee",
          "link": ""
        }
      ]
    },
    "footer": {
      "createYear": 2022,
      "copyrightInfo": "lj | MIT License"
    },
    "htmlModules": {}
  }
}