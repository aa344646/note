<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>react综合归类 | LiuJun的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="js数据类型 判断数据类型方法12345678910111213基本数据类型： string number boolean null undefined symbol 和BigInt引用数据类型：Object基本数据类型存放于栈中，引用数据类型的引用指针地址存放于栈，实体部分存放于堆中instanceof 构造函数的 prototype 属性是否在某个实例对象的原型链上,返回Booleantype">
<meta property="og:type" content="article">
<meta property="og:title" content="react综合归类">
<meta property="og:url" content="https://aa344646.github.io/2023/02/21/note/index.html">
<meta property="og:site_name" content="LiuJun的个人博客">
<meta property="og:description" content="js数据类型 判断数据类型方法12345678910111213基本数据类型： string number boolean null undefined symbol 和BigInt引用数据类型：Object基本数据类型存放于栈中，引用数据类型的引用指针地址存放于栈，实体部分存放于堆中instanceof 构造函数的 prototype 属性是否在某个实例对象的原型链上,返回Booleantype">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:\Users\joker\AppData\Roaming\Typora\typora-user-images\image-20221020135330903.png">
<meta property="og:image" content="c:\Users\joker\AppData\Roaming\Typora\typora-user-images\image-20221020135533760.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020042623230374.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MTUwMA==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="c:\Users\joker\AppData\Roaming\Typora\typora-user-images\image-20230216170551173.png">
<meta property="article:published_time" content="2023-02-21T01:00:00.000Z">
<meta property="article:modified_time" content="2023-02-26T16:30:53.211Z">
<meta property="article:author" content="LiuJun">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\joker\AppData\Roaming\Typora\typora-user-images\image-20221020135330903.png">
  
    <link rel="alternate" href="/note/atom.xml" title="LiuJun的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/note/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/note/css/style.css">

  
    
<link rel="stylesheet" href="/note/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/note/" id="logo">LiuJun的个人博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/note/">Home</a>
        
          <a class="main-nav-link" href="/note/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/note/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://aa344646.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-note" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/note/2023/02/21/note/" class="article-date">
  <time class="dt-published" datetime="2023-02-21T01:00:00.000Z" itemprop="datePublished">2023-02-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      react综合归类
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><h5 id="数据类型-判断数据类型方法"><a href="#数据类型-判断数据类型方法" class="headerlink" title="数据类型 判断数据类型方法"></a>数据类型 判断数据类型方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型： string number boolean <span class="literal">null</span> <span class="literal">undefined</span> symbol 和<span class="title class_">BigInt</span></span><br><span class="line">引用数据类型：<span class="title class_">Object</span></span><br><span class="line"></span><br><span class="line">基本数据类型存放于栈中，引用数据类型的引用指针地址存放于栈，实体部分存放于堆中</span><br><span class="line"><span class="keyword">instanceof</span> 构造函数的 prototype 属性是否在某个实例对象的原型链上,返回<span class="title class_">Boolean</span></span><br><span class="line"><span class="keyword">typeof</span> 返回一个字符串，表示操作数的类型</span><br><span class="line">		<span class="keyword">typeof</span> <span class="literal">undefined</span>  <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">		<span class="keyword">typeof</span> <span class="literal">null</span>  <span class="string">&#x27;object&#x27;</span></span><br><span class="line">		<span class="keyword">typeof</span> <span class="title class_">Symbol</span> <span class="string">&#x27;function&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>() <span class="string">&#x27;[object Null]&#x27;</span> <span class="string">&#x27;[object Undefined]&#x27;</span> </span><br><span class="line">jquery.<span class="title function_">type</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">this代表函数运行时，自动生成的一个内部对象，只能在函数内部使用，</span><br><span class="line">随着函数使用场合的不同，this的值会发生变化。</span><br><span class="line"></span><br><span class="line">指向:</span><br><span class="line">1.在方法中，this 表示该方法所属的对象。</span><br><span class="line">2.如果单独使用，this 表示全局对象。</span><br><span class="line">3.函数中，this 表示全局对象。</span><br><span class="line">4.严格模式下，this 是未定义的(undefined)。</span><br><span class="line">5.在事件中，this 表示接收事件的元素。</span><br><span class="line">6.类似 call() 和 apply() 方法可以将 this 引用到任何对象。</span><br><span class="line">7.箭头函数本身是没有this和arguments的，引用的this实际上是调用的是定义时的上一层作用域的this。</span><br></pre></td></tr></table></figure>

<h5 id="null-undefined"><a href="#null-undefined" class="headerlink" title="null undefined"></a>null undefined</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> 代表的含义是未定义，</span><br><span class="line"><span class="literal">null</span> 代表的含义是空对象</span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="literal">true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="literal">false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">null</span> ===<span class="literal">null</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>  <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>  <span class="string">&#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>



<h5 id="怎么判断数组的类型"><a href="#怎么判断数组的类型" class="headerlink" title="怎么判断数组的类型"></a>怎么判断数组的类型</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>()</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>()方法</span><br></pre></td></tr></table></figure>

<h5 id="for-in-for-of"><a href="#for-in-for-of" class="headerlink" title="for in for of"></a>for in for of</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">in</span>遍历的是数组的索引（index），而<span class="keyword">for</span> <span class="keyword">of</span>遍历的是数组元素值,</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">in</span> 可以遍历对象，遍历的是key值,<span class="keyword">for</span> <span class="keyword">of</span>不能遍历对象不然就报错,或者用<span class="title class_">Object</span>.<span class="title function_">keys</span>()把对象转为数组【key】</span><br></pre></td></tr></table></figure>

<h5 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">push，在数组末尾添加一位或多位元素</span><br><span class="line">pop，删除数组最后一位元素</span><br><span class="line">unshift，在数组的开头添加一位或多位元素</span><br><span class="line">shift，删除数组的第一位元素</span><br><span class="line">join，将数组转换为字符串</span><br><span class="line">reserve，反转数组元素的顺序</span><br><span class="line">sort，对数组进行排序</span><br><span class="line">concat，连接两个或多个数组</span><br><span class="line">splice，添加或删除数组中的元素</span><br><span class="line">slice，从已有的数组中返回选定的元素</span><br><span class="line">indexOf、lastIndexOf，查找数组中的元素</span><br><span class="line">forEach，对数组进行遍历循环，对数组中每一项运行指定的函数</span><br><span class="line">map，迭代数组</span><br><span class="line">filter，对数组中的元素进行指定的检查返回符合条件的元素放入一个新数组中</span><br><span class="line">every，测试所有元素是否都符合指定条件</span><br><span class="line">some，测试某些元素是否符合指定条件</span><br><span class="line">reduce，接收一个函数作为累加器，数组中的每个值开始缩减，最终计算为一个值</span><br><span class="line">toString，将数组转换为字符串</span><br></pre></td></tr></table></figure>

<h5 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">charAt</span>() 方法可以返回指定位置的字符</span><br><span class="line"><span class="title function_">indexOf</span>()：查找某个字符，有则返回第一次匹配到的位置，否则返回-<span class="number">1</span></span><br><span class="line"><span class="title function_">lastIndexOf</span>()：查找某个字符，有则返回最后一次匹配到的位置，否则返回-<span class="number">1</span></span><br><span class="line"><span class="title function_">includes</span>()：该方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span></span><br><span class="line"><span class="title function_">startsWith</span>()：该方法用于检测字符串是否以指定的子字符串开始 返回布尔值</span><br><span class="line"><span class="title function_">endsWith</span>()：该方法用来判断当前字符串是否是以指定的子字符串结尾</span><br><span class="line"><span class="title function_">concat</span>() 方法用于连接两个或多个字符串。该方法不会改变原有字符串，会返回连接两个或多个字符串的新字符串。</span><br><span class="line"><span class="title function_">split</span>() 方法用于把一个字符串分割成字符串数组</span><br><span class="line"><span class="title function_">slice</span>() 方法用于提取字符串的某个部分，并以新的字符串返回被提取的部分</span><br><span class="line"><span class="title function_">substr</span>() 方法用于在字符串中抽取从开始下标开始的指定数目的字符</span><br><span class="line"><span class="title function_">substring</span>() 方法用于提取字符串中介于两个指定下标之间的字符</span><br><span class="line"><span class="title function_">toLowerCase</span>()：该方法用于把字符串转换为小写。</span><br><span class="line"><span class="title function_">toUpperCase</span>()：该方法用于把字符串转换为大写。</span><br><span class="line"><span class="title function_">replace</span>()：该方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串</span><br><span class="line"><span class="title function_">trim</span>() 方法用于移除字符串首尾空白符，该方法不会改变原始字符串</span><br></pre></td></tr></table></figure>



<h5 id="Array-from（）和new-Array-区别"><a href="#Array-from（）和new-Array-区别" class="headerlink" title="Array.from（）和new Array 区别"></a>Array.from（）和new Array 区别</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>()是把类数组对象（拥有length属性，且属性名为数值或字符串类型数字）、字符串、set结构的数据，当其参数为一个数组时会返回一个新数组</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>是生成一个数组对象</span><br></pre></td></tr></table></figure>



<h5 id="栈-堆"><a href="#栈-堆" class="headerlink" title="栈 堆"></a>栈 堆</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">栈是后进先出，自动分配内存空间，放置基本数据类型的值和引用类型的地址</span><br><span class="line">堆是动态分配的内存，大小不定，<span class="variable constant_">JS</span>不能直接访问内存中的值, 只能操作对象的地址, 所以产生深/浅拷贝问题</span><br></pre></td></tr></table></figure>

<h5 id="深-浅拷贝"><a href="#深-浅拷贝" class="headerlink" title="深 浅拷贝"></a>深 浅拷贝</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">浅拷贝拷贝地址，深拷贝是解决这个问题的</span><br><span class="line">常见深拷贝解决方案</span><br><span class="line">递归，函数内<span class="keyword">for</span> <span class="keyword">in</span>遍历，遇到引用类型对象，传值自调用</span><br><span class="line">序列化反序列化，缺点是只能序列化自身可枚举属性，<span class="keyword">function</span>、<span class="literal">undefined</span>丢失，<span class="variable constant_">NAN</span>会变成<span class="literal">null</span></span><br><span class="line">三方lodash库</span><br></pre></td></tr></table></figure>

<h5 id="序列化深拷贝的缺点"><a href="#序列化深拷贝的缺点" class="headerlink" title="序列化深拷贝的缺点"></a>序列化深拷贝的缺点</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化深拷贝的缺点？</span></span><br><span class="line">用json.<span class="title function_">pare</span>(json.<span class="title function_">stringify</span>(obj))会导致<span class="keyword">function</span>、<span class="literal">undefined</span> 丢失 </span><br><span class="line"><span class="variable constant_">NAN</span>会变成<span class="literal">null</span> </span><br><span class="line">只能序列化自身可枚举属性</span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line">lodash \或者递归处理</span><br></pre></td></tr></table></figure>

<h5 id="递归实现深拷贝"><a href="#递归实现深拷贝" class="headerlink" title="递归实现深拷贝"></a>递归实现深拷贝</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//怎么用递归实现深拷贝？</span></span><br><span class="line">设置一个函数，接受一个obj，先判断这个obj是数组还是对象，根据obj的类型三目赋值一个变量a空数组还是空对象,<span class="keyword">for</span> <span class="keyword">in</span> 遍历obj，判断obj的[key]是不是等于object，如果等于，调用自身且把这一项作为参数传入，不等于就把这一项赋值给a[key]，最后返回a</span><br></pre></td></tr></table></figure>

<h5 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防抖和节流的实现？</span></span><br><span class="line">- 节流原理是在连续触发的事件中，一定的时间内只执行一次函数。具体实现是设定一个函数 接收两个参数 一个是回调函数另一个是指定的时间，设定一个标识，初始为<span class="literal">true</span>，返回一个函数，在返回函数中判断标识<span class="literal">false</span>就<span class="keyword">return</span>掉，接着设置标识为<span class="literal">false</span>，在定时器中调用参数函数，apply绑定<span class="variable language_">this</span>和<span class="variable language_">arguments</span>,标识置为<span class="literal">true</span></span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">throllet</span> = (<span class="params">fn: <span class="built_in">Function</span>, wait: number</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> run = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: unknown</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!run) <span class="keyword">return</span>;</span><br><span class="line">            run = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">                run = <span class="literal">true</span>;</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">- 防抖原理是触发后n秒内只能执行一次 如果n秒内又触发了该事件，就重新计算时间  设定一个函数，两个参数，一个是回调函数，另一个是指定时间，如果有定时器timer就清空定时器 重新设定定时器</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">fn: <span class="built_in">Function</span>, wait: number</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="attr">timer</span>: number | <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: unknown</span>) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h5 id="事件轮询-宏任务-微任务"><a href="#事件轮询-宏任务-微任务" class="headerlink" title="事件轮询 宏任务 微任务"></a>事件轮询 宏任务 微任务</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件轮询是为了解决js单线程所造成的阻塞问题，任务分为同步任务和异步任务，在事件轮询的整个过程中，先执行宏任务中的代码块，放入调用栈，先进后出执行调用栈中内容，同步的立刻执行，异步的（<span class="built_in">setTimeout</span>、<span class="built_in">setInterval</span>、promise.<span class="property">then</span>等）经过web api分配到任务队列中，常用的<span class="built_in">setTimeout</span>、<span class="built_in">setInterval</span>分配到宏任务队列，promise.<span class="property">then</span>到微任务队列，因为一开始先执行的宏任务，所以接着执行微任务，微任务清空event loop会再看宏任务还有没有东西，没有的话结束。</span><br></pre></td></tr></table></figure>

<h5 id="js延迟加载"><a href="#js延迟加载" class="headerlink" title="js延迟加载"></a>js延迟加载</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.把js脚本放在文档最底部</span><br><span class="line">2.给脚本添加defer属性，与文档解析同步，文档解析完成后加载脚本，多个defer默认顺序，在一些浏览器可能不同</span><br><span class="line">3.添加async属性，异步加载，加载完成后立即执行，此时如果文档未解析完成会阻塞，多个async乱序执行</span><br><span class="line">4.动态dom添加，当文档加载完成后创建script标签引入js脚本</span><br></pre></td></tr></table></figure>

<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_43586120/article/details/89456183</span><br><span class="line">在一个函数中嵌套另一个函数，内部函数引用了外部函数的变量</span><br><span class="line">造成的后果：延长了外面变量的生命周期，外部函数可以更改内部变量，使用不当会造成内存泄漏甚至内存溢出，比如挂载监听事件内不去清除引用，就会一直占用内存</span><br><span class="line">解决方案：闭包缓存变量引用清除，GC就会回收这部分内存</span><br><span class="line">使用场景：</span><br><span class="line">循环赋值（遍历赋值，内部为自执行函数，值传入）</span><br><span class="line">返回值 内部变量返回出来</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">外部操作内部变量例如</span><br><span class="line">function a()&#123;</span><br><span class="line">    let b = &#123;a:1&#125;</span><br><span class="line">   </span><br><span class="line">    return function c()&#123;</span><br><span class="line">         console.log(&#x27;b&#x27;,b)</span><br><span class="line">        return b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b = a()</span><br><span class="line">let c = b()</span><br><span class="line">c.a = 2</span><br><span class="line">b() //b &#123;a: 2&#125; 此时内部b变量已被更改</span><br></pre></td></tr></table></figure>

<h5 id="原型-原型链"><a href="#原型-原型链" class="headerlink" title="原型 原型链"></a>原型 原型链</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原型：</span><br><span class="line">每一个函数都有一个prototype对象属性，指向另一个对象</span><br><span class="line">prototype就是调用构造函数所创建的那个实例对象的原型</span><br><span class="line">原型链：</span><br><span class="line">实例对象与原型之间的连接，叫做原型链。</span><br><span class="line"><span class="variable constant_">JS</span>在创建对象的时候，都有一个叫做__proto__的内置属性，用于指向创建它的函数对象的原型对象prototype。</span><br></pre></td></tr></table></figure>



<h5 id="call-bind-apply"><a href="#call-bind-apply" class="headerlink" title="call,bind,apply"></a>call,bind,apply</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">都是改变this指向</span><br><span class="line">call和apply是改变this指向后执行，bind返回函数</span><br><span class="line">call可以接收一个参数列表 (this，1,2,3)</span><br><span class="line">apply接收一个数组 (this,[1,2,3])</span><br></pre></td></tr></table></figure>

<h5 id="Ajax、Axios、Fetch的认识"><a href="#Ajax、Axios、Fetch的认识" class="headerlink" title="Ajax、Axios、Fetch的认识"></a>Ajax、Axios、Fetch的认识</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ajax是js和xml的集合，传统意义上的<span class="title class_">Ajax</span>是基于xhr的异步请求</span><br><span class="line">ajax提交post请求的数据：<span class="number">1.</span>创建核心对象；<span class="number">2.</span>准备建立连接；<span class="number">3.</span>发送请求；<span class="number">4.</span>处理响应</span><br><span class="line"></span><br><span class="line">axios是xhr的二次封装，基于promise的网络请求库，支持浏览器和nodejs</span><br><span class="line">fetch基于promise，可链式调用，原生方法</span><br></pre></td></tr></table></figure>

<h5 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和   POST 的区别"></a>GET 和   POST 的区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">除了带参数长度限制之外，GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。（幂等性：对同一URL的多个请求应该返回同样的结果。）因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h5 id="模块化开发的几种方案"><a href="#模块化开发的几种方案" class="headerlink" title="模块化开发的几种方案"></a>模块化开发的几种方案</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">commonjs require引入模块，module.exports暴露，同步引用，服务端用的</span><br><span class="line">AMD 异步加载，不过是全部加载，require.js实现了AMD规范</span><br><span class="line">CMD 异步加载，按需引入，sea.js实现了cmd规范</span><br><span class="line">ES6方案，使用import export去导入导出模块</span><br></pre></td></tr></table></figure>

<h5 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，</span><br><span class="line">所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</span><br><span class="line"></span><br><span class="line">由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，</span><br><span class="line">但是这种方式容易造成全局变量的污染，并且模块间没有联系。</span><br><span class="line"></span><br><span class="line">后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，</span><br><span class="line">但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。</span><br><span class="line"></span><br><span class="line">现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</span><br></pre></td></tr></table></figure>

<h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1、单例模式</span><br><span class="line">2、工厂模式</span><br><span class="line">3、观察者模式</span><br><span class="line">4、代理模式</span><br><span class="line">5、策略模式</span><br><span class="line">6、迭代器模式</span><br><span class="line"></span><br><span class="line">观察者模式中</span><br><span class="line">	在观察者模式中，有两个模型，一个观察者 (observer)和一个被观察者 (Observed)。 当被观察者发生改变或变化时，会通知观察者。</span><br><span class="line">	定义了对象间的一种 一对多 的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。</span><br><span class="line">单例模式（Singleton Pattern）</span><br><span class="line">	单例模式中Class的实例个数最多为1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。</span><br><span class="line">	</span><br><span class="line">工厂模式</span><br><span class="line">	工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</span><br><span class="line">使用场景：如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</span><br><span class="line">class Product &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    init() &#123;</span><br><span class="line">        console.log(&#x27;init&#x27;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">class Factory &#123;</span><br><span class="line">    create(name) &#123;</span><br><span class="line">        return new Product(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// use</span><br><span class="line">let factory = new Factory()</span><br><span class="line">let p = factory.create(&#x27;p1&#x27;)</span><br><span class="line">p.init()</span><br><span class="line">https://juejin.im/post/6844904200917221389#heading-81  </span><br></pre></td></tr></table></figure>

<h5 id="js继承方式的优缺点"><a href="#js继承方式的优缺点" class="headerlink" title="js继承方式的优缺点"></a>js继承方式的优缺点</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>原型链继承</span><br><span class="line">父类的实例作为子类的原型</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Woman</span>(<span class="params"></span>)&#123; </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Woman</span>.<span class="property"><span class="keyword">prototype</span></span>= <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line"><span class="title class_">Woman</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;haixia&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> womanObj = <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line">优点：</span><br><span class="line">简单易于实现，父类的新增的实例与属性子类都能访问</span><br><span class="line">缺点：</span><br><span class="line">可以在子类中增加实例属性，如果要新增加原型属性和方法需要在<span class="keyword">new</span> 父类构造函数的后面</span><br><span class="line">无法实现多继承</span><br><span class="line">创建子类实例时，不能向父类构造函数中传参数</span><br><span class="line"><span class="number">2.</span>实例继承（原型式继承）</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Wonman</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">  instance.<span class="property">name</span> = name || <span class="string">&#x27;wangxiaoxia&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> wonmanObj = <span class="keyword">new</span> <span class="title class_">Wonman</span>();</span><br><span class="line">优点：</span><br><span class="line">不限制调用方式</span><br><span class="line">简单，易实现</span><br><span class="line">缺点：不能多次继承</span><br><span class="line"><span class="number">3.</span>.<span class="property">es6</span>继承</span><br><span class="line">使用<span class="keyword">extends</span>继承基类，construtor中用<span class="variable language_">super</span>继承父类属性</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name=<span class="string">&#x27;wang&#x27;</span>,age=<span class="string">&#x27;27&#x27;</span></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eat</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> eat food`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Woman</span> <span class="keyword">extends</span> <span class="title class_ inherited__">People</span>&#123; </span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">name = <span class="string">&#x27;ren&#x27;</span>,age = <span class="string">&#x27;27&#x27;</span></span>)&#123; </span><br><span class="line">     <span class="comment">//继承父类属性</span></span><br><span class="line">     <span class="variable language_">super</span>(name, age); </span><br><span class="line">   &#125; </span><br><span class="line">    <span class="title function_">eat</span>(<span class="params"></span>)&#123; </span><br><span class="line">     <span class="comment">//继承父类方法</span></span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">eat</span>() </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h5 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.Node不是一个后端语言，但是它可以做类似后端语言的功能</span><br><span class="line">2.Node是使用谷歌V8引擎</span><br><span class="line">3.Node是js的一个运行环境</span><br><span class="line">4.Node具有非阻塞I/O 特点</span><br><span class="line">5.Node采用了Common.js规范  </span><br><span class="line"></span><br><span class="line">node+koa2   node+express</span><br><span class="line"></span><br><span class="line">用于快速构建Node.js项目</span><br><span class="line"></span><br><span class="line">node.js 是一个基于 Chrome V8 引擎的 JavaScirpt 运行环境。</span><br><span class="line"></span><br><span class="line">Node.js使用了一个事件驱动、非阻塞式I/O的模型,使其轻量又高效**</span><br><span class="line"></span><br><span class="line">Node.js基于commonjs规范</span><br><span class="line"></span><br><span class="line">事件驱动： 任务执行，发布者，订阅者，事件驱动 .</span><br><span class="line">异步（非阻塞）： 执行某一个任务的同时也可以执行其他任务</span><br><span class="line">同步（阻塞）： 执行某一个任务，这个任务如果没有执行完成，其他任务必须等待</span><br><span class="line">I/O: 输入/输出（ 数据库操作，文件系统操作等  ） - 服务器的环境</span><br><span class="line">非阻塞I/O模型： 当使用Node.js来实现数据库操作、文件系统等操作时，要进行的异步操作，异步操作的核心传统实现方式就是回调函数和事件。</span><br><span class="line"></span><br><span class="line">Node.js的包管理工具npm</span><br><span class="line"></span><br><span class="line">优点：Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，异步编程，使其轻量又高效。</span><br><span class="line">缺点：单进程，单线程，只支持单核cpu，不能充分的利用多核cpu服务器。一旦这个进程崩掉，那么整个web服务就崩掉了。</span><br><span class="line"></span><br><span class="line">内置模块 http 是用于创建一个能够处理和响应 http 响应的服务</span><br><span class="line"></span><br><span class="line">fs 用于对系统文件及目录进行读写操作。</span><br><span class="line">path 提供了一些用于处理文件路径的小工具</span><br><span class="line">Url：帮助我们对提交上来的url进行解析处理</span><br><span class="line">querystring  提供用于解析和格式化 URL 查询字符串的工具。qs.parse()   qs.stringify()</span><br></pre></td></tr></table></figure>
<h5 id="上传和下载"><a href="#上传和下载" class="headerlink" title="上传和下载"></a>上传和下载</h5><pre><code>下载： 通过将文件写入内存，并且创建a元素，a链接href属性指向内存中的文件，download属性指向要下载的文件名，模拟a元素的点击事件，进行下载；
let downloadUrl = window.URL.createObjectURL(blob);
创建下载的链接
上传：使用upoload上传，可以
</code></pre>
<h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><p>ui &#x3D; render (data)</p>
<h5 id="diff算法和fiber"><a href="#diff算法和fiber" class="headerlink" title="diff算法和fiber"></a>diff算法和fiber</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">React中，在某一时间节点调用render会创建一颗Virtual DOM树，当props或者state更新的时候会创建一棵新的树， React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，来保证当前 UI 与最新的树保持同步，传统的算法复杂度为O(n^3)，开销太昂贵了，所以基于不用类型元素产生不同的树和子元素用key标识的假设，设计出来O(n)的diff算法。diff算法同层按照key比较新旧dom树，更新虚拟dom,因为是同层比较，没有递归，所以时间复杂度为O(n),计算出Virtual DOM中真 正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面。使用key是为了做对比更新用的，没有key的话只能重新创建所有的子元素，因为react无法区分哪个是新建哪个是仅仅平移。不建议使用下标作为key，当元素进行排序或者逆序增删的时候，key会被赋值到一个新的元素，产生不必要的dom更新，其次如果元素为输入类的dom,比如input,就会出现界面问题，（输入后首位新增item,值会出现在新增的item上）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fiber是16版本后推出的，把任务分片，可在执行完一小片任务后中断任务处理其他事件</span><br></pre></td></tr></table></figure>
<h5 id="vdom快还是操作真实dom快"><a href="#vdom快还是操作真实dom快" class="headerlink" title="vdom快还是操作真实dom快"></a>vdom快还是操作真实dom快</h5><pre><code>操作真实Dom更快，但是大批量更新会把所有dom都重新操作一遍，开销太高
而且对 DOM 反复操作会导致页面重绘、回流，效率非常低，页面可能会被卡死。
</code></pre>
<h5 id="react合成事件-原生事件"><a href="#react合成事件-原生事件" class="headerlink" title="react合成事件 原生事件"></a>react合成事件 原生事件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 合成事件原理</span><br><span class="line">   如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。</span><br><span class="line"></span><br><span class="line">当用户在为onClick添加函数时，React并没有将Click时间绑定在DOM上面。</span><br><span class="line">而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装交给中间层SyntheticEvent（负责所有事件合成）</span><br><span class="line">所以当事件触发的时候，对使用统一的分发函数dispatchEvent将指定函数执行。</span><br><span class="line"></span><br><span class="line">2. 与原生事件的区别</span><br><span class="line">   React合成事件一套机制：React并不是将click事件直接绑定在dom上面，而是采用事件冒泡的形式冒泡到document上面，然后React将事件封装给正式的函数处理运行和处理。</span><br><span class="line">   </span><br><span class="line">   (原生事件和合成事件块，不能混用，比如合成事件用e.preventDefault()和原生事件return false不同)</span><br><span class="line"> 3.原生事件</span><br><span class="line"> addEventListener(&#x27;click&#x27;,()=&gt;&#123;&#125;,false),false 冒泡 true 捕获</span><br></pre></td></tr></table></figure>

<h5 id="setState同步异步"><a href="#setState同步异步" class="headerlink" title="setState同步异步"></a>setState同步异步</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState在合成事件和钩子函数中是异步的，在原生中和<span class="built_in">setTimeout</span>中是同步的,因为原生和定时器中react检测不到，在react18中定时器也会被批量合并更新</span><br></pre></td></tr></table></figure>

<h5 id="垃圾回收机制（GC）和v8引擎回收"><a href="#垃圾回收机制（GC）和v8引擎回收" class="headerlink" title="垃圾回收机制（GC）和v8引擎回收"></a>垃圾回收机制（GC）和v8引擎回收</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现代浏览器的垃圾回收机制有两种，一个是标记清除法，另一个是引用计数法，常用的是标记清除法，会先遍历存储对象，打上标记，代码执行过程中对用到的变量清除标记，清除阶段对有标记的进行清除。不过会造成碎片化内存，需要配合标记整理算法对内存进行整理。</span><br><span class="line">引用计数法，变量声明赋值后，值的引用数为1，当同一个值被赋给另一个对象时，引用数加一，被覆盖引用数减一，为0的时候被清理</span><br><span class="line"></span><br><span class="line">v8的回收机制是对标记清除法的优化，基于分代回收机制，会把内存分为新生代和老生代，新生代又根据scavenge算法进行垃圾回收，新生代分为使用区和空闲区，新对象都在使用区，使用区满了就把还活动的对象拷贝到空闲区，再交换。经历过一次scavenge回收的对象可以放到老生代，老生代就按照正常的标记清除和标记整理</span><br></pre></td></tr></table></figure>



<h5 id="react16-8生命周期"><a href="#react16-8生命周期" class="headerlink" title="react16.8生命周期"></a>react16.8生命周期</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">react生命周期</span><br><span class="line">如生命周期相同则先执行子组件</span><br><span class="line">&lt;--初始化阶段--&gt;</span><br><span class="line">constructor 是初始化阶段的生命周期钩子 一定是最先执行的 只执行一次</span><br><span class="line">&lt;--挂载--&gt;</span><br><span class="line">componentWillMount 组件将要挂载 </span><br><span class="line">render 渲染</span><br><span class="line">componentDidMount 在组件被挂载结束以后执行的钩子</span><br><span class="line">&lt;--更新--&gt;</span><br><span class="line">vue里面只有发生改变的触发 在react里面都触发</span><br><span class="line">componentWillReceiveProps 组将将要被更新 </span><br><span class="line">shouldComponentUpdate 组件应该更新 有return 返回布尔值 true表示放行  【PureComponent】如果class继承这个就不需要shouldComponentUpdate 这一步判断了 直接完成</span><br><span class="line">componentWillUpdate 数组将要更新</span><br><span class="line">render 渲染</span><br><span class="line">componentDidUpdate 数组已经被更新</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\joker\AppData\Roaming\Typora\typora-user-images\image-20221020135330903.png" alt="image-20221020135330903"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getDerivedStateFromProps 需要前面加上static 有两个参数  nextProps （新的属性）, prevState （旧的状态） 会合并之前的对象 </span><br></pre></td></tr></table></figure>

<img src="C:\Users\joker\AppData\Roaming\Typora\typora-user-images\image-20221020135533760.png" alt="image-20221020135533760" style="zoom: 67%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">块级格式化上下文，内部空间独立，浮动元素参与计算，相邻margin会重叠</span><br><span class="line">触发条件：float不为none,position为absolute或者fixed，display为行内块或者tab-cell，flex等，overflow不为默认</span><br></pre></td></tr></table></figure>

<h5 id="react废弃生命周期"><a href="#react废弃生命周期" class="headerlink" title="react废弃生命周期"></a>react废弃生命周期</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、componentWillMount</span><br><span class="line"><span class="number">2</span>、componentWillUpdate</span><br><span class="line"><span class="number">3</span>、componentWillReceiveProps</span><br><span class="line">原因：</span><br><span class="line">在 componentWillMount进行异步请求，能使数据返回的更快。但，componentWillMount 结束后，render 会立刻被触发，但此时componentWillMount中的异步请求结果可能还未返回结果，一但结果返回会重新render,所以说即使在componentWillMount就进行了异步请求，在返回数据后又会重新render,这会导致服务端渲染场景下的冗余请求等额外问题，得不偿失。因此与在componentDidMount来请求没太大差别，所以官方将它废除。</span><br><span class="line"></span><br><span class="line">假如在 componentWillReceiveProps 和 componentWillUpdate 里滥用 setState ，将导致重复渲染死循环。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="class组件和函数组件"><a href="#class组件和函数组件" class="headerlink" title="class组件和函数组件"></a>class组件和函数组件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 语法上的区别：</span><br><span class="line">函数式组件是一个纯函数，它是需要接受props参数并且返回一个<span class="title class_">React</span>元素就可以了。类组件是需要继承<span class="title class_">React</span>.<span class="property">Component</span>的，而且<span class="keyword">class</span>组件需要创建render并且返回<span class="title class_">React</span>元素，语法上来讲更复杂。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 调用方式</span><br><span class="line">函数式组件可以直接调用，返回一个新的<span class="title class_">React</span>元素；类组件在调用时是需要创建一个实例的，然后通过调用实例里的render方法来返回一个<span class="title class_">React</span>元素。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 状态管理</span><br><span class="line">函数式组件没有状态管理，类组件有状态管理。</span><br></pre></td></tr></table></figure>



<h5 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">为什么使用hook</span><br><span class="line">    让函数组件也能做类组件的事，有自己的状态，处理一些副作用，能获取ref，也能做数据缓存；</span><br><span class="line">解决逻辑复用的难题，放弃面向对象编程，拥抱函数编程</span><br><span class="line"></span><br><span class="line">出现原因<span class="number">3</span>点</span><br><span class="line">    为了让函数组件拥有类组件的功能。</span><br><span class="line">    	原因</span><br><span class="line">    	比如useState、useReducer  状态定义</span><br><span class="line">    	比如useEffect、useLayoutEffect 生命周期功能</span><br><span class="line">    	比如useRef useImperativeHandle 替代了类组件的 <span class="title class_">Ref</span></span><br><span class="line">    为了优化函数组件，比如useMemo、useCallback</span><br><span class="line">	函数组件添加新的方法,如</span><br><span class="line">    	useDebugValue显示自定义hook，自己添加hook类名</span><br><span class="line">    	自定义hooks来复用状态</span><br><span class="line"></span><br><span class="line"><span class="comment">//优点4点</span></span><br><span class="line"><span class="number">1.</span>让函数组件可以定义状态 </span><br><span class="line">	让函数组件可以使用生命周期、监听数据</span><br><span class="line">	让函数组件可以有<span class="title class_">Ref</span>的功能（父组件获取子组件）</span><br><span class="line">	优化函数组件 useMemo、useCallback</span><br><span class="line">	自定义hooks来复用状态,</span><br><span class="line">	代码量比类组件更少，更清爽。</span><br><span class="line">缺点：</span><br><span class="line">-- 在闭包场景可能会引用到旧的state、props值</span><br><span class="line">-- <span class="title class_">React</span>.<span class="property">memo</span>并不能完全替代<span class="title function_">shouldComponentUpdate</span>(因为拿不到 state change，只针对 props change)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用规则2点</span></span><br><span class="line">	不要在循环，条件或嵌套函数中调用 <span class="title class_">Hook</span></span><br><span class="line">	只在函数组件中使用 <span class="title class_">Hooks</span></span><br><span class="line">(因为调用hooks的过程中，我们是在操作数组上的指针，如果你在多次render中，改变了hooks的调用顺序，将导致数组上的指针和组件里的 useState不匹配，从而返回错误的 state以及 setter。)</span><br><span class="line"><span class="number">3.</span>常用<span class="title class_">Hook</span></span><br><span class="line">	<span class="attr">useState</span>:</span><br><span class="line">		定义状态 修改状态</span><br><span class="line">		返回一个数组，其中第一项是状态值，第二项是一个更新状态的函数。</span><br><span class="line">		状态一旦改变，<span class="title class_">React</span> 就会重新渲染组件，变量获取新的状态值。</span><br><span class="line">	<span class="attr">useEffect</span>:</span><br><span class="line">		相当于componentDidMount,componentDidUpdate,componentWillUnmount三个钩子的组合</span><br><span class="line">		参数一：执行的回调函数；</span><br><span class="line">		参数二：该useEffect在哪些state发生变化时，才重新执行；</span><br><span class="line">		第二个参数是空数组的时候执行一次,相当于componentDidMount,不加的时候执行多次</span><br><span class="line">		第二个参数的作用就是 仅在更改时更新，实现性能的优化</span><br><span class="line">		<span class="variable constant_">DOM</span>操作 第三方实例化可以做 清除无用实例和事件</span><br><span class="line">		useEffect传入的回调函数本身可以有一个返回值，</span><br><span class="line">		这个返回值是另外一个回调函数，来模拟componentWillUnmount</span><br><span class="line">	<span class="attr">useLayoutEffect</span>:</span><br><span class="line">		布局副作用</span><br><span class="line">			useEffect 在浏览器渲染完成后执行</span><br><span class="line">			useLayoutEffect 在浏览器渲染前执行</span><br><span class="line">		useLayoutEffect 里的任务最好影响了 <span class="title class_">Layout</span></span><br><span class="line">		为了用户体验，优先使用 useEffect (优先渲染)</span><br><span class="line">	<span class="attr">useContext</span>:</span><br><span class="line">		跨组件通信 createContext创建一个组件 &lt;numContext.<span class="property">Provider</span> value=&#123;num&#125;&gt;</span><br><span class="line">	<span class="attr">useDebugValue</span>:</span><br><span class="line">		自定义 hook 的标签 方便调试台查看</span><br><span class="line">	<span class="attr">useMemo</span>:</span><br><span class="line">		记忆组件 动态缓存 新值和旧值一样,不重新渲染页面,优化作用,类似于shouldComponentUpdate     	<span class="attr">useCallBack</span>:</span><br><span class="line">		作用和 useMemo 一样</span><br><span class="line">		useMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行</span><br><span class="line">		并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。</span><br><span class="line">		<span class="title function_">useCallback</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(x), [m]) 等价于</span><br><span class="line">		<span class="title function_">useMemo</span>( <span class="function">() =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(x), [m])</span><br><span class="line">	<span class="attr">useRef</span>:</span><br><span class="line">		返回一个可变的ref对象</span><br><span class="line">	<span class="attr">useImperativeHandle</span>:</span><br><span class="line">		将组件中的方法放到外面使用</span><br><span class="line">		搭配<span class="title class_">React</span>.<span class="property">forwardRef</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>自定义hook</span><br><span class="line">   类似于高阶组件 </span><br><span class="line">   高阶组件返回的一个类组件，而自定义<span class="title class_">Hook</span>可以返回任何东西</span><br><span class="line">   高阶组件必须传递一个组件作为参数，而自定义<span class="title class_">Hook</span>不需要</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">useFriendStatus</span>(<span class="params">friendID</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> [isOnline, setIsOnline] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line">      <span class="comment">// 在开发者工具中的这个 Hook 旁边显示标签</span></span><br><span class="line">      <span class="comment">// e.g. &quot;FriendStatus: Online&quot;</span></span><br><span class="line">      <span class="title function_">useDebugValue</span>(isOnline ? <span class="string">&#x27;Online&#x27;</span> : <span class="string">&#x27;Offline&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> isOnline;</span><br><span class="line">   &#125;</span><br><span class="line">可以理解为数据的操作都在hook里进行，而外部只关心自己想要的。我只要数据列表，获取产品钩子（可能并不需要，可通过参数变更从而触发重新获取数据）、删除产品钩子</span><br><span class="line">为了封装方法：节流；</span><br></pre></td></tr></table></figure>

<h5 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h5><pre><code>seEffect:
    相当于componentDidMount,componentDidUpdate,componentWillUnmount三个钩子的组合
    参数一：执行的回调函数；
    参数二：该useEffect在哪些state发生变化时，才重新执行；
    第二个参数是空数组的时候执行一次,相当于componentDidMount,不加的时候执行多次
    第二个参数的作用就是 仅在更改时更新，实现性能的优化
    DOM操作 第三方实例化可以做 清除无用实例和事件
    useEffect传入的回调函数本身可以有一个返回值，
    这个返回值是另外一个回调函数，来模拟componentWillUnmount
    
      3.React 18 中 useEffect 会运行两次 
1.这是 React18 才新增的特性。
2.仅在开发模式(&quot;development&quot;)下，且使用了严格模式(&quot;Strict Mode&quot;)下会触发。
  生产环境(&quot;production&quot;)模式下和原来一样，仅执行一次。
3.之所以执行两次，是为了模拟立即卸载组件和重新挂载组件。
  为了帮助开发者提前发现重复挂载造成的 Bug 的代码。 
  同时，也是为了以后 React的新功能做铺垫。 
  未来会给 React 增加一个特性，允许 React 在保留状态的同时，能够做到仅仅对UI部分的添加和删除。
  让开发者能够提前习惯和适应，做到组件的卸载和重新挂载之后， 重复执行 useEffect的时候不会影响应用正常运行。
    解决方案： 取消严格模式
    在 Next.js 中，可以在 next.config.js 文件里增加这个选项：
        reactStrictMode: false
    在 cra 创建的应用里，可以把 index.js 文件里的 StrictMode 高阶组件去除
</code></pre>
<h5 id="Hooks做性能优化"><a href="#Hooks做性能优化" class="headerlink" title="Hooks做性能优化"></a>Hooks做性能优化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//怎么用Hooks做性能优化？</span></span><br><span class="line"><span class="title class_">Usecallback</span>主要是缓存函数接受两个参数，第一个是函数，第二个是依赖项，usememo缓存计算，和vue里面计算属性差不多</span><br><span class="line">(<span class="title class_">React</span>.<span class="property">memo</span> 比对props是否改变来决定是否渲染和类组件的purecomponent)</span><br></pre></td></tr></table></figure>

<h5 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h5><img src="https://img-blog.csdnimg.cn/2020042623230374.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg3MTUwMA==,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">view通过dispatch一个action给store来改变数据，store接收到action后传递一个preState和action给reducer，reducer返回一个newState，store接收到后进行state的更改，最后由subscribe()获取新的state，React更新组件</span><br><span class="line"></span><br><span class="line">redux组成</span><br><span class="line">	state  :用来存储数据和数据管理的、更新视图</span><br><span class="line">	reducer:是一个纯函数，接收旧 state 和 action，根据不同的 Action 做出不同的操作并返回新的 state</span><br><span class="line">	actions:发送动作给reducer,reducer接收动作，判断动作类型修改数据，修改事件后，组件重新做redux事件的订阅</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="react-hooks的实现原理"><a href="#react-hooks的实现原理" class="headerlink" title="react hooks的实现原理"></a>react hooks的实现原理</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### useMemo,useCallback,React.memo</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">useMeme 缓存<span class="keyword">return</span>后的结果，也就是计算结果，接收两个参数，一个是回调函数，另一个是依赖</span><br><span class="line">useCallback 缓存整个函数，同样接收两个参数，跟useMemo接收参数一样，可以避免由于函数引用变动所导致的组件重复渲染。</span><br><span class="line"><span class="title class_">React</span>.<span class="property">memo</span> 缓存组件，通过对比上次和这次的props是否一致，跟useCallback配合使用更佳</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <strong>useMemo</strong> 在函数组件需要进行大量的计算，不希望每一次函数组件渲染的时候都去执行这些计算逻辑，就可以把这些逻辑放到useMemo中，然后把计算结果缓存起来。<br>        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const value=useMemo(function,array);</span><br><span class="line">//参数解释：function为一个函数，array为一个数组，value为返回值，执行function过后的返回值，如果array的依赖项发生改变，返回一个重新执行完的function的值，否则取的就是上一次的缓存值。</span><br></pre></td></tr></table></figure><br><strong>useCallback</strong>返回的是一个函数，这个回调函数是经过处理后的结果，<br>    useCallback的作用其实是用来避免子组件不必要的reRender：</p>
<h5 id="redux、mobx区别"><a href="#redux、mobx区别" class="headerlink" title="redux、mobx区别"></a>redux、mobx区别</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中</span><br><span class="line">redux使用不可变状态,用纯函数返回一个新的状态，mobx状态是可变的，可以直接修改</span><br><span class="line">mobx更简单轻量</span><br></pre></td></tr></table></figure>

<h5 id="react和vue的区别"><a href="#react和vue的区别" class="headerlink" title="react和vue的区别"></a>react和vue的区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">相同点:</span><br><span class="line">1.都使用了虚拟dom,如果需要改变任何元素的状态,先改虚拟dom,当有变化产生时,会创建新的虚拟dom,通过diff算法对比新旧虚拟dom的差异,只需要渲染差异部分就行</span><br><span class="line">2.都使用组件化</span><br><span class="line"></span><br><span class="line">不同点:</span><br><span class="line">1.react中有新语法jsx,vue用普通的html   </span><br><span class="line">2.vue中父组件和子组件有通信的时候,父组件数据改变引起子组件改变,子组件会重新渲染，如果父子组件没有通信,父组件改变子组件不会渲染，react中不管是否有数据通信,父组件改变子组件都会渲染</span><br><span class="line">3.react:create-react-app</span><br><span class="line">  vue  :vue-cli</span><br><span class="line">4.react中用redux管理状态,state通过setState更新</span><br><span class="line">  vue中数据由vuex管理</span><br></pre></td></tr></table></figure>

<h5 id="受控组件和非受控组件"><a href="#受控组件和非受控组件" class="headerlink" title="受控组件和非受控组件"></a>受控组件和非受控组件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">受控组件</span><br><span class="line">	HTML中的表单元素是可输入的，也就是有自己的可变状态</span><br><span class="line">	而React中可变状态通常保存在state中，并且只能通过setState()方法来修改</span><br><span class="line">	React将state与表单元素值value绑定在一起，由state的值来控制表单元素的值，简单来说，值受到react控制的表单元素</span><br><span class="line">	（元素绑定value，外部传入值）</span><br><span class="line">非受控组件</span><br><span class="line">	调用 React.createRef() 方法创建ref对象</span><br><span class="line">	将创建好的 ref 对象添加到文本框中</span><br><span class="line">	通过ref对象获取到文本框的值</span><br><span class="line">	简单来说，表单组件没有value prop就可以称为非受控组件</span><br><span class="line">	（值的更改和外部无关，只是用户输入本身）</span><br><span class="line">受控组件：渲染表单的React组件还控制着用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素就叫做受控组件。</span><br><span class="line">有时候子组件的渲染受父组件的控制也叫受控组件</span><br><span class="line"></span><br><span class="line">非受控组件：</span><br><span class="line">    表单自己管理自己的状态，这就叫做非受控组件</span><br><span class="line"></span><br><span class="line">半受控</span><br><span class="line">一个表单组中，一部分表单元素的取值交给了组件的state管理，一部分自己管理 </span><br></pre></td></tr></table></figure>

<h5 id="setState概述-同步异步"><a href="#setState概述-同步异步" class="headerlink" title="setState概述,同步异步"></a>setState概述,同步异步</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 两个参数及用法</span><br><span class="line">	第一个参数可以是对象或者函数，是更新state   </span><br><span class="line">	第二个参数获取最新的state,副作用操作，dom操作事件触发声明，数据获取，第三方库实例化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 同步/异步原理</span><br><span class="line">	setState在合成事件和钩子函数中是异步的 </span><br><span class="line">	在原生事件和setTimeout中是同步的</span><br><span class="line"></span><br><span class="line">setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</span><br><span class="line"></span><br><span class="line">setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</span><br></pre></td></tr></table></figure>

<h5 id="react组件通信5种"><a href="#react组件通信5种" class="headerlink" title="react组件通信5种"></a>react组件通信5种</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1.父组件向子组件通信</span><br><span class="line">React数据流动是单向的,父组件向子组件通信也是最常见的;父组件通过props向子组件传递需要的信息</span><br><span class="line"></span><br><span class="line">2.子组件向父组件通信</span><br><span class="line">利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。</span><br><span class="line">也可以用useImperativeHandle传出子组件方法</span><br><span class="line">const Son = forwardRef((&#123;...props&#125;,ref)=&gt;&#123;</span><br><span class="line">    useImperativeHandle(ref,()=&gt;&#123;</span><br><span class="line">        getData:子组件xxx方法</span><br><span class="line">        &#125;)</span><br><span class="line">    return &lt;&gt;&lt;/&gt;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.非嵌套组件间通信</span><br><span class="line">非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</span><br><span class="line">	利用二者共同父组件的 context 对象进行通信</span><br><span class="line">	使用自定义事件的方式</span><br><span class="line">如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以。</span><br><span class="line"></span><br><span class="line">4.跨组件通信</span><br><span class="line">所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</span><br><span class="line">	中间组件层层传递 props</span><br><span class="line">	使用 context 对象</span><br><span class="line">中间组件层层传递 props:</span><br><span class="line">    如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些 props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。</span><br><span class="line">    </span><br><span class="line">使用 context 对象:</span><br><span class="line">	context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。</span><br><span class="line">使用 context 也很简单，需要满足两个条件：</span><br><span class="line">	上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</span><br><span class="line">	子组件要声明自己需要使用 context</span><br><span class="line"></span><br><span class="line">5.redux</span><br><span class="line">首先由view dispatch拦截action，然后执行对应reducer并更新到store中，最终views会根据store数据的改变执行界面的刷新渲染操作。</span><br><span class="line">	1)首先先把redux相关工具安装好 </span><br><span class="line">	2)通过创建一个store实例createStore,接收一个rootReducer和中间件执行函数</span><br><span class="line">	3)创建分块的数据rootReducer,通过combineReducers打造rootReducer,里面放分块的数据</span><br><span class="line">	4)在组件中通过高阶组件connect函数,接收store里的数据,把ActionCreators里的方法绑定到组件身上,</span><br><span class="line">	  并且可以发送动作action给reducer</span><br><span class="line">	5)在reductor中根据action中的type动作类型,判断动作修改数据</span><br></pre></td></tr></table></figure>

<h5 id="react-18-改变"><a href="#react-18-改变" class="headerlink" title="react 18 改变"></a>react 18 改变</h5><pre><code>1.改进已有属性，**如自动批量处理**，让ssr支持Suspense与lazy，修补Suspense等，
ReactDom.render 替换成了ReactDOM.createRoot

2.支持Concurrent模式，带来新的api，如startTransition等
    react 18 会加入新的模式，即并发渲染模式（concurrent rendering），当然这个模式是可选的，这个模式也使的react 能同时支持多个UI版本，这个变化对于开发者来说大部分是不可见的，但是它解锁了react应用在性能提升的方面的一些新特性
    
3.React 18 中 useEffect 会运行两次 
1.这是 React18 才新增的特性。
2.仅在开发模式(&quot;development&quot;)下，且使用了严格模式(&quot;Strict Mode&quot;)下会触发。
  生产环境(&quot;production&quot;)模式下和原来一样，仅执行一次。
3.之所以执行两次，是为了模拟立即卸载组件和重新挂载组件。
  为了帮助开发者提前发现重复挂载造成的 Bug 的代码。 
  同时，也是为了以后 React的新功能做铺垫。 
  未来会给 React 增加一个特性，允许 React 在保留状态的同时，能够做到仅仅对UI部分的添加和删除。
  让开发者能够提前习惯和适应，做到组件的卸载和重新挂载之后， 重复执行 useEffect的时候不会影响应用正常运行。
    解决方案： 取消严格模式
    在 Next.js 中，可以在 next.config.js 文件里增加这个选项：
        reactStrictMode: false
    在 cra 创建的应用里，可以把 index.js 文件里的 StrictMode 高阶组件去除
</code></pre>
<h5 id="StrictMode-目前有助于："><a href="#StrictMode-目前有助于：" class="headerlink" title="StrictMode 目前有助于："></a>StrictMode 目前有助于：</h5><pre><code>1、识别不安全的生命周期
2、关于使用过时字符串 ref API 的警告
3、关于使用废弃的 findDOMNode 方法的警告
4、检测意外的副作用
5、检测过时的 context API      
</code></pre>
<h5 id="Concurrent模式"><a href="#Concurrent模式" class="headerlink" title="Concurrent模式"></a>Concurrent模式</h5><pre><code>Concurrent模式 指的是React的启用模式
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//legacy 模式： 是同步的渲染链路</span><br><span class="line"> ReactDOM.render(&lt;App /&gt;, rootNode);</span><br><span class="line"> //concurrent 模式：</span><br><span class="line"> ReactDOM.createRoot(rootNode).render(&lt;App /&gt;);</span><br></pre></td></tr></table></figure>
是一组react的新功能，可以帮组应用保持响应，并且根据用户的设备性能和网速进行适当的调整。
在Concurrent模式中，react可以同时更新多个状态， （就像分支可以让不同的团队成员独立工作一样）
1.对于COU-bound的更新，并发意味着一个更急迫的更新可以中断已经开始的渲染
2.对于IP-bound的更新，例如网络加载带啊吗或数据，并发意味着react 甚至可以在全部数据到达之前就在内存中开始渲染，跳过不愉快的空白加载状态
你使用react的方式是相同的，
</code></pre>
<h5 id="render-渲染原理"><a href="#render-渲染原理" class="headerlink" title="render  渲染原理"></a>render  渲染原理</h5><pre><code>我们在组件中通过 setState 来进行更新，根据先前建立好的映射关系找到组件对应 Fiber，在 Fiber 的 updateQueue 中插入一个 update 对象，updateQueue 也是一个链表结构，会记录所属 Fiber 节点上收集到的更新。然后，我们会从触发 setState 的 Fiber 节点，不断 向上回溯，通知沿途上的 Fiber 节点，你有子孙节点被更新了，直至最顶端的 HostRoot。

接着，我们从 HostRoot 开始对 Fiber 树进行深度优先遍历。每个 Fiber 节点在遍历到时，若自身存在变更，会根据 Fiber 类型对节点执行创建/更新，其中包含了执行部分生命周期，给 Fiber 节点打上 effectTag 等操作。effectTag 代表了 Fiber 节点做了怎样的变更，具有 effectTag 的 Fiber 会成为 effect。每个 Fiber 中带有自身子节点的信息，据此来判断是否需要继续向下深度遍历，这个过程被称为 beginWork。

若不需要再向下遍历，Fiber 节点会开始回溯，判断是否存在兄弟节点需要进行遍历，如果没有，则回溯到父节点，并将自身及自身子树上的 effect 形成 effect list 向父节点传递，以此往复，直至 HostRoot，这个过程被称为 completeUnitOfWork。

合在一起，就是 render 过程，它是纯粹的 JS 计算，不（应）带有任何“副作用”。
</code></pre>
<p>​<br>​    在render过程中，React 将新调用的 render函数返回的树与旧版本的树进行比较，这一步是决定如何更新 DOM 的必要步骤，然后进行 diff 比较，更新 DOM树</p>
<p>​<br>​<br>​    </p>
<h5 id="updateQueue"><a href="#updateQueue" class="headerlink" title="updateQueue"></a>updateQueue</h5><pre><code>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    export const updateQueue = &#123;</span><br><span class="line">  isBatchingUpdate: false, // 是否是批量更新，true 要批量更新            我们就存，false 我们就执行</span><br><span class="line">  updaters: new Set(), // 当前更新队列中保存的所有的 updaters 实例，每个 updater 实例对应一个组件</span><br><span class="line">  batchUpdate() &#123;</span><br><span class="line">    updateQueue.isBatchingUpdate = false; // 要执行了我们还原为 false，为下次再执行重新初始化</span><br><span class="line">    // 批量更新</span><br><span class="line">    for (const updater of updateQueue.updaters) &#123;</span><br><span class="line">      updater.updateComponent();  // 每个组件有自己的更新方法</span><br><span class="line">    &#125;</span><br><span class="line">    updateQueue.updaters.clear(); // 执行完后清空</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
<h5 id="前端系分"><a href="#前端系分" class="headerlink" title="前端系分"></a>前端系分</h5><pre><code>1.需求的业务背景
2.业务逻辑，可以放些ER图，思维导图用来理清本次需求业务逻辑；
3.需求的详细功能点说明，左边可以放对应功能点的设计图，右边写上实现代码逻辑，以及让服务端同学看到需要消费的字段；
4.工作量评估
</code></pre>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h5 id="webpack介绍"><a href="#webpack介绍" class="headerlink" title="webpack介绍"></a>webpack介绍</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack是一个打包压缩工具，其配置文件用commonJS规范引入和输出，有output 输出 entry 入口 loader转换器 plugins插件，只能识别js文件所以需要特定loader进行转换</span><br></pre></td></tr></table></figure>

<h5 id="webpack-vite"><a href="#webpack-vite" class="headerlink" title="webpack vite"></a>webpack vite</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="title class_">Webpack</span> 的开发过程会出现以下问题</span><br><span class="line">    <span class="title class_">Webpack</span> <span class="title class_">Dev</span> <span class="title class_">Server</span> 冷启动时间会比较长</span><br><span class="line">    <span class="title class_">Webpack</span> <span class="variable constant_">HMR</span> 热更新的反应速度比较慢</span><br><span class="line"><span class="number">2</span>、vite的特点</span><br><span class="line">        轻量</span><br><span class="line">        按需打包</span><br><span class="line">        <span class="variable constant_">HMR</span> (热渲染依赖）</span><br><span class="line"> webpack dev server 在启动时需要先build一遍，将所有模块提前编译、打包进bundle，这个过程需要消耗很多时间</span><br><span class="line">但是<span class="title class_">Vite</span> 不同的是 执行vite serve 时，内部直接启动了web <span class="title class_">Server</span>, 并不会先编译所有的代码文件。</span><br></pre></td></tr></table></figure>

<img src="C:\Users\joker\AppData\Roaming\Typora\typora-user-images\image-20230216170551173.png" alt="image-20230216170551173" style="zoom: 67%;" />



<h5 id="常用loader-plugin"><a href="#常用loader-plugin" class="headerlink" title="常用loader plugin"></a>常用loader plugin</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">CSS</span>-<span class="title class_">Loader</span>，<span class="title class_">Style</span>-<span class="title class_">Loader</span>等。babel-loader优雅降级配置<span class="variable constant_">ES</span>高版本转成低版本</span><br><span class="line">样式：style-loader、css-loader、less-loader、sass-loader等</span><br><span class="line">文件：raw-loader、file-loader 、url-loader等</span><br><span class="line">编译：babel-loader、coffee-loader 、ts-loader等</span><br><span class="line">校验测试：mocha-loader、jshint-loader 、eslint-loader等</span><br><span class="line"></span><br><span class="line">webpack常用的plugin</span><br><span class="line">createSvgIconsPlugin svgplugin  配置svg图</span><br><span class="line">webpack内置<span class="title class_">UglifyJsPlugin</span>，压缩和混淆代码。</span><br><span class="line">webpack内置<span class="title class_">CommonsChunkPlugin</span>，提高打包效率，将第三方库和业务代码分开打包。</span><br><span class="line"><span class="title class_">ProvidePlugin</span>：自动加载模块，代替<span class="built_in">require</span>和<span class="keyword">import</span></span><br><span class="line">html-webpack-plugin可以根据模板自动生成html代码，并自动引用css和js文件extract-text-webpack-plugin 将js文件中引用的样式单独抽离成css文件</span><br><span class="line"></span><br><span class="line"><span class="title class_">DefinePlugin</span> 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。</span><br></pre></td></tr></table></figure>

<h5 id="提升打包速度"><a href="#提升打包速度" class="headerlink" title="提升打包速度"></a>提升打包速度</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread-loader</span><br><span class="line">因为webpack的打包是node单线程的,打包只能逐个文件处理，限制打包速度，所以我们启用多进程，来打包项目</span><br><span class="line">thread-loader 放置在其他 loader 之前， 放置在这个 loader 之后的 loader 就会在一个单独的 worker【worker pool】 池里运行，一个worker 就是一个nodeJS 进程【node.<span class="property">js</span> proces】，每个单独进程处理时间上限为600ms，各个进程的数据交换也会限制在这个时间内。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="h5的px-to-rem"><a href="#h5的px-to-rem" class="headerlink" title="h5的px to rem"></a>h5的px to rem</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack 的loader px2rem-loader，会自动把px转为rem</span><br></pre></td></tr></table></figure>

<h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h5 id="浏览器渲染原理及流程"><a href="#浏览器渲染原理及流程" class="headerlink" title="浏览器渲染原理及流程"></a>浏览器渲染原理及流程</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 浏览器将<span class="variable constant_">HTML</span>解析成一个<span class="variable constant_">DOM</span>树，<span class="variable constant_">DOM</span> 树的构建过程是一个深度遍历过程：</span><br><span class="line">   当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 将<span class="variable constant_">CSS</span>解析成 <span class="variable constant_">CSS</span> <span class="title class_">Rule</span> <span class="title class_">Tree</span> 。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 根据<span class="variable constant_">DOM</span>树和<span class="variable constant_">CSSOM</span>来构造 <span class="title class_">Rendering</span> <span class="title class_">Tree</span>。</span><br><span class="line">   (注意：<span class="title class_">Rendering</span> <span class="title class_">Tree</span> 渲染树并不等同于 <span class="variable constant_">DOM</span> 树，</span><br><span class="line">        因为一些像<span class="title class_">Header</span>或<span class="attr">display</span>:none的东西就没必要放在渲染树中了。)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 有了<span class="title class_">Render</span> <span class="title class_">Tree</span>，浏览器已经能知道网页中有哪些节点、各个节点的<span class="variable constant_">CSS</span>定义以及他们的从属关系。</span><br><span class="line">   然后走layout，计算出每个节点在屏幕中的位置。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 再下一步就是绘制，遍历render树，绘制每个节点。</span><br></pre></td></tr></table></figure>

<h5 id="输入url按回车键后发生了什么"><a href="#输入url按回车键后发生了什么" class="headerlink" title="输入url按回车键后发生了什么"></a>输入url按回车键后发生了什么</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>输入url  </span><br><span class="line"><span class="number">2.</span><span class="variable constant_">DNS</span>解析域名  </span><br><span class="line"><span class="number">3.</span>客户端发送http请求  </span><br><span class="line"><span class="number">4.</span><span class="variable constant_">TCP</span>传输报文  </span><br><span class="line"><span class="number">5.</span><span class="variable constant_">IP</span>协议查找<span class="variable constant_">MAC</span>地址  </span><br><span class="line"><span class="number">6.</span>数据到达数据链路层 </span><br><span class="line"><span class="number">7.</span>服务器接收数据  </span><br><span class="line"><span class="number">8.</span>服务器响应请求  </span><br><span class="line"><span class="number">9.</span>返回相应数据  </span><br><span class="line"><span class="number">10.</span>页面渲染</span><br></pre></td></tr></table></figure>





<h5 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP是超文本传输协议，信息是明文传输的，HTTPS是具有ssl/tls加密传输协议。</span><br><span class="line"></span><br><span class="line">默认端口不同，前者是80，后者是443。</span><br><span class="line"></span><br><span class="line">HTTPS比HTTP安全</span><br><span class="line"></span><br><span class="line">HTTPS协议需要到CA申请证书，需要一定费用</span><br><span class="line">百度、谷歌搜索引擎对https网站排名权重更高</span><br></pre></td></tr></table></figure>

<h5 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">200	OK	请求成功。一般用于GET与POST请求</span><br><span class="line">3开头 重定向</span><br><span class="line">300	多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</span><br><span class="line">301	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</span><br><span class="line">302	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</span><br><span class="line">303	查看其它地址。与301类似。使用GET和POST请求查看</span><br><span class="line">304	未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</span><br><span class="line">305	使用代理。所请求的资源必须通过代理访问</span><br><span class="line">306	已经被废弃的HTTP状态码</span><br><span class="line">307	临时重定向。与302类似。使用GET请求重定向</span><br><span class="line">400	客户端请求的语法错误，服务器无法理解</span><br><span class="line">401	请求要求用户的身份认证</span><br><span class="line">402	保留，将来使用</span><br><span class="line">403	服务器理解请求客户端的请求，但是拒绝执行此请求</span><br><span class="line">404	服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面</span><br><span class="line">405	客户端请求中的方法被禁止</span><br><span class="line">406	N服务器无法根据客户端请求的内容特性完成请求</span><br><span class="line">407	请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</span><br><span class="line">408	服务器等待客户端发送的请求时间过长，超时</span><br><span class="line">409	服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</span><br><span class="line">410	客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</span><br><span class="line">411	服务器无法处理客户端发送的不带Content-Length的请求信息</span><br><span class="line">412	客户端请求信息的先决条件错误</span><br><span class="line">413	由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</span><br><span class="line">414	请求的URI过长（URI通常为网址），服务器无法处理</span><br><span class="line">415	服务器无法处理请求附带的媒体格式</span><br><span class="line">416	客户端请求的范围无效</span><br><span class="line">417	服务器无法满足Expect的请求头信息</span><br><span class="line">500	服务器内部错误，无法完成请求</span><br><span class="line">501	服务器不支持请求的功能，无法完成请求</span><br><span class="line">502 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</span><br><span class="line">503	由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</span><br><span class="line">504	充当网关或代理的服务器，未及时从远端服务器获取请求</span><br><span class="line">505	服务器不支持请求的HTTP协议的版本，无法完成处理</span><br></pre></td></tr></table></figure>



<h5 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">强缓存：直接从本地副本比对读取，不去请求服务器，返回的状态码是 <span class="number">200</span>。</span><br><span class="line">协商缓存：会去服务器比对，若没改变才直接读取本地缓存，返回的状态码是 <span class="number">304</span>。</span><br></pre></td></tr></table></figure>

<h5 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个程序至少有一个进程，一个进程至少有一个线程</span><br><span class="line">进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大提高了程序的运行效率</span><br></pre></td></tr></table></figure>

<h5 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">出现原因：</span><br><span class="line">浏览器的同源策略</span><br><span class="line"><span class="number">1</span>、域名不同</span><br><span class="line"><span class="number">2</span>、端口号不同</span><br><span class="line"><span class="number">3</span>、协议不同(http/https)</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> jsonp 更像是一个bug，用script标签去请求接口，只能get</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 跨域资源共享cors 服务端设置<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: *（对 <span class="title class_">XMLHttpRequest</span> 设置其 **withCredentials** = <span class="literal">true</span> 参数才能带cookie,**<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: 指定域名）</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 反向代理 webpack的</span><br><span class="line"></span><br><span class="line">   devServe :&#123;</span><br><span class="line">   	<span class="attr">proxy</span>:&#123;</span><br><span class="line">   		<span class="string">&#x27;/api&#x27;</span>:&#123;</span><br><span class="line">               <span class="attr">target</span>:<span class="string">&quot;http://xxxxx:xxx&quot;</span>,</span><br><span class="line">                   <span class="comment">//是否跨域</span></span><br><span class="line">               <span class="attr">changeOrigin</span>:<span class="literal">true</span>,</span><br><span class="line">                   <span class="comment">//代理websockets设置</span></span><br><span class="line">                <span class="attr">ws</span>:<span class="literal">true</span>,</span><br><span class="line">                <span class="comment">//https接口设置</span></span><br><span class="line">                <span class="attr">secure</span>:<span class="literal">false</span>,</span><br><span class="line">                 <span class="comment">//路径重写</span></span><br><span class="line">                <span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/api&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">                   </span><br><span class="line">           &#125;</span><br><span class="line">   	&#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="defer，async"><a href="#defer，async" class="headerlink" title="defer，async"></a>defer，async</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原本浏览器解析文档遇到script标签会停下解析下载脚本并执行，一切结束后再解析文档</span><br><span class="line"></span><br><span class="line">defer：遇到不停下解析，其他线程下载脚本，脚本完成下载等解析完成后执行脚本</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>：遇到不停下解析，其他线程下载脚本，脚本下载完立即执行脚本后解析文档</span><br></pre></td></tr></table></figure>

<h5 id="cookie-sessionStorage-localStorage"><a href="#cookie-sessionStorage-localStorage" class="headerlink" title="cookie  sessionStorage localStorage"></a>cookie  sessionStorage localStorage</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">介绍</span><br><span class="line"><span class="number">1.</span>cookie又叫会话跟踪技术，是由web服务器保存在用户浏览器上的小文本文件，它可以记录用户<span class="variable constant_">ID</span>、密码、浏览过的网页、停留的时间等信息。当用户再次来到该网站时，网站通过读取cookie，得知用户相关信息,如果用户清理了cookie，那么用户曾登录过的网站信息就没有了。</span><br><span class="line"><span class="number">2.</span>sessionStorage和<span class="variable language_">localStorage</span>是<span class="variable constant_">H5</span>新增的本地存储</span><br><span class="line"></span><br><span class="line">区别</span><br><span class="line"><span class="number">1.</span>存储大小的不同</span><br><span class="line">	sessionStorage 、<span class="variable language_">localStorage</span>的大小一般为5M</span><br><span class="line">	cookies的大小一般为4K</span><br><span class="line"><span class="number">2.</span>有效期不同：</span><br><span class="line">    <span class="variable language_">localStorage</span>的有效期为永久有效，除非你进行手动删除。</span><br><span class="line">    sessionStorage在当前会话下有效，关闭页面或者浏览器时会被清空。</span><br><span class="line">    cookies在设置的有效之前有效，当超过有效期便会失效,不设置默认是关闭浏览器清除</span><br></pre></td></tr></table></figure>

<h5 id="三次握手四次挥手"><a href="#三次握手四次挥手" class="headerlink" title="三次握手四次挥手"></a>三次握手四次挥手</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">TTP</span>协议是使用<span class="variable constant_">TCP</span>协议作为其传输层协议的，在拿到服务器的<span class="variable constant_">IP</span>地址后，客户端浏览器会与服务器建立<span class="variable constant_">TCP</span>连接，该过程包括三次握手：</span><br><span class="line">	第一次握手：建立连接时，客户端向服务端发送请求报文（<span class="variable constant_">SYN</span>）</span><br><span class="line">	第二次握手：服务器收到请求报文后，如同意连接，则向客户端发送确认报文（<span class="variable constant_">SYN</span>/<span class="variable constant_">ACK</span>）</span><br><span class="line">	第三次握手：客户端收到服务器的确认后，再次向服务器发送确认报文，完成连接（<span class="variable constant_">ACK</span>）</span><br><span class="line">三次握手主要是为了防止已经失效的请求报文字段发送给服务器，浪费资源。</span><br><span class="line">断开<span class="variable constant_">TCP</span>连接</span><br><span class="line">	第一次挥手：客户端想分手，发送消息（<span class="variable constant_">FIN</span>）给服务器</span><br><span class="line">	第二次挥手：服务器通知客户端已经接受的挥手请求，返回确认消息（<span class="variable constant_">ACK</span>），但还没做好分手准备</span><br><span class="line">	第三次挥手：服务器已经做好分手准备，通知客户端（<span class="variable constant_">FIN</span>）</span><br><span class="line">	第四次挥手：客户端发送消息给服务器（<span class="variable constant_">ACK</span>），确认分手，服务器关闭连接。</span><br></pre></td></tr></table></figure>



<h2 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">块作用域</span><br><span class="line">类</span><br><span class="line">箭头函数</span><br><span class="line">模板字符串</span><br><span class="line">对象解构</span><br><span class="line"><span class="title class_">Promise</span></span><br><span class="line">模块</span><br><span class="line"><span class="title class_">Symbol</span></span><br><span class="line">代理（proxy）<span class="title class_">Set</span></span><br><span class="line">函数默认参数</span><br><span class="line">rest</span><br><span class="line">扩展运算符</span><br><span class="line">数组和对象的扩展</span><br></pre></td></tr></table></figure>

<h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">箭头函数是es6新增，比函数表达式更简洁，箭头函数里的this指向的是定义时父级的this,且不会被call/bind/applay等改变，只有一行的话省略大括号以及return</span><br><span class="line">箭头函数不能访问arguments对象。所以调用第一个getArgs函数会抛出一个错误。</span><br><span class="line">可以使用rest参数来获得在箭头函数中传递的所有参数。</span><br><span class="line">箭头函数没有原型prototype</span><br></pre></td></tr></table></figure>

<h5 id="promise-async-x2F-await"><a href="#promise-async-x2F-await" class="headerlink" title="promise async&#x2F;await"></a>promise async&#x2F;await</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">await</span> 是generator函数的语法糖，是es7出的异步编程的解决方案，比起promise es6出的的.<span class="property">then</span>链式调用结构更清晰，更像同步代码。和promise用<span class="keyword">catch</span>获取异常不同，<span class="keyword">async</span> <span class="keyword">await</span> 是直接暴露出来，需要用<span class="keyword">try</span> <span class="keyword">catch</span> 去捕获错误。<span class="keyword">async</span>函数返回数据时自动封装为一个<span class="title class_">Promise</span>对象。</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">   <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;成功&quot;</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="string">&quot;失败&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">回调地狱问题是 想要异步任务的输出顺序在同步任务之前，只能在异步的callback里再套异步，形成了嵌套的回调结构，称为回调地狱问题</span><br></pre></td></tr></table></figure>

<h5 id="promise和promise-all的实现"><a href="#promise和promise-all的实现" class="headerlink" title="promise和promise.all的实现"></a>promise和promise.all的实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.说一说promise？如何实现promiase.all（）方法的封装</span></span><br><span class="line">promise是es6新增的一种异步解决方案，可以解决回调地狱，有三个状态pending（进行中） resolve（成功） rejected（失败）</span><br><span class="line"></span><br><span class="line">定义一个函数 传一个数组 先判断一下是不是数组 不是的话返回错误 里面是几个promise对象  然后<span class="keyword">return</span>一个promise的实例对象 </span><br><span class="line">便利之前先定义三个变量 一个是计数count 初始值<span class="number">0</span> 第二个是空数组arr  第三个是开始传入数组的长度num  再便利  成功调用promise.<span class="property">resolve</span>（里面放便利的item）然后.<span class="property">then</span> 里面计数器++  arr放结果 当count的值等于num时  resolve输出所有返回结果 </span><br><span class="line">如果没成功 定义一个函数返回reject（error）</span><br></pre></td></tr></table></figure>

<h5 id="var-let-const"><a href="#var-let-const" class="headerlink" title="var let const"></a>var let const</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">var</span>声明的变量会挂载在<span class="variable language_">window</span>上，而<span class="keyword">let</span>和<span class="keyword">const</span>声明的变量不会：</span><br><span class="line"><span class="number">2.</span><span class="keyword">var</span>声明变量存在变量提升，<span class="keyword">let</span>和<span class="keyword">const</span>不存在变量提升</span><br><span class="line"><span class="number">3.</span><span class="keyword">let</span>和<span class="keyword">const</span>声明形成块作用域</span><br><span class="line"><span class="number">4.</span>同一作用域下<span class="keyword">let</span>和<span class="keyword">const</span>不能声明同名变量，而<span class="keyword">var</span>可以</span><br></pre></td></tr></table></figure>



<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><h5 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">box-<span class="attr">sizing</span>: content-box;</span><br><span class="line">标准盒模型一个块的总宽度= width + <span class="title function_">margin</span>(左右) + <span class="title function_">padding</span>(左右) + <span class="title function_">border</span>(左右) </span><br><span class="line">box-<span class="attr">sizing</span>: border-box;</span><br><span class="line">怪异盒模型一个块的总宽度= width + <span class="title function_">margin</span>(左右)（即width已经包含了padding和 border值）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="rem-em"><a href="#rem-em" class="headerlink" title="rem em"></a>rem em</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rem 根据根元素字体大小来缩放</span><br><span class="line">em 根据自身元素大小缩放</span><br><span class="line">px 是像素</span><br></pre></td></tr></table></figure>



<h5 id="flex-1布局"><a href="#flex-1布局" class="headerlink" title="flex:1布局"></a>flex:1布局</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">flex:1 实际代表的是三个属性的简写；</span><br><span class="line">    flex-grow 父盒子的宽度大于子盒子的宽度，父盒子的剩余空间利用flex-grow，来设置子盒子增大的占比，</span><br><span class="line">    flex-shrink 用来设置子盒子超过父盒的宽度后，超出部分进行缩小的取值比例</span><br><span class="line">    flex-basis 用来设置盒子的基准宽度，并且basis 和width 同时存在basis会把width干掉</span><br></pre></td></tr></table></figure>
<pre><code>    flex :1 
    flex-grow:1
    flex-shrink :1
    flex-basis: 0% 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">##### 元素水平垂直居中</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<ol>
<li>父：display:flex<br>子：margin:auto<br>2.display:flex<br>justify-content:center<br>align-item:center</li>
<li>position:relative<br>position:absolute<br>上下左右都为0<br>margin:auto<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### BFC</span><br><span class="line"></span><br></pre></td></tr></table></figure>
块级格式化上下文，内部空间独立，浮动元素参与计算，相邻margin会重叠<br>触发条件：float不为none,position为absolute或者fixed，display为行内块或者tab-cell，flex等，overflow不为默认visible<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 两栏布局</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">//绝对定位</span><br><span class="line">一个子元素绝对定位到左边 宽度给个200px吧 另一个子元素给个margin-left:200px;</span><br><span class="line">//浮动布局</span><br><span class="line">一个子元素左浮动，宽度给个200px 另一个元素给个margin-left：200px;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="回流-重绘"><a href="#回流-重绘" class="headerlink" title="回流 重绘"></a>回流 重绘</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">回流 页面第一次加载时候会引起回流，元素的尺寸、布局等发生改变会引起回流，对浏览器性能消耗较大</span><br><span class="line">重绘 颜色、外观变化，会引起重绘，比如背景色改变，字体颜色改变等。</span><br><span class="line">回流一定会引发重绘</span><br></pre></td></tr></table></figure>

<h5 id="CSS中link和-import的区别"><a href="#CSS中link和-import的区别" class="headerlink" title="CSS中link和@import的区别"></a>CSS中link和@import的区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">link属于HTML标签，@import是CSS提供的</span><br><span class="line"></span><br><span class="line">页面被加载时，link引用的css文件会同时被加载，而@import引用的css文件要等到页面被加载完毕再加载</span><br><span class="line"></span><br><span class="line">import只在IE5以上才能识别，link是HTML标签，无兼容问题</span><br><span class="line"></span><br><span class="line">link 引入样式的权重大于@import 的引用</span><br></pre></td></tr></table></figure>

<h5 id="CSS中display-none、visibility-hidden和opacity-0-的区别"><a href="#CSS中display-none、visibility-hidden和opacity-0-的区别" class="headerlink" title="CSS中display:none、visibility:hidden和opacity:0;的区别"></a>CSS中display:none、visibility:hidden和opacity:0;的区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">display:none;隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢。</span><br><span class="line"></span><br><span class="line">visibility:hidden;隐藏对应的元素，但在文档布局中仍保留原来的空间。</span><br><span class="line"></span><br><span class="line">opacity:0;内容不可见，占据空间。</span><br></pre></td></tr></table></figure>

<h5 id="CSS中rgba-和opacity的透明效果区别"><a href="#CSS中rgba-和opacity的透明效果区别" class="headerlink" title="CSS中rgba()和opacity的透明效果区别"></a>CSS中rgba()和opacity的透明效果区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rgba()和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的所有内容的透明度；</span><br><span class="line"></span><br><span class="line">rgba()只作用于元素的颜色或其背景色（设置 rgba 透明的元素的子元素不会继承透明效果）。</span><br></pre></td></tr></table></figure>

<h5 id="LESS-SASS"><a href="#LESS-SASS" class="headerlink" title="LESS,SASS"></a>LESS,SASS</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less基于js，在客户端处理，变量用@；sass基于ruby，在服务器处理，变量用$</span><br></pre></td></tr></table></figure>

<h5 id="transform和transition、animation区别"><a href="#transform和transition、animation区别" class="headerlink" title="transform和transition、animation区别"></a>transform和transition、animation区别</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">transform是给元素做变换，rotate旋转  skew倾斜  translate移动  scale缩放 </span><br><span class="line"></span><br><span class="line">transition是做过度效果  属性 过度时间 曲线  延迟时间</span><br><span class="line"></span><br><span class="line">animation是动画 需要关键帧</span><br></pre></td></tr></table></figure>




<h5 id="遇到了返回时候如果用户没有保存表单，需要拦截路由跳转，并给出提示信息是否要退出；首先定一个允不允许跳转的state，然后通过react-router包里提供的"><a href="#遇到了返回时候如果用户没有保存表单，需要拦截路由跳转，并给出提示信息是否要退出；首先定一个允不允许跳转的state，然后通过react-router包里提供的" class="headerlink" title="遇到了返回时候如果用户没有保存表单，需要拦截路由跳转，并给出提示信息是否要退出；首先定一个允不允许跳转的state，然后通过react-router包里提供的"></a>遇到了返回时候如果用户没有保存表单，需要拦截路由跳转，并给出提示信息是否要退出；首先定一个允不允许跳转的state，然后通过react-router包里提供的</h5><pre><code> &lt;Prompt when=&#123;notAllowJump&#125; message=&#123;handleRouter&#125; /&gt;
 另外一种方法就是history.block 当block返回值是false时候，能够拦截路由跳转，后作用就是全局影响，所有路由调整都会被拦截不介意使用。
属性when 是布尔值，true 弹窗，false顺利跳转
message 绑定一个函数，函数返回true就顺利跳转，false停止跳转
字符串就弹窗字符串并停止跳转。 
    然后写handleRouter 方法，通过antd的form表单api，field.getValue(&#39;list&#39;)拿到当前Form.create(&#123; &#125;)(Form)包裹表单的数据对比原始的formData是否相同来决定弹出弹窗
                  function handleRouter() &#123;
        const list = field.getValue(&#39;list&#39;);
        const equal = xxxxx(); // 判断两次值是不是一样 
        if (equal) &#123;
        // 两次值一样，用户没改动数据，直接放行
          return true;
        &#125;
        Dialog.show(&#123;
          centered: true,
          content: &#39;是否保存当前修改数据&#39;,
          onOk() &#123;
              // 用户需要提交，提交后要放行，先将when置为false，再提交操作
            setNotAllowJump(false);
            xxxxxSubmit(); // 继续提交
          &#125;,
          async onCancel() &#123;
              // 用户不提交，直接放弃修改返回上一页。将when置为false再返回，注意setNotAllowJump操作是异步的。
            await setNotAllowJump(false);
            history.goBack();
          &#125;,
        &#125;);
        // 用户有修改，返回false拦截跳转，同时屏蔽掉默认弹出框
        return false;
      &#125;
</code></pre>
<h5 id="在使用antd，form表单的时候"><a href="#在使用antd，form表单的时候" class="headerlink" title="在使用antd，form表单的时候"></a>在使用antd，form表单的时候</h5><pre><code>    1.首先必须使用 Form.create(&#123; &#125;)(Form) 将表单组件包裹起来。
    // export default Form.create()(List)
    1. getFieldDecorator 来源  Form.create 包装的组件将会自带 this.props.form 属性，通过解构赋值将 form 解构出来；在List组件的 render 函数里面 // const &#123; form &#125; = this.props;
       const &#123; getFieldDecorator &#125; = form;
    2.getFieldDecorator 这个方法用于和表单进行双向绑定，它接收两个参数，第一个是表单的字段对象，第二个是校验规则。方法本身返回一个方法，将获取值的标签包裹住。
    3.getFieldValue
        获取 form 表单里面的值
    4.setFieldValue
设置 form 表单里面的值。
5.resetFields
    清空 form 表单
</code></pre>
<h5 id="系分文档"><a href="#系分文档" class="headerlink" title="系分文档"></a>系分文档</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、阐述业务背景和后续发展，可以帮助开发过程中对于页面结构或者组件功能的设计，有利于新接手项目的同学快速料想项目背景</span><br><span class="line"><span class="number">2</span>、放置链接资源和项目成员，比如ui图，策划案链接，代码地址，分支，以及相应前后端、产品、ui、测试的联系方式</span><br><span class="line"><span class="number">3</span>、需求拆分，给出每块的时间和总时间，留出buffer和测试时间。</span><br><span class="line"><span class="number">4</span>、对拆分的需求，给出实现思路，或者时序图</span><br><span class="line"><span class="number">5</span>、如果是迭代需求，给出影响范围，方便回归测试</span><br><span class="line"><span class="number">6</span>、如果有测试bug，补充复盘，原因和事故等级，处理方法</span><br></pre></td></tr></table></figure>

<h5 id="git"><a href="#git" class="headerlink" title="git"></a>git</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。</span><br><span class="line"></span><br><span class="line">而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。</span><br><span class="line"></span><br><span class="line">git stash -m <span class="string">&#x27;message&#x27;</span> 存放暂存区</span><br><span class="line">git stash pop 暂存区弹出stash&#123;<span class="number">0</span>&#125; 并删除</span><br><span class="line">git stash list 暂存区列表</span><br><span class="line">git stash apply 序号 弹出指定序号的存储</span><br><span class="line">git stash drop 序号 删除指定序号的存储</span><br><span class="line">git stash drop 不加序号 清空</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://aa344646.github.io/2023/02/21/note/" data-id="clelm790a000768mh4ssefarz" data-title="react综合归类" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/note/2023/02/20/MVVM%E4%B8%8EMVC/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">前端基础-MVVM设计思想</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/note/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" rel="tag">前端基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/note/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">前端基础</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/note/archives/2023/02/">February 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/note/2023/02/21/note/">react综合归类</a>
          </li>
        
          <li>
            <a href="/note/2023/02/20/MVVM%E4%B8%8EMVC/">前端基础-MVVM设计思想</a>
          </li>
        
          <li>
            <a href="/note/2023/02/19/%E9%A5%BF%E4%BA%86%E4%B9%88%E7%BB%84%E4%BB%B6%E5%BA%93%E8%B8%A9%E5%9D%91/">element-ui踩坑点</a>
          </li>
        
          <li>
            <a href="/note/2023/02/19/%E5%89%8D%E7%AB%AF%E4%B8%AD%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/">前端中高级知识要点总结</a>
          </li>
        
          <li>
            <a href="/note/2023/02/19/%E6%9C%80%E5%85%A8Vue%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%8C%E5%8A%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">最全Vue知识点总结，助你快速上手</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 LiuJun<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/note/" class="mobile-nav-link">Home</a>
  
    <a href="/note/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/note/js/jquery-3.4.1.min.js"></script>



  
<script src="/note/fancybox/jquery.fancybox.min.js"></script>




<script src="/note/js/script.js"></script>





  </div>
</body>
</html>
